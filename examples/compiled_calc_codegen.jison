//
// Stage 2(B) parser: 'The Back End = The Code Generator (Compiler Style)'
//
// TODO!
//
// See also the compiled_calc_exec source file: this is the alternative
// back-end which 'object code' output a working JavaScript sourcecode (!) representing 
// the formula, hence this is the *COMPILER* variant of that
// compile_calc_exec interpreter!
//
// The AST is stored in an array and since the AST acts as the INTERFACE
// between front-end and backend of the compiler/engine, its precise format
// is known to both 'parsers': the compile_calc_parse front-end and this
// back-end, plus additional back-ends which feed off the same AST for
// different purposes.
//
// This 'Pretty Printer' is designed to be FAST, hence the AST stream has been
// constructed the way it is, using a Polish Notation simile: this takes
// the fewest AST nodes and the fewest number of grammar rules to express 
// the entire formula calculation power.
//
// We also assume the AST is always valid (errors can be encoded in there, but
// we will exit HARD when your front-end screwed up the AST 'internal structure'
// in any way!), the result of which is that we now have enabled jison to 
// recognize the absence of all and any error checking and reporting facilities,
// which our JISON takes as an opportunity to create a severely stripped down,
// FAST grammar parser, hence a very fast 'tree walker'.
//
// Of course, the usual process is to write such a 'tree walker' by hand,
// but I want to showcase the concept here and there's something to say for
// readability as now AST format and actions performed on the atoms is 
// nicely separated! :-)
//
// ---
//
// A crucial detail is the use of the `%import` jison feature which allows
// us to import the symbol table generated by jison as part of the front-end
// parser engine: that way we have a guaranteed good set of token #IDs which we
// can use at both ends of the AST stream interface: this allows us to use 
// the other JISON feature which is `#<name>` in the action blocks everywhere:
// this will be expanded into the numeric ID of the given token by jison,
// saving us from having to generate and maintain a separate table of IDs
// for our AST objects!
//
// ---
//
// Note that the grammar is identical to the compile_calc_exec one: it's
// the ACTIONS which differ greatly!
//



// one grammar is MASTER for our common symbol set:
%import symbols  "./output/compiled_calc/compiled_calc_parse.js"







%token      NUM             // Simple double precision number
%token      VAR FUNCTION    // Variable and Function
%token      CONSTANT        // Predefined Constant Value, e.g. PI or E
%token      ERROR           // Mark error in statement
%token      COMMENT         // A line (or multiple lines) of comment

%token      END             // token to mark the end of a function argument list in the output token stream
%token      FUNCTION_0      // optimization: function without any input parameters
%token      FUNCTION_1      // optimization: function with one input parameter
%token      FUNCTION_2      // optimization: function with two input parameters
%token      FUNCTION_3      // optimization: function with three input parameters

%nonassoc   IF_ELSE         // IF ... THEN ... ELSE ...
%nonassoc   IF              // IF ... THEN ... (ELSE nil) -- the 'dangling else' issue has already been resolved by the *parser* hence this AST input stream doesn't suffer from that issue any more!


// %right      '='
%nonassoc   ASSIGN

%nonassoc   XOR
%nonassoc   OR
%nonassoc   AND

%nonassoc   EQ NEQ GEQ LEQ GT LT

// %left       '^'
// %left       '|'
// %left       '&'
%nonassoc   BITWISE_XOR
%nonassoc   BITWISE_OR
%nonassoc   BITWISE_AND

// %left       '-' '+'
// %left       '*' '/' '%'
// %right      POWER
// %right      '~'
// %right      '!' NOT
%nonassoc   ADD SUBTRACT
%nonassoc   MULTIPLY DIVIDE MODULO
%nonassoc   POWER
%nonassoc   BITWISE_NOT
%nonassoc   NOT
%nonassoc   FACTORIAL
%nonassoc   UMINUS     /* Negation--unary minus */
%nonassoc   UPLUS      /* unary plus */
%nonassoc   PERCENT    /* unary percentage */




/* Grammar follows */

%start input



//%options on-demand-lookahead    // camelCased: option.onDemandLookahead
%options no-default-action      // JISON shouldn't bother injecting the default `$$ = $1` action anywhere!
%options no-try-catch           // we assume this parser won't ever crash and we want the fastest Animal possible! So get rid of the try/catch/finally in the kernel!

%parse-param globalSpace        // extra function parameter for the generated parse() API; we use this one to pass in a reference to our workspace for the functions to play with.



%%


input:
  Îµ                             /* empty */
                                {
                                  $$ = [];
                                }
| input line EOL
                                {
                                  $input.push($line);
                                  $$ = $input;
                                }
| input COMMENT EOL
                                {
                                  console.log('COMMENT line(s): ', $COMMENT);
                                  $$ = $input;
                                }
;

line:
  exp
                                {
                                  console.log('expression result value: ', $exp);
                                  $$ = $exp;
                                }
| ERROR
                                {
                                  console.log('expression result value: ERROR - erroneous input line');
                                  $$ = NaN;
                                }
;


exp:
  NUM
                                { $$ = $NUM; }
| CONSTANT
                                { $$ = yy.constants[$CONSTANT].value; }
| VAR
                                { $$ = yy.variables[$VAR].value; }
| ASSIGN exp
                                {
                                  /*
                                     Note: #assign is always to a simple variable, hence we don't need the `#VAR`
                                     token here: it is implicit as there's nothing else we can do.

                                     Technically, this is an AST optimization, but it's such a fundamental one
                                     we do it here instead of later.

                                     NOTE: #assign implies the presence of a VAR as lhs (left hand side) so it
                                     would only be cluttering the AST stream to have a #VAR# token in there:
                                     it is *implicit* to #assign!
                                   */
                                  $$ = yy.variables[$ASSIGN].value = $exp;
                                }
| FUNCTION_0
                                { $$ = yy.functions[$FUNCTION_0].func.call(globalSpace); }
| FUNCTION arglist END
                                {
                                  /*
                                     A lot of functions have only a few arguments, which we later optimize in our AST
                                     by including that knowledge in the FUNCTION token by using derivative tokens
                                     FUNCTION_0, FUNCTION_1, etc.: this can help a smart optimizer to include
                                     special optimizations for these functions without having to re-discover
                                     the arglist length.
                                     As that approach already disambiguates the function-versus-statement
                                     situation by having encoded arglist length in the FUNCTION token, these
                                     tokens never require a sentinel token in the AST stream: small AST stream size.

                                     Also don't forget to FLATTEN the arglist! ==> `concat.apply(a, arglist)`

                                     NOTE: the #FUNCTION# rule in Polish Notation is ambiguous unless we terminate it
                                     (which is easy to parse in an LALR(1) grammar while adding a argument count is not!)
                                     as we would otherwise get confused over this scenario:

                                          ... PLUS FUNCTION exp exp exp ...

                                     - is this a function with one argument and that last `exp` in there the second term
                                       of a binary(?) opcode waiting in the leading `...`?
                                     - is this a function with two arguments and that last `exp` the second
                                       term of the PLUS?
                                     - is this a function with three arguments and is the second term of the PLUS
                                       waiting in the trailing `...`?

                                     This is the trouble with opcodes which accept a variable number of arguments:
                                     such opcodes always have to be terminated by a sentinel to make the AST grammar
                                     unambiguous.
                                  */
                                  $$ = yy.functions[$FUNCTION].func.apply(globalSpace, $arglist);
                                }
| FUNCTION_1 exp
                                {
                                  $$ = yy.functions[$FUNCTION_1].func.call(globalSpace, $exp);
                                }
| FUNCTION_2 exp exp
                                {
                                  $$ = yy.functions[$FUNCTION_2].func.call(globalSpace, $exp1, $exp2);
                                }
| FUNCTION_3 exp exp exp
                                {
                                  $$ = yy.functions[$FUNCTION_3].func.call(globalSpace, $exp1, $exp2, $exp3);
                                }

| EQ exp exp
                                { $$ = $exp1 == $exp2; }
| NEQ exp exp
                                { $$ = $exp1 != $exp2; }
| LEQ exp exp
                                { $$ = $exp1 <= $exp2; }
| GEQ exp exp
                                { $$ = $exp1 >= $exp2; }
| LT exp exp
                                { $$ = $exp1 < $exp2; }
| GT exp exp
                                { $$ = $exp1 > $exp2; }
| OR exp exp
                                { $$ = $exp1 || $exp2; }
| XOR exp exp
                                { $$ = !!(!!$exp1 ^ !!$exp2); }
| AND exp exp
                                { $$ = $exp1 && $exp2; }

| BITWISE_OR exp exp
                                { $$ = $exp1 | $exp2; }
| BITWISE_XOR exp exp
                                { $$ = $exp1 ^ $exp2; }
| BITWISE_AND exp exp
                                { $$ = $exp1 & $exp2; }

| ADD exp exp
                                { $$ = $exp1 + $exp2; }
| SUBTRACT exp exp
                                { $$ = $exp1 - $exp2; }
| MULTIPLY exp exp
                                { $$ = $exp1 * $exp2; }
| DIVIDE exp exp
                                { $$ = $exp1 / $exp2; }
| MODULO exp exp
                                { $$ = $exp1 % $exp2; }
| UMINUS exp
                                { $$ = -$exp; }
| UPLUS exp
                                { $$ = +$exp; }
| POWER exp exp
                                { $$ = Math.pow($exp1, $exp2); }
| PERCENT exp
                                { $$ = $exp / 100; }
| FACTORIAL exp
                                { $$ = yy.predefined_functions.factorial.call(globalSpace, $exp); }

| BITWISE_NOT exp
                                { $$ = ~$exp; }
| NOT exp
                                { $$ = !$exp; }


| IF_ELSE exp exp exp
                                {
                                  if ($exp1) {
                                    $$ = $exp2;
                                  } else {
                                    $$ = $exp3;
                                  }
                                }
| IF exp exp
                                {
                                  if ($exp1) {
                                    $$ = $exp2;
                                  } else {
                                    $$ = 0;
                                  }
                                }
;

arglist:
  exp
                                { $$ = [$exp]; }
| arglist exp
                                {
                                  $$ = $arglist;
                                  $$.push($exp);
                                }
;





/* End of grammar */


%%

