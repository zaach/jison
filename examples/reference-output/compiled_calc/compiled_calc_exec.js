
/* parser generated by jison 0.6.1-214 */

/*
 * Returns a Parser object of the following structure:
 *
 *  Parser: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a derivative/copy of this one,
 *               not a direct reference!
 *  }
 *
 *  Parser.prototype: {
 *    yy: {},
 *    EOF: 1,
 *    TERROR: 2,
 *
 *    trace: function(errorMessage, ...),
 *
 *    JisonParserError: function(msg, hash),
 *
 *    quoteName: function(name),
 *               Helper function which can be overridden by user code later on: put suitable
 *               quotes around literal IDs in a description string.
 *
 *    originalQuoteName: function(name),
 *               The basic quoteName handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function
 *               at the end of the `parse()`.
 *
 *    describeSymbol: function(symbol),
 *               Return a more-or-less human-readable description of the given symbol, when
 *               available, or the symbol itself, serving as its own 'description' for lack
 *               of something better to serve up.
 *
 *               Return NULL when the symbol is unknown to the parser.
 *
 *    symbols_: {associative list: name ==> number},
 *    terminals_: {associative list: number ==> name},
 *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},
 *    terminal_descriptions_: (if there are any) {associative list: number ==> description},
 *    productions_: [...],
 *
 *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)
 *                             to store/reference the rule value `$$` and location info `@$`.
 *
 *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets
 *                 to see the same object via the `this` reference, i.e. if you wish to carry custom
 *                 data from one reduce action through to the next within a single parse run, then you
 *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.
 *
 *                 `this.yy` is a direct reference to the `yy` shared state object.
 *
 *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`
 *                 object at `parse()` start and are therefore available to the action code via the
 *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from
 *                 the %parse-param` list.
 *
 *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used
 *                             to match this rule. This is *not* the look-ahead token, but the last token
 *                             that's actually part of this rule.
 *
 *                 Formulated another way, `yytext` is the value of the token immediately preceeding
 *                 the current look-ahead token.
 *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.
 *
 *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.
 *
 *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.
 *
 *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.
 *
 *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead
 *                               of an empty object when no suitable location info can be provided.
 *
 *               - `yystate` : the current parser state number, used internally for dispatching and
 *                               executing the action code chunk matching the rule currently being reduced.
 *
 *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *                 Also note that you can access this and other stack index values using the new double-hash
 *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things
 *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.
 *                 This is made available to write very advanced grammar action rules, e.g. when you want
 *                 to investigate the parse state stack in your action code, which would, for example,
 *                 be relevant when you wish to implement error diagnostics and reporting schemes similar
 *                 to the work described here:
 *
 *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.
 *                   In Journées Francophones des Languages Applicatifs.
 *
 *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.
 *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631–640.
 *
 *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.
 *                             constructs.
 *
 *               - `yylstack`: reference to the parser token location stack. Also accessed via
 *                             the `@1` etc. constructs.
 *
 *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are
 *                             UNDEFINED rather than an empty (location) object, when the lexer/parser
 *                             action code did not provide a suitable location info object when such a
 *                             slot was filled!
 *
 *               - `yystack` : reference to the parser token id stack. Also accessed via the
 *                             `#1` etc. constructs.
 *
 *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to
 *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might
 *                 want access this array for your own purposes, such as error analysis as mentioned above!
 *
 *                 Note that this stack stores the current stack of *tokens*, that is the sequence of
 *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*
 *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and
 *                 *reduced*.
 *
 *               - `yysstack`: reference to the parser state stack. This one carries the internal parser
 *                             *states* such as the one in `yystate`, which are used to represent
 *                             the parser state machine in the *parse table*. *Very* *internal* stuff,
 *                             what can I say? If you access this one, you're clearly doing wicked things
 *
 *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your
 *                             grammar definition file.
 *
 *    table: [...],
 *               State transition table
 *               ----------------------
 *
 *               index levels are:
 *               - `state`  --> hash table
 *               - `symbol` --> action (number or array)
 *
 *                 If the `action` is an array, these are the elements' meaning:
 *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept
 *                 - index [1]: GOTO `state`
 *
 *                 If the `action` is a number, it is the GOTO `state`
 *
 *    defaultActions: {...},
 *
 *    parseError: function(str, hash, ExceptionClass),
 *    yyError: function(str, ...),
 *    yyRecovering: function(),
 *    yyErrOk: function(),
 *    yyClearIn: function(),
 *
 *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this parser kernel in many places; example usage:
 *
 *                   var infoObj = parser.constructParseErrorInfo('fail!', null,
 *                                     parser.collect_expected_token_set(state), true);
 *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);
 *
 *    originalParseError: function(str, hash, ExceptionClass),
 *               The basic `parseError` handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function
 *               at the end of the `parse()`.
 *
 *    options: { ... parser %options ... },
 *
 *    parse: function(input[, args...]),
 *               Parse the given `input` and return the parsed value (or `true` when none was provided by
 *               the root action, in which case the parser is acting as a *matcher*).
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the jison run-time;
 *               when such a collision is detected an exception is thrown to prevent the generated run-time
 *               from silently accepting this confusing and potentially hazardous situation!
 *
 *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in
 *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state
 *               object and any collision with those will be reported by the lexer via a thrown exception.
 *
 *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown
 *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY
 *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and
 *               the internal parser gets properly garbage collected under these particular circumstances.
 *
 *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API can be invoked to calculate a spanning `yylloc` location info object.
 *
 *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case
 *               this function will attempt to obtain a suitable location marker by inspecting the location stack
 *               backwards.
 *
 *               For more info see the documentation comment further below, immediately above this function's
 *               implementation.
 *
 *    lexer: {
 *        yy: {...},           A reference to the so-called "shared state" `yy` once
 *                             received via a call to the `.setInput(input, yy)` lexer API.
 *        EOF: 1,
 *        ERROR: 2,
 *        JisonLexerError: function(msg, hash),
 *        parseError: function(str, hash, ExceptionClass),
 *        setInput: function(input, [yy]),
 *        input: function(),
 *        unput: function(str),
 *        more: function(),
 *        reject: function(),
 *        less: function(n),
 *        pastInput: function(n),
 *        upcomingInput: function(n),
 *        showPosition: function(),
 *        test_match: function(regex_match_array, rule_index, ...),
 *        next: function(...),
 *        lex: function(...),
 *        begin: function(condition),
 *        pushState: function(condition),
 *        popState: function(),
 *        topState: function(),
 *        _currentRules: function(),
 *        stateStackSize: function(),
 *        cleanupAfterLex: function()
 *
 *        options: { ... lexer %options ... },
 *
 *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),
 *        rules: [...],
 *        conditions: {associative list: name ==> set},
 *    }
 *  }
 *
 *
 *  token location info (@$, _$, etc.): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer and
 * parser errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *  }
 *
 * parser (grammar) errors will also provide these additional members:
 *
 *  {
 *    expected:    (array describing the set of expected tokens;
 *                  may be UNDEFINED when we cannot easily produce such a set)
 *    state:       (integer (or array when the table includes grammar collisions);
 *                  represents the current internal state of the parser kernel.
 *                  can, for example, be used to pass to the `collect_expected_token_set()`
 *                  API to obtain the expected token set)
 *    action:      (integer; represents the current internal action which will be executed)
 *    new_state:   (integer; represents the next/planned internal state, once the current
 *                  action has executed)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *    parser:      (reference to the current parser instance)
 *  }
 *
 * while `this` will reference the current parser instance.
 *
 * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    lexer:       (reference to the current lexer instance which reported the error)
 *  }
 *
 * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired
 * from either the parser or lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    exception:   (reference to the exception thrown)
 *  }
 *
 * Please do note that in the latter situation, the `expected` field will be omitted as
 * this type of failure is assumed not to be due to *parse errors* but rather due to user
 * action code in either parser or lexer failing unexpectedly.
 *
 * ---
 *
 * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.
 * These options are available:
 *
 * ### options which are global for all parser instances
 *
 *  Parser.pre_parse: function(yy)
 *                 optional: you can specify a pre_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`.
 *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: you can specify a post_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`. When it does not return any value,
 *                 the parser will return the original `retval`.
 *
 * ### options which can be set up per parser instance
 *
 *  yy: {
 *      pre_parse:  function(yy)
 *                 optional: is invoked before the parse cycle starts (and before the first
 *                 invocation of `lex()`) but immediately after the invocation of
 *                 `parser.pre_parse()`).
 *      post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: is invoked when the parse terminates due to success ('accept')
 *                 or failure (even when exceptions are thrown).
 *                 `retval` contains the return value to be produced by `Parser.parse()`;
 *                 this function can override the return value by returning another.
 *                 When it does not return any value, the parser will return the original
 *                 `retval`.
 *                 This function is invoked immediately before `parser.post_parse()`.
 *
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *      quoteName: function(name),
 *                 optional: overrides the default `quoteName` function.
 *  }
 *
 *  parser.lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */

        
    
            var compiled_calc_exec = (function () {

// See also:
// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
// with userland code which might access the derived class in a 'classic' way.
function JisonParserError(msg, hash) {
    Object.defineProperty(this, 'name', {
        enumerable: false,
        writable: false,
        value: 'JisonParserError'
    });

    if (msg == null) msg = '???';

    Object.defineProperty(this, 'message', {
        enumerable: false,
        writable: true,
        value: msg
    });

    this.hash = hash;

    var stacktrace;
    if (hash && hash.exception instanceof Error) {
        var ex2 = hash.exception;
        this.message = ex2.message || msg;
        stacktrace = ex2.stack;
    }
    if (!stacktrace) {
        if (Error.hasOwnProperty('captureStackTrace')) {        // V8/Chrome engine
            Error.captureStackTrace(this, this.constructor);
        } else {
            stacktrace = (new Error(msg)).stack;
        }
    }
    if (stacktrace) {
        Object.defineProperty(this, 'stack', {
            enumerable: false,
            writable: false,
            value: stacktrace
        });
    }
}

if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);
} else {
    JisonParserError.prototype = Object.create(Error.prototype);
}
JisonParserError.prototype.constructor = JisonParserError;
JisonParserError.prototype.name = 'JisonParserError';



        // helper: reconstruct the productions[] table
        function bp(s) {
            var rv = [];
            var p = s.pop;
            var r = s.rule;
            for (var i = 0, l = p.length; i < l; i++) {
                rv.push([
                    p[i],
                    r[i]
                ]);
            }
            return rv;
        }
    


        // helper: reconstruct the defaultActions[] table
        function bda(s) {
            var rv = {};
            var d = s.idx;
            var g = s.goto;
            for (var i = 0, l = d.length; i < l; i++) {
                var j = d[i];
                rv[j] = g[i];
            }
            return rv;
        }
    


        // helper: reconstruct the 'goto' table
        function bt(s) {
            var rv = [];
            var d = s.len;
            var y = s.symbol;
            var t = s.type;
            var a = s.state;
            var m = s.mode;
            var g = s.goto;
            for (var i = 0, l = d.length; i < l; i++) {
                var n = d[i];
                var q = {};
                for (var j = 0; j < n; j++) {
                    var z = y.shift();
                    switch (t.shift()) {
                    case 2:
                        q[z] = [
                            m.shift(),
                            g.shift()
                        ];
                        break;

                    case 0:
                        q[z] = a.shift();
                        break;

                    default:
                        // type === 1: accept
                        q[z] = [
                            3
                        ];
                    }
                }
                rv.push(q);
            }
            return rv;
        }
    


        // helper: runlength encoding with increment step: code, length: step (default step = 0)
        // `this` references an array
        function s(c, l, a) {
            a = a || 0;
            for (var i = 0; i < l; i++) {
                this.push(c);
                c += a;
            }
        }

        // helper: duplicate sequence from *relative* offset and length.
        // `this` references an array
        function c(i, l) {
            i = this.length - i;
            for (l += i; i < l; i++) {
                this.push(this[i]);
            }
        }

        // helper: unpack an array using helpers and data, all passed in an array argument 'a'.
        function u(a) {
            var rv = [];
            for (var i = 0, l = a.length; i < l; i++) {
                var e = a[i];
                // Is this entry a helper function?
                if (typeof e === 'function') {
                    i++;
                    e.apply(rv, a[i]);
                } else {
                    rv.push(e);
                }
            }
            return rv;
        }
    

var parser = {
    // Code Generator Information Report
    // ---------------------------------
    //
    // Options:
    //
    //   default action mode: ............. none,merge
    //   try..catch: ...................... false
    //   default resolve on conflict: ..... true
    //   on-demand look-ahead: ............ false
    //   error recovery token skip maximum: 3
    //   yyerror in parse actions is: ..... NOT recoverable,
    //   yyerror in lexer actions and other non-fatal lexer are:
    //   .................................. NOT recoverable,
    //   debug grammar/output: ............ false
    //   has partial LR conflict upgrade:   true
    //   rudimentary token-stack support:   false
    //   parser table compression mode: ... 2
    //   export debug tables: ............. false
    //   export *all* tables: ............. false
    //   module type: ..................... commonjs
    //   parser engine type: .............. lalr
    //   output main() in the module: ..... false
    //   has user-specified main(): ....... false
    //   has user-specified require()/import modules for main():
    //   .................................. false
    //   number of expected conflicts: .... 0
    //
    //
    // Parser Analysis flags:
    //
    //   no significant actions (parser is a language matcher only):
    //   .................................. false
    //   uses yyleng: ..................... false
    //   uses yylineno: ................... false
    //   uses yytext: ..................... false
    //   uses yylloc: ..................... false
    //   uses ParseError API: ............. true
    //   uses YYERROR: .................... false
    //   uses YYRECOVERING: ............... false
    //   uses YYERROK: .................... true
    //   uses YYCLEARIN: .................. true
    //   tracks rule values: .............. true
    //   assigns rule values: ............. true
    //   uses location tracking: .......... true
    //   assigns location: ................ true
    //   uses yystack: .................... true
    //   uses yysstack: ................... true
    //   uses yysp: ....................... true
    //   uses yyrulelength: ............... false
    //   uses yyMergeLocationInfo API: .... true
    //   has error recovery: .............. false
    //   has error reporting: ............. true
    //
    // --------- END OF REPORT -----------

trace: function no_op_trace() {},
JisonParserError: JisonParserError,
yy: {},
options: {
  type: "lalr",
  hasPartialLrUpgradeOnConflict: true,
  errorRecoveryTokenDiscardCount: 3
},
symbols_: {
  "!": 91,
  "$accept": 0,
  "$end": 1,
  "%": 90,
  "&": 82,
  "(": 72,
  ")": 75,
  "*": 87,
  "+": 84,
  ",": 96,
  "-": 85,
  "/": 89,
  ":": 95,
  "=": 71,
  "?": 93,
  "ADD": 43,
  "ADD_3": 80,
  "ADD_4": 4,
  "AND": 65,
  "AND_3": 5,
  "AND_4": 6,
  "ASSIGN": 7,
  "BITWISE_AND": 38,
  "BITWISE_NOT": 126,
  "BITWISE_OR": 124,
  "BITWISE_XOR": 94,
  "COMMENT": 97,
  "CONDITION": 63,
  "CONSTANT": 8,
  "DIVIDE": 47,
  "ELSE": 9,
  "END": 10,
  "EOF": 1,
  "EOL": 11,
  "EQ": 61,
  "ERROR": 3,
  "ERROR_AND_SKIP": 12,
  "EXCHANGE_A_R1": 13,
  "EXCHANGE_A_R2": 14,
  "EXCHANGE_R1_R2": 15,
  "EXEC": 16,
  "FACTORIAL": 17,
  "FALSE": 18,
  "FALSE_AND_SKIP": 19,
  "FUNCTION": 70,
  "FUNCTION_0": 48,
  "FUNCTION_1": 49,
  "FUNCTION_2": 50,
  "FUNCTION_3": 51,
  "FUNCTION_N": 57,
  "GEQ": 20,
  "GT": 62,
  "IF": 21,
  "IF_ELSE": 22,
  "LEQ": 23,
  "LT": 60,
  "MODULO": 37,
  "MOVE_ALL_TO_RX": 24,
  "MOVE_FROM_R1": 25,
  "MOVE_FROM_R2": 26,
  "MOVE_R2_TO_R1": 27,
  "MOVE_TO_R1": 28,
  "MOVE_TO_R2": 29,
  "MOVE_TO_RX": 30,
  "MULTIPLY": 42,
  "MULTIPLY_3": 77,
  "MULTIPLY_4": 31,
  "NEQ": 110,
  "NOP": 32,
  "NOT": 33,
  "NUM": 73,
  "NUM_AND_SKIP": 74,
  "OR": 79,
  "OR_3": 34,
  "OR_4": 35,
  "PERCENT": 36,
  "POP": 39,
  "POWER": 40,
  "PUSH": 44,
  "PUSH_NUMS": 78,
  "SHIFT_EX": 41,
  "SKIP": 83,
  "STRING": 46,
  "STRING_AND_SKIP": 52,
  "SUBTRACT": 45,
  "SUBTRACT_3": 53,
  "SUBTRACT_4": 54,
  "THEN": 98,
  "TRUE": 55,
  "TRUE_AND_SKIP": 56,
  "UMINUS": 58,
  "UNSHIFT_EX": 59,
  "UNSHIFT_RX_TO_ALL": 64,
  "UNSHIFT_RX_TO_R12": 66,
  "UPLUS": 67,
  "VAR": 86,
  "VAR_TO_VALUE": 68,
  "VAR_VALUE": 69,
  "XOR": 88,
  "^": 81,
  "arglist": 102,
  "error": 2,
  "exp": 101,
  "input": 99,
  "line": 100,
  "s": 103,
  "|": 76,
  "~": 92
},
terminals_: {
  1: "EOF",
  2: "error",
  3: "ERROR",
  4: "ADD_4",
  5: "AND_3",
  6: "AND_4",
  7: "ASSIGN",
  8: "CONSTANT",
  9: "ELSE",
  10: "END",
  11: "EOL",
  12: "ERROR_AND_SKIP",
  13: "EXCHANGE_A_R1",
  14: "EXCHANGE_A_R2",
  15: "EXCHANGE_R1_R2",
  16: "EXEC",
  17: "FACTORIAL",
  18: "FALSE",
  19: "FALSE_AND_SKIP",
  20: "GEQ",
  21: "IF",
  22: "IF_ELSE",
  23: "LEQ",
  24: "MOVE_ALL_TO_RX",
  25: "MOVE_FROM_R1",
  26: "MOVE_FROM_R2",
  27: "MOVE_R2_TO_R1",
  28: "MOVE_TO_R1",
  29: "MOVE_TO_R2",
  30: "MOVE_TO_RX",
  31: "MULTIPLY_4",
  32: "NOP",
  33: "NOT",
  34: "OR_3",
  35: "OR_4",
  36: "PERCENT",
  37: "MODULO",
  38: "BITWISE_AND",
  39: "POP",
  40: "POWER",
  41: "SHIFT_EX",
  42: "MULTIPLY",
  43: "ADD",
  44: "PUSH",
  45: "SUBTRACT",
  46: "STRING",
  47: "DIVIDE",
  48: "FUNCTION_0",
  49: "FUNCTION_1",
  50: "FUNCTION_2",
  51: "FUNCTION_3",
  52: "STRING_AND_SKIP",
  53: "SUBTRACT_3",
  54: "SUBTRACT_4",
  55: "TRUE",
  56: "TRUE_AND_SKIP",
  57: "FUNCTION_N",
  58: "UMINUS",
  59: "UNSHIFT_EX",
  60: "LT",
  61: "EQ",
  62: "GT",
  63: "CONDITION",
  64: "UNSHIFT_RX_TO_ALL",
  65: "AND",
  66: "UNSHIFT_RX_TO_R12",
  67: "UPLUS",
  68: "VAR_TO_VALUE",
  69: "VAR_VALUE",
  70: "FUNCTION",
  71: "=",
  72: "(",
  73: "NUM",
  74: "NUM_AND_SKIP",
  75: ")",
  76: "|",
  77: "MULTIPLY_3",
  78: "PUSH_NUMS",
  79: "OR",
  80: "ADD_3",
  81: "^",
  82: "&",
  83: "SKIP",
  84: "+",
  85: "-",
  86: "VAR",
  87: "*",
  88: "XOR",
  89: "/",
  90: "%",
  91: "!",
  92: "~",
  93: "?",
  94: "BITWISE_XOR",
  95: ":",
  96: ",",
  97: "COMMENT",
  98: "THEN",
  103: "s",
  110: "NEQ",
  124: "BITWISE_OR",
  126: "BITWISE_NOT"
},
TERROR: 2,
EOF: 1,

// internals: defined here so the object *structure* doesn't get modified by parse() et al,
// thus helping JIT compilers like Chrome V8.
originalQuoteName: null,
originalParseError: null,
cleanupAfterParse: null,
constructParseErrorInfo: null,
yyMergeLocationInfo: null,

__reentrant_call_depth: 0, // INTERNAL USE ONLY
__error_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup
__error_recovery_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup

// APIs which will be set up depending on user action code analysis:
//yyRecovering: 0,
//yyErrOk: 0,
//yyClearIn: 0,

// Helper APIs
// -----------

// Helper function which can be overridden by user code later on: put suitable quotes around
// literal IDs in a description string.
quoteName: function parser_quoteName(id_str) {
    return '"' + id_str + '"';
},

// Return the name of the given symbol (terminal or non-terminal) as a string, when available.
//
// Return NULL when the symbol is unknown to the parser.
getSymbolName: function parser_getSymbolName(symbol) {
    if (this.terminals_[symbol]) {
        return this.terminals_[symbol];
    }

    // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.
    //
    // An example of this may be where a rule's action code contains a call like this:
    //
    //      parser.getSymbolName(#$)
    //
    // to obtain a human-readable name of the current grammar rule.
    var s = this.symbols_;
    for (var key in s) {
        if (s[key] === symbol) {
            return key;
        }
    }
    return null;
},

// Return a more-or-less human-readable description of the given symbol, when available,
// or the symbol itself, serving as its own 'description' for lack of something better to serve up.
//
// Return NULL when the symbol is unknown to the parser.
describeSymbol: function parser_describeSymbol(symbol) {
    if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {
        return this.terminal_descriptions_[symbol];
    } else if (symbol === this.EOF) {
        return 'end of input';
    }
    var id = this.getSymbolName(symbol);
    if (id) {
        return this.quoteName(id);
    }
    return null;
},

// Produce a (more or less) human-readable list of expected tokens at the point of failure.
//
// The produced list may contain token or token set descriptions instead of the tokens
// themselves to help turning this output into something that easier to read by humans
// unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,
// expected terminals and nonterminals is produced.
//
// The returned list (array) will not contain any duplicate entries.
collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {
    var TERROR = this.TERROR;
    var tokenset = [];
    var check = {};
    // Has this (error?) state been outfitted with a custom expectations description text for human consumption?
    // If so, use that one instead of the less palatable token set.
    if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {
        return [this.state_descriptions_[state]];
    }
    for (var p in this.table[state]) {
        p = +p;
        if (p !== TERROR) {
            var d = do_not_describe ? p : this.describeSymbol(p);
            if (d && !check[d]) {
                tokenset.push(d);
                check[d] = true; // Mark this token description as already mentioned to prevent outputting duplicate entries.
            }
        }
    }
    return tokenset;
},
productions_: bp({
  pop: u([
  s,
  [99, 3],
  100,
  100,
  s,
  [101, 35],
  102,
  102
]),
  rule: u([
  0,
  3,
  3,
  s,
  [1, 5],
  2,
  1,
  3,
  2,
  3,
  4,
  s,
  [3, 17],
  2,
  2,
  c,
  [3, 3],
  2,
  2,
  4,
  3,
  1,
  2
])
}),
performAction: function parser__PerformAction(yyloc, yystate /* action[1] */, yysp, yyvstack, yylstack, yystack, yysstack) {

          /* this == yyval */

          // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!
          var yy = this.yy;
          var yyparser = yy.parser;
          var yylexer = yy.lexer;

          

          switch (yystate) {
case 0:
    /*! Production::    $accept : input $end */

    // default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,LT,LA,-,-):
    this.$ = undefined;
    this._$ = yylstack[yysp - 1];
    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,LT,LA,-,-)
    break;

case 1:
    /*! Production::    input : %epsilon */

    // default action (generated by JISON mode none/merge :: 0,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(null, null, null, null, true);
    // END of default action (generated by JISON mode none/merge :: 0,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = [];
    break;

case 2:
    /*! Production::    input : input line EOL */

    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
    
    
    yyvstack[yysp - 2].push(yyvstack[yysp - 1]);
    this.$ = yyvstack[yysp - 2];
    break;

case 3:
    /*! Production::    input : input COMMENT EOL */

    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
    
    
    console.log('COMMENT line(s): ', yyvstack[yysp - 1]);
    this.$ = yyvstack[yysp - 2];
    break;

case 4:
    /*! Production::    line : exp */

    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
    
    
    console.log('expression result value: ', yyvstack[yysp]);
    this.$ = yyvstack[yysp];
    break;

case 5:
    /*! Production::    line : ERROR */

    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
    
    
    console.log('expression result value: ERROR - erroneous input line');
    this.$ = NaN;
    break;

case 6:
    /*! Production::    exp : NUM */

    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp];
    break;

case 7:
    /*! Production::    exp : CONSTANT */

    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yy.constants[yyvstack[yysp]].value;
    break;

case 8:
    /*! Production::    exp : VAR */

    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yy.variables[yyvstack[yysp]].value;
    break;

case 9:
    /*! Production::    exp : ASSIGN exp */

    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
    
    
    /*
       Note: #ASSIGN is always to a simple variable, hence we don't need the `#VAR`
       token here: it is implicit as there's nothing else we can do.
    
       Technically, this is an AST optimization, but it's such a fundamental one
       we do it here instead of later.
    
       NOTE: #ASSIGN implies the presence of a VAR as lhs (left hand side) so it
       would only be cluttering the AST stream to have a #VAR# token in there:
       it is *implicit* to #assign!
     */
    this.$ = yy.variables[yyvstack[yysp - 1]].value = yyvstack[yysp];
    break;

case 10:
    /*! Production::    exp : FUNCTION_0 */

    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yy.functions[yyvstack[yysp]].func.call(globalSpace);
    break;

case 11:
    /*! Production::    exp : FUNCTION arglist END */

    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
    
    
    /*
       A lot of functions have only a few arguments, which we later optimize in our AST
       by including that knowledge in the FUNCTION token by using derivative tokens
       FUNCTION_0, FUNCTION_1, etc.: this can help a smart optimizer to include
       special optimizations for these functions without having to re-discover
       the arglist length.
       As that approach already disambiguates the function-versus-statement
       situation by having encoded arglist length in the FUNCTION token, these
       tokens never require a sentinel token in the AST stream: small AST stream size.
    
       Also don't forget to FLATTEN the arglist! ==> `concat.apply(a, arglist)`
    
       NOTE: the #FUNCTION# rule in Polish Notation is ambiguous unless we terminate it
       (which is easy to parse in an LALR(1) grammar while adding a argument count is not!)
       as we would otherwise get confused over this scenario:
    
            ... PLUS FUNCTION exp exp exp ...
    
       - is this a function with one argument and that last `exp` in there the second term
         of a binary(?) opcode waiting in the leading `...`?
       - is this a function with two arguments and that last `exp` the second
         term of the PLUS?
       - is this a function with three arguments and is the second term of the PLUS
         waiting in the trailing `...`?
    
       This is the trouble with opcodes which accept a variable number of arguments:
       such opcodes always have to be terminated by a sentinel to make the AST grammar
       unambiguous.
    */
    this.$ = yy.functions[yyvstack[yysp - 2]].func.apply(globalSpace, yyvstack[yysp - 1]);
    break;

case 12:
    /*! Production::    exp : FUNCTION_1 exp */

    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yy.functions[yyvstack[yysp - 1]].func.call(globalSpace, yyvstack[yysp]);
    break;

case 13:
    /*! Production::    exp : FUNCTION_2 exp exp */

    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yy.functions[yyvstack[yysp - 2]].func.call(globalSpace, yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 14:
    /*! Production::    exp : FUNCTION_3 exp exp exp */

    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yy.functions[yyvstack[yysp - 3]].func.call(globalSpace, yyvstack[yysp - 2], yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 15:
    /*! Production::    exp : EQ exp exp */

    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp - 1] == yyvstack[yysp];
    break;

case 16:
    /*! Production::    exp : NEQ exp exp */

    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp - 1] != yyvstack[yysp];
    break;

case 17:
    /*! Production::    exp : LEQ exp exp */

    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp - 1] <= yyvstack[yysp];
    break;

case 18:
    /*! Production::    exp : GEQ exp exp */

    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp - 1] >= yyvstack[yysp];
    break;

case 19:
    /*! Production::    exp : LT exp exp */

    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp - 1] < yyvstack[yysp];
    break;

case 20:
    /*! Production::    exp : GT exp exp */

    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp - 1] > yyvstack[yysp];
    break;

case 21:
    /*! Production::    exp : OR exp exp */

    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp - 1] || yyvstack[yysp];
    break;

case 22:
    /*! Production::    exp : XOR exp exp */

    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = !!(!!yyvstack[yysp - 1] ^ !!yyvstack[yysp]);
    break;

case 23:
    /*! Production::    exp : AND exp exp */

    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp - 1] && yyvstack[yysp];
    break;

case 24:
    /*! Production::    exp : BITWISE_OR exp exp */

    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp - 1] | yyvstack[yysp];
    break;

case 25:
    /*! Production::    exp : BITWISE_XOR exp exp */

    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp - 1] ^ yyvstack[yysp];
    break;

case 26:
    /*! Production::    exp : BITWISE_AND exp exp */

    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp - 1] & yyvstack[yysp];
    break;

case 27:
    /*! Production::    exp : ADD exp exp */

    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp - 1] + yyvstack[yysp];
    break;

case 28:
    /*! Production::    exp : SUBTRACT exp exp */

    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp - 1] - yyvstack[yysp];
    break;

case 29:
    /*! Production::    exp : MULTIPLY exp exp */

    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp - 1] * yyvstack[yysp];
    break;

case 30:
    /*! Production::    exp : DIVIDE exp exp */

    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp - 1] / yyvstack[yysp];
    break;

case 31:
    /*! Production::    exp : MODULO exp exp */

    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp - 1] % yyvstack[yysp];
    break;

case 32:
    /*! Production::    exp : UMINUS exp */

    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = -yyvstack[yysp];
    break;

case 33:
    /*! Production::    exp : UPLUS exp */

    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = +yyvstack[yysp];
    break;

case 34:
    /*! Production::    exp : POWER exp exp */

    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = Math.pow(yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 35:
    /*! Production::    exp : PERCENT exp */

    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp] / 100;
    break;

case 36:
    /*! Production::    exp : FACTORIAL exp */

    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yy.predefined_functions.factorial.call(globalSpace, yyvstack[yysp]);
    break;

case 37:
    /*! Production::    exp : BITWISE_NOT exp */

    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = ~yyvstack[yysp];
    break;

case 38:
    /*! Production::    exp : NOT exp */

    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = !yyvstack[yysp];
    break;

case 39:
    /*! Production::    exp : IF_ELSE exp exp exp */

    // default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
    // END of default action (generated by JISON mode none/merge :: 4,VT,VA,VU,-,LT,LA,-,-)
    
    
    if (yyvstack[yysp - 2]) {
      this.$ = yyvstack[yysp - 1];
    } else {
      this.$ = yyvstack[yysp];
    }
    break;

case 40:
    /*! Production::    exp : IF exp exp */

    // default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
    // END of default action (generated by JISON mode none/merge :: 3,VT,VA,VU,-,LT,LA,-,-)
    
    
    if (yyvstack[yysp - 1]) {
      this.$ = yyvstack[yysp];
    } else {
      this.$ = 0;
    }
    break;

case 41:
    /*! Production::    arglist : exp */

    // default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yylstack[yysp];
    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = [yyvstack[yysp]];
    break;

case 42:
    /*! Production::    arglist : arglist exp */

    // default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
    this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
    // END of default action (generated by JISON mode none/merge :: 2,VT,VA,VU,-,LT,LA,-,-)
    
    
    this.$ = yyvstack[yysp - 1];
    this.$.push(yyvstack[yysp]);
    break;

}
},
table: bt({
  len: u([
  1,
  40,
  1,
  1,
  s,
  [0, 5],
  36,
  0,
  37,
  s,
  [36, 29],
  s,
  [0, 3],
  37,
  c,
  [38, 3],
  c,
  [25, 20],
  c,
  [28, 4],
  c,
  [26, 3],
  c,
  [69, 5],
  s,
  [0, 17],
  c,
  [19, 4]
]),
  symbol: u([
  99,
  1,
  3,
  7,
  8,
  17,
  s,
  [20, 4, 1],
  33,
  36,
  37,
  38,
  40,
  42,
  43,
  45,
  s,
  [47, 5, 1],
  58,
  60,
  61,
  62,
  65,
  67,
  70,
  73,
  79,
  86,
  88,
  94,
  97,
  100,
  101,
  110,
  124,
  126,
  11,
  11,
  c,
  [40, 32],
  c,
  [38, 4],
  c,
  [36, 33],
  102,
  c,
  [37, 36],
  c,
  [36, 1013],
  10,
  c,
  [901, 898]
]),
  type: u([
  0,
  1,
  s,
  [2, 34],
  0,
  0,
  s,
  [2, 37],
  c,
  [38, 36],
  c,
  [75, 37],
  c,
  [36, 1044],
  c,
  [901, 869]
]),
  state: u([
  1,
  2,
  4,
  43,
  45,
  44,
  s,
  [46, 29, 1],
  s,
  [76, 25, 1]
]),
  mode: u([
  s,
  [1, 2000]
]),
  goto: u([
  5,
  9,
  7,
  36,
  18,
  40,
  39,
  17,
  38,
  35,
  31,
  26,
  34,
  29,
  27,
  28,
  30,
  10,
  12,
  13,
  14,
  32,
  19,
  15,
  20,
  23,
  33,
  11,
  6,
  21,
  8,
  22,
  25,
  3,
  16,
  24,
  37,
  41,
  42,
  c,
  [38, 32],
  c,
  [37, 3],
  c,
  [35, 1052],
  75,
  c,
  [876, 873]
])
}),
defaultActions: bda({
  idx: u([
  0,
  s,
  [4, 5, 1],
  10,
  41,
  42,
  43,
  45,
  46,
  66,
  67,
  s,
  [69, 4, 1],
  75,
  76,
  77,
  s,
  [79, 18, 1],
  98,
  99,
  100
]),
  goto: u([
  1,
  s,
  [4, 5, 1],
  10,
  2,
  3,
  9,
  41,
  12,
  32,
  33,
  s,
  [35, 4, 1],
  11,
  42,
  13,
  s,
  [15, 17, 1],
  34,
  40,
  14,
  39
])
}),
parseError: function parseError(str, hash, ExceptionClass) {
    if (hash.recoverable) {
        if (typeof this.trace === 'function') {
            this.trace(str);
        }
        hash.destroy();             // destroy... well, *almost*!
    } else {
        if (typeof this.trace === 'function') {
            this.trace(str);
        }
        if (!ExceptionClass) {
            ExceptionClass = this.JisonParserError;
        }
        throw new ExceptionClass(str, hash);
    }
},
parse: function parse(input, globalSpace) {
    var self = this;
    var stack = new Array(128);         // token stack: stores token which leads to state at the same index (column storage)
    var sstack = new Array(128);        // state stack: stores states (column storage)

    var vstack = new Array(128);        // semantic value stack
    var lstack = new Array(128);        // location stack
    var table = this.table;
    var sp = 0;                         // 'stack pointer': index into the stacks
    var yyloc;

    


    var symbol = 0;



    var TERROR = this.TERROR;
    var EOF = this.EOF;
    var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = (this.options.errorRecoveryTokenDiscardCount | 0) || 3;
    var NO_ACTION = [0, 101 /* === table.length :: ensures that anyone using this new state will fail dramatically! */];

    var lexer;
    if (this.__lexer__) {
        lexer = this.__lexer__;
    } else {
        lexer = this.__lexer__ = Object.create(this.lexer);
    }

    var sharedState_yy = {
        parseError: undefined,
        quoteName: undefined,
        lexer: undefined,
        parser: undefined,
        pre_parse: undefined,
        post_parse: undefined,
        pre_lex: undefined,
        post_lex: undefined,
        globalSpace: globalSpace  // parseParams::globalSpace      // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!
    };

    var ASSERT;
    if (typeof assert !== 'function') {
        ASSERT = function JisonAssert(cond, msg) {
            if (!cond) {
                throw new Error('assertion failed: ' + (msg || '***'));
            }
        };
    } else {
        ASSERT = assert;
    }

    this.yyGetSharedState = function yyGetSharedState() {
        return sharedState_yy;
    };


    // shallow clone objects, straight copy of simple `src` values
    // e.g. `lexer.yytext` MAY be a complex value object,
    // rather than a simple string/value.
    function shallow_copy(src) {
        if (typeof src === 'object') {
            var dst = {};
            for (var k in src) {
                if (Object.prototype.hasOwnProperty.call(src, k)) {
                    dst[k] = src[k];
                }
            }
            return dst;
        }
        return src;
    }
    function shallow_copy_noclobber(dst, src) {
        for (var k in src) {
            if (typeof dst[k] === 'undefined' && Object.prototype.hasOwnProperty.call(src, k)) {
                dst[k] = src[k];
            }
        }
    }
    function copy_yylloc(loc) {
        var rv = shallow_copy(loc);
        if (rv && rv.range) {
            rv.range = rv.range.slice(0);
        }
        return rv;
    }

    // copy state
    shallow_copy_noclobber(sharedState_yy, this.yy);

    sharedState_yy.lexer = lexer;
    sharedState_yy.parser = this;





    // *Always* setup `yyError`, `YYRECOVERING`, `yyErrOk` and `yyClearIn` functions as it is paramount
    // to have *their* closure match ours -- if we only set them up once,
    // any subsequent `parse()` runs will fail in very obscure ways when
    // these functions are invoked in the user action code block(s) as
    // their closure will still refer to the `parse()` instance which set
    // them up. Hence we MUST set them up at the start of every `parse()` run!






    // Does the shared state override the default `parseError` that already comes with this instance?
    if (typeof sharedState_yy.parseError === 'function') {
        this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {
            if (!ExceptionClass) {
                ExceptionClass = this.JisonParserError;
            }
            return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);
        };
    } else {
        this.parseError = this.originalParseError;
    }

    // Does the shared state override the default `quoteName` that already comes with this instance?
    if (typeof sharedState_yy.quoteName === 'function') {
        this.quoteName = function quoteNameAlt(id_str) {
            return sharedState_yy.quoteName.call(this, id_str);
        };
    } else {
        this.quoteName = this.originalQuoteName;
    }

    // set up the cleanup function; make it an API so that external code can re-use this one in case of
    // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which
    // case this parse() API method doesn't come with a `finally { ... }` block any more!
    //
    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `sharedState`, etc. references will be *wrong*!
    this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {
        var rv;

        if (invoke_post_methods) {
            var hash;

            if (sharedState_yy.post_parse || this.post_parse) {
                // create an error hash info instance: we re-use this API in a **non-error situation**
                // as this one delivers all parser internals ready for access by userland code.
                hash = this.constructParseErrorInfo(null /* no error! */, null /* no exception! */, null, false);
            }

            if (sharedState_yy.post_parse) {
                rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }
            if (this.post_parse) {
                rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }

            // cleanup:
            if (hash && hash.destroy) {
                hash.destroy();
            }
        }




        // clean up the lingering lexer structures as well:
        if (lexer.cleanupAfterLex) {
            lexer.cleanupAfterLex(do_not_nuke_errorinfos);
        }

        // prevent lingering circular references from causing memory leaks:
        if (sharedState_yy) {
            sharedState_yy.lexer = undefined;
            sharedState_yy.parser = undefined;
            if (lexer.yy === sharedState_yy) {
                lexer.yy = undefined;
            }
        }
        sharedState_yy = undefined;
        this.parseError = this.originalParseError;
        this.quoteName = this.originalQuoteName;

        // nuke the vstack[] array at least as that one will still reference obsoleted user values.
        // To be safe, we nuke the other internal stack columns as well...
        stack.length = 0;               // fastest way to nuke an array without overly bothering the GC
        sstack.length = 0;
        lstack.length = 0;
        vstack.length = 0;
        sp = 0;

        // nuke the error hash info instances created during this run.
        // Userland code must COPY any data/references
        // in the error hash instance(s) it is more permanently interested in.
        if (!do_not_nuke_errorinfos) {
            for (var i = this.__error_infos.length - 1; i >= 0; i--) {
                var el = this.__error_infos[i];
                if (el && typeof el.destroy === 'function') {
                    el.destroy();
                }
            }
            this.__error_infos.length = 0;


        }

        return resultValue;
    };

    // merge yylloc info into a new yylloc instance.
    //
    // `first_index` and `last_index` MAY be UNDEFINED/NULL or these are indexes into the `lstack[]` location stack array.
    //
    // `first_yylloc` and `last_yylloc` MAY be UNDEFINED/NULL or explicit (custom or regular) `yylloc` instances, in which
    // case these override the corresponding first/last indexes.
    //
    // `dont_look_back` is an optional flag (default: FALSE), which instructs this merge operation NOT to search
    // through the parse location stack for a location, which would otherwise be used to construct the new (epsilon!)
    // yylloc info.
    //
    // Note: epsilon rule's yylloc situation is detected by passing both `first_index` and `first_yylloc` as UNDEFINED/NULL.
    this.yyMergeLocationInfo = function parser_yyMergeLocationInfo(first_index, last_index, first_yylloc, last_yylloc, dont_look_back) {
        var i1 = first_index | 0,
            i2 = last_index | 0;
        var l1 = first_yylloc,
            l2 = last_yylloc;
        var rv;

        // rules:
        // - first/last yylloc entries override first/last indexes

        if (!l1) {
            if (first_index != null) {
                for (var i = i1; i <= i2; i++) {
                    l1 = lstack[i];
                    if (l1) {
                        break;
                    }
                }
            }
        }

        if (!l2) {
            if (last_index != null) {
                for (var i = i2; i >= i1; i--) {
                    l2 = lstack[i];
                    if (l2) {
                        break;
                    }
                }
            }
        }

        // - detect if an epsilon rule is being processed and act accordingly:
        if (!l1 && first_index == null) {
            // epsilon rule span merger. With optional look-ahead in l2.
            if (!dont_look_back) {
                for (var i = (i1 || sp) - 1; i >= 0; i--) {
                    l1 = lstack[i];
                    if (l1) {
                        break;
                    }
                }
            }
            if (!l1) {
                if (!l2) {
                    // when we still don't have any valid yylloc info, we're looking at an epsilon rule
                    // without look-ahead and no preceding terms and/or `dont_look_back` set:
                    // in that case we ca do nothing but return NULL/UNDEFINED:
                    return undefined;
                } else {
                    // shallow-copy L2: after all, we MAY be looking
                    // at unconventional yylloc info objects...
                    rv = shallow_copy(l2);
                    if (rv.range) {
                        // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
                        rv.range = rv.range.slice(0);
                    }
                    return rv;
                }
            } else {
                // shallow-copy L1, then adjust first col/row 1 column past the end.
                rv = shallow_copy(l1);
                rv.first_line = rv.last_line;
                rv.first_column = rv.last_column;
                if (rv.range) {
                    // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
                    rv.range = rv.range.slice(0);
                    rv.range[0] = rv.range[1];
                }

                if (l2) {
                    // shallow-mixin L2, then adjust last col/row accordingly.
                    shallow_copy_noclobber(rv, l2);
                    rv.last_line = l2.last_line;
                    rv.last_column = l2.last_column;
                    if (rv.range && l2.range) {
                        rv.range[1] = l2.range[1];
                    }
                }
                return rv;
            }
        }

        if (!l1) {
            l1 = l2;
            l2 = null;
        }
        if (!l1) {
            return undefined;
        }

        // shallow-copy L1|L2, before we try to adjust the yylloc values: after all, we MAY be looking
        // at unconventional yylloc info objects...
        rv = shallow_copy(l1);

        // first_line: ...,
        // first_column: ...,
        // last_line: ...,
        // last_column: ...,
        if (rv.range) {
            // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
            rv.range = rv.range.slice(0);
        }

        if (l2) {
            shallow_copy_noclobber(rv, l2);
            rv.last_line = l2.last_line;
            rv.last_column = l2.last_column;
            if (rv.range && l2.range) {
                rv.range[1] = l2.range[1];
            }
        }

        return rv;
    };

    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!
    this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {
        var pei = {
            errStr: msg,
            exception: ex,
            text: lexer.match,
            value: lexer.yytext,
            token: this.describeSymbol(symbol) || symbol,
            token_id: symbol,
            line: lexer.yylineno,
            loc: copy_yylloc(lexer.yylloc),
            expected: expected,
            recoverable: recoverable,
            state: state,
            action: action,
            new_state: newState,
            symbol_stack: stack,
            state_stack: sstack,
            value_stack: vstack,
            location_stack: lstack,
            stack_pointer: sp,
            yy: sharedState_yy,
            lexer: lexer,
            parser: this,

            // and make sure the error info doesn't stay due to potential
            // ref cycle via userland code manipulations.
            // These would otherwise all be memory leak opportunities!
            //
            // Note that only array and object references are nuked as those
            // constitute the set of elements which can produce a cyclic ref.
            // The rest of the members is kept intact as they are harmless.
            destroy: function destructParseErrorInfo() {
                // remove cyclic references added to error info:
                // info.yy = null;
                // info.lexer = null;
                // info.value = null;
                // info.value_stack = null;
                // ...
                var rec = !!this.recoverable;
                for (var key in this) {
                    if (this.hasOwnProperty(key) && typeof key === 'object') {
                        this[key] = undefined;
                    }
                }
                this.recoverable = rec;
            }
        };
        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
        this.__error_infos.push(pei);
        return pei;
    };













    function getNonTerminalFromCode(symbol) {
        var tokenName = self.getSymbolName(symbol);
        if (!tokenName) {
            tokenName = symbol;
        }
        return tokenName;
    }


    function stdLex() {
        var token = lexer.lex();
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }

        return token || 1/* EOF */;
    }

    function fastLex() {
        var token = lexer.fastLex();
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }

        return token || 1/* EOF */;
    }

    var lex = stdLex;


    var state, action, r, t;
    var yyval = {
        $: true,
        _$: undefined,
        yy: sharedState_yy
    };
    var p;
    var yyrulelen;
    var this_production;
    var newState;
    var retval = false;




    lexer.setInput(input, sharedState_yy);

    // NOTE: we *assume* no lexer pre/post handlers are set up *after* 
    // this initial `setInput()` call: hence we can now check and decide
    // whether we'll go with the standard, slower, lex() API or the
    // `fast_lex()` one:
    if (typeof lexer.canIUse === 'function') {
        var lexerInfo = lexer.canIUse();
        if (lexerInfo.fastLex && typeof fastLex === 'function') {
            lex = fastLex;
        }
    } 

    yyloc = lexer.yylloc;
    lstack[sp] = yyloc;
    vstack[sp] = null;
    sstack[sp] = 0;
    stack[sp] = 0;
    ++sp;





    if (this.pre_parse) {
        this.pre_parse.call(this, sharedState_yy);
    }
    if (sharedState_yy.pre_parse) {
        sharedState_yy.pre_parse.call(this, sharedState_yy);
    }

    newState = sstack[sp - 1];
    for (;;) {
        // retrieve state number from top of stack
        state = newState;               // sstack[sp - 1];

        // use default actions if available
        if (this.defaultActions[state]) {
            action = 2;
            newState = this.defaultActions[state];
        } else {
            // The single `==` condition below covers both these `===` comparisons in a single
            // operation:
            //
            //     if (symbol === null || typeof symbol === 'undefined') ...
            if (!symbol) {
                symbol = lex();
            }
            // read action for current state and first input
            t = (table[state] && table[state][symbol]) || NO_ACTION;
            newState = t[1];
            action = t[0];











            // handle parse error
            if (!action) {
                var errStr;
                var errSymbolDescr = (this.describeSymbol(symbol) || symbol);
                var expected = this.collect_expected_token_set(state);

                // Report error
                if (typeof lexer.yylineno === 'number') {
                    errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';
                } else {
                    errStr = 'Parse error: ';
                }
                if (typeof lexer.showPosition === 'function') {
                    errStr += '\n' + lexer.showPosition(79 - 10, 10) + '\n';
                }
                if (expected.length) {
                    errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;
                } else {
                    errStr += 'Unexpected ' + errSymbolDescr;
                }
                // we cannot recover from the error!
                p = this.constructParseErrorInfo(errStr, null, expected, false);
                r = this.parseError(p.errStr, p, this.JisonParserError);
                if (typeof r !== 'undefined') {
                    retval = r;
                }
                break;
            }


        }










        switch (action) {
        // catch misc. parse failures:
        default:
            // this shouldn't happen, unless resolve defaults are off
            if (action instanceof Array) {
                p = this.constructParseErrorInfo('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, null, null, false);
                r = this.parseError(p.errStr, p, this.JisonParserError);
                if (typeof r !== 'undefined') {
                    retval = r;
                }
                break;
            }
            // Another case of better safe than sorry: in case state transitions come out of another error recovery process
            // or a buggy LUT (LookUp Table):
            p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);
            r = this.parseError(p.errStr, p, this.JisonParserError);
            if (typeof r !== 'undefined') {
                retval = r;
            }
            break;

        // shift:
        case 1:
            stack[sp] = symbol;
            vstack[sp] = lexer.yytext;
            lstack[sp] = copy_yylloc(lexer.yylloc);
            sstack[sp] = newState; // push state

            ++sp;
            symbol = 0;




            // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:



            yyloc = lexer.yylloc;
            continue;

        // reduce:
        case 2:



            this_production = this.productions_[newState - 1];  // `this.productions_[]` is zero-based indexed while states start from 1 upwards...
            yyrulelen = this_production[1];










            r = this.performAction.call(yyval, yyloc, newState, sp - 1, vstack, lstack, stack, sstack);

            if (typeof r !== 'undefined') {
                retval = r;
                break;
            }

            // pop off stack
            sp -= yyrulelen;

            // don't overwrite the `symbol` variable: use a local var to speed things up:
            var ntsymbol = this_production[0];    // push nonterminal (reduce)
            stack[sp] = ntsymbol;
            vstack[sp] = yyval.$;
            lstack[sp] = yyval._$;
            // goto new state = table[STATE][NONTERMINAL]
            newState = table[sstack[sp - 1]][ntsymbol];
            sstack[sp] = newState;
            ++sp;









            continue;

        // accept:
        case 3:
            if (sp !== -2) {
                retval = true;
                // Return the `$accept` rule's `$$` result, if available.
                //
                // Also note that JISON always adds this top-most `$accept` rule (with implicit,
                // default, action):
                //
                //     $accept: <startSymbol> $end
                //                  %{ $$ = $1; @$ = @1; %}
                //
                // which, combined with the parse kernel's `$accept` state behaviour coded below,
                // will produce the `$$` value output of the <startSymbol> rule as the parse result,
                // IFF that result is *not* `undefined`. (See also the parser kernel code.)
                //
                // In code:
                //
                //                  %{
                //                      @$ = @1;            // if location tracking support is included
                //                      if (typeof $1 !== 'undefined')
                //                          return $1;
                //                      else
                //                          return true;           // the default parse result if the rule actions don't produce anything
                //                  %}
                sp--;
                if (typeof vstack[sp] !== 'undefined') {
                    retval = vstack[sp];
                }
            }
            break;
        }

        // break out of loop: we accept or fail with error
        break;
    }
    
    // ... AND FINALLY ...

    retval = this.cleanupAfterParse(retval, true, true);


    

    return retval;
},
yyErrOk: 1,
yyClearIn: 1
};
parser.originalParseError = parser.parseError;
parser.originalQuoteName = parser.quoteName;

// The compiled grammars for the basic example:
// every phase is driven by a jison-generated tree walker:

// Included by Jison: ./output/compiled_calc/compiled_calc_parse.js:


/* parser generated by jison 0.6.1-214 */

/*
 * Returns a Parser object of the following structure:
 *
 *  Parser: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a derivative/copy of this one,
 *               not a direct reference!
 *  }
 *
 *  Parser.prototype: {
 *    yy: {},
 *    EOF: 1,
 *    TERROR: 2,
 *
 *    trace: function(errorMessage, ...),
 *
 *    JisonParserError: function(msg, hash),
 *
 *    quoteName: function(name),
 *               Helper function which can be overridden by user code later on: put suitable
 *               quotes around literal IDs in a description string.
 *
 *    originalQuoteName: function(name),
 *               The basic quoteName handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function
 *               at the end of the `parse()`.
 *
 *    describeSymbol: function(symbol),
 *               Return a more-or-less human-readable description of the given symbol, when
 *               available, or the symbol itself, serving as its own 'description' for lack
 *               of something better to serve up.
 *
 *               Return NULL when the symbol is unknown to the parser.
 *
 *    symbols_: {associative list: name ==> number},
 *    terminals_: {associative list: number ==> name},
 *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},
 *    terminal_descriptions_: (if there are any) {associative list: number ==> description},
 *    productions_: [...],
 *
 *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)
 *                             to store/reference the rule value `$$` and location info `@$`.
 *
 *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets
 *                 to see the same object via the `this` reference, i.e. if you wish to carry custom
 *                 data from one reduce action through to the next within a single parse run, then you
 *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.
 *
 *                 `this.yy` is a direct reference to the `yy` shared state object.
 *
 *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`
 *                 object at `parse()` start and are therefore available to the action code via the
 *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from
 *                 the %parse-param` list.
 *
 *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used
 *                             to match this rule. This is *not* the look-ahead token, but the last token
 *                             that's actually part of this rule.
 *
 *                 Formulated another way, `yytext` is the value of the token immediately preceeding
 *                 the current look-ahead token.
 *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.
 *
 *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.
 *
 *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.
 *
 *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.
 *
 *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead
 *                               of an empty object when no suitable location info can be provided.
 *
 *               - `yystate` : the current parser state number, used internally for dispatching and
 *                               executing the action code chunk matching the rule currently being reduced.
 *
 *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *                 Also note that you can access this and other stack index values using the new double-hash
 *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things
 *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.
 *                 This is made available to write very advanced grammar action rules, e.g. when you want
 *                 to investigate the parse state stack in your action code, which would, for example,
 *                 be relevant when you wish to implement error diagnostics and reporting schemes similar
 *                 to the work described here:
 *
 *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.
 *                   In Journées Francophones des Languages Applicatifs.
 *
 *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.
 *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631–640.
 *
 *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.
 *                             constructs.
 *
 *               - `yylstack`: reference to the parser token location stack. Also accessed via
 *                             the `@1` etc. constructs.
 *
 *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are
 *                             UNDEFINED rather than an empty (location) object, when the lexer/parser
 *                             action code did not provide a suitable location info object when such a
 *                             slot was filled!
 *
 *               - `yystack` : reference to the parser token id stack. Also accessed via the
 *                             `#1` etc. constructs.
 *
 *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to
 *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might
 *                 want access this array for your own purposes, such as error analysis as mentioned above!
 *
 *                 Note that this stack stores the current stack of *tokens*, that is the sequence of
 *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*
 *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and
 *                 *reduced*.
 *
 *               - `yysstack`: reference to the parser state stack. This one carries the internal parser
 *                             *states* such as the one in `yystate`, which are used to represent
 *                             the parser state machine in the *parse table*. *Very* *internal* stuff,
 *                             what can I say? If you access this one, you're clearly doing wicked things
 *
 *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your
 *                             grammar definition file.
 *
 *    table: [...],
 *               State transition table
 *               ----------------------
 *
 *               index levels are:
 *               - `state`  --> hash table
 *               - `symbol` --> action (number or array)
 *
 *                 If the `action` is an array, these are the elements' meaning:
 *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept
 *                 - index [1]: GOTO `state`
 *
 *                 If the `action` is a number, it is the GOTO `state`
 *
 *    defaultActions: {...},
 *
 *    parseError: function(str, hash, ExceptionClass),
 *    yyError: function(str, ...),
 *    yyRecovering: function(),
 *    yyErrOk: function(),
 *    yyClearIn: function(),
 *
 *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this parser kernel in many places; example usage:
 *
 *                   var infoObj = parser.constructParseErrorInfo('fail!', null,
 *                                     parser.collect_expected_token_set(state), true);
 *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);
 *
 *    originalParseError: function(str, hash, ExceptionClass),
 *               The basic `parseError` handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function
 *               at the end of the `parse()`.
 *
 *    options: { ... parser %options ... },
 *
 *    parse: function(input[, args...]),
 *               Parse the given `input` and return the parsed value (or `true` when none was provided by
 *               the root action, in which case the parser is acting as a *matcher*).
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the jison run-time;
 *               when such a collision is detected an exception is thrown to prevent the generated run-time
 *               from silently accepting this confusing and potentially hazardous situation!
 *
 *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in
 *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state
 *               object and any collision with those will be reported by the lexer via a thrown exception.
 *
 *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown
 *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY
 *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and
 *               the internal parser gets properly garbage collected under these particular circumstances.
 *
 *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API can be invoked to calculate a spanning `yylloc` location info object.
 *
 *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case
 *               this function will attempt to obtain a suitable location marker by inspecting the location stack
 *               backwards.
 *
 *               For more info see the documentation comment further below, immediately above this function's
 *               implementation.
 *
 *    lexer: {
 *        yy: {...},           A reference to the so-called "shared state" `yy` once
 *                             received via a call to the `.setInput(input, yy)` lexer API.
 *        EOF: 1,
 *        ERROR: 2,
 *        JisonLexerError: function(msg, hash),
 *        parseError: function(str, hash, ExceptionClass),
 *        setInput: function(input, [yy]),
 *        input: function(),
 *        unput: function(str),
 *        more: function(),
 *        reject: function(),
 *        less: function(n),
 *        pastInput: function(n),
 *        upcomingInput: function(n),
 *        showPosition: function(),
 *        test_match: function(regex_match_array, rule_index, ...),
 *        next: function(...),
 *        lex: function(...),
 *        begin: function(condition),
 *        pushState: function(condition),
 *        popState: function(),
 *        topState: function(),
 *        _currentRules: function(),
 *        stateStackSize: function(),
 *        cleanupAfterLex: function()
 *
 *        options: { ... lexer %options ... },
 *
 *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),
 *        rules: [...],
 *        conditions: {associative list: name ==> set},
 *    }
 *  }
 *
 *
 *  token location info (@$, _$, etc.): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer and
 * parser errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *  }
 *
 * parser (grammar) errors will also provide these additional members:
 *
 *  {
 *    expected:    (array describing the set of expected tokens;
 *                  may be UNDEFINED when we cannot easily produce such a set)
 *    state:       (integer (or array when the table includes grammar collisions);
 *                  represents the current internal state of the parser kernel.
 *                  can, for example, be used to pass to the `collect_expected_token_set()`
 *                  API to obtain the expected token set)
 *    action:      (integer; represents the current internal action which will be executed)
 *    new_state:   (integer; represents the next/planned internal state, once the current
 *                  action has executed)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *    parser:      (reference to the current parser instance)
 *  }
 *
 * while `this` will reference the current parser instance.
 *
 * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    lexer:       (reference to the current lexer instance which reported the error)
 *  }
 *
 * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired
 * from either the parser or lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    exception:   (reference to the exception thrown)
 *  }
 *
 * Please do note that in the latter situation, the `expected` field will be omitted as
 * this type of failure is assumed not to be due to *parse errors* but rather due to user
 * action code in either parser or lexer failing unexpectedly.
 *
 * ---
 *
 * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.
 * These options are available:
 *
 * ### options which are global for all parser instances
 *
 *  Parser.pre_parse: function(yy)
 *                 optional: you can specify a pre_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`.
 *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: you can specify a post_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`. When it does not return any value,
 *                 the parser will return the original `retval`.
 *
 * ### options which can be set up per parser instance
 *
 *  yy: {
 *      pre_parse:  function(yy)
 *                 optional: is invoked before the parse cycle starts (and before the first
 *                 invocation of `lex()`) but immediately after the invocation of
 *                 `parser.pre_parse()`).
 *      post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: is invoked when the parse terminates due to success ('accept')
 *                 or failure (even when exceptions are thrown).
 *                 `retval` contains the return value to be produced by `Parser.parse()`;
 *                 this function can override the return value by returning another.
 *                 When it does not return any value, the parser will return the original
 *                 `retval`.
 *                 This function is invoked immediately before `parser.post_parse()`.
 *
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *      quoteName: function(name),
 *                 optional: overrides the default `quoteName` function.
 *  }
 *
 *  parser.lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */

        
    
            var compiled_calc_parse = (function () {

// See also:
// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
// with userland code which might access the derived class in a 'classic' way.
function JisonParserError(msg, hash) {
    Object.defineProperty(this, 'name', {
        enumerable: false,
        writable: false,
        value: 'JisonParserError'
    });

    if (msg == null) msg = '???';

    Object.defineProperty(this, 'message', {
        enumerable: false,
        writable: true,
        value: msg
    });

    this.hash = hash;

    var stacktrace;
    if (hash && hash.exception instanceof Error) {
        var ex2 = hash.exception;
        this.message = ex2.message || msg;
        stacktrace = ex2.stack;
    }
    if (!stacktrace) {
        if (Error.hasOwnProperty('captureStackTrace')) {        // V8/Chrome engine
            Error.captureStackTrace(this, this.constructor);
        } else {
            stacktrace = (new Error(msg)).stack;
        }
    }
    if (stacktrace) {
        Object.defineProperty(this, 'stack', {
            enumerable: false,
            writable: false,
            value: stacktrace
        });
    }
}

if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);
} else {
    JisonParserError.prototype = Object.create(Error.prototype);
}
JisonParserError.prototype.constructor = JisonParserError;
JisonParserError.prototype.name = 'JisonParserError';



        // helper: reconstruct the productions[] table
        function bp(s) {
            var rv = [];
            var p = s.pop;
            var r = s.rule;
            for (var i = 0, l = p.length; i < l; i++) {
                rv.push([
                    p[i],
                    r[i]
                ]);
            }
            return rv;
        }
    


        // helper: reconstruct the defaultActions[] table
        function bda(s) {
            var rv = {};
            var d = s.idx;
            var g = s.goto;
            for (var i = 0, l = d.length; i < l; i++) {
                var j = d[i];
                rv[j] = g[i];
            }
            return rv;
        }
    


        // helper: reconstruct the 'goto' table
        function bt(s) {
            var rv = [];
            var d = s.len;
            var y = s.symbol;
            var t = s.type;
            var a = s.state;
            var m = s.mode;
            var g = s.goto;
            for (var i = 0, l = d.length; i < l; i++) {
                var n = d[i];
                var q = {};
                for (var j = 0; j < n; j++) {
                    var z = y.shift();
                    switch (t.shift()) {
                    case 2:
                        q[z] = [
                            m.shift(),
                            g.shift()
                        ];
                        break;

                    case 0:
                        q[z] = a.shift();
                        break;

                    default:
                        // type === 1: accept
                        q[z] = [
                            3
                        ];
                    }
                }
                rv.push(q);
            }
            return rv;
        }
    


        // helper: runlength encoding with increment step: code, length: step (default step = 0)
        // `this` references an array
        function s(c, l, a) {
            a = a || 0;
            for (var i = 0; i < l; i++) {
                this.push(c);
                c += a;
            }
        }

        // helper: duplicate sequence from *relative* offset and length.
        // `this` references an array
        function c(i, l) {
            i = this.length - i;
            for (l += i; i < l; i++) {
                this.push(this[i]);
            }
        }

        // helper: unpack an array using helpers and data, all passed in an array argument 'a'.
        function u(a) {
            var rv = [];
            for (var i = 0, l = a.length; i < l; i++) {
                var e = a[i];
                // Is this entry a helper function?
                if (typeof e === 'function') {
                    i++;
                    e.apply(rv, a[i]);
                } else {
                    rv.push(e);
                }
            }
            return rv;
        }
    

var parser = {
    // Code Generator Information Report
    // ---------------------------------
    //
    // Options:
    //
    //   default action mode: ............. none,merge
    //   try..catch: ...................... false
    //   default resolve on conflict: ..... true
    //   on-demand look-ahead: ............ false
    //   error recovery token skip maximum: 42
    //   yyerror in parse actions is: ..... NOT recoverable,
    //   yyerror in lexer actions and other non-fatal lexer are:
    //   .................................. NOT recoverable,
    //   debug grammar/output: ............ false
    //   has partial LR conflict upgrade:   true
    //   rudimentary token-stack support:   false
    //   parser table compression mode: ... 2
    //   export debug tables: ............. false
    //   export *all* tables: ............. false
    //   module type: ..................... commonjs
    //   parser engine type: .............. lalr
    //   output main() in the module: ..... true
    //   has user-specified main(): ....... false
    //   has user-specified require()/import modules for main():
    //   .................................. false
    //   number of expected conflicts: .... 0
    //
    //
    // Parser Analysis flags:
    //
    //   no significant actions (parser is a language matcher only):
    //   .................................. false
    //   uses yyleng: ..................... true
    //   uses yylineno: ................... false
    //   uses yytext: ..................... true
    //   uses yylloc: ..................... false
    //   uses ParseError API: ............. false
    //   uses YYERROR: .................... false
    //   uses YYRECOVERING: ............... false
    //   uses YYERROK: .................... true
    //   uses YYCLEARIN: .................. true
    //   tracks rule values: .............. true
    //   assigns rule values: ............. true
    //   uses location tracking: .......... false
    //   assigns location: ................ false
    //   uses yystack: .................... false
    //   uses yysstack: ................... false
    //   uses yysp: ....................... true
    //   uses yyrulelength: ............... false
    //   uses yyMergeLocationInfo API: .... false
    //   has error recovery: .............. true
    //   has error reporting: ............. false
    //
    // --------- END OF REPORT -----------

trace: function no_op_trace() {},
JisonParserError: JisonParserError,
yy: {},
options: {
  type: "lalr",
  hasPartialLrUpgradeOnConflict: true,
  errorRecoveryTokenDiscardCount: 42,
  ebnf: true
},
symbols_: {
  "!": 91,
  "$accept": 0,
  "$end": 1,
  "%": 90,
  "&": 82,
  "(": 72,
  ")": 75,
  "*": 87,
  "+": 84,
  ",": 96,
  "-": 85,
  "/": 89,
  ":": 95,
  "=": 71,
  "?": 93,
  "ADD": 43,
  "ADD_3": 80,
  "ADD_4": 4,
  "AND": 65,
  "AND_3": 5,
  "AND_4": 6,
  "ASSIGN": 7,
  "BITWISE_AND": 38,
  "BITWISE_NOT": 126,
  "BITWISE_OR": 124,
  "BITWISE_XOR": 94,
  "COMMENT": 97,
  "CONDITION": 63,
  "CONSTANT": 8,
  "DIVIDE": 47,
  "ELSE": 9,
  "END": 10,
  "EOF": 1,
  "EOL": 11,
  "EQ": 61,
  "ERROR": 3,
  "ERROR_AND_SKIP": 12,
  "EXCHANGE_A_R1": 13,
  "EXCHANGE_A_R2": 14,
  "EXCHANGE_R1_R2": 15,
  "EXEC": 16,
  "FACTORIAL": 17,
  "FALSE": 18,
  "FALSE_AND_SKIP": 19,
  "FUNCTION": 70,
  "FUNCTION_0": 48,
  "FUNCTION_1": 49,
  "FUNCTION_2": 50,
  "FUNCTION_3": 51,
  "FUNCTION_N": 57,
  "GEQ": 20,
  "GT": 62,
  "IF": 21,
  "IF_ELSE": 22,
  "LEQ": 23,
  "LT": 60,
  "MODULO": 37,
  "MOVE_ALL_TO_RX": 24,
  "MOVE_FROM_R1": 25,
  "MOVE_FROM_R2": 26,
  "MOVE_R2_TO_R1": 27,
  "MOVE_TO_R1": 28,
  "MOVE_TO_R2": 29,
  "MOVE_TO_RX": 30,
  "MULTIPLY": 42,
  "MULTIPLY_3": 77,
  "MULTIPLY_4": 31,
  "NEQ": 110,
  "NOP": 32,
  "NOT": 33,
  "NUM": 73,
  "NUM_AND_SKIP": 74,
  "OR": 79,
  "OR_3": 34,
  "OR_4": 35,
  "PERCENT": 36,
  "POP": 39,
  "POWER": 40,
  "PUSH": 44,
  "PUSH_NUMS": 78,
  "SHIFT_EX": 41,
  "SKIP": 83,
  "STRING": 46,
  "STRING_AND_SKIP": 52,
  "SUBTRACT": 45,
  "SUBTRACT_3": 53,
  "SUBTRACT_4": 54,
  "THEN": 98,
  "TRUE": 55,
  "TRUE_AND_SKIP": 56,
  "UMINUS": 58,
  "UNSHIFT_EX": 59,
  "UNSHIFT_RX_TO_ALL": 64,
  "UNSHIFT_RX_TO_R12": 66,
  "UPLUS": 67,
  "VAR": 86,
  "VAR_TO_VALUE": 68,
  "VAR_VALUE": 69,
  "XOR": 88,
  "^": 81,
  "arglist": 102,
  "error": 2,
  "exp": 101,
  "input": 99,
  "line": 100,
  "s": 103,
  "|": 76,
  "~": 92
},
terminals_: {
  1: "EOF",
  2: "error",
  3: "ERROR",
  4: "ADD_4",
  5: "AND_3",
  6: "AND_4",
  7: "ASSIGN",
  8: "CONSTANT",
  9: "ELSE",
  10: "END",
  11: "EOL",
  12: "ERROR_AND_SKIP",
  13: "EXCHANGE_A_R1",
  14: "EXCHANGE_A_R2",
  15: "EXCHANGE_R1_R2",
  16: "EXEC",
  17: "FACTORIAL",
  18: "FALSE",
  19: "FALSE_AND_SKIP",
  20: "GEQ",
  21: "IF",
  22: "IF_ELSE",
  23: "LEQ",
  24: "MOVE_ALL_TO_RX",
  25: "MOVE_FROM_R1",
  26: "MOVE_FROM_R2",
  27: "MOVE_R2_TO_R1",
  28: "MOVE_TO_R1",
  29: "MOVE_TO_R2",
  30: "MOVE_TO_RX",
  31: "MULTIPLY_4",
  32: "NOP",
  33: "NOT",
  34: "OR_3",
  35: "OR_4",
  36: "PERCENT",
  37: "MODULO",
  38: "BITWISE_AND",
  39: "POP",
  40: "POWER",
  41: "SHIFT_EX",
  42: "MULTIPLY",
  43: "ADD",
  44: "PUSH",
  45: "SUBTRACT",
  46: "STRING",
  47: "DIVIDE",
  48: "FUNCTION_0",
  49: "FUNCTION_1",
  50: "FUNCTION_2",
  51: "FUNCTION_3",
  52: "STRING_AND_SKIP",
  53: "SUBTRACT_3",
  54: "SUBTRACT_4",
  55: "TRUE",
  56: "TRUE_AND_SKIP",
  57: "FUNCTION_N",
  58: "UMINUS",
  59: "UNSHIFT_EX",
  60: "LT",
  61: "EQ",
  62: "GT",
  63: "CONDITION",
  64: "UNSHIFT_RX_TO_ALL",
  65: "AND",
  66: "UNSHIFT_RX_TO_R12",
  67: "UPLUS",
  68: "VAR_TO_VALUE",
  69: "VAR_VALUE",
  70: "FUNCTION",
  71: "=",
  72: "(",
  73: "NUM",
  74: "NUM_AND_SKIP",
  75: ")",
  76: "|",
  77: "MULTIPLY_3",
  78: "PUSH_NUMS",
  79: "OR",
  80: "ADD_3",
  81: "^",
  82: "&",
  83: "SKIP",
  84: "+",
  85: "-",
  86: "VAR",
  87: "*",
  88: "XOR",
  89: "/",
  90: "%",
  91: "!",
  92: "~",
  93: "?",
  94: "BITWISE_XOR",
  95: ":",
  96: ",",
  97: "COMMENT",
  98: "THEN",
  110: "NEQ",
  124: "BITWISE_OR",
  126: "BITWISE_NOT"
},
TERROR: 2,
EOF: 1,

// internals: defined here so the object *structure* doesn't get modified by parse() et al,
// thus helping JIT compilers like Chrome V8.
originalQuoteName: null,
originalParseError: null,
cleanupAfterParse: null,
constructParseErrorInfo: null,
yyMergeLocationInfo: null,

__reentrant_call_depth: 0, // INTERNAL USE ONLY
__error_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup
__error_recovery_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup

// APIs which will be set up depending on user action code analysis:
//yyRecovering: 0,
//yyErrOk: 0,
//yyClearIn: 0,

// Helper APIs
// -----------

// Helper function which can be overridden by user code later on: put suitable quotes around
// literal IDs in a description string.
quoteName: function parser_quoteName(id_str) {
    return '"' + id_str + '"';
},

// Return the name of the given symbol (terminal or non-terminal) as a string, when available.
//
// Return NULL when the symbol is unknown to the parser.
getSymbolName: function parser_getSymbolName(symbol) {
    if (this.terminals_[symbol]) {
        return this.terminals_[symbol];
    }

    // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.
    //
    // An example of this may be where a rule's action code contains a call like this:
    //
    //      parser.getSymbolName(#$)
    //
    // to obtain a human-readable name of the current grammar rule.
    var s = this.symbols_;
    for (var key in s) {
        if (s[key] === symbol) {
            return key;
        }
    }
    return null;
},

// Return a more-or-less human-readable description of the given symbol, when available,
// or the symbol itself, serving as its own 'description' for lack of something better to serve up.
//
// Return NULL when the symbol is unknown to the parser.
describeSymbol: function parser_describeSymbol(symbol) {
    if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {
        return this.terminal_descriptions_[symbol];
    } else if (symbol === this.EOF) {
        return 'end of input';
    }
    var id = this.getSymbolName(symbol);
    if (id) {
        return this.quoteName(id);
    }
    return null;
},

// Produce a (more or less) human-readable list of expected tokens at the point of failure.
//
// The produced list may contain token or token set descriptions instead of the tokens
// themselves to help turning this output into something that easier to read by humans
// unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,
// expected terminals and nonterminals is produced.
//
// The returned list (array) will not contain any duplicate entries.
collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {
    var TERROR = this.TERROR;
    var tokenset = [];
    var check = {};
    // Has this (error?) state been outfitted with a custom expectations description text for human consumption?
    // If so, use that one instead of the less palatable token set.
    if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {
        return [this.state_descriptions_[state]];
    }
    for (var p in this.table[state]) {
        p = +p;
        if (p !== TERROR) {
            var d = do_not_describe ? p : this.describeSymbol(p);
            if (d && !check[d]) {
                tokenset.push(d);
                check[d] = true; // Mark this token description as already mentioned to prevent outputting duplicate entries.
            }
        }
    }
    return tokenset;
},
productions_: bp({
  pop: u([
  99,
  s,
  [100, 4],
  s,
  [101, 35],
  102,
  102,
  103,
  103
]),
  rule: u([
  3,
  0,
  s,
  [1, 6],
  3,
  3,
  4,
  s,
  [3, 17],
  2,
  2,
  c,
  [3, 3],
  s,
  [2, 3],
  3,
  5,
  6,
  4,
  1,
  3,
  0,
  3
])
}),
performAction: function parser__PerformAction(yytext, yyleng, yystate /* action[1] */, yysp, yyvstack) {

          /* this == yyval */

          // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!
          var yy = this.yy;
          var yyparser = yy.parser;
          var yylexer = yy.lexer;

          

          switch (yystate) {
case 0:
    /*! Production::    $accept : input $end */

    // default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,-,-,-,-):
    this.$ = undefined;
    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,-,-,-,-)
    break;

case 1:
    /*! Production::    input : s line EOF */

    var rv = null;
    for (var i = 0, len = yyvstack[yysp - 2].length; i < len; i++) {
      var line = yyvstack[yysp - 2][i][0];
      if (!rv) {
        rv = line;
      } else if (line.length) {
        // We MUST signal the end of an expression as otherwise our AST grammar
        // will be ambiguous (and thus our tree walkers confused and unable to
        // work) as we must be able to differentiate between 'end of function arglist'
        // and 'end of statement': since we expect more functions (and thus
        // arglist terminations) than statements, we choose to give the FUNCTION
        // arglist an implicit termination while the statement gets to have an
        // *explicit* termination (#EOL# token) so that we end up with a shorter
        // AST stream -- iff our assumption holds in actual use!
        //
        // NOTE: We only need to add a sentinel when multiple statements (lines)
        // are input: when there's only a single statement (line) it'll be unambiguously
        // terminated by EOF!
        if (rv.length) {
          rv.push( /* EOL */ 11);
        }
        append.apply(rv, line);
      }
    }
    
    if (!rv) {
      rv = yyvstack[yysp - 1];
    } else if (yyvstack[yysp - 1].length) {
      // We MUST signal the end of an expression as otherwise our AST grammar
      // will be ambiguous (and thus our tree walkers confused and unable to
      // work) as we must be able to differentiate between 'end of function arglist'
      // and 'end of statement': since we expect more functions (and thus
      // arglist terminations) than statements, we choose to give the FUNCTION
      // arglist an implicit termination while the statement gets to have an
      // *explicit* termination (#EOL# token) so that we end up with a shorter
      // AST stream -- iff our assumption holds in actual use!
      //
      // NOTE: We only need to add a sentinel when multiple statements (lines)
      // are input: when there's only a single statement (line) it'll be unambiguously
      // terminated by EOF!
      if (rv.length) {
        rv.push( /* EOL */ 11);
      }
      append.apply(rv, yyvstack[yysp - 1]);
    }
    
    // always make sure the AST stream is terminated by an EOL:
    // this makes the treewalker grammars a little easier as then a line is always
    // followed by an EOL!
    if (rv.length) {
      rv.push( /* EOL */ 11);
    }
    
    this.$ = rv;
    break;

case 2:
    /*! Production::    line : %epsilon */
case 43:
    /*! Production::    s : %epsilon */

    this.$ = [];
    break;

case 3:
    /*! Production::    line : exp */

    console.log('line: ', JSON.stringify(yyvstack[yysp], null, 2));
    this.$ = yyvstack[yysp];
    break;

case 4:
    /*! Production::    line : COMMENT */

    this.$ = [ /* COMMENT */ 97, yyvstack[yysp]];
    break;

case 5:
    /*! Production::    line : error */

    yyparser.yyErrOk();
    yyparser.yyClearIn();
    console.log('skipped erroneous input line', typeof yy.lastErrorInfo, yyvstack[yysp], yytext, yyleng);
    this.$ = [ /* ERROR */ 3, yy.lastErrorInfo.errStr];
    break;

case 6:
    /*! Production::    exp : NUM */

    this.$ = [ /* NUM */ 73, yyvstack[yysp]];
    break;

case 7:
    /*! Production::    exp : CONSTANT */

    this.$ = [ /* CONSTANT */ 8, yyvstack[yysp]];
    break;

case 8:
    /*! Production::    exp : VAR */

    this.$ = [ /* VAR */ 86, yyvstack[yysp]];
    break;

case 9:
    /*! Production::    exp : VAR "=" exp */

    /*
       Note: #assign is always to a simple variable, hence we don't need the `#VAR`
       token here: it is implicit as there's nothing else we can do.
    
       Technically, this is an AST optimization, but it's such a fundamental one
       we do it here instead of later.
    
       NOTE: #assign implies the presence of a VAR as lhs (left hand side) so it
       would only be cluttering the AST stream to have a #VAR# token in there:
       it is *implicit* to #assign!
     */
    yyvstack[yysp].unshift( /* ASSIGN */ 7, yyvstack[yysp - 2]);
    this.$ = yyvstack[yysp];
    break;

case 10:
    /*! Production::    exp : FUNCTION "(" ")" */

    this.$ = [ /* FUNCTION_0 */ 48, yyvstack[yysp - 2]];
    break;

case 11:
    /*! Production::    exp : FUNCTION "(" arglist ")" */

    /*
       See the comment in the statement EOL rule above: to disambiguate a sequence
       of exp subtrees, we MUST add a terminator to either or both statement and
       function, otherwise the sequence `FUNCTION exp exp` is ambiguous: it could
       be:
    
       - a no-args functions and two more statements,
       - a single-arg function and one more statement,
       - a two-arg function.
    
       Of course, you may argue that adding 'number of arguments' knowledge to the
       FUNCTION token would also resolve this issue, and it would, but that would
       be a bit harder to encode in an LALR(1) grammar used as the treewalker core.
       It is easier to use a sentinel token in one or both spots.
    
       A lot of functions have only a few arguments, which we later optimize in our AST
       by including that knowledge in the FUNCTION token by using derivative tokens
       FUNCTION_0, FUNCTION_1, etc.: this can help a smart optimizer to include
       special optimizations for these functions without having to re-discover
       the arglist length.
       As that approach already disambiguates the function-versus-statement
       situation by having encoded arglist length in the FUNCTION token, these
       tokens never require a sentinel token in the AST stream: small AST stream size.
    
       Now we let the optimizer deal with this when the time comes...
    
       Meanwhile, keep it as simple as possible in here!
    
       Also don't forget to FLATTEN the arglist! ==> `concat.apply(a, arglist)`
    
       NOTE: the #FUNCTION# rule in Polish Notation is ambiguous unless we terminate it
       (which is easy to parse in an LALR(1) grammar while adding a argument count is not!)
       as we would otherwise get confused over this scenario:
    
            ... PLUS FUNCTION exp exp exp ...
    
       - is this a function with one argument and that last `exp` in there the second term
         of a binary(?) opcode waiting in the leading `...`?
       - is this a function with two arguments and that last `exp` the second
         term of the PLUS?
       - is this a function with three arguments and is the second term of the PLUS
         waiting in the trailing `...`?
    
       This is the trouble with opcodes which accept a variable number of arguments:
       such opcodes always have to be terminated by a sentinel to make the AST grammar
       unambiguous.
    
       ... On second thought, we can easily apply the FUNCTION_<N> AST optimization
       now, and it doesn't impact the AST rule set much, while it opens up other
       possibilities...
    */
    switch (yyvstack[yysp - 1].length) {
    default:
      this.$ = flatten.apply([ /* FUNCTION */ 70, yyvstack[yysp - 3]], yyvstack[yysp - 1]);
      this.$.push( /* END */ 10);
      break;
    
    case 1:
      this.$ = flatten.apply([ /* FUNCTION_1 */ 49, yyvstack[yysp - 3]], yyvstack[yysp - 1]);
      break;
    
    case 2:
      this.$ = flatten.apply([ /* FUNCTION_2 */ 50, yyvstack[yysp - 3]], yyvstack[yysp - 1]);
      break;
    
    case 3:
      this.$ = flatten.apply([ /* FUNCTION_3 */ 51, yyvstack[yysp - 3]], yyvstack[yysp - 1]);
      break;
    }
    break;

case 12:
    /*! Production::    exp : exp EQ exp */

    yyvstack[yysp - 2].unshift( /* EQ */ 61);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    this.$ = yyvstack[yysp - 2];
    break;

case 13:
    /*! Production::    exp : exp NEQ exp */

    yyvstack[yysp - 2].unshift( /* NEQ */ 110);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    this.$ = yyvstack[yysp - 2];
    break;

case 14:
    /*! Production::    exp : exp LEQ exp */

    yyvstack[yysp - 2].unshift( /* LEQ */ 23);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    this.$ = yyvstack[yysp - 2];
    break;

case 15:
    /*! Production::    exp : exp GEQ exp */

    yyvstack[yysp - 2].unshift( /* GEQ */ 20);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    this.$ = yyvstack[yysp - 2];
    break;

case 16:
    /*! Production::    exp : exp LT exp */

    yyvstack[yysp - 2].unshift( /* LT */ 60);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    this.$ = yyvstack[yysp - 2];
    break;

case 17:
    /*! Production::    exp : exp GT exp */

    yyvstack[yysp - 2].unshift( /* GT */ 62);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    this.$ = yyvstack[yysp - 2];
    break;

case 18:
    /*! Production::    exp : exp OR exp */

    yyvstack[yysp - 2].unshift( /* OR */ 79);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    this.$ = yyvstack[yysp - 2];
    break;

case 19:
    /*! Production::    exp : exp XOR exp */

    yyvstack[yysp - 2].unshift( /* XOR */ 88);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    this.$ = yyvstack[yysp - 2];
    break;

case 20:
    /*! Production::    exp : exp AND exp */

    yyvstack[yysp - 2].unshift( /* AND */ 65);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    this.$ = yyvstack[yysp - 2];
    break;

case 21:
    /*! Production::    exp : exp "|" exp */

    yyvstack[yysp - 2].unshift( /* BITWISE_OR */ 124);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    this.$ = yyvstack[yysp - 2];
    break;

case 22:
    /*! Production::    exp : exp "^" exp */

    yyvstack[yysp - 2].unshift( /* BITWISE_XOR */ 94);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    this.$ = yyvstack[yysp - 2];
    break;

case 23:
    /*! Production::    exp : exp "&" exp */

    yyvstack[yysp - 2].unshift( /* BITWISE_AND */ 38);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    this.$ = yyvstack[yysp - 2];
    break;

case 24:
    /*! Production::    exp : exp "+" exp */

    yyvstack[yysp - 2].unshift( /* ADD */ 43);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    this.$ = yyvstack[yysp - 2];
    break;

case 25:
    /*! Production::    exp : exp "-" exp */

    yyvstack[yysp - 2].unshift( /* SUBTRACT */ 45);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    this.$ = yyvstack[yysp - 2];
    break;

case 26:
    /*! Production::    exp : exp "*" exp */

    yyvstack[yysp - 2].unshift( /* MULTIPLY */ 42);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    this.$ = yyvstack[yysp - 2];
    break;

case 27:
    /*! Production::    exp : exp "/" exp */

    yyvstack[yysp - 2].unshift( /* DIVIDE */ 47);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    this.$ = yyvstack[yysp - 2];
    break;

case 28:
    /*! Production::    exp : exp "%" exp */

    yyvstack[yysp - 2].unshift( /* MODULO */ 37);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    this.$ = yyvstack[yysp - 2];
    break;

case 29:
    /*! Production::    exp : "-" exp */

    yyvstack[yysp].unshift( /* UMINUS */ 58);
    this.$ = yyvstack[yysp];
    break;

case 30:
    /*! Production::    exp : "+" exp */

    yyvstack[yysp].unshift( /* UPLUS */ 67);
    this.$ = yyvstack[yysp];
    break;

case 31:
    /*! Production::    exp : exp POWER exp */

    yyvstack[yysp - 2].unshift( /* POWER */ 40);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    this.$ = yyvstack[yysp - 2];
    break;

case 32:
    /*! Production::    exp : exp "%" */

    yyvstack[yysp - 1].unshift( /* PERCENT */ 36);
    this.$ = yyvstack[yysp - 1];
    break;

case 33:
    /*! Production::    exp : exp "!" */

    yyvstack[yysp - 1].unshift( /* FACTORIAL */ 17);
    this.$ = yyvstack[yysp - 1];
    break;

case 34:
    /*! Production::    exp : "~" exp */

    yyvstack[yysp].unshift( /* BITWISE_NOT */ 126);
    this.$ = yyvstack[yysp];
    break;

case 35:
    /*! Production::    exp : "!" exp */
case 36:
    /*! Production::    exp : NOT exp */

    yyvstack[yysp].unshift( /* NOT */ 33);
    this.$ = yyvstack[yysp];
    break;

case 37:
    /*! Production::    exp : "(" exp ")" */

    this.$ = yyvstack[yysp - 1];
    break;

case 38:
    /*! Production::    exp : exp "?" exp ":" exp */
case 39:
    /*! Production::    exp : IF exp THEN exp ELSE exp */

    // $$ = [#IF_ELSE#].concat($exp1, $exp2, $exp3);
    yyvstack[yysp - 4].unshift( /* IF_ELSE */ 22);
    append.apply(yyvstack[yysp - 4], yyvstack[yysp - 2]);
    append.apply(yyvstack[yysp - 4], yyvstack[yysp]);
    this.$ = yyvstack[yysp - 4];
    break;

case 40:
    /*! Production::    exp : IF exp THEN exp */

    // $$ = [#IF#].concat($exp1, $exp2);
    yyvstack[yysp - 2].unshift( /* IF */ 21);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    this.$ = yyvstack[yysp - 2];
    break;

case 41:
    /*! Production::    arglist : exp */

    this.$ = [yyvstack[yysp]];
    break;

case 42:
    /*! Production::    arglist : arglist "," exp */

    this.$ = yyvstack[yysp - 2];
    this.$.push(yyvstack[yysp]);
    break;

case 44:
    /*! Production::    s : s line EOL */

    yyvstack[yysp - 2].push([yyvstack[yysp - 1], yyvstack[yysp]]);
    this.$ = yyvstack[yysp - 2];
    break;

case 82:       // === NO_ACTION[1] :: ensures that anyone (but us) using this new state will fail dramatically!
                // error recovery reduction action (action generated by jison,
                // using the user-specified `%code error_recovery_reduction` %{...%}
                // code chunk below.

                
                break;
            
}
},
table: bt({
  len: u([
  17,
  1,
  17,
  2,
  22,
  2,
  2,
  27,
  27,
  28,
  1,
  s,
  [12, 7],
  1,
  15,
  s,
  [12, 16],
  36,
  12,
  27,
  12,
  12,
  14,
  s,
  [27, 5],
  21,
  21,
  s,
  [27, 18],
  c,
  [19, 3],
  2,
  22,
  c,
  [34, 3],
  27,
  12,
  27,
  27,
  22,
  12,
  27
]),
  symbol: u([
  1,
  2,
  8,
  11,
  21,
  33,
  70,
  72,
  73,
  84,
  85,
  86,
  91,
  92,
  97,
  99,
  103,
  1,
  c,
  [18, 15],
  100,
  101,
  1,
  11,
  1,
  11,
  20,
  23,
  40,
  60,
  61,
  62,
  65,
  76,
  79,
  81,
  82,
  84,
  85,
  s,
  [87, 5, 1],
  93,
  110,
  c,
  [24, 4],
  1,
  9,
  c,
  [27, 8],
  75,
  c,
  [28, 12],
  95,
  96,
  98,
  110,
  c,
  [27, 37],
  71,
  c,
  [28, 17],
  72,
  8,
  c,
  [125, 10],
  101,
  c,
  [12, 72],
  c,
  [213, 16],
  c,
  [100, 84],
  c,
  [12, 108],
  1,
  8,
  c,
  [322, 3],
  21,
  23,
  33,
  c,
  [324, 5],
  c,
  [22, 3],
  c,
  [326, 7],
  s,
  [86, 8, 1],
  c,
  [328, 3],
  101,
  110,
  c,
  [48, 13],
  c,
  [396, 26],
  c,
  [111, 30],
  75,
  c,
  [13, 6],
  102,
  c,
  [488, 64],
  c,
  [27, 71],
  c,
  [24, 20],
  c,
  [21, 8],
  c,
  [20, 12],
  c,
  [150, 110],
  c,
  [27, 378],
  c,
  [507, 19],
  95,
  c,
  [75, 55],
  75,
  96,
  c,
  [26, 20],
  96,
  c,
  [51, 28],
  c,
  [926, 25],
  c,
  [51, 38],
  c,
  [771, 74],
  96,
  c,
  [88, 40]
]),
  type: u([
  s,
  [2, 15],
  0,
  0,
  1,
  c,
  [18, 17],
  s,
  [2, 122],
  c,
  [123, 12],
  c,
  [12, 72],
  c,
  [100, 100],
  c,
  [12, 108],
  c,
  [215, 35],
  c,
  [48, 36],
  c,
  [99, 29],
  c,
  [516, 124],
  s,
  [2, 678],
  c,
  [926, 47],
  c,
  [39, 43],
  c,
  [139, 61],
  s,
  [2, 16]
]),
  state: u([
  s,
  [1, 4, 1],
  s,
  [42, 27, 1],
  71,
  70,
  77,
  78,
  79,
  81
]),
  mode: u([
  s,
  [2, 16],
  1,
  1,
  c,
  [3, 3],
  s,
  [1, 11],
  c,
  [18, 4],
  s,
  [1, 18],
  s,
  [2, 68],
  c,
  [69, 18],
  s,
  [1, 78],
  c,
  [94, 94],
  s,
  [1, 98],
  c,
  [289, 5],
  c,
  [6, 6],
  c,
  [189, 5],
  c,
  [311, 12],
  c,
  [14, 7],
  c,
  [402, 38],
  c,
  [299, 50],
  c,
  [470, 77],
  c,
  [27, 18],
  c,
  [602, 9],
  c,
  [10, 6],
  c,
  [221, 8],
  c,
  [476, 46],
  c,
  [69, 24],
  c,
  [27, 144],
  c,
  [450, 4],
  c,
  [27, 26],
  c,
  [8, 10],
  c,
  [81, 35],
  c,
  [323, 15],
  c,
  [533, 11],
  c,
  [33, 12],
  c,
  [27, 24],
  c,
  [583, 8],
  c,
  [27, 23],
  c,
  [114, 7],
  c,
  [27, 49],
  c,
  [16, 15],
  c,
  [27, 76],
  c,
  [507, 30],
  c,
  [1193, 14],
  c,
  [635, 30],
  c,
  [43, 10],
  c,
  [53, 14],
  c,
  [823, 50],
  c,
  [49, 38],
  c,
  [165, 30],
  c,
  [27, 19],
  c,
  [64, 12],
  c,
  [163, 15],
  c,
  [87, 38]
]),
  goto: u([
  s,
  [43, 15],
  2,
  6,
  8,
  2,
  17,
  15,
  10,
  16,
  7,
  12,
  11,
  9,
  14,
  13,
  5,
  18,
  19,
  3,
  3,
  23,
  22,
  37,
  24,
  20,
  25,
  28,
  29,
  26,
  s,
  [30, 5, 1],
  27,
  35,
  36,
  38,
  39,
  21,
  4,
  4,
  5,
  5,
  s,
  [6, 27],
  s,
  [7, 27],
  s,
  [8, 10],
  40,
  s,
  [8, 17],
  41,
  8,
  c,
  [123, 10],
  c,
  [11, 66],
  1,
  s,
  [44, 15],
  c,
  [93, 77],
  c,
  [11, 99],
  32,
  8,
  s,
  [32, 3],
  17,
  32,
  15,
  s,
  [32, 5],
  c,
  [21, 3],
  s,
  [32, 7],
  9,
  s,
  [32, 4],
  c,
  [30, 3],
  s,
  [32, 4],
  c,
  [46, 11],
  s,
  [33, 27],
  c,
  [106, 28],
  69,
  c,
  [12, 5],
  s,
  [29, 27],
  s,
  [30, 27],
  s,
  [34, 21],
  38,
  s,
  [34, 5],
  s,
  [35, 21],
  38,
  s,
  [35, 5],
  s,
  [36, 3],
  c,
  [594, 6],
  36,
  36,
  29,
  36,
  c,
  [595, 5],
  36,
  c,
  [595, 3],
  s,
  [36, 4],
  21,
  c,
  [618, 7],
  72,
  c,
  [619, 13],
  c,
  [639, 19],
  73,
  21,
  s,
  [12, 3],
  c,
  [24, 6],
  12,
  12,
  29,
  12,
  c,
  [25, 5],
  12,
  c,
  [25, 3],
  s,
  [12, 4],
  21,
  s,
  [13, 3],
  c,
  [27, 6],
  13,
  13,
  29,
  13,
  c,
  [27, 5],
  13,
  c,
  [27, 3],
  s,
  [13, 4],
  21,
  s,
  [14, 3],
  c,
  [27, 6],
  14,
  14,
  29,
  14,
  c,
  [27, 5],
  14,
  c,
  [27, 3],
  s,
  [14, 4],
  21,
  s,
  [15, 3],
  c,
  [27, 6],
  15,
  15,
  29,
  15,
  c,
  [27, 5],
  15,
  c,
  [27, 3],
  s,
  [15, 4],
  21,
  s,
  [16, 3],
  c,
  [27, 6],
  16,
  16,
  29,
  16,
  c,
  [27, 5],
  16,
  c,
  [27, 3],
  s,
  [16, 4],
  21,
  s,
  [17, 3],
  c,
  [27, 6],
  17,
  17,
  29,
  17,
  c,
  [27, 5],
  17,
  c,
  [27, 3],
  s,
  [17, 4],
  21,
  s,
  [18, 3],
  c,
  [186, 7],
  18,
  29,
  18,
  c,
  [27, 5],
  18,
  c,
  [27, 3],
  s,
  [18, 4],
  21,
  s,
  [19, 3],
  c,
  [27, 7],
  19,
  c,
  [214, 7],
  19,
  c,
  [27, 3],
  s,
  [19, 4],
  21,
  s,
  [20, 3],
  c,
  [27, 6],
  20,
  20,
  29,
  20,
  c,
  [27, 5],
  20,
  c,
  [27, 3],
  s,
  [20, 4],
  s,
  [21, 6],
  37,
  s,
  [21, 8],
  c,
  [27, 4],
  21,
  c,
  [27, 3],
  s,
  [21, 5],
  s,
  [22, 5],
  37,
  s,
  [22, 5],
  29,
  22,
  22,
  c,
  [27, 4],
  22,
  c,
  [27, 3],
  s,
  [22, 5],
  s,
  [23, 5],
  37,
  s,
  [23, 9],
  c,
  [27, 3],
  23,
  c,
  [27, 3],
  s,
  [23, 5],
  s,
  [24, 5],
  37,
  s,
  [24, 11],
  34,
  24,
  c,
  [27, 3],
  s,
  [24, 5],
  s,
  [25, 5],
  37,
  s,
  [25, 11],
  34,
  25,
  c,
  [27, 3],
  s,
  [25, 5],
  s,
  [26, 5],
  37,
  s,
  [26, 15],
  38,
  s,
  [26, 5],
  s,
  [27, 5],
  37,
  s,
  [27, 15],
  38,
  s,
  [27, 5],
  s,
  [28, 5],
  37,
  s,
  [28, 15],
  38,
  s,
  [28, 5],
  s,
  [31, 5],
  37,
  s,
  [31, 15],
  38,
  s,
  [31, 5],
  c,
  [507, 19],
  74,
  21,
  s,
  [9, 3],
  c,
  [24, 7],
  9,
  c,
  [25, 12],
  s,
  [9, 3],
  21,
  s,
  [10, 27],
  75,
  76,
  c,
  [53, 7],
  41,
  c,
  [53, 12],
  41,
  21,
  s,
  [37, 27],
  c,
  [823, 22],
  s,
  [11, 27],
  c,
  [38, 11],
  s,
  [40, 3],
  c,
  [112, 7],
  40,
  c,
  [112, 12],
  s,
  [40, 3],
  21,
  s,
  [38, 3],
  c,
  [27, 7],
  38,
  c,
  [27, 11],
  s,
  [38, 4],
  c,
  [747, 8],
  42,
  c,
  [51, 12],
  42,
  21,
  c,
  [87, 11],
  s,
  [39, 3],
  c,
  [36, 7],
  39,
  c,
  [36, 12],
  s,
  [39, 3],
  21
])
}),
defaultActions: bda({
  idx: u([
  0,
  s,
  [5, 4, 1],
  18,
  19,
  38,
  42,
  43,
  69,
  72,
  75
]),
  goto: u([
  43,
  s,
  [4, 4, 1],
  1,
  44,
  33,
  29,
  30,
  10,
  37,
  11
])
}),
parseError: function parseError(str, hash, ExceptionClass) {
    if (hash.recoverable) {
        if (typeof this.trace === 'function') {
            this.trace(str);
        }
        hash.destroy();             // destroy... well, *almost*!
    } else {
        if (typeof this.trace === 'function') {
            this.trace(str);
        }
        if (!ExceptionClass) {
            ExceptionClass = this.JisonParserError;
        }
        throw new ExceptionClass(str, hash);
    }
},
parse: function parse(input, globalSpace) {
    var self = this;
    var stack = new Array(128);         // token stack: stores token which leads to state at the same index (column storage)
    var sstack = new Array(128);        // state stack: stores states (column storage)

    var vstack = new Array(128);        // semantic value stack

    var table = this.table;
    var sp = 0;                         // 'stack pointer': index into the stacks

    var yytext;
    
    var yyleng;

    var symbol = 0;
    var preErrorSymbol = 0;
    var lastEofErrorStateDepth = Infinity;
    var recoveringErrorInfo = null;
    var recovering = 0;                 // (only used when the grammar contains error recovery rules)
    var TERROR = this.TERROR;
    var EOF = this.EOF;
    var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = (this.options.errorRecoveryTokenDiscardCount | 0) || 3;
    var NO_ACTION = [0, 82 /* === table.length :: ensures that anyone using this new state will fail dramatically! */];

    var lexer;
    if (this.__lexer__) {
        lexer = this.__lexer__;
    } else {
        lexer = this.__lexer__ = Object.create(this.lexer);
    }

    var sharedState_yy = {
        parseError: undefined,
        quoteName: undefined,
        lexer: undefined,
        parser: undefined,
        pre_parse: undefined,
        post_parse: undefined,
        pre_lex: undefined,
        post_lex: undefined,
        globalSpace: globalSpace  // parseParams::globalSpace      // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!
    };

    var ASSERT;
    if (typeof assert !== 'function') {
        ASSERT = function JisonAssert(cond, msg) {
            if (!cond) {
                throw new Error('assertion failed: ' + (msg || '***'));
            }
        };
    } else {
        ASSERT = assert;
    }

    this.yyGetSharedState = function yyGetSharedState() {
        return sharedState_yy;
    };


    this.yyGetErrorInfoTrack = function yyGetErrorInfoTrack() {
        return recoveringErrorInfo;
    };


    // shallow clone objects, straight copy of simple `src` values
    // e.g. `lexer.yytext` MAY be a complex value object,
    // rather than a simple string/value.
    function shallow_copy(src) {
        if (typeof src === 'object') {
            var dst = {};
            for (var k in src) {
                if (Object.prototype.hasOwnProperty.call(src, k)) {
                    dst[k] = src[k];
                }
            }
            return dst;
        }
        return src;
    }
    function shallow_copy_noclobber(dst, src) {
        for (var k in src) {
            if (typeof dst[k] === 'undefined' && Object.prototype.hasOwnProperty.call(src, k)) {
                dst[k] = src[k];
            }
        }
    }

    // copy state
    shallow_copy_noclobber(sharedState_yy, this.yy);

    sharedState_yy.lexer = lexer;
    sharedState_yy.parser = this;





    // *Always* setup `yyError`, `YYRECOVERING`, `yyErrOk` and `yyClearIn` functions as it is paramount
    // to have *their* closure match ours -- if we only set them up once,
    // any subsequent `parse()` runs will fail in very obscure ways when
    // these functions are invoked in the user action code block(s) as
    // their closure will still refer to the `parse()` instance which set
    // them up. Hence we MUST set them up at the start of every `parse()` run!





    if (this.yyErrOk) {
        this.yyErrOk = function yyErrOk() {









            recovering = 0;

            // DO NOT reset/cleanup `recoveringErrorInfo` yet: userland code
            // MAY invoke this API before the error is actually fully
            // recovered, in which case the parser recovery code won't be able
            // to append the skipped tokens to this info object.
            // 
            // The rest of the kernel code is safe enough that it won't inadvertedly
            // re-use an old `recoveringErrorInfo` chunk so we'ld better wait
            // with destruction/cleanup until the end of the parse or until another
            // fresh parse error rears its ugly head...
            //
            // if (recoveringErrorInfo && typeof recoveringErrorInfo.destroy === 'function') {
            //     recoveringErrorInfo.destroy();
            //     recoveringErrorInfo = undefined;
            // }
        };
    }

    if (this.yyClearIn) {
        this.yyClearIn = function yyClearIn() {









            if (symbol === TERROR) {
                symbol = 0;
                yytext = null;
                yyleng = 0;

            }
            preErrorSymbol = 0;
        };
    }


    // Does the shared state override the default `parseError` that already comes with this instance?
    if (typeof sharedState_yy.parseError === 'function') {
        this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {
            if (!ExceptionClass) {
                ExceptionClass = this.JisonParserError;
            }
            return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);
        };
    } else {
        this.parseError = this.originalParseError;
    }

    // Does the shared state override the default `quoteName` that already comes with this instance?
    if (typeof sharedState_yy.quoteName === 'function') {
        this.quoteName = function quoteNameAlt(id_str) {
            return sharedState_yy.quoteName.call(this, id_str);
        };
    } else {
        this.quoteName = this.originalQuoteName;
    }

    // set up the cleanup function; make it an API so that external code can re-use this one in case of
    // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which
    // case this parse() API method doesn't come with a `finally { ... }` block any more!
    //
    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `sharedState`, etc. references will be *wrong*!
    this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {
        var rv;

        if (invoke_post_methods) {
            var hash;

            if (sharedState_yy.post_parse || this.post_parse) {
                // create an error hash info instance: we re-use this API in a **non-error situation**
                // as this one delivers all parser internals ready for access by userland code.
                hash = this.constructParseErrorInfo(null /* no error! */, null /* no exception! */, null, false);
            }

            if (sharedState_yy.post_parse) {
                rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }
            if (this.post_parse) {
                rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }

            // cleanup:
            if (hash && hash.destroy) {
                hash.destroy();
            }
        }




        // clean up the lingering lexer structures as well:
        if (lexer.cleanupAfterLex) {
            lexer.cleanupAfterLex(do_not_nuke_errorinfos);
        }

        // prevent lingering circular references from causing memory leaks:
        if (sharedState_yy) {
            sharedState_yy.lexer = undefined;
            sharedState_yy.parser = undefined;
            if (lexer.yy === sharedState_yy) {
                lexer.yy = undefined;
            }
        }
        sharedState_yy = undefined;
        this.parseError = this.originalParseError;
        this.quoteName = this.originalQuoteName;

        // nuke the vstack[] array at least as that one will still reference obsoleted user values.
        // To be safe, we nuke the other internal stack columns as well...
        stack.length = 0;               // fastest way to nuke an array without overly bothering the GC
        sstack.length = 0;

        vstack.length = 0;
        sp = 0;

        // nuke the error hash info instances created during this run.
        // Userland code must COPY any data/references
        // in the error hash instance(s) it is more permanently interested in.
        if (!do_not_nuke_errorinfos) {
            for (var i = this.__error_infos.length - 1; i >= 0; i--) {
                var el = this.__error_infos[i];
                if (el && typeof el.destroy === 'function') {
                    el.destroy();
                }
            }
            this.__error_infos.length = 0;


            for (var i = this.__error_recovery_infos.length - 1; i >= 0; i--) {
                var el = this.__error_recovery_infos[i];
                if (el && typeof el.destroy === 'function') {
                    el.destroy();
                }
            }
            this.__error_recovery_infos.length = 0;

            // `recoveringErrorInfo` is also part of the `__error_recovery_infos` array,
            // hence has been destroyed already: no need to do that *twice*.
            if (recoveringErrorInfo) {
                recoveringErrorInfo = undefined;
            }


        }

        return resultValue;
    };






































































































































    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!
    this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {
        var pei = {
            errStr: msg,
            exception: ex,
            text: lexer.match,
            value: lexer.yytext,
            token: this.describeSymbol(symbol) || symbol,
            token_id: symbol,
            line: lexer.yylineno,

            expected: expected,
            recoverable: recoverable,
            state: state,
            action: action,
            new_state: newState,
            symbol_stack: stack,
            state_stack: sstack,
            value_stack: vstack,

            stack_pointer: sp,
            yy: sharedState_yy,
            lexer: lexer,
            parser: this,

            // and make sure the error info doesn't stay due to potential
            // ref cycle via userland code manipulations.
            // These would otherwise all be memory leak opportunities!
            //
            // Note that only array and object references are nuked as those
            // constitute the set of elements which can produce a cyclic ref.
            // The rest of the members is kept intact as they are harmless.
            destroy: function destructParseErrorInfo() {
                // remove cyclic references added to error info:
                // info.yy = null;
                // info.lexer = null;
                // info.value = null;
                // info.value_stack = null;
                // ...
                var rec = !!this.recoverable;
                for (var key in this) {
                    if (this.hasOwnProperty(key) && typeof key === 'object') {
                        this[key] = undefined;
                    }
                }
                this.recoverable = rec;
            }
        };
        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
        this.__error_infos.push(pei);
        return pei;
    };

    // clone some parts of the (possibly enhanced!) errorInfo object
    // to give them some persistence.
    this.shallowCopyErrorInfo = function parser_shallowCopyErrorInfo(p) {
        var rv = shallow_copy(p);

        // remove the large parts which can only cause cyclic references
        // and are otherwise available from the parser kernel anyway.
        delete rv.sharedState_yy;
        delete rv.parser;
        delete rv.lexer;

        // lexer.yytext MAY be a complex value object, rather than a simple string/value:
        rv.value = shallow_copy(rv.value);




        // the 'expected' set won't be modified, so no need to clone it:
        //rv.expected = rv.expected.slice(0);

        //symbol stack is a simple array:
        rv.symbol_stack = rv.symbol_stack.slice(0);
        // ditto for state stack:
        rv.state_stack = rv.state_stack.slice(0);


        // and the value stack may carry both simple and complex values:
        // shallow-copy the latter.
        rv.value_stack = rv.value_stack.map(shallow_copy);

        // and we don't bother with the sharedState_yy reference:
        //delete rv.yy;

        // now we prepare for tracking the COMBINE actions
        // in the error recovery code path:
        //
        // as we want to keep the maximum error info context, we
        // *scan* the state stack to find the first *empty* slot.
        // This position will surely be AT OR ABOVE the current
        // stack pointer, but we want to keep the 'used but discarded'
        // part of the parse stacks *intact* as those slots carry
        // error context that may be useful when you want to produce
        // very detailed error diagnostic reports.
        //
        // ### Purpose of each stack pointer:
        //
        // - stack_pointer: points at the top of the parse stack
        //                  **as it existed at the time of the error
        //                  occurrence, i.e. at the time the stack
        //                  snapshot was taken and copied into the
        //                  errorInfo object.**
        // - base_pointer:  the bottom of the **empty part** of the
        //                  stack, i.e. **the start of the rest of
        //                  the stack space /above/ the existing
        //                  parse stack. This section will be filled
        //                  by the error recovery process as it
        //                  travels the parse state machine to
        //                  arrive at the resolving error recovery rule.**
        // - info_stack_pointer:
        //                  this stack pointer points to the **top of
        //                  the error ecovery tracking stack space**, i.e.
        //                  this stack pointer takes up the role of
        //                  the `stack_pointer` for the error recovery
        //                  process. Any mutations in the **parse stack**
        //                  are **copy-appended** to this part of the
        //                  stack space, keeping the bottom part of the
        //                  stack (the 'snapshot' part where the parse
        //                  state at the time of error occurrence was kept)
        //                  intact.
        // - root_failure_pointer:
        //                  copy of the `stack_pointer`...
        //
        for (var i = rv.stack_pointer; typeof rv.state_stack[i] !== 'undefined'; i++) {
            // empty
        }
        rv.base_pointer = i;
        rv.info_stack_pointer = i;

        rv.root_failure_pointer = rv.stack_pointer;

        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
        this.__error_recovery_infos.push(rv);

        return rv;
    };

    function getNonTerminalFromCode(symbol) {
        var tokenName = self.getSymbolName(symbol);
        if (!tokenName) {
            tokenName = symbol;
        }
        return tokenName;
    }


    function stdLex() {
        var token = lexer.lex();
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }

        return token || 1/* EOF */;
    }

    function fastLex() {
        var token = lexer.fastLex();
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }

        return token || 1/* EOF */;
    }

    var lex = stdLex;


    var state, action, r, t;
    var yyval = {
        $: true,
        _$: undefined,
        yy: sharedState_yy
    };
    var p;
    var yyrulelen;
    var this_production;
    var newState;
    var retval = false;


    // Return the rule stack depth where the nearest error rule can be found.
    // Return -1 when no error recovery rule was found.
    function locateNearestErrorRecoveryRule(state) {
        var stack_probe = sp - 1;
        var depth = 0;

        // try to recover from error
        while (stack_probe >= 0) {
            // check for error recovery rule in this state









            var t = table[state][TERROR] || NO_ACTION;
            if (t[0]) {
                // We need to make sure we're not cycling forever:
                // once we hit EOF, even when we `yyerrok()` an error, we must
                // prevent the core from running forever,
                // e.g. when parent rules are still expecting certain input to
                // follow after this, for example when you handle an error inside a set
                // of braces which are matched by a parent rule in your grammar.
                //
                // Hence we require that every error handling/recovery attempt
                // *after we've hit EOF* has a diminishing state stack: this means
                // we will ultimately have unwound the state stack entirely and thus
                // terminate the parse in a controlled fashion even when we have
                // very complex error/recovery code interplay in the core + user
                // action code blocks:









                if (symbol === 1/* EOF */) {
                    if (lastEofErrorStateDepth > sp - 1 - depth) {
                        lastEofErrorStateDepth = sp - 1 - depth;
                    } else {









                        --stack_probe; // popStack(1): [symbol, action]
                        state = sstack[stack_probe];
                        ++depth;
                        continue;
                    }
                }
                return depth;
            }
            if (state === 0 /* $accept rule */ || stack_probe < 1) {









                return -1; // No suitable error recovery rule available.
            }
            --stack_probe; // popStack(1): [symbol, action]
            state = sstack[stack_probe];
            ++depth;
        }









        return -1; // No suitable error recovery rule available.
    }




    lexer.setInput(input, sharedState_yy);

    // NOTE: we *assume* no lexer pre/post handlers are set up *after* 
    // this initial `setInput()` call: hence we can now check and decide
    // whether we'll go with the standard, slower, lex() API or the
    // `fast_lex()` one:
    if (typeof lexer.canIUse === 'function') {
        var lexerInfo = lexer.canIUse();
        if (lexerInfo.fastLex && typeof fastLex === 'function') {
            lex = fastLex;
        }
    } 



    vstack[sp] = null;
    sstack[sp] = 0;
    stack[sp] = 0;
    ++sp;

    yytext = lexer.yytext;

    yyleng = lexer.yyleng;

    if (this.pre_parse) {
        this.pre_parse.call(this, sharedState_yy);
    }
    if (sharedState_yy.pre_parse) {
        sharedState_yy.pre_parse.call(this, sharedState_yy);
    }

    newState = sstack[sp - 1];
    for (;;) {
        // retrieve state number from top of stack
        state = newState;               // sstack[sp - 1];

        // use default actions if available
        if (this.defaultActions[state]) {
            action = 2;
            newState = this.defaultActions[state];
        } else {
            // The single `==` condition below covers both these `===` comparisons in a single
            // operation:
            //
            //     if (symbol === null || typeof symbol === 'undefined') ...
            if (!symbol) {
                symbol = lex();
            }
            // read action for current state and first input
            t = (table[state] && table[state][symbol]) || NO_ACTION;
            newState = t[1];
            action = t[0];











            // handle parse error
            if (!action) {
                // first see if there's any chance at hitting an error recovery rule:
                var error_rule_depth = locateNearestErrorRecoveryRule(state);
                var errStr = null;
                var errSymbolDescr = (this.describeSymbol(symbol) || symbol);
                var expected = this.collect_expected_token_set(state);

                if (!recovering) {
                    // Report error
                    if (typeof lexer.yylineno === 'number') {
                        errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';
                    } else {
                        errStr = 'Parse error: ';
                    }

                    if (typeof lexer.showPosition === 'function') {
                        errStr += '\n' + lexer.showPosition(79 - 10, 10) + '\n';
                    }
                    if (expected.length) {
                        errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;
                    } else {
                        errStr += 'Unexpected ' + errSymbolDescr;
                    }

                    p = this.constructParseErrorInfo(errStr, null, expected, (error_rule_depth >= 0));

                    // DO NOT cleanup the old one before we start the new error info track:
                    // the old one will *linger* on the error stack and stay alive until we 
                    // invoke the parser's cleanup API!
                    recoveringErrorInfo = this.shallowCopyErrorInfo(p);

                    r = this.parseError(p.errStr, p, this.JisonParserError);









                    // Protect against overly blunt userland `parseError` code which *sets*
                    // the `recoverable` flag without properly checking first:
                    // we always terminate the parse when there's no recovery rule available anyhow!
                    if (!p.recoverable || error_rule_depth < 0) {
                        if (typeof r !== 'undefined') {
                            retval = r;
                        }
                        break;
                    } else {
                        // TODO: allow parseError callback to edit symbol and or state at the start of the error recovery process...
                    }
                }










                var esp = recoveringErrorInfo.info_stack_pointer;

                // just recovered from another error
                if (recovering === ERROR_RECOVERY_TOKEN_DISCARD_COUNT && error_rule_depth >= 0) {
                    // SHIFT current lookahead and grab another
                    recoveringErrorInfo.symbol_stack[esp] = symbol;
                    recoveringErrorInfo.value_stack[esp] = shallow_copy(lexer.yytext);

                    recoveringErrorInfo.state_stack[esp] = newState; // push state
                    ++esp;

                    // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:
                    yyleng = lexer.yyleng;
                    yytext = lexer.yytext;



                    preErrorSymbol = 0;
                    symbol = lex();









                }

                // try to recover from error
                if (error_rule_depth < 0) {
                    ASSERT(recovering > 0, "line 897");
                    recoveringErrorInfo.info_stack_pointer = esp;

                    // barf a fatal hairball when we're out of look-ahead symbols and none hit a match
                    // while we are still busy recovering from another error:
                    var po = this.__error_infos[this.__error_infos.length - 1];

                    // Report error
                    if (typeof lexer.yylineno === 'number') {
                        errStr = 'Parsing halted on line ' + (lexer.yylineno + 1) + ' while starting to recover from another error';
                    } else {
                        errStr = 'Parsing halted while starting to recover from another error';
                    }

                    if (po) {
                        errStr += ' -- previous error which resulted in this fatal result: ' + po.errStr;
                    } else {
                        errStr += ': ';
                    }

                    if (typeof lexer.showPosition === 'function') {
                        errStr += '\n' + lexer.showPosition(79 - 10, 10) + '\n';
                    }
                    if (expected.length) {
                        errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;
                    } else {
                        errStr += 'Unexpected ' + errSymbolDescr;
                    }

                    p = this.constructParseErrorInfo(errStr, null, expected, false);
                    if (po) {
                        p.extra_error_attributes = po;
                    }

                    r = this.parseError(p.errStr, p, this.JisonParserError);
                    if (typeof r !== 'undefined') {
                        retval = r;
                    }
                    break;
                }

                preErrorSymbol = (symbol === TERROR ? 0 : symbol); // save the lookahead token
                symbol = TERROR;            // insert generic error symbol as new lookahead

                const EXTRA_STACK_SAMPLE_DEPTH = 3;

                // REDUCE/COMBINE the pushed terms/tokens to a new ERROR token:
                recoveringErrorInfo.symbol_stack[esp] = preErrorSymbol;
                if (errStr) {
                    recoveringErrorInfo.value_stack[esp] = {
                        yytext: shallow_copy(lexer.yytext),
                        errorRuleDepth: error_rule_depth,
                        errStr: errStr,
                        errorSymbolDescr: errSymbolDescr,
                        expectedStr: expected,
                        stackSampleLength: error_rule_depth + EXTRA_STACK_SAMPLE_DEPTH
                    };









                } else {
                    recoveringErrorInfo.value_stack[esp] = {
                        yytext: shallow_copy(lexer.yytext),
                        errorRuleDepth: error_rule_depth,
                        stackSampleLength: error_rule_depth + EXTRA_STACK_SAMPLE_DEPTH
                    };
                }

                recoveringErrorInfo.state_stack[esp] = newState || NO_ACTION[1];

                ++esp;
                recoveringErrorInfo.info_stack_pointer = esp;

                yyval.$ = recoveringErrorInfo;


                yyrulelen = error_rule_depth;









                r = this.performAction.call(yyval, yytext, yyleng, NO_ACTION[1], sp - 1, vstack);

                if (typeof r !== 'undefined') {
                    retval = r;
                    break;
                }

                // pop off stack
                sp -= yyrulelen;

                // and move the top entries + discarded part of the parse stacks onto the error info stack:
                for (var idx = sp - EXTRA_STACK_SAMPLE_DEPTH, top = idx + yyrulelen; idx < top; idx++, esp++) {
                    recoveringErrorInfo.symbol_stack[esp] = stack[idx];
                    recoveringErrorInfo.value_stack[esp] = shallow_copy(vstack[idx]);

                    recoveringErrorInfo.state_stack[esp] = sstack[idx];
                }

                recoveringErrorInfo.symbol_stack[esp] = TERROR;
                recoveringErrorInfo.value_stack[esp] = shallow_copy(yyval.$);


                // goto new state = table[STATE][NONTERMINAL]
                newState = sstack[sp - 1];

                if (this.defaultActions[newState]) {
                    recoveringErrorInfo.state_stack[esp] = this.defaultActions[newState];
                } else {
                    t = (table[newState] && table[newState][symbol]) || NO_ACTION;
                    recoveringErrorInfo.state_stack[esp] = t[1];
                }

                ++esp;
                recoveringErrorInfo.info_stack_pointer = esp;

                // allow N (default: 3) real symbols to be shifted before reporting a new error
                recovering = ERROR_RECOVERY_TOKEN_DISCARD_COUNT;










                // Now duplicate the standard parse machine here, at least its initial
                // couple of rounds until the TERROR symbol is **pushed onto the parse stack**,
                // as we wish to push something special then!
                //
                // Run the state machine in this copy of the parser state machine
                // until we *either* consume the error symbol (and its related information)
                // *or* we run into another error while recovering from this one
                // *or* we execute a `reduce` action which outputs a final parse
                // result (yes, that MAY happen!).
                //
                // We stay in this secondary parse loop until we have completed
                // the *error recovery phase* as the main parse loop (further below)
                // is optimized for regular parse operation and DOES NOT cope with
                // error recovery *at all*.
                //
                // We call the secondary parse loop just below the "slow parse loop",
                // while the main parse loop, which is an almost-duplicate of this one,
                // yet optimized for regular parse operation, is called the "fast
                // parse loop".
                //
                // Compare this to `bison` & (vanilla) `jison`, both of which have
                // only a single parse loop, which handles everything. Our goal is
                // to eke out every drop of performance in the main parse loop...

                ASSERT(recoveringErrorInfo, "line 1049");
                ASSERT(symbol === TERROR, "line 1050");
                ASSERT(!action, "line 1051");
                var errorSymbolFromParser = true;
                for (;;) {
                    // retrieve state number from top of stack
                    state = newState;               // sstack[sp - 1];

                    // use default actions if available
                    if (this.defaultActions[state]) {
                        action = 2;
                        newState = this.defaultActions[state];
                    } else {
                        // The single `==` condition below covers both these `===` comparisons in a single
                        // operation:
                        //
                        //     if (symbol === null || typeof symbol === 'undefined') ...
                        if (!symbol) {
                            symbol = lex();
                            // **Warning: Edge Case**: the *lexer* may produce
                            // TERROR tokens of its own volition: *those* TERROR
                            // tokens should be treated like *regular tokens*
                            // i.e. tokens which have a lexer-provided `yyvalue`

                            errorSymbolFromParser = false;
                        }
                        // read action for current state and first input
                        t = (table[state] && table[state][symbol]) || NO_ACTION;
                        newState = t[1];
                        action = t[0];










                        // encountered another parse error? If so, break out to main loop
                        // and take it from there!
                        if (!action) {










                            ASSERT(recoveringErrorInfo, "line 1087");

                            // Prep state variables so that upon breaking out of
                            // this "slow parse loop" and hitting the `continue;`
                            // statement in the outer "fast parse loop" we redo
                            // the exact same state table lookup as the one above
                            // so that the outer=main loop will also correctly
                            // detect the 'parse error' state (`!action`) we have
                            // just encountered above.
                            newState = state;
                            break;
                        }
                    }










                    switch (action) {
                    // catch misc. parse failures:
                    default:
                        // this shouldn't happen, unless resolve defaults are off
                        //
                        // SILENTLY SIGNAL that the outer "fast parse loop" should
                        // take care of this internal error condition:
                        // prevent useless code duplication now/here.
                        break;

                    // shift:
                    case 1:
                        stack[sp] = symbol;
                        // ### Note/Warning ###
                        //
                        // The *lexer* may also produce TERROR tokens on its own,
                        // so we specifically test for the TERROR we did set up
                        // in the error recovery logic further above!
                        if (symbol === TERROR && errorSymbolFromParser) {
                            // Push a special value onto the stack when we're
                            // shifting the `error` symbol that is related to the
                            // error we're recovering from.
                            ASSERT(recoveringErrorInfo, "line 1131");
                            vstack[sp] = recoveringErrorInfo;
                        } else {
                            ASSERT(symbol !== 0, "line 1135");
                            ASSERT(preErrorSymbol === 0, "line 1136");
                            vstack[sp] = lexer.yytext;

                        }
                        sstack[sp] = newState; // push state

                        ++sp;
                        symbol = 0;
                        // **Warning: Edge Case**: the *lexer* may have produced
                        // TERROR tokens of its own volition: *those* TERROR
                        // tokens should be treated like *regular tokens*
                        // i.e. tokens which have a lexer-provided `yyvalue`

                        errorSymbolFromParser = false;
                        if (!preErrorSymbol) { // normal execution / no error
                            // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:
                            yyleng = lexer.yyleng;
                            yytext = lexer.yytext;



                            if (recovering > 0) {
                                recovering--;









                            }
                        } else {
                            // error just occurred, resume old lookahead f/ before error, *unless* that drops us straight back into error mode:
                            ASSERT(recovering > 0, "line 1163");
                            symbol = preErrorSymbol;
                            preErrorSymbol = 0;









                            // read action for current state and first input
                            t = (table[newState] && table[newState][symbol]) || NO_ACTION;
                            if (!t[0] || symbol === TERROR) {
                                // forget about that symbol and move forward: this wasn't a 'forgot to insert' error type where
                                // (simple) stuff might have been missing before the token which caused the error we're
                                // recovering from now...
                                //
                                // Also check if the LookAhead symbol isn't the ERROR token we set as part of the error
                                // recovery, for then this we would we idling (cycling) on the error forever.
                                // Yes, this does not take into account the possibility that the *lexer* may have
                                // produced a *new* TERROR token all by itself, but that would be a very peculiar grammar!









                                symbol = 0;
                            }
                        }

                        // once we have pushed the special ERROR token value,
                        // we REMAIN in this inner, "slow parse loop" until
                        // the entire error recovery phase has completed.
                        //
                        // ### Note About Edge Case ###
                        //
                        // Userland action code MAY already have 'reset' the
                        // error recovery phase marker `recovering` to ZERO(0)
                        // while the error symbol hasn't been shifted onto
                        // the stack yet. Hence we only exit this "slow parse loop"
                        // when *both* conditions are met!
                        ASSERT(preErrorSymbol === 0, "line 1194");
                        if (recovering === 0) {
                            break;
                        }
                        continue;

                    // reduce:
                    case 2:
                        this_production = this.productions_[newState - 1];  // `this.productions_[]` is zero-based indexed while states start from 1 upwards...
                        yyrulelen = this_production[1];










                        r = this.performAction.call(yyval, yytext, yyleng, newState, sp - 1, vstack);

                        if (typeof r !== 'undefined') {
                            // signal end of error recovery loop AND end of outer parse loop
                            action = 3;
                            sp = -2;      // magic number: signal outer "fast parse loop" ACCEPT state that we already have a properly set up `retval` parser return value.
                            retval = r;
                            break;
                        }

                        // pop off stack
                        sp -= yyrulelen;

                        // don't overwrite the `symbol` variable: use a local var to speed things up:
                        var ntsymbol = this_production[0];    // push nonterminal (reduce)
                        stack[sp] = ntsymbol;
                        vstack[sp] = yyval.$;

                        // goto new state = table[STATE][NONTERMINAL]
                        newState = table[sstack[sp - 1]][ntsymbol];
                        sstack[sp] = newState;
                        ++sp;









                        continue;

                    // accept:
                    case 3:
                        retval = true;
                        // Return the `$accept` rule's `$$` result, if available.
                        //
                        // Also note that JISON always adds this top-most `$accept` rule (with implicit,
                        // default, action):
                        //
                        //     $accept: <startSymbol> $end
                        //                  %{ $$ = $1; @$ = @1; %}
                        //
                        // which, combined with the parse kernel's `$accept` state behaviour coded below,
                        // will produce the `$$` value output of the <startSymbol> rule as the parse result,
                        // IFF that result is *not* `undefined`. (See also the parser kernel code.)
                        //
                        // In code:
                        //
                        //                  %{
                        //                      @$ = @1;            // if location tracking support is included
                        //                      if (typeof $1 !== 'undefined')
                        //                          return $1;
                        //                      else
                        //                          return true;           // the default parse result if the rule actions don't produce anything
                        //                  %}
                        sp--;
                        if (sp >= 0 && typeof vstack[sp] !== 'undefined') {
                            retval = vstack[sp];
                        }
                        sp = -2;      // magic number: signal outer "fast parse loop" ACCEPT state that we already have a properly set up `retval` parser return value.
                        break;
                    }

                    // break out of loop: we accept or fail with error
                    break;
                }

                // should we also break out of the regular/outer parse loop,
                // i.e. did the parser already produce a parse result in here?!
                // *or* did we hit an unsupported parse state, to be handled
                // in the `switch/default` code further below?
                ASSERT(action !== 2, "line 1272");
                if (!action || action === 1) {
                    continue;
                }
            }


        }










        switch (action) {
        // catch misc. parse failures:
        default:
            // this shouldn't happen, unless resolve defaults are off
            if (action instanceof Array) {
                p = this.constructParseErrorInfo('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, null, null, false);
                r = this.parseError(p.errStr, p, this.JisonParserError);
                if (typeof r !== 'undefined') {
                    retval = r;
                }
                break;
            }
            // Another case of better safe than sorry: in case state transitions come out of another error recovery process
            // or a buggy LUT (LookUp Table):
            p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);
            r = this.parseError(p.errStr, p, this.JisonParserError);
            if (typeof r !== 'undefined') {
                retval = r;
            }
            break;

        // shift:
        case 1:
            stack[sp] = symbol;
            vstack[sp] = lexer.yytext;

            sstack[sp] = newState; // push state

            ++sp;
            symbol = 0;

            ASSERT(preErrorSymbol === 0, "line 1352");         // normal execution / no error
            ASSERT(recovering === 0, "line 1353");             // normal execution / no error

            // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:
            yyleng = lexer.yyleng;
            yytext = lexer.yytext;


            continue;

        // reduce:
        case 2:
            ASSERT(preErrorSymbol === 0, "line 1364");         // normal execution / no error
            ASSERT(recovering === 0, "line 1365");             // normal execution / no error

            this_production = this.productions_[newState - 1];  // `this.productions_[]` is zero-based indexed while states start from 1 upwards...
            yyrulelen = this_production[1];










            r = this.performAction.call(yyval, yytext, yyleng, newState, sp - 1, vstack);

            if (typeof r !== 'undefined') {
                retval = r;
                break;
            }

            // pop off stack
            sp -= yyrulelen;

            // don't overwrite the `symbol` variable: use a local var to speed things up:
            var ntsymbol = this_production[0];    // push nonterminal (reduce)
            stack[sp] = ntsymbol;
            vstack[sp] = yyval.$;

            // goto new state = table[STATE][NONTERMINAL]
            newState = table[sstack[sp - 1]][ntsymbol];
            sstack[sp] = newState;
            ++sp;









            continue;

        // accept:
        case 3:
            if (sp !== -2) {
                retval = true;
                // Return the `$accept` rule's `$$` result, if available.
                //
                // Also note that JISON always adds this top-most `$accept` rule (with implicit,
                // default, action):
                //
                //     $accept: <startSymbol> $end
                //                  %{ $$ = $1; @$ = @1; %}
                //
                // which, combined with the parse kernel's `$accept` state behaviour coded below,
                // will produce the `$$` value output of the <startSymbol> rule as the parse result,
                // IFF that result is *not* `undefined`. (See also the parser kernel code.)
                //
                // In code:
                //
                //                  %{
                //                      @$ = @1;            // if location tracking support is included
                //                      if (typeof $1 !== 'undefined')
                //                          return $1;
                //                      else
                //                          return true;           // the default parse result if the rule actions don't produce anything
                //                  %}
                sp--;
                if (typeof vstack[sp] !== 'undefined') {
                    retval = vstack[sp];
                }
            }
            break;
        }

        // break out of loop: we accept or fail with error
        break;
    }
    
    // ... AND FINALLY ...

    retval = this.cleanupAfterParse(retval, true, true);


    

    return retval;
},
yyErrOk: 1,
yyClearIn: 1
};
parser.originalParseError = parser.parseError;
parser.originalQuoteName = parser.quoteName;
/* lexer generated by jison-lex 0.6.1-214 */

/*
 * Returns a Lexer object of the following structure:
 *
 *  Lexer: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a direct reference!
 *
 *               This "shared context" object was passed to the lexer by way of 
 *               the `lexer.setInput(str, yy)` API before you may use it.
 *
 *               This "shared context" object is passed to the lexer action code in `performAction()`
 *               so userland code in the lexer actions may communicate with the outside world 
 *               and/or other lexer rules' actions in more or less complex ways.
 *
 *  }
 *
 *  Lexer.prototype: {
 *    EOF: 1,
 *    ERROR: 2,
 *
 *    yy:        The overall "shared context" object reference.
 *
 *    JisonLexerError: function(msg, hash),
 *
 *    performAction: function lexer__performAction(yy, yyrulenumber, YY_START),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `lexer` instance. 
 *                               `yy_` is an alias for `this` lexer instance reference used internally.
 *
 *               - `yy`      : a reference to the `yy` "shared state" object which was passed to the lexer
 *                             by way of the `lexer.setInput(str, yy)` API before.
 *
 *                             Note:
 *                             The extra arguments you specified in the `%parse-param` statement in your
 *                             **parser** grammar definition file are passed to the lexer via this object
 *                             reference as member variables.
 *
 *               - `yyrulenumber`   : index of the matched lexer rule (regex), used internally.
 *
 *               - `YY_START`: the current lexer "start condition" state.
 *
 *    parseError: function(str, hash, ExceptionClass),
 *
 *    constructLexErrorInfo: function(error_message, is_recoverable),
 *               Helper function.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this lexer kernel in many places; example usage:
 *
 *                   var infoObj = lexer.constructParseErrorInfo('fail!', true);
 *                   var retVal = lexer.parseError(infoObj.errStr, infoObj, lexer.JisonLexerError);
 *
 *    options: { ... lexer %options ... },
 *
 *    lex: function(),
 *               Produce one token of lexed input, which was passed in earlier via the `lexer.setInput()` API.
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of the **lexer** grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Lexer's additional `args...` parameters (via lexer's `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the **parser** or the jison run-time; 
 *               when such a collision is detected an exception is thrown to prevent the generated run-time 
 *               from silently accepting this confusing and potentially hazardous situation! 
 *
 *    cleanupAfterLex: function(do_not_nuke_errorinfos),
 *               Helper function.
 *
 *               This helper API is invoked when the **parse process** has completed: it is the responsibility
 *               of the **parser** (or the calling userland code) to invoke this method once cleanup is desired. 
 *
 *               This helper may be invoked by user code to ensure the internal lexer gets properly garbage collected.
 *
 *    setInput: function(input, [yy]),
 *
 *
 *    input: function(),
 *
 *
 *    unput: function(str),
 *
 *
 *    more: function(),
 *
 *
 *    reject: function(),
 *
 *
 *    less: function(n),
 *
 *
 *    pastInput: function(n),
 *
 *
 *    upcomingInput: function(n),
 *
 *
 *    showPosition: function(),
 *
 *
 *    test_match: function(regex_match_array, rule_index),
 *
 *
 *    next: function(),
 *
 *
 *    begin: function(condition),
 *
 *
 *    pushState: function(condition),
 *
 *
 *    popState: function(),
 *
 *
 *    topState: function(),
 *
 *
 *    _currentRules: function(),
 *
 *
 *    stateStackSize: function(),
 *
 *
 *    performAction: function(yy, yy_, yyrulenumber, YY_START),
 *
 *
 *    rules: [...],
 *
 *
 *    conditions: {associative list: name ==> set},
 *  }
 *
 *
 *  token location info (`yylloc`): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *  }
 *
 * while `this` will reference the current lexer instance.
 *
 * When `parseError` is invoked by the lexer, the default implementation will
 * attempt to invoke `yy.parser.parseError()`; when this callback is not provided
 * it will try to invoke `yy.parseError()` instead. When that callback is also not
 * provided, a `JisonLexerError` exception will be thrown containing the error
 * message and `hash`, as constructed by the `constructLexErrorInfo()` API.
 *
 * Note that the lexer's `JisonLexerError` error class is passed via the
 * `ExceptionClass` argument, which is invoked to construct the exception
 * instance to be thrown, so technically `parseError` will throw the object
 * produced by the `new ExceptionClass(str, hash)` JavaScript expression.
 *
 * ---
 *
 * You can specify lexer options by setting / modifying the `.options` object of your Lexer instance.
 * These options are available:
 *
 * (Options are permanent.)
 *  
 *  yy: {
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *  }
 *
 *  lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 * WARNING: the next set of options are not meant to be changed. They echo the abilities of
 * the lexer as per when it was compiled!
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this %option has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */


var lexer = function() {
  /**
   * See also:
   * http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
   * but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
   * with userland code which might access the derived class in a 'classic' way.
   *
   * @public
   * @constructor
   * @nocollapse
   */
  function JisonLexerError(msg, hash) {
    Object.defineProperty(this, 'name', {
      enumerable: false,
      writable: false,
      value: 'JisonLexerError'
    });

    if (msg == null)
      msg = '???';

    Object.defineProperty(this, 'message', {
      enumerable: false,
      writable: true,
      value: msg
    });

    this.hash = hash;
    var stacktrace;

    if (hash && hash.exception instanceof Error) {
      var ex2 = hash.exception;
      this.message = ex2.message || msg;
      stacktrace = ex2.stack;
    }

    if (!stacktrace) {
      if (Error.hasOwnProperty('captureStackTrace')) {
        // V8
        Error.captureStackTrace(this, this.constructor);
      } else {
        stacktrace = new Error(msg).stack;
      }
    }

    if (stacktrace) {
      Object.defineProperty(this, 'stack', {
        enumerable: false,
        writable: false,
        value: stacktrace
      });
    }
  }

  if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonLexerError.prototype, Error.prototype);
  } else {
    JisonLexerError.prototype = Object.create(Error.prototype);
  }

  JisonLexerError.prototype.constructor = JisonLexerError;
  JisonLexerError.prototype.name = 'JisonLexerError';

  var lexer = {
    
// Code Generator Information Report
// ---------------------------------
//
// Options:
//
//   backtracking: .................... false
//   location.ranges: ................. false
//   location line+column tracking: ... true
//
//
// Forwarded Parser Analysis flags:
//
//   uses yyleng: ..................... true
//   uses yylineno: ................... false
//   uses yytext: ..................... true
//   uses yylloc: ..................... false
//   uses lexer values: ............... true / true
//   location tracking: ............... false
//   location assignment: ............. false
//
//
// Lexer Analysis flags:
//
//   uses yyleng: ..................... ???
//   uses yylineno: ................... ???
//   uses yytext: ..................... ???
//   uses yylloc: ..................... ???
//   uses ParseError API: ............. ???
//   uses yyerror: .................... ???
//   uses location tracking & editing:  ???
//   uses more() API: ................. ???
//   uses unput() API: ................ ???
//   uses reject() API: ............... ???
//   uses less() API: ................. ???
//   uses display APIs pastInput(), upcomingInput(), showPosition():
//        ............................. ???
//   uses describeYYLLOC() API: ....... ???
//
// --------- END OF REPORT -----------

EOF: 1,
    ERROR: 2,

    // JisonLexerError: JisonLexerError,        /// <-- injected by the code generator

    // options: {},                             /// <-- injected by the code generator

    // yy: ...,                                 /// <-- injected by setInput()

    __currentRuleSet__: null,                   /// INTERNAL USE ONLY: internal rule set cache for the current lexer state  

    __error_infos: [],                          /// INTERNAL USE ONLY: the set of lexErrorInfo objects created since the last cleanup  
    __decompressed: false,                      /// INTERNAL USE ONLY: mark whether the lexer instance has been 'unfolded' completely and is now ready for use  
    done: false,                                /// INTERNAL USE ONLY  
    _backtrack: false,                          /// INTERNAL USE ONLY  
    _input: '',                                 /// INTERNAL USE ONLY  
    _more: false,                               /// INTERNAL USE ONLY  
    _signaled_error_token: false,               /// INTERNAL USE ONLY  
    conditionStack: [],                         /// INTERNAL USE ONLY; managed via `pushState()`, `popState()`, `topState()` and `stateStackSize()`  
    match: '',                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction. `match` is identical to `yytext` except that this one still contains the matched input string after `lexer.performAction()` has been invoked, where userland code MAY have changed/replaced the `yytext` value entirely!  
    matched: '',                                /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks entire input which has been matched so far  
    matches: false,                             /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks RE match result for last (successful) match attempt  
    yytext: '',                                 /// ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction; this value is transferred to the parser as the 'token value' when the parser consumes the lexer token produced through a call to the `lex()` API.  
    offset: 0,                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks the 'cursor position' in the input string, i.e. the number of characters matched so far  
    yyleng: 0,                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: length of matched input for the token under construction (`yytext`)  
    yylineno: 0,                                /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: 'line number' at which the token under construction is located  
    yylloc: null,                               /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks location info (lines + columns) for the token under construction  

    /**
     * INTERNAL USE: construct a suitable error info hash object instance for `parseError`.
     * 
     * @public
     * @this {RegExpLexer}
     */
    constructLexErrorInfo: function lexer_constructLexErrorInfo(msg, recoverable, show_input_position) {
      msg = '' + msg;

      // heuristic to determine if the error message already contains a (partial) source code dump
      // as produced by either `showPosition()` or `prettyPrintRange()`:
      if (show_input_position == undefined) {
        show_input_position = !(msg.indexOf('\n') > 0 && msg.indexOf('^') > 0);
      }

      if (this.yylloc && show_input_position) {
        if (typeof this.prettyPrintRange === 'function') {
          var pretty_src = this.prettyPrintRange(this.yylloc);

          if (!/\n\s*$/.test(msg)) {
            msg += '\n';
          }

          msg += '\n  Erroneous area:\n' + this.prettyPrintRange(this.yylloc);
        } else if (typeof this.showPosition === 'function') {
          var pos_str = this.showPosition();

          if (pos_str) {
            if (msg.length && msg[msg.length - 1] !== '\n' && pos_str[0] !== '\n') {
              msg += '\n' + pos_str;
            } else {
              msg += pos_str;
            }
          }
        }
      }

      /** @constructor */
      var pei = {
        errStr: msg,
        recoverable: !!recoverable,
        text: this.match,           // This one MAY be empty; userland code should use the `upcomingInput` API to obtain more text which follows the 'lexer cursor position'...  
        token: null,
        line: this.yylineno,
        loc: this.yylloc,
        yy: this.yy,
        lexer: this,

        /**
         * and make sure the error info doesn't stay due to potential
         * ref cycle via userland code manipulations.
         * These would otherwise all be memory leak opportunities!
         * 
         * Note that only array and object references are nuked as those
         * constitute the set of elements which can produce a cyclic ref.
         * The rest of the members is kept intact as they are harmless.
         * 
         * @public
         * @this {LexErrorInfo}
         */
        destroy: function destructLexErrorInfo() {
          // remove cyclic references added to error info:
          // info.yy = null;
          // info.lexer = null;
          // ...
          var rec = !!this.recoverable;

          for (var key in this) {
            if (this.hasOwnProperty(key) && typeof key === 'object') {
              this[key] = undefined;
            }
          }

          this.recoverable = rec;
        }
      };

      // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
      this.__error_infos.push(pei);

      return pei;
    },

    /**
     * handler which is invoked when a lexer error occurs.
     * 
     * @public
     * @this {RegExpLexer}
     */
    parseError: function lexer_parseError(str, hash, ExceptionClass) {
      if (!ExceptionClass) {
        ExceptionClass = this.JisonLexerError;
      }

      if (this.yy) {
        if (this.yy.parser && typeof this.yy.parser.parseError === 'function') {
          return this.yy.parser.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
        } else if (typeof this.yy.parseError === 'function') {
          return this.yy.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
        }
      }

      throw new ExceptionClass(str, hash);
    },

    /**
     * method which implements `yyerror(str, ...args)` functionality for use inside lexer actions.
     * 
     * @public
     * @this {RegExpLexer}
     */
    yyerror: function yyError(str /*, ...args */) {
      var lineno_msg = '';

      if (this.yylloc) {
        lineno_msg = ' on line ' + (this.yylineno + 1);
      }

      var p = this.constructLexErrorInfo(
        'Lexical error' + lineno_msg + ': ' + str,
        this.options.lexerErrorsAreRecoverable
      );

      // Add any extra args to the hash under the name `extra_error_attributes`:
      var args = Array.prototype.slice.call(arguments, 1);

      if (args.length) {
        p.extra_error_attributes = args;
      }

      return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
    },

    /**
     * final cleanup function for when we have completed lexing the input;
     * make it an API so that external code can use this one once userland
     * code has decided it's time to destroy any lingering lexer error
     * hash object instances and the like: this function helps to clean
     * up these constructs, which *may* carry cyclic references which would
     * otherwise prevent the instances from being properly and timely
     * garbage-collected, i.e. this function helps prevent memory leaks!
     * 
     * @public
     * @this {RegExpLexer}
     */
    cleanupAfterLex: function lexer_cleanupAfterLex(do_not_nuke_errorinfos) {
      // prevent lingering circular references from causing memory leaks:
      this.setInput('', {});

      // nuke the error hash info instances created during this run.
      // Userland code must COPY any data/references
      // in the error hash instance(s) it is more permanently interested in.
      if (!do_not_nuke_errorinfos) {
        for (var i = this.__error_infos.length - 1; i >= 0; i--) {
          var el = this.__error_infos[i];

          if (el && typeof el.destroy === 'function') {
            el.destroy();
          }
        }

        this.__error_infos.length = 0;
      }

      return this;
    },

    /**
     * clear the lexer token context; intended for internal use only
     * 
     * @public
     * @this {RegExpLexer}
     */
    clear: function lexer_clear() {
      this.yytext = '';
      this.yyleng = 0;
      this.match = '';

      // - DO NOT reset `this.matched`
      this.matches = false;

      this._more = false;
      this._backtrack = false;
      var col = (this.yylloc ? this.yylloc.last_column : 0);

      this.yylloc = {
        first_line: this.yylineno + 1,
        first_column: col,
        last_line: this.yylineno + 1,
        last_column: col,
        range: [this.offset, this.offset]
      };
    },

    /**
     * resets the lexer, sets new input
     * 
     * @public
     * @this {RegExpLexer}
     */
    setInput: function lexer_setInput(input, yy) {
      this.yy = yy || this.yy || {};

      // also check if we've fully initialized the lexer instance,
      // including expansion work to be done to go from a loaded
      // lexer to a usable lexer:
      if (!this.__decompressed) {
        // step 1: decompress the regex list:
        var rules = this.rules;

        for (var i = 0, len = rules.length; i < len; i++) {
          var rule_re = rules[i];

          // compression: is the RE an xref to another RE slot in the rules[] table?
          if (typeof rule_re === 'number') {
            rules[i] = rules[rule_re];
          }
        }

        // step 2: unfold the conditions[] set to make these ready for use:
        var conditions = this.conditions;

        for (var k in conditions) {
          var spec = conditions[k];
          var rule_ids = spec.rules;
          var len = rule_ids.length;
          var rule_regexes = new Array(len + 1);             // slot 0 is unused; we use a 1-based index approach here to keep the hottest code in `lexer_next()` fast and simple! 
          var rule_new_ids = new Array(len + 1);

          for (var i = 0; i < len; i++) {
            var idx = rule_ids[i];
            var rule_re = rules[idx];
            rule_regexes[i + 1] = rule_re;
            rule_new_ids[i + 1] = idx;
          }

          spec.rules = rule_new_ids;
          spec.__rule_regexes = rule_regexes;
          spec.__rule_count = len;
        }

        this.__decompressed = true;
      }

      this._input = input || '';
      this.clear();
      this._signaled_error_token = false;
      this.done = false;
      this.yylineno = 0;
      this.matched = '';
      this.conditionStack = ['INITIAL'];
      this.__currentRuleSet__ = null;

      this.yylloc = {
        first_line: 1,
        first_column: 0,
        last_line: 1,
        last_column: 0,
        range: [0, 0]
      };

      this.offset = 0;
      return this;
    },

    /**
     * edit the remaining input via user-specified callback.
     * This can be used to forward-adjust the input-to-parse, 
     * e.g. inserting macro expansions and alike in the
     * input which has yet to be lexed.
     * The behaviour of this API contrasts the `unput()` et al
     * APIs as those act on the *consumed* input, while this
     * one allows one to manipulate the future, without impacting
     * the current `yyloc` cursor location or any history. 
     * 
     * Use this API to help implement C-preprocessor-like
     * `#include` statements, etc.
     * 
     * The provided callback must be synchronous and is
     * expected to return the edited input (string).
     *
     * The `cpsArg` argument value is passed to the callback
     * as-is.
     *
     * `callback` interface: 
     * `function callback(input, cpsArg)`
     * 
     * - `input` will carry the remaining-input-to-lex string
     *   from the lexer.
     * - `cpsArg` is `cpsArg` passed into this API.
     * 
     * The `this` reference for the callback will be set to
     * reference this lexer instance so that userland code
     * in the callback can easily and quickly access any lexer
     * API. 
     *
     * When the callback returns a non-string-type falsey value,
     * we assume the callback did not edit the input and we
     * will using the input as-is.
     *
     * When the callback returns a non-string-type value, it
     * is converted to a string for lexing via the `"" + retval`
     * operation. (See also why: http://2ality.com/2012/03/converting-to-string.html 
     * -- that way any returned object's `toValue()` and `toString()`
     * methods will be invoked in a proper/desirable order.)
     * 
     * @public
     * @this {RegExpLexer}
     */
    editRemainingInput: function lexer_editRemainingInput(callback, cpsArg) {
      var rv = callback.call(this, this._input, cpsArg);

      if (typeof rv !== 'string') {
        if (rv) {
          this._input = '' + rv;
        } 
        // else: keep `this._input` as is.  
      } else {
        this._input = rv;
      }

      return this;
    },

    /**
     * consumes and returns one char from the input
     * 
     * @public
     * @this {RegExpLexer}
     */
    input: function lexer_input() {
      if (!this._input) {
        //this.done = true;    -- don't set `done` as we want the lex()/next() API to be able to produce one custom EOF token match after this anyhow. (lexer can match special <<EOF>> tokens and perform user action code for a <<EOF>> match, but only does so *once*)
        return null;
      }

      var ch = this._input[0];
      this.yytext += ch;
      this.yyleng++;
      this.offset++;
      this.match += ch;
      this.matched += ch;

      // Count the linenumber up when we hit the LF (or a stand-alone CR).
      // On CRLF, the linenumber is incremented when you fetch the CR or the CRLF combo
      // and we advance immediately past the LF as well, returning both together as if
      // it was all a single 'character' only.
      var slice_len = 1;

      var lines = false;

      if (ch === '\n') {
        lines = true;
      } else if (ch === '\r') {
        lines = true;
        var ch2 = this._input[1];

        if (ch2 === '\n') {
          slice_len++;
          ch += ch2;
          this.yytext += ch2;
          this.yyleng++;
          this.offset++;
          this.match += ch2;
          this.matched += ch2;
          this.yylloc.range[1]++;
        }
      }

      if (lines) {
        this.yylineno++;
        this.yylloc.last_line++;
        this.yylloc.last_column = 0;
      } else {
        this.yylloc.last_column++;
      }

      this.yylloc.range[1]++;
      this._input = this._input.slice(slice_len);
      return ch;
    },

    /**
     * unshifts one char (or an entire string) into the input
     * 
     * @public
     * @this {RegExpLexer}
     */
    unput: function lexer_unput(ch) {
      var len = ch.length;
      var lines = ch.split(/(?:\r\n?|\n)/g);
      this._input = ch + this._input;
      this.yytext = this.yytext.substr(0, this.yytext.length - len);
      this.yyleng = this.yytext.length;
      this.offset -= len;
      this.match = this.match.substr(0, this.match.length - len);
      this.matched = this.matched.substr(0, this.matched.length - len);

      if (lines.length > 1) {
        this.yylineno -= lines.length - 1;
        this.yylloc.last_line = this.yylineno + 1;

        // Get last entirely matched line into the `pre_lines[]` array's
        // last index slot; we don't mind when other previously 
        // matched lines end up in the array too. 
        var pre = this.match;

        var pre_lines = pre.split(/(?:\r\n?|\n)/g);

        if (pre_lines.length === 1) {
          pre = this.matched;
          pre_lines = pre.split(/(?:\r\n?|\n)/g);
        }

        this.yylloc.last_column = pre_lines[pre_lines.length - 1].length;
      } else {
        this.yylloc.last_column -= len;
      }

      this.yylloc.range[1] = this.yylloc.range[0] + this.yyleng;
      this.done = false;
      return this;
    },

    /**
     * cache matched text and append it on next action
     * 
     * @public
     * @this {RegExpLexer}
     */
    more: function lexer_more() {
      this._more = true;
      return this;
    },

    /**
     * signal the lexer that this rule fails to match the input, so the
     * next matching rule (regex) should be tested instead.
     * 
     * @public
     * @this {RegExpLexer}
     */
    reject: function lexer_reject() {
      if (this.options.backtrack_lexer) {
        this._backtrack = true;
      } else {
        // when the `parseError()` call returns, we MUST ensure that the error is registered.
        // We accomplish this by signaling an 'error' token to be produced for the current
        // `.lex()` run.
        var lineno_msg = '';

        if (this.yylloc) {
          lineno_msg = ' on line ' + (this.yylineno + 1);
        }

        var p = this.constructLexErrorInfo(
          'Lexical error' + lineno_msg + ': You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).',
          false
        );

        this._signaled_error_token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
      }

      return this;
    },

    /**
     * retain first n characters of the match
     * 
     * @public
     * @this {RegExpLexer}
     */
    less: function lexer_less(n) {
      return this.unput(this.match.slice(n));
    },

    /**
     * return (part of the) already matched input, i.e. for error
     * messages.
     * 
     * Limit the returned string length to `maxSize` (default: 20).
     * 
     * Limit the returned string to the `maxLines` number of lines of
     * input (default: 1).
     * 
     * Negative limit values equal *unlimited*.
     * 
     * @public
     * @this {RegExpLexer}
     */
    pastInput: function lexer_pastInput(maxSize, maxLines) {
      var past = this.matched.substring(0, this.matched.length - this.match.length);

      if (maxSize < 0)
        maxSize = past.length;
      else if (!maxSize)
        maxSize = 20;

      if (maxLines < 0)
        maxLines = past.length;          // can't ever have more input lines than this! 
      else if (!maxLines)
        maxLines = 1;

      // `substr` anticipation: treat \r\n as a single character and take a little
      // more than necessary so that we can still properly check against maxSize
      // after we've transformed and limited the newLines in here:
      past = past.substr(-maxSize * 2 - 2);

      // now that we have a significantly reduced string to process, transform the newlines
      // and chop them, then limit them:
      var a = past.replace(/\r\n|\r/g, '\n').split('\n');

      a = a.slice(-maxLines);
      past = a.join('\n');

      // When, after limiting to maxLines, we still have too much to return,
      // do add an ellipsis prefix...
      if (past.length > maxSize) {
        past = '...' + past.substr(-maxSize);
      }

      return past;
    },

    /**
     * return (part of the) upcoming input, i.e. for error messages.
     * 
     * Limit the returned string length to `maxSize` (default: 20).
     * 
     * Limit the returned string to the `maxLines` number of lines of input (default: 1).
     * 
     * Negative limit values equal *unlimited*.
     *
     * > ### NOTE ###
     * >
     * > *"upcoming input"* is defined as the whole of the both
     * > the *currently lexed* input, together with any remaining input
     * > following that. *"currently lexed"* input is the input 
     * > already recognized by the lexer but not yet returned with
     * > the lexer token. This happens when you are invoking this API
     * > from inside any lexer rule action code block. 
     * >
     * 
     * @public
     * @this {RegExpLexer}
     */
    upcomingInput: function lexer_upcomingInput(maxSize, maxLines) {
      var next = this.match;

      if (maxSize < 0)
        maxSize = next.length + this._input.length;
      else if (!maxSize)
        maxSize = 20;

      if (maxLines < 0)
        maxLines = maxSize;          // can't ever have more input lines than this! 
      else if (!maxLines)
        maxLines = 1;

      // `substring` anticipation: treat \r\n as a single character and take a little
      // more than necessary so that we can still properly check against maxSize
      // after we've transformed and limited the newLines in here:
      if (next.length < maxSize * 2 + 2) {
        next += this._input.substring(0, maxSize * 2 + 2);   // substring is faster on Chrome/V8 
      }

      // now that we have a significantly reduced string to process, transform the newlines
      // and chop them, then limit them:
      var a = next.replace(/\r\n|\r/g, '\n').split('\n');

      a = a.slice(0, maxLines);
      next = a.join('\n');

      // When, after limiting to maxLines, we still have too much to return,
      // do add an ellipsis postfix...
      if (next.length > maxSize) {
        next = next.substring(0, maxSize) + '...';
      }

      return next;
    },

    /**
     * return a string which displays the character position where the
     * lexing error occurred, i.e. for error messages
     * 
     * @public
     * @this {RegExpLexer}
     */
    showPosition: function lexer_showPosition(maxPrefix, maxPostfix) {
      var pre = this.pastInput(maxPrefix).replace(/\s/g, ' ');
      var c = new Array(pre.length + 1).join('-');
      return pre + this.upcomingInput(maxPostfix).replace(/\s/g, ' ') + '\n' + c + '^';
    },

    /**
     * return an YYLLOC info object derived off the given context (actual, preceding, following, current).
     * Use this method when the given `actual` location is not guaranteed to exist (i.e. when
     * it MAY be NULL) and you MUST have a valid location info object anyway:
     * then we take the given context of the `preceding` and `following` locations, IFF those are available,
     * and reconstruct the `actual` location info from those.
     * If this fails, the heuristic is to take the `current` location, IFF available.
     * If this fails as well, we assume the sought location is at/around the current lexer position
     * and then produce that one as a response. DO NOTE that these heuristic/derived location info
     * values MAY be inaccurate!
     *
     * NOTE: `deriveLocationInfo()` ALWAYS produces a location info object *copy* of `actual`, not just
     * a *reference* hence all input location objects can be assumed to be 'constant' (function has no side-effects).
     * 
     * @public
     * @this {RegExpLexer}
     */
    deriveLocationInfo: function lexer_deriveYYLLOC(actual, preceding, following, current) {
      var loc = {
        first_line: 1,
        first_column: 0,
        last_line: 1,
        last_column: 0,
        range: [0, 0]
      };

      if (actual) {
        loc.first_line = actual.first_line | 0;
        loc.last_line = actual.last_line | 0;
        loc.first_column = actual.first_column | 0;
        loc.last_column = actual.last_column | 0;

        if (actual.range) {
          loc.range[0] = actual.range[0] | 0;
          loc.range[1] = actual.range[1] | 0;
        }
      }

      if (loc.first_line <= 0 || loc.last_line < loc.first_line) {
        // plan B: heuristic using preceding and following:
        if (loc.first_line <= 0 && preceding) {
          loc.first_line = preceding.last_line | 0;
          loc.first_column = preceding.last_column | 0;

          if (preceding.range) {
            loc.range[0] = actual.range[1] | 0;
          }
        }

        if ((loc.last_line <= 0 || loc.last_line < loc.first_line) && following) {
          loc.last_line = following.first_line | 0;
          loc.last_column = following.first_column | 0;

          if (following.range) {
            loc.range[1] = actual.range[0] | 0;
          }
        }

        // plan C?: see if the 'current' location is useful/sane too:
        if (loc.first_line <= 0 && current && (loc.last_line <= 0 || current.last_line <= loc.last_line)) {
          loc.first_line = current.first_line | 0;
          loc.first_column = current.first_column | 0;

          if (current.range) {
            loc.range[0] = current.range[0] | 0;
          }
        }

        if (loc.last_line <= 0 && current && (loc.first_line <= 0 || current.first_line >= loc.first_line)) {
          loc.last_line = current.last_line | 0;
          loc.last_column = current.last_column | 0;

          if (current.range) {
            loc.range[1] = current.range[1] | 0;
          }
        }
      }

      // sanitize: fix last_line BEFORE we fix first_line as we use the 'raw' value of the latter
      // or plan D heuristics to produce a 'sensible' last_line value:
      if (loc.last_line <= 0) {
        if (loc.first_line <= 0) {
          loc.first_line = this.yylloc.first_line;
          loc.last_line = this.yylloc.last_line;
          loc.first_column = this.yylloc.first_column;
          loc.last_column = this.yylloc.last_column;
          loc.range[0] = this.yylloc.range[0];
          loc.range[1] = this.yylloc.range[1];
        } else {
          loc.last_line = this.yylloc.last_line;
          loc.last_column = this.yylloc.last_column;
          loc.range[1] = this.yylloc.range[1];
        }
      }

      if (loc.first_line <= 0) {
        loc.first_line = loc.last_line;
        loc.first_column = 0;  // loc.last_column; 
        loc.range[1] = loc.range[0];
      }

      if (loc.first_column < 0) {
        loc.first_column = 0;
      }

      if (loc.last_column < 0) {
        loc.last_column = (loc.first_column > 0 ? loc.first_column : 80);
      }

      return loc;
    },

    /**
     * return a string which displays the lines & columns of input which are referenced 
     * by the given location info range, plus a few lines of context.
     * 
     * This function pretty-prints the indicated section of the input, with line numbers 
     * and everything!
     * 
     * This function is very useful to provide highly readable error reports, while
     * the location range may be specified in various flexible ways:
     * 
     * - `loc` is the location info object which references the area which should be
     *   displayed and 'marked up': these lines & columns of text are marked up by `^`
     *   characters below each character in the entire input range.
     * 
     * - `context_loc` is the *optional* location info object which instructs this
     *   pretty-printer how much *leading* context should be displayed alongside
     *   the area referenced by `loc`. This can help provide context for the displayed
     *   error, etc.
     * 
     *   When this location info is not provided, a default context of 3 lines is
     *   used.
     * 
     * - `context_loc2` is another *optional* location info object, which serves
     *   a similar purpose to `context_loc`: it specifies the amount of *trailing*
     *   context lines to display in the pretty-print output.
     * 
     *   When this location info is not provided, a default context of 1 line only is
     *   used.
     * 
     * Special Notes:
     * 
     * - when the `loc`-indicated range is very large (about 5 lines or more), then
     *   only the first and last few lines of this block are printed while a
     *   `...continued...` message will be printed between them.
     * 
     *   This serves the purpose of not printing a huge amount of text when the `loc`
     *   range happens to be huge: this way a manageable & readable output results
     *   for arbitrary large ranges.
     * 
     * - this function can display lines of input which whave not yet been lexed.
     *   `prettyPrintRange()` can access the entire input!
     * 
     * @public
     * @this {RegExpLexer}
     */
    prettyPrintRange: function lexer_prettyPrintRange(loc, context_loc, context_loc2) {
      loc = this.deriveLocationInfo(loc, context_loc, context_loc2);
      const CONTEXT = 3;
      const CONTEXT_TAIL = 1;
      const MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT = 2;
      var input = this.matched + this._input;
      var lines = input.split('\n');
      var l0 = Math.max(1, (context_loc ? context_loc.first_line : loc.first_line - CONTEXT));
      var l1 = Math.max(1, (context_loc2 ? context_loc2.last_line : loc.last_line + CONTEXT_TAIL));
      var lineno_display_width = 1 + Math.log10(l1 | 1) | 0;
      var ws_prefix = new Array(lineno_display_width).join(' ');
      var nonempty_line_indexes = [];

      var rv = lines.slice(l0 - 1, l1 + 1).map(function injectLineNumber(line, index) {
        var lno = index + l0;
        var lno_pfx = (ws_prefix + lno).substr(-lineno_display_width);
        var rv = lno_pfx + ': ' + line;
        var errpfx = new Array(lineno_display_width + 1).join('^');
        var offset = 2 + 1;
        var len = 0;

        if (lno === loc.first_line) {
          offset += loc.first_column;

          len = Math.max(
            2,
            ((lno === loc.last_line ? loc.last_column : line.length)) - loc.first_column + 1
          );
        } else if (lno === loc.last_line) {
          len = Math.max(2, loc.last_column + 1);
        } else if (lno > loc.first_line && lno < loc.last_line) {
          len = Math.max(2, line.length + 1);
        }

        if (len) {
          var lead = new Array(offset).join('.');
          var mark = new Array(len).join('^');
          rv += '\n' + errpfx + lead + mark;

          if (line.trim().length > 0) {
            nonempty_line_indexes.push(index);
          }
        }

        rv = rv.replace(/\t/g, ' ');
        return rv;
      });

      // now make sure we don't print an overly large amount of error area: limit it 
      // to the top and bottom line count:
      if (nonempty_line_indexes.length > 2 * MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT) {
        var clip_start = nonempty_line_indexes[MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT - 1] + 1;
        var clip_end = nonempty_line_indexes[nonempty_line_indexes.length - MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT] - 1;
        var intermediate_line = new Array(lineno_display_width + 1).join(' ') + '  (...continued...)';
        intermediate_line += '\n' + new Array(lineno_display_width + 1).join('-') + '  (---------------)';
        rv.splice(clip_start, clip_end - clip_start + 1, intermediate_line);
      }

      return rv.join('\n');
    },

    /**
     * helper function, used to produce a human readable description as a string, given
     * the input `yylloc` location object.
     * 
     * Set `display_range_too` to TRUE to include the string character index position(s)
     * in the description if the `yylloc.range` is available.
     * 
     * @public
     * @this {RegExpLexer}
     */
    describeYYLLOC: function lexer_describe_yylloc(yylloc, display_range_too) {
      var l1 = yylloc.first_line;
      var l2 = yylloc.last_line;
      var c1 = yylloc.first_column;
      var c2 = yylloc.last_column;
      var dl = l2 - l1;
      var dc = c2 - c1;
      var rv;

      if (dl === 0) {
        rv = 'line ' + l1 + ', ';

        if (dc <= 1) {
          rv += 'column ' + c1;
        } else {
          rv += 'columns ' + c1 + ' .. ' + c2;
        }
      } else {
        rv = 'lines ' + l1 + '(column ' + c1 + ') .. ' + l2 + '(column ' + c2 + ')';
      }

      if (yylloc.range && display_range_too) {
        var r1 = yylloc.range[0];
        var r2 = yylloc.range[1] - 1;

        if (r2 <= r1) {
          rv += ' {String Offset: ' + r1 + '}';
        } else {
          rv += ' {String Offset range: ' + r1 + ' .. ' + r2 + '}';
        }
      }

      return rv;
    },

    /**
     * test the lexed token: return FALSE when not a match, otherwise return token.
     * 
     * `match` is supposed to be an array coming out of a regex match, i.e. `match[0]`
     * contains the actually matched text string.
     * 
     * Also move the input cursor forward and update the match collectors:
     * 
     * - `yytext`
     * - `yyleng`
     * - `match`
     * - `matches`
     * - `yylloc`
     * - `offset`
     * 
     * @public
     * @this {RegExpLexer}
     */
    test_match: function lexer_test_match(match, indexed_rule) {
      var token, lines, backup, match_str, match_str_len;

      if (this.options.backtrack_lexer) {
        // save context
        backup = {
          yylineno: this.yylineno,

          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.yylloc.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column,
            range: this.yylloc.range.slice(0)
          },

          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,

          //_signaled_error_token: this._signaled_error_token,
          yy: this.yy,

          conditionStack: this.conditionStack.slice(0),
          done: this.done
        };
      }

      match_str = match[0];
      match_str_len = match_str.length;

      // if (match_str.indexOf('\n') !== -1 || match_str.indexOf('\r') !== -1) {
      lines = match_str.split(/(?:\r\n?|\n)/g);

      if (lines.length > 1) {
        this.yylineno += lines.length - 1;
        this.yylloc.last_line = this.yylineno + 1;
        this.yylloc.last_column = lines[lines.length - 1].length;
      } else {
        this.yylloc.last_column += match_str_len;
      }

      // }
      this.yytext += match_str;

      this.match += match_str;
      this.matched += match_str;
      this.matches = match;
      this.yyleng = this.yytext.length;
      this.yylloc.range[1] += match_str_len;

      // previous lex rules MAY have invoked the `more()` API rather than producing a token:
      // those rules will already have moved this `offset` forward matching their match lengths,
      // hence we must only add our own match length now:
      this.offset += match_str_len;

      this._more = false;
      this._backtrack = false;
      this._input = this._input.slice(match_str_len);

      // calling this method:
      //
      //   function lexer__performAction(yy, yyrulenumber, YY_START) {...}
      token = this.performAction.call(
        this,
        this.yy,
        indexed_rule,
        this.conditionStack[this.conditionStack.length - 1] /* = YY_START */
      );

      // otherwise, when the action codes are all simple return token statements:
      //token = this.simpleCaseActionClusters[indexed_rule];

      if (this.done && this._input) {
        this.done = false;
      }

      if (token) {
        return token;
      } else if (this._backtrack) {
        // recover context
        for (var k in backup) {
          this[k] = backup[k];
        }

        this.__currentRuleSet__ = null;
        return false;  // rule action called reject() implying the next rule should be tested instead. 
      } else if (this._signaled_error_token) {
        // produce one 'error' token as `.parseError()` in `reject()`
        // did not guarantee a failure signal by throwing an exception!
        token = this._signaled_error_token;

        this._signaled_error_token = false;
        return token;
      }

      return false;
    },

    /**
     * return next match in input
     * 
     * @public
     * @this {RegExpLexer}
     */
    next: function lexer_next() {
      if (this.done) {
        this.clear();
        return this.EOF;
      }

      if (!this._input) {
        this.done = true;
      }

      var token, match, tempMatch, index;

      if (!this._more) {
        this.clear();
      }

      var spec = this.__currentRuleSet__;

      if (!spec) {
        // Update the ruleset cache as we apparently encountered a state change or just started lexing.
        // The cache is set up for fast lookup -- we assume a lexer will switch states much less often than it will
        // invoke the `lex()` token-producing API and related APIs, hence caching the set for direct access helps
        // speed up those activities a tiny bit.
        spec = this.__currentRuleSet__ = this._currentRules();

        // Check whether a *sane* condition has been pushed before: this makes the lexer robust against
        // user-programmer bugs such as https://github.com/zaach/jison-lex/issues/19
        if (!spec || !spec.rules) {
          var lineno_msg = '';

          if (this.options.trackPosition) {
            lineno_msg = ' on line ' + (this.yylineno + 1);
          }

          var p = this.constructLexErrorInfo(
            'Internal lexer engine error' + lineno_msg + ': The lex grammar programmer pushed a non-existing condition name "' + this.topState() + '"; this is a fatal error and should be reported to the application programmer team!',
            false
          );

          // produce one 'error' token until this situation has been resolved, most probably by parse termination!
          return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
        }
      }

      var rule_ids = spec.rules;
      var regexes = spec.__rule_regexes;
      var len = spec.__rule_count;

      // Note: the arrays are 1-based, while `len` itself is a valid index,
      // hence the non-standard less-or-equal check in the next loop condition!
      for (var i = 1; i <= len; i++) {
        tempMatch = this._input.match(regexes[i]);

        if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
          match = tempMatch;
          index = i;

          if (this.options.backtrack_lexer) {
            token = this.test_match(tempMatch, rule_ids[i]);

            if (token !== false) {
              return token;
            } else if (this._backtrack) {
              match = undefined;
              continue;  // rule action called reject() implying a rule MISmatch. 
            } else {
              // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
              return false;
            }
          } else if (!this.options.flex) {
            break;
          }
        }
      }

      if (match) {
        token = this.test_match(match, rule_ids[index]);

        if (token !== false) {
          return token;
        }

        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
        return false;
      }

      if (!this._input) {
        this.done = true;
        this.clear();
        return this.EOF;
      } else {
        var lineno_msg = '';

        if (this.options.trackPosition) {
          lineno_msg = ' on line ' + (this.yylineno + 1);
        }

        var p = this.constructLexErrorInfo(
          'Lexical error' + lineno_msg + ': Unrecognized text.',
          this.options.lexerErrorsAreRecoverable
        );

        var pendingInput = this._input;
        var activeCondition = this.topState();
        var conditionStackDepth = this.conditionStack.length;
        token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;

        if (token === this.ERROR) {
          // we can try to recover from a lexer error that `parseError()` did not 'recover' for us
          // by moving forward at least one character at a time IFF the (user-specified?) `parseError()`
          // has not consumed/modified any pending input or changed state in the error handler:
          if (!this.matches && // and make sure the input has been modified/consumed ...
          pendingInput === this._input && // ...or the lexer state has been modified significantly enough
          // to merit a non-consuming error handling action right now.
          activeCondition === this.topState() && conditionStackDepth === this.conditionStack.length) {
            this.input();
          }
        }

        return token;
      }
    },

    /**
     * return next match that has a token
     * 
     * @public
     * @this {RegExpLexer}
     */
    lex: function lexer_lex() {
      var r;

      // allow the PRE/POST handlers set/modify the return token for maximum flexibility of the generated lexer:
      if (typeof this.pre_lex === 'function') {
        r = this.pre_lex.call(this, 0);
      }

      if (typeof this.options.pre_lex === 'function') {
        // (also account for a userdef function which does not return any value: keep the token as is)
        r = this.options.pre_lex.call(this, r) || r;
      }

      if (this.yy && typeof this.yy.pre_lex === 'function') {
        // (also account for a userdef function which does not return any value: keep the token as is)
        r = this.yy.pre_lex.call(this, r) || r;
      }

      while (!r) {
        r = this.next();
      }

      if (this.yy && typeof this.yy.post_lex === 'function') {
        // (also account for a userdef function which does not return any value: keep the token as is)
        r = this.yy.post_lex.call(this, r) || r;
      }

      if (typeof this.options.post_lex === 'function') {
        // (also account for a userdef function which does not return any value: keep the token as is)
        r = this.options.post_lex.call(this, r) || r;
      }

      if (typeof this.post_lex === 'function') {
        // (also account for a userdef function which does not return any value: keep the token as is)
        r = this.post_lex.call(this, r) || r;
      }

      return r;
    },

    /**
     * return next match that has a token. Identical to the `lex()` API but does not invoke any of the 
     * `pre_lex()` nor any of the `post_lex()` callbacks.
     * 
     * @public
     * @this {RegExpLexer}
     */
    fastLex: function lexer_fastLex() {
      var r;

      while (!r) {
        r = this.next();
      }

      return r;
    },

    /**
     * return info about the lexer state that can help a parser or other lexer API user to use the
     * most efficient means available. This API is provided to aid run-time performance for larger
     * systems which employ this lexer.
     * 
     * @public
     * @this {RegExpLexer}
     */
    canIUse: function lexer_canIUse() {
      var rv = {
        fastLex: !(typeof this.pre_lex === 'function' || typeof this.options.pre_lex === 'function' || this.yy && typeof this.yy.pre_lex === 'function' || this.yy && typeof this.yy.post_lex === 'function' || typeof this.options.post_lex === 'function' || typeof this.post_lex === 'function') && typeof this.fastLex === 'function'
      };

      return rv;
    },

    /**
     * backwards compatible alias for `pushState()`;
     * the latter is symmetrical with `popState()` and we advise to use
     * those APIs in any modern lexer code, rather than `begin()`.
     * 
     * @public
     * @this {RegExpLexer}
     */
    begin: function lexer_begin(condition) {
      return this.pushState(condition);
    },

    /**
     * activates a new lexer condition state (pushes the new lexer
     * condition state onto the condition stack)
     * 
     * @public
     * @this {RegExpLexer}
     */
    pushState: function lexer_pushState(condition) {
      this.conditionStack.push(condition);
      this.__currentRuleSet__ = null;
      return this;
    },

    /**
     * pop the previously active lexer condition state off the condition
     * stack
     * 
     * @public
     * @this {RegExpLexer}
     */
    popState: function lexer_popState() {
      var n = this.conditionStack.length - 1;

      if (n > 0) {
        this.__currentRuleSet__ = null;
        return this.conditionStack.pop();
      } else {
        return this.conditionStack[0];
      }
    },

    /**
     * return the currently active lexer condition state; when an index
     * argument is provided it produces the N-th previous condition state,
     * if available
     * 
     * @public
     * @this {RegExpLexer}
     */
    topState: function lexer_topState(n) {
      n = this.conditionStack.length - 1 - Math.abs(n || 0);

      if (n >= 0) {
        return this.conditionStack[n];
      } else {
        return 'INITIAL';
      }
    },

    /**
     * (internal) determine the lexer rule set which is active for the
     * currently active lexer condition state
     * 
     * @public
     * @this {RegExpLexer}
     */
    _currentRules: function lexer__currentRules() {
      if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
        return this.conditions[this.conditionStack[this.conditionStack.length - 1]];
      } else {
        return this.conditions['INITIAL'];
      }
    },

    /**
     * return the number of states currently on the stack
     * 
     * @public
     * @this {RegExpLexer}
     */
    stateStackSize: function lexer_stateStackSize() {
      return this.conditionStack.length;
    },

    options: {
      trackPosition: true,
      caseInsensitive: true,
      easy_keyword_rules: true
    },

    JisonLexerError: JisonLexerError,

    performAction: function lexer__performAction(yy, yyrulenumber, YY_START) {
      var yy_ = this;
      var YYSTATE = YY_START;

      switch (yyrulenumber) {
      case 0:
        /*! Conditions:: INITIAL */
        /*! Rule::       [0-9]+\.[0-9]*(?:[eE][-+]*[0-9]+)?\b */
        yy_.yytext = parseFloat(yy_.yytext);

        return 73;
        break;

      case 1:
        /*! Conditions:: INITIAL */
        /*! Rule::       [0-9]*\.[0-9]+(?:[eE][-+]*[0-9]+)?\b */
        yy_.yytext = parseFloat(yy_.yytext);

        return 73;
        break;

      case 2:
        /*! Conditions:: INITIAL */
        /*! Rule::       [0-9]+(?:[eE][-+]*[0-9]+)?\b */
        yy_.yytext = parseFloat(yy_.yytext);

        return 73;
        break;

      case 10:
        /*! Conditions:: INITIAL */
        /*! Rule::       [a-zA-Z_$]+[a-zA-Z_0-9.$]*\b */
        var rv = lookup_constant(yy_.yytext);

        if (rv) {
          yy_.yytext = rv;
          return 8;
        }

        rv = lookup_function(yy_.yytext);

        if (rv) {
          yy_.yytext = rv;
          return 70;
        }

        rv = lookup_or_register_variable(yy_.yytext);
        yy_.yytext = rv;
        return 86;
        break;

      case 11:
        /*! Conditions:: INITIAL */
        /*! Rule::       \/\/.* */
        yy_.yytext = yy_.yytext.substr(2).trim();

        return 97;  // skip C++-style comments  
        break;

      case 12:
        /*! Conditions:: INITIAL */
        /*! Rule::       \/\*[\s\S]*?\*\/ */
        yy_.yytext = yy_.yytext.substring(2, yy_.yyleng - 2).trim();

        return 97;  // skip C-style multi-line comments  
        break;

      case 21:
        /*! Conditions:: INITIAL */
        /*! Rule::       \*\* */
        return 40;

        /* Exponentiation        */
        break;

      case 35:
        /*! Conditions:: INITIAL */
        /*! Rule::       \? */
        return 93;                          // IF  

        break;

      case 36:
        /*! Conditions:: INITIAL */
        /*! Rule::       : */
        return 95;                          // ELSE  

        break;

      case 40:
        /*! Conditions:: INITIAL */
        /*! Rule::       \\[\r\n] */
        // accept C-style line continuation: ignore this bit. 
        break;

      case 42:
        /*! Conditions:: INITIAL */
        /*! Rule::       [^\S\r\n]+ */
        // ignore whitespace 
        break;

      default:
        return this.simpleCaseActionClusters[yyrulenumber];
      }
    },

    simpleCaseActionClusters: {
      /*! Conditions:: INITIAL */
      /*! Rule::       and\b */
      3: 65,

      /*! Conditions:: INITIAL */
      /*! Rule::       or\b */
      4: 79,

      /*! Conditions:: INITIAL */
      /*! Rule::       xor\b */
      5: 88,

      /*! Conditions:: INITIAL */
      /*! Rule::       not\b */
      6: 33,

      /*! Conditions:: INITIAL */
      /*! Rule::       if\b */
      7: 21,

      /*! Conditions:: INITIAL */
      /*! Rule::       then\b */
      8: 98,

      /*! Conditions:: INITIAL */
      /*! Rule::       else\b */
      9: 9,

      /*! Conditions:: INITIAL */
      /*! Rule::       === */
      13: 61,

      /*! Conditions:: INITIAL */
      /*! Rule::       == */
      14: 61,

      /*! Conditions:: INITIAL */
      /*! Rule::       != */
      15: 110,

      /*! Conditions:: INITIAL */
      /*! Rule::       <= */
      16: 23,

      /*! Conditions:: INITIAL */
      /*! Rule::       >= */
      17: 20,

      /*! Conditions:: INITIAL */
      /*! Rule::       \|\| */
      18: 79,

      /*! Conditions:: INITIAL */
      /*! Rule::       \^\^ */
      19: 88,

      /*! Conditions:: INITIAL */
      /*! Rule::       && */
      20: 65,

      /*! Conditions:: INITIAL */
      /*! Rule::       < */
      22: 60,

      /*! Conditions:: INITIAL */
      /*! Rule::       > */
      23: 62,

      /*! Conditions:: INITIAL */
      /*! Rule::       = */
      24: 71,

      /*! Conditions:: INITIAL */
      /*! Rule::       - */
      25: 85,

      /*! Conditions:: INITIAL */
      /*! Rule::       \+ */
      26: 84,

      /*! Conditions:: INITIAL */
      /*! Rule::       \* */
      27: 87,

      /*! Conditions:: INITIAL */
      /*! Rule::       \/ */
      28: 89,

      /*! Conditions:: INITIAL */
      /*! Rule::       \( */
      29: 72,

      /*! Conditions:: INITIAL */
      /*! Rule::       \) */
      30: 75,

      /*! Conditions:: INITIAL */
      /*! Rule::       , */
      31: 96,

      /*! Conditions:: INITIAL */
      /*! Rule::       ! */
      32: 91,

      /*! Conditions:: INITIAL */
      /*! Rule::       % */
      33: 90,

      /*! Conditions:: INITIAL */
      /*! Rule::       ~ */
      34: 92,

      /*! Conditions:: INITIAL */
      /*! Rule::       \| */
      37: 76,

      /*! Conditions:: INITIAL */
      /*! Rule::       \^ */
      38: 81,

      /*! Conditions:: INITIAL */
      /*! Rule::       & */
      39: 82,

      /*! Conditions:: INITIAL */
      /*! Rule::       [\r\n] */
      41: 11,

      /*! Conditions:: INITIAL */
      /*! Rule::       $ */
      43: 1,

      /*! Conditions:: INITIAL */
      /*! Rule::       . */
      44: 'INVALID'
    },

    rules: [
      /*  0: */  /^(?:\d+\.\d*(?:[Ee][-+]*\d+)?\b)/i,
      /*  1: */  /^(?:\d*\.\d+(?:[Ee][-+]*\d+)?\b)/i,
      /*  2: */  /^(?:\d+(?:[Ee][-+]*\d+)?\b)/i,
      /*  3: */  /^(?:and\b)/i,
      /*  4: */  /^(?:or\b)/i,
      /*  5: */  /^(?:xor\b)/i,
      /*  6: */  /^(?:not\b)/i,
      /*  7: */  /^(?:if\b)/i,
      /*  8: */  /^(?:then\b)/i,
      /*  9: */  /^(?:else\b)/i,
      /* 10: */  /^(?:[$A-Z_a-z]+[\w$.]*\b)/i,
      /* 11: */  /^(?:\/\/.*)/i,
      /* 12: */  /^(?:\/\*[\s\S]*?\*\/)/i,
      /* 13: */  /^(?:===)/i,
      /* 14: */  /^(?:==)/i,
      /* 15: */  /^(?:!=)/i,
      /* 16: */  /^(?:<=)/i,
      /* 17: */  /^(?:>=)/i,
      /* 18: */  /^(?:\|\|)/i,
      /* 19: */  /^(?:\^\^)/i,
      /* 20: */  /^(?:&&)/i,
      /* 21: */  /^(?:\*\*)/i,
      /* 22: */  /^(?:<)/i,
      /* 23: */  /^(?:>)/i,
      /* 24: */  /^(?:=)/i,
      /* 25: */  /^(?:-)/i,
      /* 26: */  /^(?:\+)/i,
      /* 27: */  /^(?:\*)/i,
      /* 28: */  /^(?:\/)/i,
      /* 29: */  /^(?:\()/i,
      /* 30: */  /^(?:\))/i,
      /* 31: */  /^(?:,)/i,
      /* 32: */  /^(?:!)/i,
      /* 33: */  /^(?:%)/i,
      /* 34: */  /^(?:~)/i,
      /* 35: */  /^(?:\?)/i,
      /* 36: */  /^(?::)/i,
      /* 37: */  /^(?:\|)/i,
      /* 38: */  /^(?:\^)/i,
      /* 39: */  /^(?:&)/i,
      /* 40: */  /^(?:\\[\r\n])/i,
      /* 41: */  /^(?:[\r\n])/i,
      /* 42: */  /^(?:[^\S\r\n]+)/i,
      /* 43: */  /^(?:$)/i,
      /* 44: */  /^(?:.)/i
    ],

    conditions: {
      'INITIAL': {
        rules: [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24,
          25,
          26,
          27,
          28,
          29,
          30,
          31,
          32,
          33,
          34,
          35,
          36,
          37,
          38,
          39,
          40,
          41,
          42,
          43,
          44
        ],

        inclusive: true
      }
    }
  };

  return lexer;
}();
parser.lexer = lexer;

// helper functions which will help us reduce garbage production cf. https://www.scirra.com/blog/76/how-to-write-low-garbage-real-time-javascript

// flatten arrays into one:
var flatten = [].concat;

// append array of items:
var append = [].push;

function Parser() {
  this.yy = {};
}
Parser.prototype = parser;
parser.Parser = Parser;

return new Parser();
})();

        


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
  exports.parser = compiled_calc_parse;
  exports.Parser = compiled_calc_parse.Parser;
  exports.parse = function () {
    return compiled_calc_parse.parse.apply(compiled_calc_parse, arguments);
  };
  
}


// End Of Include by Jison: ./output/compiled_calc/compiled_calc_parse.js



// Included by Jison: ./output/compiled_calc/compiled_calc_codegen.js:


/* parser generated by jison 0.6.1-214 */

/*
 * Returns a Parser object of the following structure:
 *
 *  Parser: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a derivative/copy of this one,
 *               not a direct reference!
 *  }
 *
 *  Parser.prototype: {
 *    yy: {},
 *    EOF: 1,
 *    TERROR: 2,
 *
 *    trace: function(errorMessage, ...),
 *
 *    JisonParserError: function(msg, hash),
 *
 *    quoteName: function(name),
 *               Helper function which can be overridden by user code later on: put suitable
 *               quotes around literal IDs in a description string.
 *
 *    originalQuoteName: function(name),
 *               The basic quoteName handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function
 *               at the end of the `parse()`.
 *
 *    describeSymbol: function(symbol),
 *               Return a more-or-less human-readable description of the given symbol, when
 *               available, or the symbol itself, serving as its own 'description' for lack
 *               of something better to serve up.
 *
 *               Return NULL when the symbol is unknown to the parser.
 *
 *    symbols_: {associative list: name ==> number},
 *    terminals_: {associative list: number ==> name},
 *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},
 *    terminal_descriptions_: (if there are any) {associative list: number ==> description},
 *    productions_: [...],
 *
 *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)
 *                             to store/reference the rule value `$$` and location info `@$`.
 *
 *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets
 *                 to see the same object via the `this` reference, i.e. if you wish to carry custom
 *                 data from one reduce action through to the next within a single parse run, then you
 *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.
 *
 *                 `this.yy` is a direct reference to the `yy` shared state object.
 *
 *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`
 *                 object at `parse()` start and are therefore available to the action code via the
 *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from
 *                 the %parse-param` list.
 *
 *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used
 *                             to match this rule. This is *not* the look-ahead token, but the last token
 *                             that's actually part of this rule.
 *
 *                 Formulated another way, `yytext` is the value of the token immediately preceeding
 *                 the current look-ahead token.
 *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.
 *
 *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.
 *
 *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.
 *
 *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.
 *
 *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead
 *                               of an empty object when no suitable location info can be provided.
 *
 *               - `yystate` : the current parser state number, used internally for dispatching and
 *                               executing the action code chunk matching the rule currently being reduced.
 *
 *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *                 Also note that you can access this and other stack index values using the new double-hash
 *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things
 *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.
 *                 This is made available to write very advanced grammar action rules, e.g. when you want
 *                 to investigate the parse state stack in your action code, which would, for example,
 *                 be relevant when you wish to implement error diagnostics and reporting schemes similar
 *                 to the work described here:
 *
 *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.
 *                   In Journées Francophones des Languages Applicatifs.
 *
 *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.
 *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631–640.
 *
 *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.
 *                             constructs.
 *
 *               - `yylstack`: reference to the parser token location stack. Also accessed via
 *                             the `@1` etc. constructs.
 *
 *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are
 *                             UNDEFINED rather than an empty (location) object, when the lexer/parser
 *                             action code did not provide a suitable location info object when such a
 *                             slot was filled!
 *
 *               - `yystack` : reference to the parser token id stack. Also accessed via the
 *                             `#1` etc. constructs.
 *
 *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to
 *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might
 *                 want access this array for your own purposes, such as error analysis as mentioned above!
 *
 *                 Note that this stack stores the current stack of *tokens*, that is the sequence of
 *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*
 *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and
 *                 *reduced*.
 *
 *               - `yysstack`: reference to the parser state stack. This one carries the internal parser
 *                             *states* such as the one in `yystate`, which are used to represent
 *                             the parser state machine in the *parse table*. *Very* *internal* stuff,
 *                             what can I say? If you access this one, you're clearly doing wicked things
 *
 *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your
 *                             grammar definition file.
 *
 *    table: [...],
 *               State transition table
 *               ----------------------
 *
 *               index levels are:
 *               - `state`  --> hash table
 *               - `symbol` --> action (number or array)
 *
 *                 If the `action` is an array, these are the elements' meaning:
 *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept
 *                 - index [1]: GOTO `state`
 *
 *                 If the `action` is a number, it is the GOTO `state`
 *
 *    defaultActions: {...},
 *
 *    parseError: function(str, hash, ExceptionClass),
 *    yyError: function(str, ...),
 *    yyRecovering: function(),
 *    yyErrOk: function(),
 *    yyClearIn: function(),
 *
 *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this parser kernel in many places; example usage:
 *
 *                   var infoObj = parser.constructParseErrorInfo('fail!', null,
 *                                     parser.collect_expected_token_set(state), true);
 *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);
 *
 *    originalParseError: function(str, hash, ExceptionClass),
 *               The basic `parseError` handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function
 *               at the end of the `parse()`.
 *
 *    options: { ... parser %options ... },
 *
 *    parse: function(input[, args...]),
 *               Parse the given `input` and return the parsed value (or `true` when none was provided by
 *               the root action, in which case the parser is acting as a *matcher*).
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the jison run-time;
 *               when such a collision is detected an exception is thrown to prevent the generated run-time
 *               from silently accepting this confusing and potentially hazardous situation!
 *
 *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in
 *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state
 *               object and any collision with those will be reported by the lexer via a thrown exception.
 *
 *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown
 *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY
 *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and
 *               the internal parser gets properly garbage collected under these particular circumstances.
 *
 *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API can be invoked to calculate a spanning `yylloc` location info object.
 *
 *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case
 *               this function will attempt to obtain a suitable location marker by inspecting the location stack
 *               backwards.
 *
 *               For more info see the documentation comment further below, immediately above this function's
 *               implementation.
 *
 *    lexer: {
 *        yy: {...},           A reference to the so-called "shared state" `yy` once
 *                             received via a call to the `.setInput(input, yy)` lexer API.
 *        EOF: 1,
 *        ERROR: 2,
 *        JisonLexerError: function(msg, hash),
 *        parseError: function(str, hash, ExceptionClass),
 *        setInput: function(input, [yy]),
 *        input: function(),
 *        unput: function(str),
 *        more: function(),
 *        reject: function(),
 *        less: function(n),
 *        pastInput: function(n),
 *        upcomingInput: function(n),
 *        showPosition: function(),
 *        test_match: function(regex_match_array, rule_index, ...),
 *        next: function(...),
 *        lex: function(...),
 *        begin: function(condition),
 *        pushState: function(condition),
 *        popState: function(),
 *        topState: function(),
 *        _currentRules: function(),
 *        stateStackSize: function(),
 *        cleanupAfterLex: function()
 *
 *        options: { ... lexer %options ... },
 *
 *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),
 *        rules: [...],
 *        conditions: {associative list: name ==> set},
 *    }
 *  }
 *
 *
 *  token location info (@$, _$, etc.): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer and
 * parser errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *  }
 *
 * parser (grammar) errors will also provide these additional members:
 *
 *  {
 *    expected:    (array describing the set of expected tokens;
 *                  may be UNDEFINED when we cannot easily produce such a set)
 *    state:       (integer (or array when the table includes grammar collisions);
 *                  represents the current internal state of the parser kernel.
 *                  can, for example, be used to pass to the `collect_expected_token_set()`
 *                  API to obtain the expected token set)
 *    action:      (integer; represents the current internal action which will be executed)
 *    new_state:   (integer; represents the next/planned internal state, once the current
 *                  action has executed)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *    parser:      (reference to the current parser instance)
 *  }
 *
 * while `this` will reference the current parser instance.
 *
 * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    lexer:       (reference to the current lexer instance which reported the error)
 *  }
 *
 * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired
 * from either the parser or lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    exception:   (reference to the exception thrown)
 *  }
 *
 * Please do note that in the latter situation, the `expected` field will be omitted as
 * this type of failure is assumed not to be due to *parse errors* but rather due to user
 * action code in either parser or lexer failing unexpectedly.
 *
 * ---
 *
 * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.
 * These options are available:
 *
 * ### options which are global for all parser instances
 *
 *  Parser.pre_parse: function(yy)
 *                 optional: you can specify a pre_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`.
 *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: you can specify a post_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`. When it does not return any value,
 *                 the parser will return the original `retval`.
 *
 * ### options which can be set up per parser instance
 *
 *  yy: {
 *      pre_parse:  function(yy)
 *                 optional: is invoked before the parse cycle starts (and before the first
 *                 invocation of `lex()`) but immediately after the invocation of
 *                 `parser.pre_parse()`).
 *      post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: is invoked when the parse terminates due to success ('accept')
 *                 or failure (even when exceptions are thrown).
 *                 `retval` contains the return value to be produced by `Parser.parse()`;
 *                 this function can override the return value by returning another.
 *                 When it does not return any value, the parser will return the original
 *                 `retval`.
 *                 This function is invoked immediately before `parser.post_parse()`.
 *
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *      quoteName: function(name),
 *                 optional: overrides the default `quoteName` function.
 *  }
 *
 *  parser.lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */

        
    
            var compiled_calc_codegen = (function () {

// See also:
// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
// with userland code which might access the derived class in a 'classic' way.
function JisonParserError(msg, hash) {
    Object.defineProperty(this, 'name', {
        enumerable: false,
        writable: false,
        value: 'JisonParserError'
    });

    if (msg == null) msg = '???';

    Object.defineProperty(this, 'message', {
        enumerable: false,
        writable: true,
        value: msg
    });

    this.hash = hash;

    var stacktrace;
    if (hash && hash.exception instanceof Error) {
        var ex2 = hash.exception;
        this.message = ex2.message || msg;
        stacktrace = ex2.stack;
    }
    if (!stacktrace) {
        if (Error.hasOwnProperty('captureStackTrace')) {        // V8/Chrome engine
            Error.captureStackTrace(this, this.constructor);
        } else {
            stacktrace = (new Error(msg)).stack;
        }
    }
    if (stacktrace) {
        Object.defineProperty(this, 'stack', {
            enumerable: false,
            writable: false,
            value: stacktrace
        });
    }
}

if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);
} else {
    JisonParserError.prototype = Object.create(Error.prototype);
}
JisonParserError.prototype.constructor = JisonParserError;
JisonParserError.prototype.name = 'JisonParserError';



        // helper: reconstruct the productions[] table
        function bp(s) {
            var rv = [];
            var p = s.pop;
            var r = s.rule;
            for (var i = 0, l = p.length; i < l; i++) {
                rv.push([
                    p[i],
                    r[i]
                ]);
            }
            return rv;
        }
    


        // helper: reconstruct the defaultActions[] table
        function bda(s) {
            var rv = {};
            var d = s.idx;
            var g = s.goto;
            for (var i = 0, l = d.length; i < l; i++) {
                var j = d[i];
                rv[j] = g[i];
            }
            return rv;
        }
    


        // helper: reconstruct the 'goto' table
        function bt(s) {
            var rv = [];
            var d = s.len;
            var y = s.symbol;
            var t = s.type;
            var a = s.state;
            var m = s.mode;
            var g = s.goto;
            for (var i = 0, l = d.length; i < l; i++) {
                var n = d[i];
                var q = {};
                for (var j = 0; j < n; j++) {
                    var z = y.shift();
                    switch (t.shift()) {
                    case 2:
                        q[z] = [
                            m.shift(),
                            g.shift()
                        ];
                        break;

                    case 0:
                        q[z] = a.shift();
                        break;

                    default:
                        // type === 1: accept
                        q[z] = [
                            3
                        ];
                    }
                }
                rv.push(q);
            }
            return rv;
        }
    


        // helper: runlength encoding with increment step: code, length: step (default step = 0)
        // `this` references an array
        function s(c, l, a) {
            a = a || 0;
            for (var i = 0; i < l; i++) {
                this.push(c);
                c += a;
            }
        }

        // helper: duplicate sequence from *relative* offset and length.
        // `this` references an array
        function c(i, l) {
            i = this.length - i;
            for (l += i; i < l; i++) {
                this.push(this[i]);
            }
        }

        // helper: unpack an array using helpers and data, all passed in an array argument 'a'.
        function u(a) {
            var rv = [];
            for (var i = 0, l = a.length; i < l; i++) {
                var e = a[i];
                // Is this entry a helper function?
                if (typeof e === 'function') {
                    i++;
                    e.apply(rv, a[i]);
                } else {
                    rv.push(e);
                }
            }
            return rv;
        }
    

var parser = {
    // Code Generator Information Report
    // ---------------------------------
    //
    // Options:
    //
    //   default action mode: ............. none,merge
    //   try..catch: ...................... false
    //   default resolve on conflict: ..... true
    //   on-demand look-ahead: ............ false
    //   error recovery token skip maximum: 3
    //   yyerror in parse actions is: ..... NOT recoverable,
    //   yyerror in lexer actions and other non-fatal lexer are:
    //   .................................. NOT recoverable,
    //   debug grammar/output: ............ false
    //   has partial LR conflict upgrade:   true
    //   rudimentary token-stack support:   false
    //   parser table compression mode: ... 2
    //   export debug tables: ............. false
    //   export *all* tables: ............. false
    //   module type: ..................... commonjs
    //   parser engine type: .............. lalr
    //   output main() in the module: ..... true
    //   has user-specified main(): ....... false
    //   has user-specified require()/import modules for main():
    //   .................................. false
    //   number of expected conflicts: .... 0
    //
    //
    // Parser Analysis flags:
    //
    //   no significant actions (parser is a language matcher only):
    //   .................................. false
    //   uses yyleng: ..................... false
    //   uses yylineno: ................... false
    //   uses yytext: ..................... false
    //   uses yylloc: ..................... false
    //   uses ParseError API: ............. false
    //   uses YYERROR: .................... false
    //   uses YYRECOVERING: ............... false
    //   uses YYERROK: .................... false
    //   uses YYCLEARIN: .................. false
    //   tracks rule values: .............. true
    //   assigns rule values: ............. true
    //   uses location tracking: .......... false
    //   assigns location: ................ false
    //   uses yystack: .................... false
    //   uses yysstack: ................... false
    //   uses yysp: ....................... true
    //   uses yyrulelength: ............... false
    //   uses yyMergeLocationInfo API: .... false
    //   has error recovery: .............. false
    //   has error reporting: ............. false
    //
    // --------- END OF REPORT -----------

trace: function no_op_trace() {},
JisonParserError: JisonParserError,
yy: {},
options: {
  type: "lalr",
  hasPartialLrUpgradeOnConflict: true,
  errorRecoveryTokenDiscardCount: 3
},
symbols_: {
  "!": 91,
  "$accept": 0,
  "$end": 1,
  "%": 90,
  "&": 82,
  "(": 72,
  ")": 75,
  "*": 87,
  "+": 84,
  ",": 96,
  "-": 85,
  "/": 89,
  ":": 95,
  "=": 71,
  "?": 93,
  "ADD": 43,
  "ADD_3": 80,
  "ADD_4": 4,
  "AND": 65,
  "AND_3": 5,
  "AND_4": 6,
  "ASSIGN": 7,
  "BITWISE_AND": 38,
  "BITWISE_NOT": 126,
  "BITWISE_OR": 124,
  "BITWISE_XOR": 94,
  "COMMENT": 97,
  "CONDITION": 63,
  "CONSTANT": 8,
  "DIVIDE": 47,
  "ELSE": 9,
  "END": 10,
  "EOF": 1,
  "EOL": 11,
  "EQ": 61,
  "ERROR": 3,
  "ERROR_AND_SKIP": 12,
  "EXCHANGE_A_R1": 13,
  "EXCHANGE_A_R2": 14,
  "EXCHANGE_R1_R2": 15,
  "EXEC": 16,
  "FACTORIAL": 17,
  "FALSE": 18,
  "FALSE_AND_SKIP": 19,
  "FUNCTION": 70,
  "FUNCTION_0": 48,
  "FUNCTION_1": 49,
  "FUNCTION_2": 50,
  "FUNCTION_3": 51,
  "FUNCTION_N": 57,
  "GEQ": 20,
  "GT": 62,
  "IF": 21,
  "IF_ELSE": 22,
  "LEQ": 23,
  "LT": 60,
  "MODULO": 37,
  "MOVE_ALL_TO_RX": 24,
  "MOVE_FROM_R1": 25,
  "MOVE_FROM_R2": 26,
  "MOVE_R2_TO_R1": 27,
  "MOVE_TO_R1": 28,
  "MOVE_TO_R2": 29,
  "MOVE_TO_RX": 30,
  "MULTIPLY": 42,
  "MULTIPLY_3": 77,
  "MULTIPLY_4": 31,
  "NEQ": 110,
  "NOP": 32,
  "NOT": 33,
  "NUM": 73,
  "NUM_AND_SKIP": 74,
  "OR": 79,
  "OR_3": 34,
  "OR_4": 35,
  "PERCENT": 36,
  "POP": 39,
  "POWER": 40,
  "PUSH": 44,
  "PUSH_NUMS": 78,
  "SHIFT_EX": 41,
  "SKIP": 83,
  "STRING": 46,
  "STRING_AND_SKIP": 52,
  "SUBTRACT": 45,
  "SUBTRACT_3": 53,
  "SUBTRACT_4": 54,
  "THEN": 98,
  "TRUE": 55,
  "TRUE_AND_SKIP": 56,
  "UMINUS": 58,
  "UNSHIFT_EX": 59,
  "UNSHIFT_RX_TO_ALL": 64,
  "UNSHIFT_RX_TO_R12": 66,
  "UPLUS": 67,
  "VAR": 86,
  "VAR_TO_VALUE": 68,
  "VAR_VALUE": 69,
  "XOR": 88,
  "^": 81,
  "arglist": 102,
  "error": 2,
  "exp": 101,
  "input": 99,
  "line": 100,
  "s": 103,
  "|": 76,
  "~": 92
},
terminals_: {
  1: "EOF",
  2: "error",
  3: "ERROR",
  4: "ADD_4",
  5: "AND_3",
  6: "AND_4",
  7: "ASSIGN",
  8: "CONSTANT",
  9: "ELSE",
  10: "END",
  11: "EOL",
  12: "ERROR_AND_SKIP",
  13: "EXCHANGE_A_R1",
  14: "EXCHANGE_A_R2",
  15: "EXCHANGE_R1_R2",
  16: "EXEC",
  17: "FACTORIAL",
  18: "FALSE",
  19: "FALSE_AND_SKIP",
  20: "GEQ",
  21: "IF",
  22: "IF_ELSE",
  23: "LEQ",
  24: "MOVE_ALL_TO_RX",
  25: "MOVE_FROM_R1",
  26: "MOVE_FROM_R2",
  27: "MOVE_R2_TO_R1",
  28: "MOVE_TO_R1",
  29: "MOVE_TO_R2",
  30: "MOVE_TO_RX",
  31: "MULTIPLY_4",
  32: "NOP",
  33: "NOT",
  34: "OR_3",
  35: "OR_4",
  36: "PERCENT",
  37: "MODULO",
  38: "BITWISE_AND",
  39: "POP",
  40: "POWER",
  41: "SHIFT_EX",
  42: "MULTIPLY",
  43: "ADD",
  44: "PUSH",
  45: "SUBTRACT",
  46: "STRING",
  47: "DIVIDE",
  48: "FUNCTION_0",
  49: "FUNCTION_1",
  50: "FUNCTION_2",
  51: "FUNCTION_3",
  52: "STRING_AND_SKIP",
  53: "SUBTRACT_3",
  54: "SUBTRACT_4",
  55: "TRUE",
  56: "TRUE_AND_SKIP",
  57: "FUNCTION_N",
  58: "UMINUS",
  59: "UNSHIFT_EX",
  60: "LT",
  61: "EQ",
  62: "GT",
  63: "CONDITION",
  64: "UNSHIFT_RX_TO_ALL",
  65: "AND",
  66: "UNSHIFT_RX_TO_R12",
  67: "UPLUS",
  68: "VAR_TO_VALUE",
  69: "VAR_VALUE",
  70: "FUNCTION",
  71: "=",
  72: "(",
  73: "NUM",
  74: "NUM_AND_SKIP",
  75: ")",
  76: "|",
  77: "MULTIPLY_3",
  78: "PUSH_NUMS",
  79: "OR",
  80: "ADD_3",
  81: "^",
  82: "&",
  83: "SKIP",
  84: "+",
  85: "-",
  86: "VAR",
  87: "*",
  88: "XOR",
  89: "/",
  90: "%",
  91: "!",
  92: "~",
  93: "?",
  94: "BITWISE_XOR",
  95: ":",
  96: ",",
  97: "COMMENT",
  98: "THEN",
  103: "s",
  110: "NEQ",
  124: "BITWISE_OR",
  126: "BITWISE_NOT"
},
TERROR: 2,
EOF: 1,

// internals: defined here so the object *structure* doesn't get modified by parse() et al,
// thus helping JIT compilers like Chrome V8.
originalQuoteName: null,
originalParseError: null,
cleanupAfterParse: null,
constructParseErrorInfo: null,
yyMergeLocationInfo: null,

__reentrant_call_depth: 0, // INTERNAL USE ONLY
__error_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup
__error_recovery_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup

// APIs which will be set up depending on user action code analysis:
//yyRecovering: 0,
//yyErrOk: 0,
//yyClearIn: 0,

// Helper APIs
// -----------

// Helper function which can be overridden by user code later on: put suitable quotes around
// literal IDs in a description string.
quoteName: function parser_quoteName(id_str) {
    return '"' + id_str + '"';
},

// Return the name of the given symbol (terminal or non-terminal) as a string, when available.
//
// Return NULL when the symbol is unknown to the parser.
getSymbolName: function parser_getSymbolName(symbol) {
    if (this.terminals_[symbol]) {
        return this.terminals_[symbol];
    }

    // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.
    //
    // An example of this may be where a rule's action code contains a call like this:
    //
    //      parser.getSymbolName(#$)
    //
    // to obtain a human-readable name of the current grammar rule.
    var s = this.symbols_;
    for (var key in s) {
        if (s[key] === symbol) {
            return key;
        }
    }
    return null;
},

// Return a more-or-less human-readable description of the given symbol, when available,
// or the symbol itself, serving as its own 'description' for lack of something better to serve up.
//
// Return NULL when the symbol is unknown to the parser.
describeSymbol: function parser_describeSymbol(symbol) {
    if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {
        return this.terminal_descriptions_[symbol];
    } else if (symbol === this.EOF) {
        return 'end of input';
    }
    var id = this.getSymbolName(symbol);
    if (id) {
        return this.quoteName(id);
    }
    return null;
},

// Produce a (more or less) human-readable list of expected tokens at the point of failure.
//
// The produced list may contain token or token set descriptions instead of the tokens
// themselves to help turning this output into something that easier to read by humans
// unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,
// expected terminals and nonterminals is produced.
//
// The returned list (array) will not contain any duplicate entries.
collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {
    var TERROR = this.TERROR;
    var tokenset = [];
    var check = {};
    // Has this (error?) state been outfitted with a custom expectations description text for human consumption?
    // If so, use that one instead of the less palatable token set.
    if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {
        return [this.state_descriptions_[state]];
    }
    for (var p in this.table[state]) {
        p = +p;
        if (p !== TERROR) {
            var d = do_not_describe ? p : this.describeSymbol(p);
            if (d && !check[d]) {
                tokenset.push(d);
                check[d] = true; // Mark this token description as already mentioned to prevent outputting duplicate entries.
            }
        }
    }
    return tokenset;
},
productions_: bp({
  pop: u([
  s,
  [99, 3],
  100,
  100,
  s,
  [101, 35],
  102,
  102
]),
  rule: u([
  0,
  3,
  3,
  s,
  [1, 5],
  2,
  1,
  3,
  2,
  3,
  4,
  s,
  [3, 17],
  2,
  2,
  c,
  [3, 3],
  2,
  2,
  4,
  3,
  1,
  2
])
}),
performAction: function parser__PerformAction(yystate /* action[1] */, yysp, yyvstack) {

          /* this == yyval */

          // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!
          var yy = this.yy;
          var yyparser = yy.parser;
          var yylexer = yy.lexer;

          

          switch (yystate) {
case 0:
    /*! Production::    $accept : input $end */

    // default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,-,-,-,-):
    this.$ = undefined;
    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,-,-,-,-)
    break;

case 1:
    /*! Production::    input : %epsilon */

    this.$ = [];
    break;

case 2:
    /*! Production::    input : input line EOL */

    yyvstack[yysp - 2].push(yyvstack[yysp - 1]);
    this.$ = yyvstack[yysp - 2];
    break;

case 3:
    /*! Production::    input : input COMMENT EOL */

    console.log('COMMENT line(s): ', yyvstack[yysp - 1]);
    this.$ = yyvstack[yysp - 2];
    break;

case 4:
    /*! Production::    line : exp */

    console.log('expression result value: ', yyvstack[yysp]);
    this.$ = yyvstack[yysp];
    break;

case 5:
    /*! Production::    line : ERROR */

    console.log('expression result value: ERROR - erroneous input line');
    this.$ = NaN;
    break;

case 6:
    /*! Production::    exp : NUM */

    this.$ = yyvstack[yysp];
    break;

case 7:
    /*! Production::    exp : CONSTANT */

    this.$ = yy.constants[yyvstack[yysp]].value;
    break;

case 8:
    /*! Production::    exp : VAR */

    this.$ = yy.variables[yyvstack[yysp]].value;
    break;

case 9:
    /*! Production::    exp : ASSIGN exp */

    /*
       Note: #assign is always to a simple variable, hence we don't need the `#VAR`
       token here: it is implicit as there's nothing else we can do.
    
       Technically, this is an AST optimization, but it's such a fundamental one
       we do it here instead of later.
    
       NOTE: #assign implies the presence of a VAR as lhs (left hand side) so it
       would only be cluttering the AST stream to have a #VAR# token in there:
       it is *implicit* to #assign!
     */
    this.$ = yy.variables[yyvstack[yysp - 1]].value = yyvstack[yysp];
    break;

case 10:
    /*! Production::    exp : FUNCTION_0 */

    this.$ = yy.functions[yyvstack[yysp]].func.call(globalSpace);
    break;

case 11:
    /*! Production::    exp : FUNCTION arglist END */

    /*
       A lot of functions have only a few arguments, which we later optimize in our AST
       by including that knowledge in the FUNCTION token by using derivative tokens
       FUNCTION_0, FUNCTION_1, etc.: this can help a smart optimizer to include
       special optimizations for these functions without having to re-discover
       the arglist length.
       As that approach already disambiguates the function-versus-statement
       situation by having encoded arglist length in the FUNCTION token, these
       tokens never require a sentinel token in the AST stream: small AST stream size.
    
       Also don't forget to FLATTEN the arglist! ==> `concat.apply(a, arglist)`
    
       NOTE: the #FUNCTION# rule in Polish Notation is ambiguous unless we terminate it
       (which is easy to parse in an LALR(1) grammar while adding a argument count is not!)
       as we would otherwise get confused over this scenario:
    
            ... PLUS FUNCTION exp exp exp ...
    
       - is this a function with one argument and that last `exp` in there the second term
         of a binary(?) opcode waiting in the leading `...`?
       - is this a function with two arguments and that last `exp` the second
         term of the PLUS?
       - is this a function with three arguments and is the second term of the PLUS
         waiting in the trailing `...`?
    
       This is the trouble with opcodes which accept a variable number of arguments:
       such opcodes always have to be terminated by a sentinel to make the AST grammar
       unambiguous.
    */
    this.$ = yy.functions[yyvstack[yysp - 2]].func.apply(globalSpace, yyvstack[yysp - 1]);
    break;

case 12:
    /*! Production::    exp : FUNCTION_1 exp */

    this.$ = yy.functions[yyvstack[yysp - 1]].func.call(globalSpace, yyvstack[yysp]);
    break;

case 13:
    /*! Production::    exp : FUNCTION_2 exp exp */

    this.$ = yy.functions[yyvstack[yysp - 2]].func.call(globalSpace, yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 14:
    /*! Production::    exp : FUNCTION_3 exp exp exp */

    this.$ = yy.functions[yyvstack[yysp - 3]].func.call(globalSpace, yyvstack[yysp - 2], yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 15:
    /*! Production::    exp : EQ exp exp */

    this.$ = yyvstack[yysp - 1] == yyvstack[yysp];
    break;

case 16:
    /*! Production::    exp : NEQ exp exp */

    this.$ = yyvstack[yysp - 1] != yyvstack[yysp];
    break;

case 17:
    /*! Production::    exp : LEQ exp exp */

    this.$ = yyvstack[yysp - 1] <= yyvstack[yysp];
    break;

case 18:
    /*! Production::    exp : GEQ exp exp */

    this.$ = yyvstack[yysp - 1] >= yyvstack[yysp];
    break;

case 19:
    /*! Production::    exp : LT exp exp */

    this.$ = yyvstack[yysp - 1] < yyvstack[yysp];
    break;

case 20:
    /*! Production::    exp : GT exp exp */

    this.$ = yyvstack[yysp - 1] > yyvstack[yysp];
    break;

case 21:
    /*! Production::    exp : OR exp exp */

    this.$ = yyvstack[yysp - 1] || yyvstack[yysp];
    break;

case 22:
    /*! Production::    exp : XOR exp exp */

    this.$ = !!(!!yyvstack[yysp - 1] ^ !!yyvstack[yysp]);
    break;

case 23:
    /*! Production::    exp : AND exp exp */

    this.$ = yyvstack[yysp - 1] && yyvstack[yysp];
    break;

case 24:
    /*! Production::    exp : BITWISE_OR exp exp */

    this.$ = yyvstack[yysp - 1] | yyvstack[yysp];
    break;

case 25:
    /*! Production::    exp : BITWISE_XOR exp exp */

    this.$ = yyvstack[yysp - 1] ^ yyvstack[yysp];
    break;

case 26:
    /*! Production::    exp : BITWISE_AND exp exp */

    this.$ = yyvstack[yysp - 1] & yyvstack[yysp];
    break;

case 27:
    /*! Production::    exp : ADD exp exp */

    this.$ = yyvstack[yysp - 1] + yyvstack[yysp];
    break;

case 28:
    /*! Production::    exp : SUBTRACT exp exp */

    this.$ = yyvstack[yysp - 1] - yyvstack[yysp];
    break;

case 29:
    /*! Production::    exp : MULTIPLY exp exp */

    this.$ = yyvstack[yysp - 1] * yyvstack[yysp];
    break;

case 30:
    /*! Production::    exp : DIVIDE exp exp */

    this.$ = yyvstack[yysp - 1] / yyvstack[yysp];
    break;

case 31:
    /*! Production::    exp : MODULO exp exp */

    this.$ = yyvstack[yysp - 1] % yyvstack[yysp];
    break;

case 32:
    /*! Production::    exp : UMINUS exp */

    this.$ = -yyvstack[yysp];
    break;

case 33:
    /*! Production::    exp : UPLUS exp */

    this.$ = +yyvstack[yysp];
    break;

case 34:
    /*! Production::    exp : POWER exp exp */

    this.$ = Math.pow(yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 35:
    /*! Production::    exp : PERCENT exp */

    this.$ = yyvstack[yysp] / 100;
    break;

case 36:
    /*! Production::    exp : FACTORIAL exp */

    this.$ = yy.predefined_functions.factorial.call(globalSpace, yyvstack[yysp]);
    break;

case 37:
    /*! Production::    exp : BITWISE_NOT exp */

    this.$ = ~yyvstack[yysp];
    break;

case 38:
    /*! Production::    exp : NOT exp */

    this.$ = !yyvstack[yysp];
    break;

case 39:
    /*! Production::    exp : IF_ELSE exp exp exp */

    if (yyvstack[yysp - 2]) {
      this.$ = yyvstack[yysp - 1];
    } else {
      this.$ = yyvstack[yysp];
    }
    break;

case 40:
    /*! Production::    exp : IF exp exp */

    if (yyvstack[yysp - 1]) {
      this.$ = yyvstack[yysp];
    } else {
      this.$ = 0;
    }
    break;

case 41:
    /*! Production::    arglist : exp */

    this.$ = [yyvstack[yysp]];
    break;

case 42:
    /*! Production::    arglist : arglist exp */

    this.$ = yyvstack[yysp - 1];
    this.$.push(yyvstack[yysp]);
    break;

}
},
table: bt({
  len: u([
  1,
  40,
  1,
  1,
  s,
  [0, 5],
  36,
  0,
  37,
  s,
  [36, 29],
  s,
  [0, 3],
  37,
  c,
  [38, 3],
  c,
  [25, 20],
  c,
  [28, 4],
  c,
  [26, 3],
  c,
  [69, 5],
  s,
  [0, 17],
  c,
  [19, 4]
]),
  symbol: u([
  99,
  1,
  3,
  7,
  8,
  17,
  s,
  [20, 4, 1],
  33,
  36,
  37,
  38,
  40,
  42,
  43,
  45,
  s,
  [47, 5, 1],
  58,
  60,
  61,
  62,
  65,
  67,
  70,
  73,
  79,
  86,
  88,
  94,
  97,
  100,
  101,
  110,
  124,
  126,
  11,
  11,
  c,
  [40, 32],
  c,
  [38, 4],
  c,
  [36, 33],
  102,
  c,
  [37, 36],
  c,
  [36, 1013],
  10,
  c,
  [901, 898]
]),
  type: u([
  0,
  1,
  s,
  [2, 34],
  0,
  0,
  s,
  [2, 37],
  c,
  [38, 36],
  c,
  [75, 37],
  c,
  [36, 1044],
  c,
  [901, 869]
]),
  state: u([
  1,
  2,
  4,
  43,
  45,
  44,
  s,
  [46, 29, 1],
  s,
  [76, 25, 1]
]),
  mode: u([
  s,
  [1, 2000]
]),
  goto: u([
  5,
  9,
  7,
  36,
  18,
  40,
  39,
  17,
  38,
  35,
  31,
  26,
  34,
  29,
  27,
  28,
  30,
  10,
  12,
  13,
  14,
  32,
  19,
  15,
  20,
  23,
  33,
  11,
  6,
  21,
  8,
  22,
  25,
  3,
  16,
  24,
  37,
  41,
  42,
  c,
  [38, 32],
  c,
  [37, 3],
  c,
  [35, 1052],
  75,
  c,
  [876, 873]
])
}),
defaultActions: bda({
  idx: u([
  0,
  s,
  [4, 5, 1],
  10,
  41,
  42,
  43,
  45,
  46,
  66,
  67,
  s,
  [69, 4, 1],
  75,
  76,
  77,
  s,
  [79, 18, 1],
  98,
  99,
  100
]),
  goto: u([
  1,
  s,
  [4, 5, 1],
  10,
  2,
  3,
  9,
  41,
  12,
  32,
  33,
  s,
  [35, 4, 1],
  11,
  42,
  13,
  s,
  [15, 17, 1],
  34,
  40,
  14,
  39
])
}),
parseError: function parseError(str, hash, ExceptionClass) {
    if (hash.recoverable) {
        if (typeof this.trace === 'function') {
            this.trace(str);
        }
        hash.destroy();             // destroy... well, *almost*!
    } else {
        if (typeof this.trace === 'function') {
            this.trace(str);
        }
        if (!ExceptionClass) {
            ExceptionClass = this.JisonParserError;
        }
        throw new ExceptionClass(str, hash);
    }
},
parse: function parse(input, globalSpace) {
    var self = this;
    var stack = new Array(128);         // token stack: stores token which leads to state at the same index (column storage)
    var sstack = new Array(128);        // state stack: stores states (column storage)

    var vstack = new Array(128);        // semantic value stack

    var table = this.table;
    var sp = 0;                         // 'stack pointer': index into the stacks


    


    var symbol = 0;



    var TERROR = this.TERROR;
    var EOF = this.EOF;
    var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = (this.options.errorRecoveryTokenDiscardCount | 0) || 3;
    var NO_ACTION = [0, 101 /* === table.length :: ensures that anyone using this new state will fail dramatically! */];

    var lexer;
    if (this.__lexer__) {
        lexer = this.__lexer__;
    } else {
        lexer = this.__lexer__ = Object.create(this.lexer);
    }

    var sharedState_yy = {
        parseError: undefined,
        quoteName: undefined,
        lexer: undefined,
        parser: undefined,
        pre_parse: undefined,
        post_parse: undefined,
        pre_lex: undefined,
        post_lex: undefined,
        globalSpace: globalSpace  // parseParams::globalSpace      // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!
    };

    var ASSERT;
    if (typeof assert !== 'function') {
        ASSERT = function JisonAssert(cond, msg) {
            if (!cond) {
                throw new Error('assertion failed: ' + (msg || '***'));
            }
        };
    } else {
        ASSERT = assert;
    }

    this.yyGetSharedState = function yyGetSharedState() {
        return sharedState_yy;
    };








    function shallow_copy_noclobber(dst, src) {
        for (var k in src) {
            if (typeof dst[k] === 'undefined' && Object.prototype.hasOwnProperty.call(src, k)) {
                dst[k] = src[k];
            }
        }
    }

    // copy state
    shallow_copy_noclobber(sharedState_yy, this.yy);

    sharedState_yy.lexer = lexer;
    sharedState_yy.parser = this;






    // Does the shared state override the default `parseError` that already comes with this instance?
    if (typeof sharedState_yy.parseError === 'function') {
        this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {
            if (!ExceptionClass) {
                ExceptionClass = this.JisonParserError;
            }
            return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);
        };
    } else {
        this.parseError = this.originalParseError;
    }

    // Does the shared state override the default `quoteName` that already comes with this instance?
    if (typeof sharedState_yy.quoteName === 'function') {
        this.quoteName = function quoteNameAlt(id_str) {
            return sharedState_yy.quoteName.call(this, id_str);
        };
    } else {
        this.quoteName = this.originalQuoteName;
    }

    // set up the cleanup function; make it an API so that external code can re-use this one in case of
    // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which
    // case this parse() API method doesn't come with a `finally { ... }` block any more!
    //
    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `sharedState`, etc. references will be *wrong*!
    this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {
        var rv;

        if (invoke_post_methods) {
            var hash;

            if (sharedState_yy.post_parse || this.post_parse) {
                // create an error hash info instance: we re-use this API in a **non-error situation**
                // as this one delivers all parser internals ready for access by userland code.
                hash = this.constructParseErrorInfo(null /* no error! */, null /* no exception! */, null, false);
            }

            if (sharedState_yy.post_parse) {
                rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }
            if (this.post_parse) {
                rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }

            // cleanup:
            if (hash && hash.destroy) {
                hash.destroy();
            }
        }




        // clean up the lingering lexer structures as well:
        if (lexer.cleanupAfterLex) {
            lexer.cleanupAfterLex(do_not_nuke_errorinfos);
        }

        // prevent lingering circular references from causing memory leaks:
        if (sharedState_yy) {
            sharedState_yy.lexer = undefined;
            sharedState_yy.parser = undefined;
            if (lexer.yy === sharedState_yy) {
                lexer.yy = undefined;
            }
        }
        sharedState_yy = undefined;
        this.parseError = this.originalParseError;
        this.quoteName = this.originalQuoteName;

        // nuke the vstack[] array at least as that one will still reference obsoleted user values.
        // To be safe, we nuke the other internal stack columns as well...
        stack.length = 0;               // fastest way to nuke an array without overly bothering the GC
        sstack.length = 0;

        vstack.length = 0;
        sp = 0;

        // nuke the error hash info instances created during this run.
        // Userland code must COPY any data/references
        // in the error hash instance(s) it is more permanently interested in.
        if (!do_not_nuke_errorinfos) {
            for (var i = this.__error_infos.length - 1; i >= 0; i--) {
                var el = this.__error_infos[i];
                if (el && typeof el.destroy === 'function') {
                    el.destroy();
                }
            }
            this.__error_infos.length = 0;


        }

        return resultValue;
    };






































































































































    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!
    this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {
        var pei = {
            errStr: msg,
            exception: ex,
            text: lexer.match,
            value: lexer.yytext,
            token: this.describeSymbol(symbol) || symbol,
            token_id: symbol,
            line: lexer.yylineno,

            expected: expected,
            recoverable: recoverable,
            state: state,
            action: action,
            new_state: newState,
            symbol_stack: stack,
            state_stack: sstack,
            value_stack: vstack,

            stack_pointer: sp,
            yy: sharedState_yy,
            lexer: lexer,
            parser: this,

            // and make sure the error info doesn't stay due to potential
            // ref cycle via userland code manipulations.
            // These would otherwise all be memory leak opportunities!
            //
            // Note that only array and object references are nuked as those
            // constitute the set of elements which can produce a cyclic ref.
            // The rest of the members is kept intact as they are harmless.
            destroy: function destructParseErrorInfo() {
                // remove cyclic references added to error info:
                // info.yy = null;
                // info.lexer = null;
                // info.value = null;
                // info.value_stack = null;
                // ...
                var rec = !!this.recoverable;
                for (var key in this) {
                    if (this.hasOwnProperty(key) && typeof key === 'object') {
                        this[key] = undefined;
                    }
                }
                this.recoverable = rec;
            }
        };
        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
        this.__error_infos.push(pei);
        return pei;
    };













    function getNonTerminalFromCode(symbol) {
        var tokenName = self.getSymbolName(symbol);
        if (!tokenName) {
            tokenName = symbol;
        }
        return tokenName;
    }


    function stdLex() {
        var token = lexer.lex();
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }

        return token || 1/* EOF */;
    }

    function fastLex() {
        var token = lexer.fastLex();
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }

        return token || 1/* EOF */;
    }

    var lex = stdLex;


    var state, action, r, t;
    var yyval = {
        $: true,
        _$: undefined,
        yy: sharedState_yy
    };
    var p;
    var yyrulelen;
    var this_production;
    var newState;
    var retval = false;




    lexer.setInput(input, sharedState_yy);

    // NOTE: we *assume* no lexer pre/post handlers are set up *after* 
    // this initial `setInput()` call: hence we can now check and decide
    // whether we'll go with the standard, slower, lex() API or the
    // `fast_lex()` one:
    if (typeof lexer.canIUse === 'function') {
        var lexerInfo = lexer.canIUse();
        if (lexerInfo.fastLex && typeof fastLex === 'function') {
            lex = fastLex;
        }
    } 



    vstack[sp] = null;
    sstack[sp] = 0;
    stack[sp] = 0;
    ++sp;





    if (this.pre_parse) {
        this.pre_parse.call(this, sharedState_yy);
    }
    if (sharedState_yy.pre_parse) {
        sharedState_yy.pre_parse.call(this, sharedState_yy);
    }

    newState = sstack[sp - 1];
    for (;;) {
        // retrieve state number from top of stack
        state = newState;               // sstack[sp - 1];

        // use default actions if available
        if (this.defaultActions[state]) {
            action = 2;
            newState = this.defaultActions[state];
        } else {
            // The single `==` condition below covers both these `===` comparisons in a single
            // operation:
            //
            //     if (symbol === null || typeof symbol === 'undefined') ...
            if (!symbol) {
                symbol = lex();
            }
            // read action for current state and first input
            t = (table[state] && table[state][symbol]) || NO_ACTION;
            newState = t[1];
            action = t[0];











            // handle parse error
            if (!action) {
                var errStr;
                var errSymbolDescr = (this.describeSymbol(symbol) || symbol);
                var expected = this.collect_expected_token_set(state);

                // Report error
                if (typeof lexer.yylineno === 'number') {
                    errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';
                } else {
                    errStr = 'Parse error: ';
                }
                if (typeof lexer.showPosition === 'function') {
                    errStr += '\n' + lexer.showPosition(79 - 10, 10) + '\n';
                }
                if (expected.length) {
                    errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;
                } else {
                    errStr += 'Unexpected ' + errSymbolDescr;
                }
                // we cannot recover from the error!
                p = this.constructParseErrorInfo(errStr, null, expected, false);
                r = this.parseError(p.errStr, p, this.JisonParserError);
                if (typeof r !== 'undefined') {
                    retval = r;
                }
                break;
            }


        }










        switch (action) {
        // catch misc. parse failures:
        default:
            // this shouldn't happen, unless resolve defaults are off
            if (action instanceof Array) {
                p = this.constructParseErrorInfo('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, null, null, false);
                r = this.parseError(p.errStr, p, this.JisonParserError);
                if (typeof r !== 'undefined') {
                    retval = r;
                }
                break;
            }
            // Another case of better safe than sorry: in case state transitions come out of another error recovery process
            // or a buggy LUT (LookUp Table):
            p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);
            r = this.parseError(p.errStr, p, this.JisonParserError);
            if (typeof r !== 'undefined') {
                retval = r;
            }
            break;

        // shift:
        case 1:
            stack[sp] = symbol;
            vstack[sp] = lexer.yytext;

            sstack[sp] = newState; // push state

            ++sp;
            symbol = 0;




            // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:




            continue;

        // reduce:
        case 2:



            this_production = this.productions_[newState - 1];  // `this.productions_[]` is zero-based indexed while states start from 1 upwards...
            yyrulelen = this_production[1];










            r = this.performAction.call(yyval, newState, sp - 1, vstack);

            if (typeof r !== 'undefined') {
                retval = r;
                break;
            }

            // pop off stack
            sp -= yyrulelen;

            // don't overwrite the `symbol` variable: use a local var to speed things up:
            var ntsymbol = this_production[0];    // push nonterminal (reduce)
            stack[sp] = ntsymbol;
            vstack[sp] = yyval.$;

            // goto new state = table[STATE][NONTERMINAL]
            newState = table[sstack[sp - 1]][ntsymbol];
            sstack[sp] = newState;
            ++sp;









            continue;

        // accept:
        case 3:
            if (sp !== -2) {
                retval = true;
                // Return the `$accept` rule's `$$` result, if available.
                //
                // Also note that JISON always adds this top-most `$accept` rule (with implicit,
                // default, action):
                //
                //     $accept: <startSymbol> $end
                //                  %{ $$ = $1; @$ = @1; %}
                //
                // which, combined with the parse kernel's `$accept` state behaviour coded below,
                // will produce the `$$` value output of the <startSymbol> rule as the parse result,
                // IFF that result is *not* `undefined`. (See also the parser kernel code.)
                //
                // In code:
                //
                //                  %{
                //                      @$ = @1;            // if location tracking support is included
                //                      if (typeof $1 !== 'undefined')
                //                          return $1;
                //                      else
                //                          return true;           // the default parse result if the rule actions don't produce anything
                //                  %}
                sp--;
                if (typeof vstack[sp] !== 'undefined') {
                    retval = vstack[sp];
                }
            }
            break;
        }

        // break out of loop: we accept or fail with error
        break;
    }
    
    // ... AND FINALLY ...

    retval = this.cleanupAfterParse(retval, true, true);


    

    return retval;
}
};
parser.originalParseError = parser.parseError;
parser.originalQuoteName = parser.quoteName;



function Parser() {
  this.yy = {};
}
Parser.prototype = parser;
parser.Parser = Parser;

return new Parser();
})();

        


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
  exports.parser = compiled_calc_codegen;
  exports.Parser = compiled_calc_codegen.Parser;
  exports.parse = function () {
    return compiled_calc_codegen.parse.apply(compiled_calc_codegen, arguments);
  };
  
}


// End Of Include by Jison: ./output/compiled_calc/compiled_calc_codegen.js



// Included by Jison: ./output/compiled_calc/compiled_calc_print.js:


/* parser generated by jison 0.6.1-214 */

/*
 * Returns a Parser object of the following structure:
 *
 *  Parser: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a derivative/copy of this one,
 *               not a direct reference!
 *  }
 *
 *  Parser.prototype: {
 *    yy: {},
 *    EOF: 1,
 *    TERROR: 2,
 *
 *    trace: function(errorMessage, ...),
 *
 *    JisonParserError: function(msg, hash),
 *
 *    quoteName: function(name),
 *               Helper function which can be overridden by user code later on: put suitable
 *               quotes around literal IDs in a description string.
 *
 *    originalQuoteName: function(name),
 *               The basic quoteName handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function
 *               at the end of the `parse()`.
 *
 *    describeSymbol: function(symbol),
 *               Return a more-or-less human-readable description of the given symbol, when
 *               available, or the symbol itself, serving as its own 'description' for lack
 *               of something better to serve up.
 *
 *               Return NULL when the symbol is unknown to the parser.
 *
 *    symbols_: {associative list: name ==> number},
 *    terminals_: {associative list: number ==> name},
 *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},
 *    terminal_descriptions_: (if there are any) {associative list: number ==> description},
 *    productions_: [...],
 *
 *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)
 *                             to store/reference the rule value `$$` and location info `@$`.
 *
 *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets
 *                 to see the same object via the `this` reference, i.e. if you wish to carry custom
 *                 data from one reduce action through to the next within a single parse run, then you
 *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.
 *
 *                 `this.yy` is a direct reference to the `yy` shared state object.
 *
 *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`
 *                 object at `parse()` start and are therefore available to the action code via the
 *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from
 *                 the %parse-param` list.
 *
 *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used
 *                             to match this rule. This is *not* the look-ahead token, but the last token
 *                             that's actually part of this rule.
 *
 *                 Formulated another way, `yytext` is the value of the token immediately preceeding
 *                 the current look-ahead token.
 *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.
 *
 *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.
 *
 *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.
 *
 *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.
 *
 *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead
 *                               of an empty object when no suitable location info can be provided.
 *
 *               - `yystate` : the current parser state number, used internally for dispatching and
 *                               executing the action code chunk matching the rule currently being reduced.
 *
 *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *                 Also note that you can access this and other stack index values using the new double-hash
 *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things
 *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.
 *                 This is made available to write very advanced grammar action rules, e.g. when you want
 *                 to investigate the parse state stack in your action code, which would, for example,
 *                 be relevant when you wish to implement error diagnostics and reporting schemes similar
 *                 to the work described here:
 *
 *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.
 *                   In Journées Francophones des Languages Applicatifs.
 *
 *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.
 *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631–640.
 *
 *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.
 *                             constructs.
 *
 *               - `yylstack`: reference to the parser token location stack. Also accessed via
 *                             the `@1` etc. constructs.
 *
 *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are
 *                             UNDEFINED rather than an empty (location) object, when the lexer/parser
 *                             action code did not provide a suitable location info object when such a
 *                             slot was filled!
 *
 *               - `yystack` : reference to the parser token id stack. Also accessed via the
 *                             `#1` etc. constructs.
 *
 *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to
 *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might
 *                 want access this array for your own purposes, such as error analysis as mentioned above!
 *
 *                 Note that this stack stores the current stack of *tokens*, that is the sequence of
 *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*
 *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and
 *                 *reduced*.
 *
 *               - `yysstack`: reference to the parser state stack. This one carries the internal parser
 *                             *states* such as the one in `yystate`, which are used to represent
 *                             the parser state machine in the *parse table*. *Very* *internal* stuff,
 *                             what can I say? If you access this one, you're clearly doing wicked things
 *
 *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your
 *                             grammar definition file.
 *
 *    table: [...],
 *               State transition table
 *               ----------------------
 *
 *               index levels are:
 *               - `state`  --> hash table
 *               - `symbol` --> action (number or array)
 *
 *                 If the `action` is an array, these are the elements' meaning:
 *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept
 *                 - index [1]: GOTO `state`
 *
 *                 If the `action` is a number, it is the GOTO `state`
 *
 *    defaultActions: {...},
 *
 *    parseError: function(str, hash, ExceptionClass),
 *    yyError: function(str, ...),
 *    yyRecovering: function(),
 *    yyErrOk: function(),
 *    yyClearIn: function(),
 *
 *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this parser kernel in many places; example usage:
 *
 *                   var infoObj = parser.constructParseErrorInfo('fail!', null,
 *                                     parser.collect_expected_token_set(state), true);
 *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);
 *
 *    originalParseError: function(str, hash, ExceptionClass),
 *               The basic `parseError` handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function
 *               at the end of the `parse()`.
 *
 *    options: { ... parser %options ... },
 *
 *    parse: function(input[, args...]),
 *               Parse the given `input` and return the parsed value (or `true` when none was provided by
 *               the root action, in which case the parser is acting as a *matcher*).
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the jison run-time;
 *               when such a collision is detected an exception is thrown to prevent the generated run-time
 *               from silently accepting this confusing and potentially hazardous situation!
 *
 *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in
 *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state
 *               object and any collision with those will be reported by the lexer via a thrown exception.
 *
 *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown
 *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY
 *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and
 *               the internal parser gets properly garbage collected under these particular circumstances.
 *
 *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API can be invoked to calculate a spanning `yylloc` location info object.
 *
 *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case
 *               this function will attempt to obtain a suitable location marker by inspecting the location stack
 *               backwards.
 *
 *               For more info see the documentation comment further below, immediately above this function's
 *               implementation.
 *
 *    lexer: {
 *        yy: {...},           A reference to the so-called "shared state" `yy` once
 *                             received via a call to the `.setInput(input, yy)` lexer API.
 *        EOF: 1,
 *        ERROR: 2,
 *        JisonLexerError: function(msg, hash),
 *        parseError: function(str, hash, ExceptionClass),
 *        setInput: function(input, [yy]),
 *        input: function(),
 *        unput: function(str),
 *        more: function(),
 *        reject: function(),
 *        less: function(n),
 *        pastInput: function(n),
 *        upcomingInput: function(n),
 *        showPosition: function(),
 *        test_match: function(regex_match_array, rule_index, ...),
 *        next: function(...),
 *        lex: function(...),
 *        begin: function(condition),
 *        pushState: function(condition),
 *        popState: function(),
 *        topState: function(),
 *        _currentRules: function(),
 *        stateStackSize: function(),
 *        cleanupAfterLex: function()
 *
 *        options: { ... lexer %options ... },
 *
 *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),
 *        rules: [...],
 *        conditions: {associative list: name ==> set},
 *    }
 *  }
 *
 *
 *  token location info (@$, _$, etc.): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer and
 * parser errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *  }
 *
 * parser (grammar) errors will also provide these additional members:
 *
 *  {
 *    expected:    (array describing the set of expected tokens;
 *                  may be UNDEFINED when we cannot easily produce such a set)
 *    state:       (integer (or array when the table includes grammar collisions);
 *                  represents the current internal state of the parser kernel.
 *                  can, for example, be used to pass to the `collect_expected_token_set()`
 *                  API to obtain the expected token set)
 *    action:      (integer; represents the current internal action which will be executed)
 *    new_state:   (integer; represents the next/planned internal state, once the current
 *                  action has executed)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *    parser:      (reference to the current parser instance)
 *  }
 *
 * while `this` will reference the current parser instance.
 *
 * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    lexer:       (reference to the current lexer instance which reported the error)
 *  }
 *
 * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired
 * from either the parser or lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    exception:   (reference to the exception thrown)
 *  }
 *
 * Please do note that in the latter situation, the `expected` field will be omitted as
 * this type of failure is assumed not to be due to *parse errors* but rather due to user
 * action code in either parser or lexer failing unexpectedly.
 *
 * ---
 *
 * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.
 * These options are available:
 *
 * ### options which are global for all parser instances
 *
 *  Parser.pre_parse: function(yy)
 *                 optional: you can specify a pre_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`.
 *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: you can specify a post_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`. When it does not return any value,
 *                 the parser will return the original `retval`.
 *
 * ### options which can be set up per parser instance
 *
 *  yy: {
 *      pre_parse:  function(yy)
 *                 optional: is invoked before the parse cycle starts (and before the first
 *                 invocation of `lex()`) but immediately after the invocation of
 *                 `parser.pre_parse()`).
 *      post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: is invoked when the parse terminates due to success ('accept')
 *                 or failure (even when exceptions are thrown).
 *                 `retval` contains the return value to be produced by `Parser.parse()`;
 *                 this function can override the return value by returning another.
 *                 When it does not return any value, the parser will return the original
 *                 `retval`.
 *                 This function is invoked immediately before `parser.post_parse()`.
 *
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *      quoteName: function(name),
 *                 optional: overrides the default `quoteName` function.
 *  }
 *
 *  parser.lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */

        
    
            var compiled_calc_print = (function () {

// See also:
// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
// with userland code which might access the derived class in a 'classic' way.
function JisonParserError(msg, hash) {
    Object.defineProperty(this, 'name', {
        enumerable: false,
        writable: false,
        value: 'JisonParserError'
    });

    if (msg == null) msg = '???';

    Object.defineProperty(this, 'message', {
        enumerable: false,
        writable: true,
        value: msg
    });

    this.hash = hash;

    var stacktrace;
    if (hash && hash.exception instanceof Error) {
        var ex2 = hash.exception;
        this.message = ex2.message || msg;
        stacktrace = ex2.stack;
    }
    if (!stacktrace) {
        if (Error.hasOwnProperty('captureStackTrace')) {        // V8/Chrome engine
            Error.captureStackTrace(this, this.constructor);
        } else {
            stacktrace = (new Error(msg)).stack;
        }
    }
    if (stacktrace) {
        Object.defineProperty(this, 'stack', {
            enumerable: false,
            writable: false,
            value: stacktrace
        });
    }
}

if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);
} else {
    JisonParserError.prototype = Object.create(Error.prototype);
}
JisonParserError.prototype.constructor = JisonParserError;
JisonParserError.prototype.name = 'JisonParserError';



        // helper: reconstruct the productions[] table
        function bp(s) {
            var rv = [];
            var p = s.pop;
            var r = s.rule;
            for (var i = 0, l = p.length; i < l; i++) {
                rv.push([
                    p[i],
                    r[i]
                ]);
            }
            return rv;
        }
    


        // helper: reconstruct the defaultActions[] table
        function bda(s) {
            var rv = {};
            var d = s.idx;
            var g = s.goto;
            for (var i = 0, l = d.length; i < l; i++) {
                var j = d[i];
                rv[j] = g[i];
            }
            return rv;
        }
    


        // helper: reconstruct the 'goto' table
        function bt(s) {
            var rv = [];
            var d = s.len;
            var y = s.symbol;
            var t = s.type;
            var a = s.state;
            var m = s.mode;
            var g = s.goto;
            for (var i = 0, l = d.length; i < l; i++) {
                var n = d[i];
                var q = {};
                for (var j = 0; j < n; j++) {
                    var z = y.shift();
                    switch (t.shift()) {
                    case 2:
                        q[z] = [
                            m.shift(),
                            g.shift()
                        ];
                        break;

                    case 0:
                        q[z] = a.shift();
                        break;

                    default:
                        // type === 1: accept
                        q[z] = [
                            3
                        ];
                    }
                }
                rv.push(q);
            }
            return rv;
        }
    


        // helper: runlength encoding with increment step: code, length: step (default step = 0)
        // `this` references an array
        function s(c, l, a) {
            a = a || 0;
            for (var i = 0; i < l; i++) {
                this.push(c);
                c += a;
            }
        }

        // helper: duplicate sequence from *relative* offset and length.
        // `this` references an array
        function c(i, l) {
            i = this.length - i;
            for (l += i; i < l; i++) {
                this.push(this[i]);
            }
        }

        // helper: unpack an array using helpers and data, all passed in an array argument 'a'.
        function u(a) {
            var rv = [];
            for (var i = 0, l = a.length; i < l; i++) {
                var e = a[i];
                // Is this entry a helper function?
                if (typeof e === 'function') {
                    i++;
                    e.apply(rv, a[i]);
                } else {
                    rv.push(e);
                }
            }
            return rv;
        }
    

var parser = {
    // Code Generator Information Report
    // ---------------------------------
    //
    // Options:
    //
    //   default action mode: ............. classic,merge
    //   try..catch: ...................... false
    //   default resolve on conflict: ..... true
    //   on-demand look-ahead: ............ false
    //   error recovery token skip maximum: 3
    //   yyerror in parse actions is: ..... NOT recoverable,
    //   yyerror in lexer actions and other non-fatal lexer are:
    //   .................................. NOT recoverable,
    //   debug grammar/output: ............ false
    //   has partial LR conflict upgrade:   true
    //   rudimentary token-stack support:   false
    //   parser table compression mode: ... 2
    //   export debug tables: ............. false
    //   export *all* tables: ............. false
    //   module type: ..................... commonjs
    //   parser engine type: .............. lalr
    //   output main() in the module: ..... true
    //   has user-specified main(): ....... false
    //   has user-specified require()/import modules for main():
    //   .................................. false
    //   number of expected conflicts: .... 0
    //
    //
    // Parser Analysis flags:
    //
    //   no significant actions (parser is a language matcher only):
    //   .................................. false
    //   uses yyleng: ..................... false
    //   uses yylineno: ................... false
    //   uses yytext: ..................... false
    //   uses yylloc: ..................... false
    //   uses ParseError API: ............. false
    //   uses YYERROR: .................... false
    //   uses YYRECOVERING: ............... false
    //   uses YYERROK: .................... false
    //   uses YYCLEARIN: .................. false
    //   tracks rule values: .............. true
    //   assigns rule values: ............. true
    //   uses location tracking: .......... false
    //   assigns location: ................ false
    //   uses yystack: .................... false
    //   uses yysstack: ................... false
    //   uses yysp: ....................... true
    //   uses yyrulelength: ............... false
    //   uses yyMergeLocationInfo API: .... false
    //   has error recovery: .............. false
    //   has error reporting: ............. false
    //
    // --------- END OF REPORT -----------

trace: function no_op_trace() {},
JisonParserError: JisonParserError,
yy: {},
options: {
  type: "lalr",
  hasPartialLrUpgradeOnConflict: true,
  errorRecoveryTokenDiscardCount: 3
},
symbols_: {
  "!": 91,
  "$accept": 0,
  "$end": 1,
  "%": 90,
  "&": 82,
  "(": 72,
  ")": 75,
  "*": 87,
  "+": 84,
  ",": 96,
  "-": 85,
  "/": 89,
  ":": 95,
  "=": 71,
  "?": 93,
  "ADD": 43,
  "ADD_3": 80,
  "ADD_4": 4,
  "AND": 65,
  "AND_3": 5,
  "AND_4": 6,
  "ASSIGN": 7,
  "BITWISE_AND": 38,
  "BITWISE_NOT": 126,
  "BITWISE_OR": 124,
  "BITWISE_XOR": 94,
  "COMMENT": 97,
  "CONDITION": 63,
  "CONSTANT": 8,
  "DIVIDE": 47,
  "ELSE": 9,
  "END": 10,
  "EOF": 1,
  "EOL": 11,
  "EQ": 61,
  "ERROR": 3,
  "ERROR_AND_SKIP": 12,
  "EXCHANGE_A_R1": 13,
  "EXCHANGE_A_R2": 14,
  "EXCHANGE_R1_R2": 15,
  "EXEC": 16,
  "FACTORIAL": 17,
  "FALSE": 18,
  "FALSE_AND_SKIP": 19,
  "FUNCTION": 70,
  "FUNCTION_0": 48,
  "FUNCTION_1": 49,
  "FUNCTION_2": 50,
  "FUNCTION_3": 51,
  "FUNCTION_N": 57,
  "GEQ": 20,
  "GT": 62,
  "IF": 21,
  "IF_ELSE": 22,
  "LEQ": 23,
  "LT": 60,
  "MODULO": 37,
  "MOVE_ALL_TO_RX": 24,
  "MOVE_FROM_R1": 25,
  "MOVE_FROM_R2": 26,
  "MOVE_R2_TO_R1": 27,
  "MOVE_TO_R1": 28,
  "MOVE_TO_R2": 29,
  "MOVE_TO_RX": 30,
  "MULTIPLY": 42,
  "MULTIPLY_3": 77,
  "MULTIPLY_4": 31,
  "NEQ": 110,
  "NOP": 32,
  "NOT": 33,
  "NUM": 73,
  "NUM_AND_SKIP": 74,
  "OR": 79,
  "OR_3": 34,
  "OR_4": 35,
  "PERCENT": 36,
  "POP": 39,
  "POWER": 40,
  "PUSH": 44,
  "PUSH_NUMS": 78,
  "SHIFT_EX": 41,
  "SKIP": 83,
  "STRING": 46,
  "STRING_AND_SKIP": 52,
  "SUBTRACT": 45,
  "SUBTRACT_3": 53,
  "SUBTRACT_4": 54,
  "THEN": 98,
  "TRUE": 55,
  "TRUE_AND_SKIP": 56,
  "UMINUS": 58,
  "UNSHIFT_EX": 59,
  "UNSHIFT_RX_TO_ALL": 64,
  "UNSHIFT_RX_TO_R12": 66,
  "UPLUS": 67,
  "VAR": 86,
  "VAR_TO_VALUE": 68,
  "VAR_VALUE": 69,
  "XOR": 88,
  "^": 81,
  "arglist": 102,
  "error": 2,
  "exp": 101,
  "input": 99,
  "line": 100,
  "s": 103,
  "|": 76,
  "~": 92
},
terminals_: {
  1: "EOF",
  2: "error",
  3: "ERROR",
  4: "ADD_4",
  5: "AND_3",
  6: "AND_4",
  7: "ASSIGN",
  8: "CONSTANT",
  9: "ELSE",
  10: "END",
  11: "EOL",
  12: "ERROR_AND_SKIP",
  13: "EXCHANGE_A_R1",
  14: "EXCHANGE_A_R2",
  15: "EXCHANGE_R1_R2",
  16: "EXEC",
  17: "FACTORIAL",
  18: "FALSE",
  19: "FALSE_AND_SKIP",
  20: "GEQ",
  21: "IF",
  22: "IF_ELSE",
  23: "LEQ",
  24: "MOVE_ALL_TO_RX",
  25: "MOVE_FROM_R1",
  26: "MOVE_FROM_R2",
  27: "MOVE_R2_TO_R1",
  28: "MOVE_TO_R1",
  29: "MOVE_TO_R2",
  30: "MOVE_TO_RX",
  31: "MULTIPLY_4",
  32: "NOP",
  33: "NOT",
  34: "OR_3",
  35: "OR_4",
  36: "PERCENT",
  37: "MODULO",
  38: "BITWISE_AND",
  39: "POP",
  40: "POWER",
  41: "SHIFT_EX",
  42: "MULTIPLY",
  43: "ADD",
  44: "PUSH",
  45: "SUBTRACT",
  46: "STRING",
  47: "DIVIDE",
  48: "FUNCTION_0",
  49: "FUNCTION_1",
  50: "FUNCTION_2",
  51: "FUNCTION_3",
  52: "STRING_AND_SKIP",
  53: "SUBTRACT_3",
  54: "SUBTRACT_4",
  55: "TRUE",
  56: "TRUE_AND_SKIP",
  57: "FUNCTION_N",
  58: "UMINUS",
  59: "UNSHIFT_EX",
  60: "LT",
  61: "EQ",
  62: "GT",
  63: "CONDITION",
  64: "UNSHIFT_RX_TO_ALL",
  65: "AND",
  66: "UNSHIFT_RX_TO_R12",
  67: "UPLUS",
  68: "VAR_TO_VALUE",
  69: "VAR_VALUE",
  70: "FUNCTION",
  71: "=",
  72: "(",
  73: "NUM",
  74: "NUM_AND_SKIP",
  75: ")",
  76: "|",
  77: "MULTIPLY_3",
  78: "PUSH_NUMS",
  79: "OR",
  80: "ADD_3",
  81: "^",
  82: "&",
  83: "SKIP",
  84: "+",
  85: "-",
  86: "VAR",
  87: "*",
  88: "XOR",
  89: "/",
  90: "%",
  91: "!",
  92: "~",
  93: "?",
  94: "BITWISE_XOR",
  95: ":",
  96: ",",
  97: "COMMENT",
  98: "THEN",
  103: "s",
  110: "NEQ",
  124: "BITWISE_OR",
  126: "BITWISE_NOT"
},
TERROR: 2,
EOF: 1,

// internals: defined here so the object *structure* doesn't get modified by parse() et al,
// thus helping JIT compilers like Chrome V8.
originalQuoteName: null,
originalParseError: null,
cleanupAfterParse: null,
constructParseErrorInfo: null,
yyMergeLocationInfo: null,

__reentrant_call_depth: 0, // INTERNAL USE ONLY
__error_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup
__error_recovery_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup

// APIs which will be set up depending on user action code analysis:
//yyRecovering: 0,
//yyErrOk: 0,
//yyClearIn: 0,

// Helper APIs
// -----------

// Helper function which can be overridden by user code later on: put suitable quotes around
// literal IDs in a description string.
quoteName: function parser_quoteName(id_str) {
    return '"' + id_str + '"';
},

// Return the name of the given symbol (terminal or non-terminal) as a string, when available.
//
// Return NULL when the symbol is unknown to the parser.
getSymbolName: function parser_getSymbolName(symbol) {
    if (this.terminals_[symbol]) {
        return this.terminals_[symbol];
    }

    // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.
    //
    // An example of this may be where a rule's action code contains a call like this:
    //
    //      parser.getSymbolName(#$)
    //
    // to obtain a human-readable name of the current grammar rule.
    var s = this.symbols_;
    for (var key in s) {
        if (s[key] === symbol) {
            return key;
        }
    }
    return null;
},

// Return a more-or-less human-readable description of the given symbol, when available,
// or the symbol itself, serving as its own 'description' for lack of something better to serve up.
//
// Return NULL when the symbol is unknown to the parser.
describeSymbol: function parser_describeSymbol(symbol) {
    if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {
        return this.terminal_descriptions_[symbol];
    } else if (symbol === this.EOF) {
        return 'end of input';
    }
    var id = this.getSymbolName(symbol);
    if (id) {
        return this.quoteName(id);
    }
    return null;
},

// Produce a (more or less) human-readable list of expected tokens at the point of failure.
//
// The produced list may contain token or token set descriptions instead of the tokens
// themselves to help turning this output into something that easier to read by humans
// unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,
// expected terminals and nonterminals is produced.
//
// The returned list (array) will not contain any duplicate entries.
collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {
    var TERROR = this.TERROR;
    var tokenset = [];
    var check = {};
    // Has this (error?) state been outfitted with a custom expectations description text for human consumption?
    // If so, use that one instead of the less palatable token set.
    if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {
        return [this.state_descriptions_[state]];
    }
    for (var p in this.table[state]) {
        p = +p;
        if (p !== TERROR) {
            var d = do_not_describe ? p : this.describeSymbol(p);
            if (d && !check[d]) {
                tokenset.push(d);
                check[d] = true; // Mark this token description as already mentioned to prevent outputting duplicate entries.
            }
        }
    }
    return tokenset;
},
productions_: bp({
  pop: u([
  s,
  [99, 3],
  100,
  100,
  s,
  [101, 35],
  102,
  102
]),
  rule: u([
  0,
  3,
  3,
  s,
  [1, 5],
  2,
  1,
  3,
  2,
  3,
  4,
  s,
  [3, 17],
  2,
  2,
  c,
  [3, 3],
  2,
  2,
  4,
  3,
  1,
  2
])
}),
performAction: function parser__PerformAction(yystate /* action[1] */, yysp, yyvstack) {

          /* this == yyval */

          // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!
          var yy = this.yy;
          var yyparser = yy.parser;
          var yylexer = yy.lexer;

          

          switch (yystate) {
case 0:
    /*! Production::    $accept : input $end */

    // default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,-,-,-,-):
    this.$ = yyvstack[yysp - 1];
    // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,-,-,-,-)
    break;

case 1:
    /*! Production::    input : %epsilon */

    this.$ = [];
    break;

case 2:
    /*! Production::    input : input line EOL */

    yyvstack[yysp - 2].push(yyvstack[yysp - 1]);
    this.$ = yyvstack[yysp - 2];
    break;

case 3:
    /*! Production::    input : input COMMENT EOL */

    var comment = yyvstack[yysp - 1].split('\n');
    comment.forEach(function (cmtline) {
      yyvstack[yysp - 2].push('# ' + cmtline);
    });
    this.$ = yyvstack[yysp - 2];
    break;

case 4:
    /*! Production::    line : exp */

    console.log('expression result value: ', yyvstack[yysp]);
    this.$ = yyvstack[yysp];
    break;

case 5:
    /*! Production::    line : ERROR */

    console.log('expression result value: ERROR - erroneous input line');
    this.$ = 'ERROR: ', yyvstack[yysp];
    break;

case 6:
    /*! Production::    exp : NUM */

    this.$ = $( /* NUM */ 73, yyvstack[yysp]);
    break;

case 7:
    /*! Production::    exp : CONSTANT */

    this.$ = $( /* CONSTANT */ 8, yy.constants[yyvstack[yysp]].name);
    break;

case 8:
    /*! Production::    exp : VAR */

    this.$ = $( /* VAR */ 86, yy.variables[yyvstack[yysp]].name);
    break;

case 9:
    /*! Production::    exp : ASSIGN exp */

    /*
       Note: #assign is always to a simple variable, hence we don't need the `#VAR`
       token here: it is implicit as there's nothing else we can do.
    
       Technically, this is an AST optimization, but it's such a fundamental one
       we do it here instead of later.
    
       NOTE: #assign implies the presence of a VAR as lhs (left hand side) so it
       would only be cluttering the AST stream to have a #VAR# token in there:
       it is *implicit* to #assign!
     */
    this.$ = $( /* ASSIGN */ 7, yy.variables[yyvstack[yysp - 1]].name, '=', __(yyvstack[yysp], 0,  /* ASSIGN */ 7));
    //$$ = yy.variables[$ASSIGN].name = $exp;
    break;

case 10:
    /*! Production::    exp : FUNCTION_0 */

    this.$ = $( /* FUNCTION_0 */ 48, yy.functions[yyvstack[yysp]].name);
    break;

case 11:
    /*! Production::    exp : FUNCTION arglist END */

    //$$ = $(#FUNCTION#, yy.functions[$FUNCTION_0].name, arglist);
    yyvstack[yysp - 1].unshift( /* FUNCTION */ 70, yy.functions[$FUNCTION_0].name);
    this.$ = $.apply(this, arglist);
    break;

case 12:
    /*! Production::    exp : FUNCTION_1 exp */

    this.$ = $( /* FUNCTION_1 */ 49, yy.functions[yyvstack[yysp - 1]].name, yyvstack[yysp]);
    break;

case 13:
    /*! Production::    exp : FUNCTION_2 exp exp */

    this.$ = $( /* FUNCTION_2 */ 50, yy.functions[yyvstack[yysp - 2]].name, yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 14:
    /*! Production::    exp : FUNCTION_3 exp exp exp */

    this.$ = $( /* FUNCTION_3 */ 51, yy.functions[yyvstack[yysp - 3]].name, yyvstack[yysp - 2], yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 15:
    /*! Production::    exp : EQ exp exp */

    this.$ = $( /* EQ */ 61, yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 16:
    /*! Production::    exp : NEQ exp exp */

    this.$ = $( /* NEQ */ 110, yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 17:
    /*! Production::    exp : LEQ exp exp */

    this.$ = $( /* LEQ */ 23, yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 18:
    /*! Production::    exp : GEQ exp exp */

    this.$ = $( /* GEQ */ 20, yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 19:
    /*! Production::    exp : LT exp exp */

    this.$ = $( /* LT */ 60, yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 20:
    /*! Production::    exp : GT exp exp */

    this.$ = $( /* GT */ 62, yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 21:
    /*! Production::    exp : OR exp exp */

    this.$ = $( /* OR */ 79, yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 22:
    /*! Production::    exp : XOR exp exp */

    this.$ = $( /* XOR */ 88, yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 23:
    /*! Production::    exp : AND exp exp */

    this.$ = $( /* AND */ 65, yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 24:
    /*! Production::    exp : BITWISE_OR exp exp */

    this.$ = $( /* BITWISE_OR */ 124, yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 25:
    /*! Production::    exp : BITWISE_XOR exp exp */

    this.$ = $( /* BITWISE_XOR */ 94, yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 26:
    /*! Production::    exp : BITWISE_AND exp exp */

    this.$ = $( /* BITWISE_AND */ 38, yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 27:
    /*! Production::    exp : ADD exp exp */

    this.$ = $( /* ADD */ 43, yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 28:
    /*! Production::    exp : SUBTRACT exp exp */

    this.$ = $( /* SUBTRACT */ 45, yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 29:
    /*! Production::    exp : MULTIPLY exp exp */

    this.$ = $( /* MULTIPLY */ 42, yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 30:
    /*! Production::    exp : DIVIDE exp exp */

    this.$ = $( /* DIVIDE */ 47, yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 31:
    /*! Production::    exp : MODULO exp exp */

    this.$ = $( /* MODULO */ 37, yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 32:
    /*! Production::    exp : UMINUS exp */

    this.$ = $( /* UMINUS */ 58, yyvstack[yysp]);
    break;

case 33:
    /*! Production::    exp : UPLUS exp */

    this.$ = $( /* UPLUS */ 67, yyvstack[yysp]);
    break;

case 34:
    /*! Production::    exp : POWER exp exp */

    this.$ = $( /* POWER */ 40, yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 35:
    /*! Production::    exp : PERCENT exp */

    this.$ = $( /* PERCENT */ 36, yyvstack[yysp]);
    break;

case 36:
    /*! Production::    exp : FACTORIAL exp */

    this.$ = $( /* FACTORIAL */ 17, yyvstack[yysp]);
    break;

case 37:
    /*! Production::    exp : BITWISE_NOT exp */

    this.$ = $( /* BITWISE_NOT */ 126, yyvstack[yysp]);
    break;

case 38:
    /*! Production::    exp : NOT exp */

    this.$ = $( /* NOT */ 33, yyvstack[yysp]);
    break;

case 39:
    /*! Production::    exp : IF_ELSE exp exp exp */

    this.$ = $( /* IF_ELSE */ 22, yyvstack[yysp - 2], yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 40:
    /*! Production::    exp : IF exp exp */

    this.$ = $( /* IF */ 21, yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 41:
    /*! Production::    arglist : exp */

    this.$ = [yyvstack[yysp]];
    break;

case 42:
    /*! Production::    arglist : arglist exp */

    this.$ = yyvstack[yysp - 1];
    this.$.push(yyvstack[yysp]);
    break;

}
},
table: bt({
  len: u([
  1,
  40,
  1,
  1,
  s,
  [0, 5],
  36,
  0,
  37,
  s,
  [36, 29],
  s,
  [0, 3],
  37,
  c,
  [38, 3],
  c,
  [25, 20],
  c,
  [28, 4],
  c,
  [26, 3],
  c,
  [69, 5],
  s,
  [0, 17],
  c,
  [19, 4]
]),
  symbol: u([
  99,
  1,
  3,
  7,
  8,
  17,
  s,
  [20, 4, 1],
  33,
  36,
  37,
  38,
  40,
  42,
  43,
  45,
  s,
  [47, 5, 1],
  58,
  60,
  61,
  62,
  65,
  67,
  70,
  73,
  79,
  86,
  88,
  94,
  97,
  100,
  101,
  110,
  124,
  126,
  11,
  11,
  c,
  [40, 32],
  c,
  [38, 4],
  c,
  [36, 33],
  102,
  c,
  [37, 36],
  c,
  [36, 1013],
  10,
  c,
  [901, 898]
]),
  type: u([
  0,
  1,
  s,
  [2, 34],
  0,
  0,
  s,
  [2, 37],
  c,
  [38, 36],
  c,
  [75, 37],
  c,
  [36, 1044],
  c,
  [901, 869]
]),
  state: u([
  1,
  2,
  4,
  43,
  45,
  44,
  s,
  [46, 29, 1],
  s,
  [76, 25, 1]
]),
  mode: u([
  s,
  [1, 2000]
]),
  goto: u([
  5,
  9,
  7,
  36,
  18,
  40,
  39,
  17,
  38,
  35,
  31,
  26,
  34,
  29,
  27,
  28,
  30,
  10,
  12,
  13,
  14,
  32,
  19,
  15,
  20,
  23,
  33,
  11,
  6,
  21,
  8,
  22,
  25,
  3,
  16,
  24,
  37,
  41,
  42,
  c,
  [38, 32],
  c,
  [37, 3],
  c,
  [35, 1052],
  75,
  c,
  [876, 873]
])
}),
defaultActions: bda({
  idx: u([
  0,
  s,
  [4, 5, 1],
  10,
  41,
  42,
  43,
  45,
  46,
  66,
  67,
  s,
  [69, 4, 1],
  75,
  76,
  77,
  s,
  [79, 18, 1],
  98,
  99,
  100
]),
  goto: u([
  1,
  s,
  [4, 5, 1],
  10,
  2,
  3,
  9,
  41,
  12,
  32,
  33,
  s,
  [35, 4, 1],
  11,
  42,
  13,
  s,
  [15, 17, 1],
  34,
  40,
  14,
  39
])
}),
parseError: function parseError(str, hash, ExceptionClass) {
    if (hash.recoverable) {
        if (typeof this.trace === 'function') {
            this.trace(str);
        }
        hash.destroy();             // destroy... well, *almost*!
    } else {
        if (typeof this.trace === 'function') {
            this.trace(str);
        }
        if (!ExceptionClass) {
            ExceptionClass = this.JisonParserError;
        }
        throw new ExceptionClass(str, hash);
    }
},
parse: function parse(input, globalSpace) {
    var self = this;
    var stack = new Array(128);         // token stack: stores token which leads to state at the same index (column storage)
    var sstack = new Array(128);        // state stack: stores states (column storage)

    var vstack = new Array(128);        // semantic value stack

    var table = this.table;
    var sp = 0;                         // 'stack pointer': index into the stacks


    


    var symbol = 0;



    var TERROR = this.TERROR;
    var EOF = this.EOF;
    var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = (this.options.errorRecoveryTokenDiscardCount | 0) || 3;
    var NO_ACTION = [0, 101 /* === table.length :: ensures that anyone using this new state will fail dramatically! */];

    var lexer;
    if (this.__lexer__) {
        lexer = this.__lexer__;
    } else {
        lexer = this.__lexer__ = Object.create(this.lexer);
    }

    var sharedState_yy = {
        parseError: undefined,
        quoteName: undefined,
        lexer: undefined,
        parser: undefined,
        pre_parse: undefined,
        post_parse: undefined,
        pre_lex: undefined,
        post_lex: undefined,
        globalSpace: globalSpace  // parseParams::globalSpace      // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!
    };

    var ASSERT;
    if (typeof assert !== 'function') {
        ASSERT = function JisonAssert(cond, msg) {
            if (!cond) {
                throw new Error('assertion failed: ' + (msg || '***'));
            }
        };
    } else {
        ASSERT = assert;
    }

    this.yyGetSharedState = function yyGetSharedState() {
        return sharedState_yy;
    };








    function shallow_copy_noclobber(dst, src) {
        for (var k in src) {
            if (typeof dst[k] === 'undefined' && Object.prototype.hasOwnProperty.call(src, k)) {
                dst[k] = src[k];
            }
        }
    }

    // copy state
    shallow_copy_noclobber(sharedState_yy, this.yy);

    sharedState_yy.lexer = lexer;
    sharedState_yy.parser = this;






    // Does the shared state override the default `parseError` that already comes with this instance?
    if (typeof sharedState_yy.parseError === 'function') {
        this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {
            if (!ExceptionClass) {
                ExceptionClass = this.JisonParserError;
            }
            return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);
        };
    } else {
        this.parseError = this.originalParseError;
    }

    // Does the shared state override the default `quoteName` that already comes with this instance?
    if (typeof sharedState_yy.quoteName === 'function') {
        this.quoteName = function quoteNameAlt(id_str) {
            return sharedState_yy.quoteName.call(this, id_str);
        };
    } else {
        this.quoteName = this.originalQuoteName;
    }

    // set up the cleanup function; make it an API so that external code can re-use this one in case of
    // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which
    // case this parse() API method doesn't come with a `finally { ... }` block any more!
    //
    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `sharedState`, etc. references will be *wrong*!
    this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {
        var rv;

        if (invoke_post_methods) {
            var hash;

            if (sharedState_yy.post_parse || this.post_parse) {
                // create an error hash info instance: we re-use this API in a **non-error situation**
                // as this one delivers all parser internals ready for access by userland code.
                hash = this.constructParseErrorInfo(null /* no error! */, null /* no exception! */, null, false);
            }

            if (sharedState_yy.post_parse) {
                rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }
            if (this.post_parse) {
                rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }

            // cleanup:
            if (hash && hash.destroy) {
                hash.destroy();
            }
        }




        // clean up the lingering lexer structures as well:
        if (lexer.cleanupAfterLex) {
            lexer.cleanupAfterLex(do_not_nuke_errorinfos);
        }

        // prevent lingering circular references from causing memory leaks:
        if (sharedState_yy) {
            sharedState_yy.lexer = undefined;
            sharedState_yy.parser = undefined;
            if (lexer.yy === sharedState_yy) {
                lexer.yy = undefined;
            }
        }
        sharedState_yy = undefined;
        this.parseError = this.originalParseError;
        this.quoteName = this.originalQuoteName;

        // nuke the vstack[] array at least as that one will still reference obsoleted user values.
        // To be safe, we nuke the other internal stack columns as well...
        stack.length = 0;               // fastest way to nuke an array without overly bothering the GC
        sstack.length = 0;

        vstack.length = 0;
        sp = 0;

        // nuke the error hash info instances created during this run.
        // Userland code must COPY any data/references
        // in the error hash instance(s) it is more permanently interested in.
        if (!do_not_nuke_errorinfos) {
            for (var i = this.__error_infos.length - 1; i >= 0; i--) {
                var el = this.__error_infos[i];
                if (el && typeof el.destroy === 'function') {
                    el.destroy();
                }
            }
            this.__error_infos.length = 0;


        }

        return resultValue;
    };






































































































































    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!
    this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {
        var pei = {
            errStr: msg,
            exception: ex,
            text: lexer.match,
            value: lexer.yytext,
            token: this.describeSymbol(symbol) || symbol,
            token_id: symbol,
            line: lexer.yylineno,

            expected: expected,
            recoverable: recoverable,
            state: state,
            action: action,
            new_state: newState,
            symbol_stack: stack,
            state_stack: sstack,
            value_stack: vstack,

            stack_pointer: sp,
            yy: sharedState_yy,
            lexer: lexer,
            parser: this,

            // and make sure the error info doesn't stay due to potential
            // ref cycle via userland code manipulations.
            // These would otherwise all be memory leak opportunities!
            //
            // Note that only array and object references are nuked as those
            // constitute the set of elements which can produce a cyclic ref.
            // The rest of the members is kept intact as they are harmless.
            destroy: function destructParseErrorInfo() {
                // remove cyclic references added to error info:
                // info.yy = null;
                // info.lexer = null;
                // info.value = null;
                // info.value_stack = null;
                // ...
                var rec = !!this.recoverable;
                for (var key in this) {
                    if (this.hasOwnProperty(key) && typeof key === 'object') {
                        this[key] = undefined;
                    }
                }
                this.recoverable = rec;
            }
        };
        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
        this.__error_infos.push(pei);
        return pei;
    };













    function getNonTerminalFromCode(symbol) {
        var tokenName = self.getSymbolName(symbol);
        if (!tokenName) {
            tokenName = symbol;
        }
        return tokenName;
    }


    function stdLex() {
        var token = lexer.lex();
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }

        return token || 1/* EOF */;
    }

    function fastLex() {
        var token = lexer.fastLex();
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }

        return token || 1/* EOF */;
    }

    var lex = stdLex;


    var state, action, r, t;
    var yyval = {
        $: true,
        _$: undefined,
        yy: sharedState_yy
    };
    var p;
    var yyrulelen;
    var this_production;
    var newState;
    var retval = false;




    lexer.setInput(input, sharedState_yy);

    // NOTE: we *assume* no lexer pre/post handlers are set up *after* 
    // this initial `setInput()` call: hence we can now check and decide
    // whether we'll go with the standard, slower, lex() API or the
    // `fast_lex()` one:
    if (typeof lexer.canIUse === 'function') {
        var lexerInfo = lexer.canIUse();
        if (lexerInfo.fastLex && typeof fastLex === 'function') {
            lex = fastLex;
        }
    } 



    vstack[sp] = null;
    sstack[sp] = 0;
    stack[sp] = 0;
    ++sp;





    if (this.pre_parse) {
        this.pre_parse.call(this, sharedState_yy);
    }
    if (sharedState_yy.pre_parse) {
        sharedState_yy.pre_parse.call(this, sharedState_yy);
    }

    newState = sstack[sp - 1];
    for (;;) {
        // retrieve state number from top of stack
        state = newState;               // sstack[sp - 1];

        // use default actions if available
        if (this.defaultActions[state]) {
            action = 2;
            newState = this.defaultActions[state];
        } else {
            // The single `==` condition below covers both these `===` comparisons in a single
            // operation:
            //
            //     if (symbol === null || typeof symbol === 'undefined') ...
            if (!symbol) {
                symbol = lex();
            }
            // read action for current state and first input
            t = (table[state] && table[state][symbol]) || NO_ACTION;
            newState = t[1];
            action = t[0];











            // handle parse error
            if (!action) {
                var errStr;
                var errSymbolDescr = (this.describeSymbol(symbol) || symbol);
                var expected = this.collect_expected_token_set(state);

                // Report error
                if (typeof lexer.yylineno === 'number') {
                    errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';
                } else {
                    errStr = 'Parse error: ';
                }
                if (typeof lexer.showPosition === 'function') {
                    errStr += '\n' + lexer.showPosition(79 - 10, 10) + '\n';
                }
                if (expected.length) {
                    errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;
                } else {
                    errStr += 'Unexpected ' + errSymbolDescr;
                }
                // we cannot recover from the error!
                p = this.constructParseErrorInfo(errStr, null, expected, false);
                r = this.parseError(p.errStr, p, this.JisonParserError);
                if (typeof r !== 'undefined') {
                    retval = r;
                }
                break;
            }


        }










        switch (action) {
        // catch misc. parse failures:
        default:
            // this shouldn't happen, unless resolve defaults are off
            if (action instanceof Array) {
                p = this.constructParseErrorInfo('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, null, null, false);
                r = this.parseError(p.errStr, p, this.JisonParserError);
                if (typeof r !== 'undefined') {
                    retval = r;
                }
                break;
            }
            // Another case of better safe than sorry: in case state transitions come out of another error recovery process
            // or a buggy LUT (LookUp Table):
            p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);
            r = this.parseError(p.errStr, p, this.JisonParserError);
            if (typeof r !== 'undefined') {
                retval = r;
            }
            break;

        // shift:
        case 1:
            stack[sp] = symbol;
            vstack[sp] = lexer.yytext;

            sstack[sp] = newState; // push state

            ++sp;
            symbol = 0;




            // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:




            continue;

        // reduce:
        case 2:



            this_production = this.productions_[newState - 1];  // `this.productions_[]` is zero-based indexed while states start from 1 upwards...
            yyrulelen = this_production[1];










            r = this.performAction.call(yyval, newState, sp - 1, vstack);

            if (typeof r !== 'undefined') {
                retval = r;
                break;
            }

            // pop off stack
            sp -= yyrulelen;

            // don't overwrite the `symbol` variable: use a local var to speed things up:
            var ntsymbol = this_production[0];    // push nonterminal (reduce)
            stack[sp] = ntsymbol;
            vstack[sp] = yyval.$;

            // goto new state = table[STATE][NONTERMINAL]
            newState = table[sstack[sp - 1]][ntsymbol];
            sstack[sp] = newState;
            ++sp;









            continue;

        // accept:
        case 3:
            if (sp !== -2) {
                retval = true;
                // Return the `$accept` rule's `$$` result, if available.
                //
                // Also note that JISON always adds this top-most `$accept` rule (with implicit,
                // default, action):
                //
                //     $accept: <startSymbol> $end
                //                  %{ $$ = $1; @$ = @1; %}
                //
                // which, combined with the parse kernel's `$accept` state behaviour coded below,
                // will produce the `$$` value output of the <startSymbol> rule as the parse result,
                // IFF that result is *not* `undefined`. (See also the parser kernel code.)
                //
                // In code:
                //
                //                  %{
                //                      @$ = @1;            // if location tracking support is included
                //                      if (typeof $1 !== 'undefined')
                //                          return $1;
                //                      else
                //                          return true;           // the default parse result if the rule actions don't produce anything
                //                  %}
                sp--;
                if (typeof vstack[sp] !== 'undefined') {
                    retval = vstack[sp];
                }
            }
            break;
        }

        // break out of loop: we accept or fail with error
        break;
    }
    
    // ... AND FINALLY ...

    retval = this.cleanupAfterParse(retval, true, true);


    

    return retval;
}
};
parser.originalParseError = parser.parseError;
parser.originalQuoteName = parser.quoteName;

/* @const */ var precedence_order = {
   /* NUM */ 73:            1,
   /* ADD */ 43:            100,
   /* AND */ 65:            175,
   /* ASSIGN */ 7:         300,
   /* BITWISE_AND */ 38:    50,
   /* BITWISE_NOT */ 126:    20,
   /* BITWISE_OR */ 124:     50,
   /* BITWISE_XOR */ 94:    50,
   /* CONSTANT */ 8:       1,
   /* DIVIDE */ 47:         80,
   /* EQ */ 61:             150,
   /* FACTORIAL */ 17:      20,
   /* FUNCTION */ 70:       1,
   /* FUNCTION_0 */ 48:     1,
   /* FUNCTION_1 */ 49:     1,
   /* FUNCTION_2 */ 50:     1,
   /* FUNCTION_3 */ 51:     1,
   /* GEQ */ 20:            150,
   /* GT */ 62:             150,
   /* IF */ 21:             200,
   /* IF_ELSE */ 22:        200,
   /* LEQ */ 23:            150,
   /* LT */ 60:             150,
   /* MODULO */ 37:         80,
   /* MULTIPLY */ 42:       90,
   /* NEQ */ 110:            150,
   /* NOT */ 33:            20,
   /* OR */ 79:             175,
   /* PERCENT */ 36:        20,
   /* POWER */ 40:          70,
   /* SUBTRACT */ 45:       100,
   /* UMINUS */ 58:         20,
   /* UPLUS */ 67:          20,
   /* VAR */ 86:            1,
   /* XOR */ 88:            175,
};
/* @const */ var associativity = {
   /* NUM */ 73:            0,
   /* ADD */ 43:            2,
   /* AND */ 65:            2,
   /* ASSIGN */ 7:         2,
   /* BITWISE_AND */ 38:    2,
   /* BITWISE_NOT */ 126:    1,
   /* BITWISE_OR */ 124:     2,
   /* BITWISE_XOR */ 94:    2,
   /* CONSTANT */ 8:       0,
   /* DIVIDE */ 47:         2,
   /* EQ */ 61:             2,
   /* FACTORIAL */ 17:      2,
   /* FUNCTION */ 70:       0,
   /* FUNCTION_0 */ 48:     0,
   /* FUNCTION_1 */ 49:     0,
   /* FUNCTION_2 */ 50:     0,
   /* FUNCTION_3 */ 51:     0,
   /* GEQ */ 20:            2,
   /* GT */ 62:             2,
   /* IF */ 21:             2,
   /* IF_ELSE */ 22:        2,
   /* LEQ */ 23:            2,
   /* LT */ 60:             2,
   /* MODULO */ 37:         2,
   /* MULTIPLY */ 42:       2,
   /* NEQ */ 110:            2,
   /* NOT */ 33:            1,
   /* OR */ 79:             2,
   /* PERCENT */ 36:        1,
   /* POWER */ 40:          2,
   /* SUBTRACT */ 45:       2,
   /* UMINUS */ 58:         1,
   /* UPLUS */ 67:          1,
   /* VAR */ 86:            0,
   /* XOR */ 88:            2,
};
/* @const */ var display = {
   /* NUM */ 73:                    '1',
   /* ADD */ 43:                    '(1) + (2)',
   /* AND */ 65:                    '(1) && (2)',
   /* ASSIGN */ 7:                 '1 = (2)',
   /* BITWISE_AND */ 38:            '(1) & (2)',
   /* BITWISE_NOT */ 126:            '~(1)',
   /* BITWISE_OR */ 124:             '(1) | (2)',
   /* BITWISE_XOR */ 94:            '(1) ^ (2)',
   /* CONSTANT */ 8:               '1',
   /* DIVIDE */ 47:                 '(1) / (2)',
   /* EQ */ 61:                     '(1) == (2)',
   /* FACTORIAL */ 17:              '(1)!',
  // #FUNCTION# receives special treatment:
   /* FUNCTION */ 70:               '1((2)...3...X..., (3)...)',
   /* FUNCTION_0 */ 48:             '1()', 
   /* FUNCTION_1 */ 49:             '1((2))',
   /* FUNCTION_2 */ 50:             '1((2), (3))',
   /* FUNCTION_3 */ 51:             '1((2), (3), (4))',
   /* GEQ */ 20:                    '(1) >= (2)',
   /* GT */ 62:                     '(1) > (2)',
   /* IF */ 21:                     'IF (:1:) THEN (2)',
   /* IF_ELSE */ 22:                '(1) ? (2) : (3)',
   /* LEQ */ 23:                    '(1) <= (2)',
   /* LT */ 60:                     '(1) < (2)',
   /* MODULO */ 37:                 '(1) % (2)',
   /* MULTIPLY */ 42:               '(1) * (2)',
   /* NEQ */ 110:                    '(1) != (2)',
   /* NOT */ 33:                    '!(1)',
   /* OR */ 79:                     '(1) || (2)',
   /* PERCENT */ 36:                '(1)%',
   /* POWER */ 40:                  '(1) ** (2)',
   /* SUBTRACT */ 45:               '(1) - (2)',
   /* UMINUS */ 58:                 '-(1)',
   /* UPLUS */ 67:                  '+(1)',
   /* VAR */ 86:                    '1',
   /* XOR */ 88:                    '(1) XOR (2)',
};

var argument_regex = [
  /[\[\{\(:'"]?\b1\b[\]\}\):'"]?/,
];


function escape_quotes(s, q) {
  s = s
  // escapes escape characters before we add any of our own
  .replace(/\\/g, '\\\\')
  // escape the quote `q`:
  .replace(new RegExp(q, 'g'), '\\' + q);

  return s;  
}

function $(op /* ,... */ ) {
  // first check how many args we got:
  var args = Array.prototype.slice.call(arguments, 1);
  var cnt = args.length;

  // - if any arg contains content which carries *lower* precedences, it must be braced.
  // - if the left/right argument contains content with the *same* precedence and is not supposed to, given this op's *associativity*, then it must be braced.
  var brace_me = new Array(cnt);
  var my_prec = precedence_order[op] || 0;    // precedence is higher when number is LOWER!
  var my_assoc = associativity[op] || 0;

  var s = display[op];

  // before we go and replace all the arguments, we have one prep job to do first:
  // when we're printing a function which accepts an arbitrary number of arguments,
  // e.g. `average(...)`, then we must facilitate the argument templating process 
  // below for *any* number of arguments!
  //
  // We accomplish this by preprocessing the display template to fit the number
  // of available arguments:
  // we inject the selected format for each of the arguments available in a given
  // argument index range, which can be
  // - from N to infinity, i.e. the entire remainder of the argument set
  // - from N to -M, i.e. the arguments from index N up to the argument at 
  //   index LENGTH+M, for example with argument set of 10 arguments and M = -2,
  //   N = 5 we would have to print the arguments 5, 6, 7, 8 (=10-2). This allows
  //   for printing functions which have reserved special treatment for their
  //   last few input parameters.
  // - from N to M, i.e. the arguments from index N up to and including index M.
  //   When M is specified with an explicit '+' it is a count rather than an offset,
  //   M = +2 means the range spans 2 arguments exactly.
  //
  // The template format also includes the ability to specify exactly what format
  // you wish to apply to each of the arguments: that's the third parameter of
  // a range set spec: `...N...M...fmt...`, where `fmt` can use any number to
  // represent the argument at hand.
  //
  // Note that 'infinity' is represented by 'X' in the spec:
  function adjust_one_rangespec(s, n1, m2, f3) {
    var n = parseInt(n1);
    var m = (m2 === 'X' ? cnt - 1 : parseInt(m2));
    if (m2[0] === '-') {
      m = cnt - Math.max(-m, 1);
    } else if (mm[0] === '+') {
      m = Math.min(cnt - 1, m + n);
    }
    // and replace the entire thing, using format f3 for every arg and 'joining'
    // the whole party: 
    var out = [];
    for (var i = n; i <= m; i++) {
      out.push(f3
        .replace(/[0-9]+/, i)
      );
    }
    return out.join('');
  }

  s = s.replace(/\.\.\.([0-9]+)\.\.\.(X|[-+][0-9]+)\.\.\.(.*?)\.\.\./g, adjust_one_rangespec);
console.log('$() display:', s, op, arguments);

  // now print every arg using the template:
  for (var i = 0; i < cnt; i++) {
    // is argument an 'augmented item'?
    var a = args[i];
    if (a.augmented) {
      // check precedence:
      brace_me[i] = (a.precedence > my_prec);
      // check associativity?
      if (a.precedence >= my_prec && my_assoc != i) {
        brace_me[i] = true; 
      }
    }

    // replace arg [0] via regex `/1/`, etc.:
    var re = argument_regex[i];
    if (!re) {
      // and when we have run out of arg specs, we just re-use the one for the previous argument
      re = argument_regex[i - 1];
      var re_s = '' + re;
      re_s = re_s.replace(/[0-9]+/, function (m) {
        var j = parseInt(m);
        j++;
        return '' + j;
      })
      .replace(/^\/(.*)\/$/, '$1');
      re = new RegExp(re_s);
      // and cache this one, if it is sane to do (not sane is when you cache the regex for the 100th argument, for example)
      if (i < 42) {
console.warn('cache regex for index ', i, re);
        argument_regex[i] = re;
      }
    }
console.log('$() replace argument at index:', i, a, brace_me[i], s, re, ' ::: ', arguments);

    s = s
    .replace(re, function (m) {
      var s = (a.augmented ? a.display : '' + a);

      // detect formatting requirements:
      switch (m[0]) {
      // :1: --> plain 1, no braces, even when we might previously have detected that they would be needed
      case ':':
        // s = s;
        break;
      
      // (1) --> optional braces around 1
      // {1} --> optional curly braces around 1
      // [1] --> optional square brackets around 1
      // 
      // Note: if we'd wanted *mandatory* braces around 1, we would have specced it as `(:1:)` instead!
      case '(':
      case '{':
      case '[':
        if (brace_me[i]) {
          s = m[0] + s + m[m.length - 1];
        }
        break;

      // '1' --> mandatory quotes around 1
      case "'":
      case '"':
        s = m[0] + escape_quotes(s, m[0]) + m[m.length - 1];
        break;

      // 1 --> just plain 1, no braces:
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        // s = s;
        break;

      // ?1? --> anything else surrounding 1 is a spec error.
      default:
        throw new Error('arg fmt spec error at index ' + i + ': illegal spec = ' + re);
      }

      return s;
    });
  }

  var rv = {
    augmented: true,
    display: s,
    precedence: my_prec,
  };  
  console.warn('$() output: ', rv, arguments);
  return rv;
}

function Parser() {
  this.yy = {};
}
Parser.prototype = parser;
parser.Parser = Parser;

return new Parser();
})();

        


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
  exports.parser = compiled_calc_print;
  exports.Parser = compiled_calc_print.Parser;
  exports.parse = function () {
    return compiled_calc_print.parse.apply(compiled_calc_print, arguments);
  };
  
}


// End Of Include by Jison: ./output/compiled_calc/compiled_calc_print.js



// Included by Jison: ./output/compiled_calc/compiled_calc_sorcerer.js:


/* parser generated by jison 0.6.1-214 */

/*
 * Returns a Parser object of the following structure:
 *
 *  Parser: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a derivative/copy of this one,
 *               not a direct reference!
 *  }
 *
 *  Parser.prototype: {
 *    yy: {},
 *    EOF: 1,
 *    TERROR: 2,
 *
 *    trace: function(errorMessage, ...),
 *
 *    JisonParserError: function(msg, hash),
 *
 *    quoteName: function(name),
 *               Helper function which can be overridden by user code later on: put suitable
 *               quotes around literal IDs in a description string.
 *
 *    originalQuoteName: function(name),
 *               The basic quoteName handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function
 *               at the end of the `parse()`.
 *
 *    describeSymbol: function(symbol),
 *               Return a more-or-less human-readable description of the given symbol, when
 *               available, or the symbol itself, serving as its own 'description' for lack
 *               of something better to serve up.
 *
 *               Return NULL when the symbol is unknown to the parser.
 *
 *    symbols_: {associative list: name ==> number},
 *    terminals_: {associative list: number ==> name},
 *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},
 *    terminal_descriptions_: (if there are any) {associative list: number ==> description},
 *    productions_: [...],
 *
 *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)
 *                             to store/reference the rule value `$$` and location info `@$`.
 *
 *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets
 *                 to see the same object via the `this` reference, i.e. if you wish to carry custom
 *                 data from one reduce action through to the next within a single parse run, then you
 *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.
 *
 *                 `this.yy` is a direct reference to the `yy` shared state object.
 *
 *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`
 *                 object at `parse()` start and are therefore available to the action code via the
 *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from
 *                 the %parse-param` list.
 *
 *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used
 *                             to match this rule. This is *not* the look-ahead token, but the last token
 *                             that's actually part of this rule.
 *
 *                 Formulated another way, `yytext` is the value of the token immediately preceeding
 *                 the current look-ahead token.
 *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.
 *
 *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.
 *
 *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.
 *
 *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.
 *
 *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead
 *                               of an empty object when no suitable location info can be provided.
 *
 *               - `yystate` : the current parser state number, used internally for dispatching and
 *                               executing the action code chunk matching the rule currently being reduced.
 *
 *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *                 Also note that you can access this and other stack index values using the new double-hash
 *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things
 *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.
 *                 This is made available to write very advanced grammar action rules, e.g. when you want
 *                 to investigate the parse state stack in your action code, which would, for example,
 *                 be relevant when you wish to implement error diagnostics and reporting schemes similar
 *                 to the work described here:
 *
 *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.
 *                   In Journées Francophones des Languages Applicatifs.
 *
 *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.
 *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631–640.
 *
 *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.
 *                             constructs.
 *
 *               - `yylstack`: reference to the parser token location stack. Also accessed via
 *                             the `@1` etc. constructs.
 *
 *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are
 *                             UNDEFINED rather than an empty (location) object, when the lexer/parser
 *                             action code did not provide a suitable location info object when such a
 *                             slot was filled!
 *
 *               - `yystack` : reference to the parser token id stack. Also accessed via the
 *                             `#1` etc. constructs.
 *
 *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to
 *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might
 *                 want access this array for your own purposes, such as error analysis as mentioned above!
 *
 *                 Note that this stack stores the current stack of *tokens*, that is the sequence of
 *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*
 *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and
 *                 *reduced*.
 *
 *               - `yysstack`: reference to the parser state stack. This one carries the internal parser
 *                             *states* such as the one in `yystate`, which are used to represent
 *                             the parser state machine in the *parse table*. *Very* *internal* stuff,
 *                             what can I say? If you access this one, you're clearly doing wicked things
 *
 *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your
 *                             grammar definition file.
 *
 *    table: [...],
 *               State transition table
 *               ----------------------
 *
 *               index levels are:
 *               - `state`  --> hash table
 *               - `symbol` --> action (number or array)
 *
 *                 If the `action` is an array, these are the elements' meaning:
 *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept
 *                 - index [1]: GOTO `state`
 *
 *                 If the `action` is a number, it is the GOTO `state`
 *
 *    defaultActions: {...},
 *
 *    parseError: function(str, hash, ExceptionClass),
 *    yyError: function(str, ...),
 *    yyRecovering: function(),
 *    yyErrOk: function(),
 *    yyClearIn: function(),
 *
 *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this parser kernel in many places; example usage:
 *
 *                   var infoObj = parser.constructParseErrorInfo('fail!', null,
 *                                     parser.collect_expected_token_set(state), true);
 *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);
 *
 *    originalParseError: function(str, hash, ExceptionClass),
 *               The basic `parseError` handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function
 *               at the end of the `parse()`.
 *
 *    options: { ... parser %options ... },
 *
 *    parse: function(input[, args...]),
 *               Parse the given `input` and return the parsed value (or `true` when none was provided by
 *               the root action, in which case the parser is acting as a *matcher*).
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the jison run-time;
 *               when such a collision is detected an exception is thrown to prevent the generated run-time
 *               from silently accepting this confusing and potentially hazardous situation!
 *
 *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in
 *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state
 *               object and any collision with those will be reported by the lexer via a thrown exception.
 *
 *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown
 *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY
 *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and
 *               the internal parser gets properly garbage collected under these particular circumstances.
 *
 *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API can be invoked to calculate a spanning `yylloc` location info object.
 *
 *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case
 *               this function will attempt to obtain a suitable location marker by inspecting the location stack
 *               backwards.
 *
 *               For more info see the documentation comment further below, immediately above this function's
 *               implementation.
 *
 *    lexer: {
 *        yy: {...},           A reference to the so-called "shared state" `yy` once
 *                             received via a call to the `.setInput(input, yy)` lexer API.
 *        EOF: 1,
 *        ERROR: 2,
 *        JisonLexerError: function(msg, hash),
 *        parseError: function(str, hash, ExceptionClass),
 *        setInput: function(input, [yy]),
 *        input: function(),
 *        unput: function(str),
 *        more: function(),
 *        reject: function(),
 *        less: function(n),
 *        pastInput: function(n),
 *        upcomingInput: function(n),
 *        showPosition: function(),
 *        test_match: function(regex_match_array, rule_index, ...),
 *        next: function(...),
 *        lex: function(...),
 *        begin: function(condition),
 *        pushState: function(condition),
 *        popState: function(),
 *        topState: function(),
 *        _currentRules: function(),
 *        stateStackSize: function(),
 *        cleanupAfterLex: function()
 *
 *        options: { ... lexer %options ... },
 *
 *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),
 *        rules: [...],
 *        conditions: {associative list: name ==> set},
 *    }
 *  }
 *
 *
 *  token location info (@$, _$, etc.): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer and
 * parser errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *  }
 *
 * parser (grammar) errors will also provide these additional members:
 *
 *  {
 *    expected:    (array describing the set of expected tokens;
 *                  may be UNDEFINED when we cannot easily produce such a set)
 *    state:       (integer (or array when the table includes grammar collisions);
 *                  represents the current internal state of the parser kernel.
 *                  can, for example, be used to pass to the `collect_expected_token_set()`
 *                  API to obtain the expected token set)
 *    action:      (integer; represents the current internal action which will be executed)
 *    new_state:   (integer; represents the next/planned internal state, once the current
 *                  action has executed)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *    parser:      (reference to the current parser instance)
 *  }
 *
 * while `this` will reference the current parser instance.
 *
 * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    lexer:       (reference to the current lexer instance which reported the error)
 *  }
 *
 * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired
 * from either the parser or lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    exception:   (reference to the exception thrown)
 *  }
 *
 * Please do note that in the latter situation, the `expected` field will be omitted as
 * this type of failure is assumed not to be due to *parse errors* but rather due to user
 * action code in either parser or lexer failing unexpectedly.
 *
 * ---
 *
 * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.
 * These options are available:
 *
 * ### options which are global for all parser instances
 *
 *  Parser.pre_parse: function(yy)
 *                 optional: you can specify a pre_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`.
 *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: you can specify a post_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`. When it does not return any value,
 *                 the parser will return the original `retval`.
 *
 * ### options which can be set up per parser instance
 *
 *  yy: {
 *      pre_parse:  function(yy)
 *                 optional: is invoked before the parse cycle starts (and before the first
 *                 invocation of `lex()`) but immediately after the invocation of
 *                 `parser.pre_parse()`).
 *      post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: is invoked when the parse terminates due to success ('accept')
 *                 or failure (even when exceptions are thrown).
 *                 `retval` contains the return value to be produced by `Parser.parse()`;
 *                 this function can override the return value by returning another.
 *                 When it does not return any value, the parser will return the original
 *                 `retval`.
 *                 This function is invoked immediately before `parser.post_parse()`.
 *
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *      quoteName: function(name),
 *                 optional: overrides the default `quoteName` function.
 *  }
 *
 *  parser.lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */

        
    
            var compiled_calc_sorcerer = (function () {

// See also:
// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
// with userland code which might access the derived class in a 'classic' way.
function JisonParserError(msg, hash) {
    Object.defineProperty(this, 'name', {
        enumerable: false,
        writable: false,
        value: 'JisonParserError'
    });

    if (msg == null) msg = '???';

    Object.defineProperty(this, 'message', {
        enumerable: false,
        writable: true,
        value: msg
    });

    this.hash = hash;

    var stacktrace;
    if (hash && hash.exception instanceof Error) {
        var ex2 = hash.exception;
        this.message = ex2.message || msg;
        stacktrace = ex2.stack;
    }
    if (!stacktrace) {
        if (Error.hasOwnProperty('captureStackTrace')) {        // V8/Chrome engine
            Error.captureStackTrace(this, this.constructor);
        } else {
            stacktrace = (new Error(msg)).stack;
        }
    }
    if (stacktrace) {
        Object.defineProperty(this, 'stack', {
            enumerable: false,
            writable: false,
            value: stacktrace
        });
    }
}

if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);
} else {
    JisonParserError.prototype = Object.create(Error.prototype);
}
JisonParserError.prototype.constructor = JisonParserError;
JisonParserError.prototype.name = 'JisonParserError';



        // helper: reconstruct the productions[] table
        function bp(s) {
            var rv = [];
            var p = s.pop;
            var r = s.rule;
            for (var i = 0, l = p.length; i < l; i++) {
                rv.push([
                    p[i],
                    r[i]
                ]);
            }
            return rv;
        }
    


        // helper: reconstruct the defaultActions[] table
        function bda(s) {
            var rv = {};
            var d = s.idx;
            var g = s.goto;
            for (var i = 0, l = d.length; i < l; i++) {
                var j = d[i];
                rv[j] = g[i];
            }
            return rv;
        }
    


        // helper: reconstruct the 'goto' table
        function bt(s) {
            var rv = [];
            var d = s.len;
            var y = s.symbol;
            var t = s.type;
            var a = s.state;
            var m = s.mode;
            var g = s.goto;
            for (var i = 0, l = d.length; i < l; i++) {
                var n = d[i];
                var q = {};
                for (var j = 0; j < n; j++) {
                    var z = y.shift();
                    switch (t.shift()) {
                    case 2:
                        q[z] = [
                            m.shift(),
                            g.shift()
                        ];
                        break;

                    case 0:
                        q[z] = a.shift();
                        break;

                    default:
                        // type === 1: accept
                        q[z] = [
                            3
                        ];
                    }
                }
                rv.push(q);
            }
            return rv;
        }
    


        // helper: runlength encoding with increment step: code, length: step (default step = 0)
        // `this` references an array
        function s(c, l, a) {
            a = a || 0;
            for (var i = 0; i < l; i++) {
                this.push(c);
                c += a;
            }
        }

        // helper: duplicate sequence from *relative* offset and length.
        // `this` references an array
        function c(i, l) {
            i = this.length - i;
            for (l += i; i < l; i++) {
                this.push(this[i]);
            }
        }

        // helper: unpack an array using helpers and data, all passed in an array argument 'a'.
        function u(a) {
            var rv = [];
            for (var i = 0, l = a.length; i < l; i++) {
                var e = a[i];
                // Is this entry a helper function?
                if (typeof e === 'function') {
                    i++;
                    e.apply(rv, a[i]);
                } else {
                    rv.push(e);
                }
            }
            return rv;
        }
    

var parser = {
    // Code Generator Information Report
    // ---------------------------------
    //
    // Options:
    //
    //   default action mode: ............. none,merge
    //   try..catch: ...................... true
    //   default resolve on conflict: ..... true
    //   on-demand look-ahead: ............ false
    //   error recovery token skip maximum: 3
    //   yyerror in parse actions is: ..... NOT recoverable,
    //   yyerror in lexer actions and other non-fatal lexer are:
    //   .................................. NOT recoverable,
    //   debug grammar/output: ............ false
    //   has partial LR conflict upgrade:   true
    //   rudimentary token-stack support:   false
    //   parser table compression mode: ... 2
    //   export debug tables: ............. false
    //   export *all* tables: ............. false
    //   module type: ..................... commonjs
    //   parser engine type: .............. lalr
    //   output main() in the module: ..... true
    //   has user-specified main(): ....... false
    //   has user-specified require()/import modules for main():
    //   .................................. false
    //   number of expected conflicts: .... 0
    //
    //
    // Parser Analysis flags:
    //
    //   no significant actions (parser is a language matcher only):
    //   .................................. false
    //   uses yyleng: ..................... false
    //   uses yylineno: ................... false
    //   uses yytext: ..................... false
    //   uses yylloc: ..................... false
    //   uses ParseError API: ............. false
    //   uses YYERROR: .................... false
    //   uses YYRECOVERING: ............... false
    //   uses YYERROK: .................... false
    //   uses YYCLEARIN: .................. false
    //   tracks rule values: .............. true
    //   assigns rule values: ............. true
    //   uses location tracking: .......... false
    //   assigns location: ................ false
    //   uses yystack: .................... false
    //   uses yysstack: ................... false
    //   uses yysp: ....................... true
    //   uses yyrulelength: ............... false
    //   uses yyMergeLocationInfo API: .... false
    //   has error recovery: .............. false
    //   has error reporting: ............. false
    //
    // --------- END OF REPORT -----------

trace: function no_op_trace() {},
JisonParserError: JisonParserError,
yy: {},
options: {
  type: "lalr",
  hasPartialLrUpgradeOnConflict: true,
  errorRecoveryTokenDiscardCount: 3
},
symbols_: {
  "!": 91,
  "$accept": 0,
  "$end": 1,
  "%": 90,
  "&": 82,
  "(": 72,
  ")": 75,
  "*": 87,
  "+": 84,
  ",": 96,
  "-": 85,
  "/": 89,
  ":": 95,
  "=": 71,
  "?": 93,
  "ADD": 43,
  "ADD_3": 80,
  "ADD_4": 4,
  "AND": 65,
  "AND_3": 5,
  "AND_4": 6,
  "ASSIGN": 7,
  "BITWISE_AND": 38,
  "BITWISE_NOT": 126,
  "BITWISE_OR": 124,
  "BITWISE_XOR": 94,
  "COMMENT": 97,
  "CONDITION": 63,
  "CONSTANT": 8,
  "DIVIDE": 47,
  "ELSE": 9,
  "END": 10,
  "EOF": 1,
  "EOL": 11,
  "EQ": 61,
  "ERROR": 3,
  "ERROR_AND_SKIP": 12,
  "EXCHANGE_A_R1": 13,
  "EXCHANGE_A_R2": 14,
  "EXCHANGE_R1_R2": 15,
  "EXEC": 16,
  "FACTORIAL": 17,
  "FALSE": 18,
  "FALSE_AND_SKIP": 19,
  "FUNCTION": 70,
  "FUNCTION_0": 48,
  "FUNCTION_1": 49,
  "FUNCTION_2": 50,
  "FUNCTION_3": 51,
  "FUNCTION_N": 57,
  "GEQ": 20,
  "GT": 62,
  "IF": 21,
  "IF_ELSE": 22,
  "LEQ": 23,
  "LT": 60,
  "MODULO": 37,
  "MOVE_ALL_TO_RX": 24,
  "MOVE_FROM_R1": 25,
  "MOVE_FROM_R2": 26,
  "MOVE_R2_TO_R1": 27,
  "MOVE_TO_R1": 28,
  "MOVE_TO_R2": 29,
  "MOVE_TO_RX": 30,
  "MULTIPLY": 42,
  "MULTIPLY_3": 77,
  "MULTIPLY_4": 31,
  "NEQ": 110,
  "NOP": 32,
  "NOT": 33,
  "NUM": 73,
  "NUM_AND_SKIP": 74,
  "OR": 79,
  "OR_3": 34,
  "OR_4": 35,
  "PERCENT": 36,
  "POP": 39,
  "POWER": 40,
  "PUSH": 44,
  "PUSH_NUMS": 78,
  "SHIFT_EX": 41,
  "SKIP": 83,
  "STRING": 46,
  "STRING_AND_SKIP": 52,
  "SUBTRACT": 45,
  "SUBTRACT_3": 53,
  "SUBTRACT_4": 54,
  "THEN": 98,
  "TRUE": 55,
  "TRUE_AND_SKIP": 56,
  "UMINUS": 58,
  "UNSHIFT_EX": 59,
  "UNSHIFT_RX_TO_ALL": 64,
  "UNSHIFT_RX_TO_R12": 66,
  "UPLUS": 67,
  "VAR": 86,
  "VAR_TO_VALUE": 68,
  "VAR_VALUE": 69,
  "XOR": 88,
  "^": 81,
  "arglist": 102,
  "error": 2,
  "exp": 101,
  "input": 99,
  "line": 100,
  "s": 103,
  "|": 76,
  "~": 92
},
terminals_: {
  1: "EOF",
  2: "error",
  3: "ERROR",
  4: "ADD_4",
  5: "AND_3",
  6: "AND_4",
  7: "ASSIGN",
  8: "CONSTANT",
  9: "ELSE",
  10: "END",
  11: "EOL",
  12: "ERROR_AND_SKIP",
  13: "EXCHANGE_A_R1",
  14: "EXCHANGE_A_R2",
  15: "EXCHANGE_R1_R2",
  16: "EXEC",
  17: "FACTORIAL",
  18: "FALSE",
  19: "FALSE_AND_SKIP",
  20: "GEQ",
  21: "IF",
  22: "IF_ELSE",
  23: "LEQ",
  24: "MOVE_ALL_TO_RX",
  25: "MOVE_FROM_R1",
  26: "MOVE_FROM_R2",
  27: "MOVE_R2_TO_R1",
  28: "MOVE_TO_R1",
  29: "MOVE_TO_R2",
  30: "MOVE_TO_RX",
  31: "MULTIPLY_4",
  32: "NOP",
  33: "NOT",
  34: "OR_3",
  35: "OR_4",
  36: "PERCENT",
  37: "MODULO",
  38: "BITWISE_AND",
  39: "POP",
  40: "POWER",
  41: "SHIFT_EX",
  42: "MULTIPLY",
  43: "ADD",
  44: "PUSH",
  45: "SUBTRACT",
  46: "STRING",
  47: "DIVIDE",
  48: "FUNCTION_0",
  49: "FUNCTION_1",
  50: "FUNCTION_2",
  51: "FUNCTION_3",
  52: "STRING_AND_SKIP",
  53: "SUBTRACT_3",
  54: "SUBTRACT_4",
  55: "TRUE",
  56: "TRUE_AND_SKIP",
  57: "FUNCTION_N",
  58: "UMINUS",
  59: "UNSHIFT_EX",
  60: "LT",
  61: "EQ",
  62: "GT",
  63: "CONDITION",
  64: "UNSHIFT_RX_TO_ALL",
  65: "AND",
  66: "UNSHIFT_RX_TO_R12",
  67: "UPLUS",
  68: "VAR_TO_VALUE",
  69: "VAR_VALUE",
  70: "FUNCTION",
  71: "=",
  72: "(",
  73: "NUM",
  74: "NUM_AND_SKIP",
  75: ")",
  76: "|",
  77: "MULTIPLY_3",
  78: "PUSH_NUMS",
  79: "OR",
  80: "ADD_3",
  81: "^",
  82: "&",
  83: "SKIP",
  84: "+",
  85: "-",
  86: "VAR",
  87: "*",
  88: "XOR",
  89: "/",
  90: "%",
  91: "!",
  92: "~",
  93: "?",
  94: "BITWISE_XOR",
  95: ":",
  96: ",",
  97: "COMMENT",
  98: "THEN",
  103: "s",
  110: "NEQ",
  124: "BITWISE_OR",
  126: "BITWISE_NOT"
},
TERROR: 2,
EOF: 1,

// internals: defined here so the object *structure* doesn't get modified by parse() et al,
// thus helping JIT compilers like Chrome V8.
originalQuoteName: null,
originalParseError: null,
cleanupAfterParse: null,
constructParseErrorInfo: null,
yyMergeLocationInfo: null,

__reentrant_call_depth: 0, // INTERNAL USE ONLY
__error_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup
__error_recovery_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup

// APIs which will be set up depending on user action code analysis:
//yyRecovering: 0,
//yyErrOk: 0,
//yyClearIn: 0,

// Helper APIs
// -----------

// Helper function which can be overridden by user code later on: put suitable quotes around
// literal IDs in a description string.
quoteName: function parser_quoteName(id_str) {
    return '"' + id_str + '"';
},

// Return the name of the given symbol (terminal or non-terminal) as a string, when available.
//
// Return NULL when the symbol is unknown to the parser.
getSymbolName: function parser_getSymbolName(symbol) {
    if (this.terminals_[symbol]) {
        return this.terminals_[symbol];
    }

    // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.
    //
    // An example of this may be where a rule's action code contains a call like this:
    //
    //      parser.getSymbolName(#$)
    //
    // to obtain a human-readable name of the current grammar rule.
    var s = this.symbols_;
    for (var key in s) {
        if (s[key] === symbol) {
            return key;
        }
    }
    return null;
},

// Return a more-or-less human-readable description of the given symbol, when available,
// or the symbol itself, serving as its own 'description' for lack of something better to serve up.
//
// Return NULL when the symbol is unknown to the parser.
describeSymbol: function parser_describeSymbol(symbol) {
    if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {
        return this.terminal_descriptions_[symbol];
    } else if (symbol === this.EOF) {
        return 'end of input';
    }
    var id = this.getSymbolName(symbol);
    if (id) {
        return this.quoteName(id);
    }
    return null;
},

// Produce a (more or less) human-readable list of expected tokens at the point of failure.
//
// The produced list may contain token or token set descriptions instead of the tokens
// themselves to help turning this output into something that easier to read by humans
// unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,
// expected terminals and nonterminals is produced.
//
// The returned list (array) will not contain any duplicate entries.
collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {
    var TERROR = this.TERROR;
    var tokenset = [];
    var check = {};
    // Has this (error?) state been outfitted with a custom expectations description text for human consumption?
    // If so, use that one instead of the less palatable token set.
    if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {
        return [this.state_descriptions_[state]];
    }
    for (var p in this.table[state]) {
        p = +p;
        if (p !== TERROR) {
            var d = do_not_describe ? p : this.describeSymbol(p);
            if (d && !check[d]) {
                tokenset.push(d);
                check[d] = true; // Mark this token description as already mentioned to prevent outputting duplicate entries.
            }
        }
    }
    return tokenset;
},
productions_: bp({
  pop: u([
  99,
  99,
  100,
  100,
  s,
  [101, 35],
  102,
  102
]),
  rule: u([
  0,
  s,
  [2, 3],
  s,
  [1, 3],
  2,
  1,
  3,
  2,
  3,
  4,
  s,
  [3, 17],
  2,
  2,
  c,
  [3, 3],
  2,
  2,
  4,
  3,
  1,
  2
])
}),
performAction: function parser__PerformAction(yystate /* action[1] */, yysp, yyvstack) {

          /* this == yyval */

          // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!
          var yy = this.yy;
          var yyparser = yy.parser;
          var yylexer = yy.lexer;

          

          switch (yystate) {
case 0:
    /*! Production::    $accept : input $end */

    // default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,-,-,-,-):
    this.$ = undefined;
    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,-,-,-,-)
    break;

case 1:
    /*! Production::    input : %epsilon */

    this.$ = [];
    break;

case 2:
    /*! Production::    input : input line */

    if (yyvstack[yysp].length) {
      // We MUST signal the end of an expression as otherwise our AST grammar
      // will be ambiguous (and thus our tree walkers confused and unable to
      // work) as we must be able to differentiate between 'end of function arglist'
      // and 'end of statement': since we expect more functions (and thus
      // arglist terminations) than statements, we choose to give the FUNCTION
      // arglist an implicit termination while the statement gets to have an
      // *explicit* termination (#EOL# token) so that we end up with a shorter
      // AST stream -- iff our assumption holds in actual use!
      //
      // NOTE: We only need to add a sentinel when multiple statements (lines)
      // are input: when there's only a single statement (line) it'll unambguously
      // terminated by EOF!
      if (01 && yyvstack[yysp - 1].length) {
        yyvstack[yysp].push( /* EOL */ 11);
      }
      this.$ = yyvstack[yysp - 1].concat(yyvstack[yysp]);
    } else {
      this.$ = yyvstack[yysp - 1];
    }
    break;

case 3:
    /*! Production::    line : exp EOL */

    this.$ = yyvstack[yysp - 1];
    break;

case 4:
    /*! Production::    line : ERROR EOL */

    this.$ = [ /* ERROR */ 3,  /* EOL */ 11];
    break;

case 5:
    /*! Production::    exp : NUM */

    this.$ = [ /* NUM */ 73, yyvstack[yysp]];
    break;

case 6:
    /*! Production::    exp : CONSTANT */

    this.$ = [ /* CONSTANT */ 8, yyvstack[yysp]];
    break;

case 7:
    /*! Production::    exp : VAR */

    this.$ = [ /* VAR */ 86, yyvstack[yysp]];
    break;

case 8:
    /*! Production::    exp : ASSIGN exp */

    /*
       Note: #assign is always to a simple variable, hence we don't need the `#VAR`
       token here: it is implicit as there's nothing else we can do.
    
       Technically, this is an AST optimization, but it's such a fundamental one
       we do it here instead of later.
    
       NOTE: #assign implies the presence of a VAR as lhs (left hand side) so it
       would only be cluttering the AST stream to have a #VAR# token in there:
       it is *implicit* to #assign!
     */
    this.$ = [ /* ASSIGN */ 7, yyvstack[yysp - 1]].concat(yyvstack[yysp]);
    break;

case 9:
    /*! Production::    exp : FUNCTION_0 */

    this.$ = [ /* FUNCTION_0 */ 48, yyvstack[yysp]];
    break;

case 10:
    /*! Production::    exp : FUNCTION arglist END */

    /*
       See the comment in the statement EOL rule above: to disambiguate a sequence
       of exp subtrees, we MUST add a terminator to either or both statement and
       function, otherwise the sequence `FUNCTION exp exp` is ambiguous: it could
       be:
    
       - a no-args functions and two more statements,
       - a single-arg function and one more statement,
       - a two-arg function.
    
       Of course, you may argue that adding 'number of arguments' knowledge to the
       FUNCTION token would also resolve this issue, and it would, but that would
       be a bit harder to encode in an LALR(1) grammar used as the treewalker core.
       It is easier to use a sentinel token in one or both spots.
    
       A lot of functions have only a few arguments, which we later optimize in our AST
       by including that knowledge in the FUNCTION token by using derivative tokens
       FUNCTION_0, FUNCTION_1, etc.: this can help a smart optimizer to include
       special optimizations for these functions without having to re-discover
       the arglist length.
       As that approach already disambiguates the function-versus-statement
       situation by having encoded arglist length in the FUNCTION token, these
       tokens never require a sentinel token in the AST stream: small AST stream size.
    
       Now we let the optimizer deal with this when the time comes...
    
       Meanwhile, keep it as simple as possible in here!
    
       Also don't forget to FLATTEN the arglist! ==> `concat.apply(a, arglist)`
    
       NOTE: the #FUNCTION# rule in Polish Notation is ambiguous unless we terminate it
       (which is easy to parse in an LALR(1) grammar while adding a argument count is not!)
       as we would otherwise get confused over this scenario:
    
            ... PLUS FUNCTION exp exp exp ...
    
       - is this a function with one argument and that last `exp` in there the second term
         of a binary(?) opcode waiting in the leading `...`?
       - is this a function with two arguments and that last `exp` the second
         term of the PLUS?
       - is this a function with three arguments and is the second term of the PLUS
         waiting in the trailing `...`?
    
       This is the trouble with opcodes which accept a variable number of arguments:
       such opcodes always have to be terminated by a sentinel to make the AST grammar
       unambiguous.
    */
    this.$ = [].concat.apply([ /* FUNCTION */ 70, yyvstack[yysp - 2]], yyvstack[yysp - 1]);
    this.$.push( /* END */ 10);
    break;

case 11:
    /*! Production::    exp : FUNCTION_1 exp */

    this.$ = [ /* FUNCTION_1 */ 49, yyvstack[yysp - 1]].concat(yyvstack[yysp]);
    break;

case 12:
    /*! Production::    exp : FUNCTION_2 exp exp */

    this.$ = [ /* FUNCTION_2 */ 50, yyvstack[yysp - 2]].concat(yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 13:
    /*! Production::    exp : FUNCTION_3 exp exp exp */

    this.$ = [ /* FUNCTION_3 */ 51, yyvstack[yysp - 3]].concat(yyvstack[yysp - 2], yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 14:
    /*! Production::    exp : EQ exp exp */

    this.$ = [ /* EQ */ 61].concat(yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 15:
    /*! Production::    exp : NEQ exp exp */

    this.$ = [ /* NEQ */ 110].concat(yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 16:
    /*! Production::    exp : LEQ exp exp */

    this.$ = [ /* LEQ */ 23].concat(yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 17:
    /*! Production::    exp : GEQ exp exp */

    this.$ = [ /* GEQ */ 20].concat(yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 18:
    /*! Production::    exp : LT exp exp */

    this.$ = [ /* LT */ 60].concat(yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 19:
    /*! Production::    exp : GT exp exp */

    this.$ = [ /* GT */ 62].concat(yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 20:
    /*! Production::    exp : OR exp exp */

    this.$ = [ /* OR */ 79].concat(yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 21:
    /*! Production::    exp : XOR exp exp */

    this.$ = [ /* XOR */ 88].concat(yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 22:
    /*! Production::    exp : AND exp exp */

    this.$ = [ /* AND */ 65].concat(yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 23:
    /*! Production::    exp : BITWISE_OR exp exp */

    this.$ = [ /* BITWISE_OR */ 124].concat(yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 24:
    /*! Production::    exp : BITWISE_XOR exp exp */

    this.$ = [ /* BITWISE_XOR */ 94].concat(yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 25:
    /*! Production::    exp : BITWISE_AND exp exp */

    this.$ = [ /* BITWISE_AND */ 38].concat(yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 26:
    /*! Production::    exp : ADD exp exp */

    this.$ = [ /* ADD */ 43].concat(yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 27:
    /*! Production::    exp : SUBTRACT exp exp */

    this.$ = [ /* SUBTRACT */ 45].concat(yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 28:
    /*! Production::    exp : MULTIPLY exp exp */

    this.$ = [ /* MULTIPLY */ 42].concat(yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 29:
    /*! Production::    exp : DIVIDE exp exp */

    this.$ = [ /* DIVIDE */ 47].concat(yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 30:
    /*! Production::    exp : MODULO exp exp */

    this.$ = [ /* MODULO */ 37].concat(yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 31:
    /*! Production::    exp : UMINUS exp */

    this.$ = [ /* UMINUS */ 58].concat(yyvstack[yysp]);
    break;

case 32:
    /*! Production::    exp : UPLUS exp */

    this.$ = [ /* UPLUS */ 67].concat(yyvstack[yysp]);
    break;

case 33:
    /*! Production::    exp : POWER exp exp */

    this.$ = [ /* POWER */ 40].concat(yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 34:
    /*! Production::    exp : PERCENT exp */

    this.$ = [ /* PERCENT */ 36].concat(yyvstack[yysp]);
    break;

case 35:
    /*! Production::    exp : FACTORIAL exp */

    this.$ = [ /* FACTORIAL */ 17].concat(yyvstack[yysp]);
    break;

case 36:
    /*! Production::    exp : BITWISE_NOT exp */

    this.$ = [ /* BITWISE_NOT */ 126].concat(yyvstack[yysp]);
    break;

case 37:
    /*! Production::    exp : NOT exp */

    this.$ = [ /* NOT */ 33].concat(yyvstack[yysp]);
    break;

case 38:
    /*! Production::    exp : IF_ELSE exp exp exp */

    this.$ = [ /* IF_ELSE */ 22].concat(yyvstack[yysp - 2], yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 39:
    /*! Production::    exp : IF exp exp */

    this.$ = [ /* IF */ 21].concat(yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 40:
    /*! Production::    arglist : exp */

    this.$ = [yyvstack[yysp]];
    break;

case 41:
    /*! Production::    arglist : arglist exp */

    this.$ = yyvstack[yysp - 1];
    this.$.push(yyvstack[yysp]);
    break;

}
},
table: bt({
  len: u([
  1,
  39,
  0,
  1,
  1,
  s,
  [0, 3],
  36,
  0,
  37,
  s,
  [36, 29],
  s,
  [0, 3],
  37,
  c,
  [38, 3],
  c,
  [25, 20],
  c,
  [28, 4],
  c,
  [26, 3],
  c,
  [69, 5],
  s,
  [0, 17],
  c,
  [19, 4]
]),
  symbol: u([
  99,
  1,
  3,
  7,
  8,
  17,
  s,
  [20, 4, 1],
  33,
  36,
  37,
  38,
  40,
  42,
  43,
  45,
  s,
  [47, 5, 1],
  58,
  60,
  61,
  62,
  65,
  67,
  70,
  73,
  79,
  86,
  88,
  94,
  100,
  101,
  110,
  124,
  126,
  11,
  11,
  c,
  [39, 32],
  c,
  [38, 4],
  c,
  [36, 33],
  102,
  c,
  [37, 36],
  c,
  [36, 1013],
  10,
  c,
  [901, 898]
]),
  type: u([
  0,
  1,
  s,
  [2, 33],
  0,
  0,
  s,
  [2, 37],
  c,
  [38, 36],
  c,
  [75, 37],
  c,
  [36, 1044],
  c,
  [901, 869]
]),
  state: u([
  1,
  2,
  3,
  42,
  44,
  43,
  s,
  [45, 29, 1],
  s,
  [75, 25, 1]
]),
  mode: u([
  s,
  [1, 1999]
]),
  goto: u([
  4,
  8,
  6,
  35,
  17,
  39,
  38,
  16,
  37,
  34,
  30,
  25,
  33,
  28,
  26,
  27,
  29,
  9,
  11,
  12,
  13,
  31,
  18,
  14,
  19,
  22,
  32,
  10,
  5,
  20,
  7,
  21,
  24,
  15,
  23,
  36,
  40,
  41,
  c,
  [37, 35],
  c,
  [35, 1052],
  74,
  c,
  [876, 873]
])
}),
defaultActions: bda({
  idx: u([
  0,
  2,
  5,
  6,
  7,
  9,
  40,
  41,
  42,
  44,
  45,
  65,
  66,
  s,
  [68, 4, 1],
  74,
  75,
  76,
  s,
  [78, 18, 1],
  97,
  98,
  99
]),
  goto: u([
  1,
  2,
  5,
  6,
  7,
  9,
  3,
  4,
  8,
  40,
  11,
  31,
  32,
  s,
  [34, 4, 1],
  10,
  41,
  12,
  s,
  [14, 17, 1],
  33,
  39,
  13,
  38
])
}),
parseError: function parseError(str, hash, ExceptionClass) {
    if (hash.recoverable) {
        if (typeof this.trace === 'function') {
            this.trace(str);
        }
        hash.destroy();             // destroy... well, *almost*!
    } else {
        if (typeof this.trace === 'function') {
            this.trace(str);
        }
        if (!ExceptionClass) {
            ExceptionClass = this.JisonParserError;
        }
        throw new ExceptionClass(str, hash);
    }
},
parse: function parse(input, globalSpace) {
    var self = this;
    var stack = new Array(128);         // token stack: stores token which leads to state at the same index (column storage)
    var sstack = new Array(128);        // state stack: stores states (column storage)

    var vstack = new Array(128);        // semantic value stack

    var table = this.table;
    var sp = 0;                         // 'stack pointer': index into the stacks


    


    var symbol = 0;



    var TERROR = this.TERROR;
    var EOF = this.EOF;
    var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = (this.options.errorRecoveryTokenDiscardCount | 0) || 3;
    var NO_ACTION = [0, 100 /* === table.length :: ensures that anyone using this new state will fail dramatically! */];

    var lexer;
    if (this.__lexer__) {
        lexer = this.__lexer__;
    } else {
        lexer = this.__lexer__ = Object.create(this.lexer);
    }

    var sharedState_yy = {
        parseError: undefined,
        quoteName: undefined,
        lexer: undefined,
        parser: undefined,
        pre_parse: undefined,
        post_parse: undefined,
        pre_lex: undefined,
        post_lex: undefined,
        globalSpace: globalSpace  // parseParams::globalSpace      // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!
    };

    var ASSERT;
    if (typeof assert !== 'function') {
        ASSERT = function JisonAssert(cond, msg) {
            if (!cond) {
                throw new Error('assertion failed: ' + (msg || '***'));
            }
        };
    } else {
        ASSERT = assert;
    }

    this.yyGetSharedState = function yyGetSharedState() {
        return sharedState_yy;
    };








    function shallow_copy_noclobber(dst, src) {
        for (var k in src) {
            if (typeof dst[k] === 'undefined' && Object.prototype.hasOwnProperty.call(src, k)) {
                dst[k] = src[k];
            }
        }
    }

    // copy state
    shallow_copy_noclobber(sharedState_yy, this.yy);

    sharedState_yy.lexer = lexer;
    sharedState_yy.parser = this;






    // Does the shared state override the default `parseError` that already comes with this instance?
    if (typeof sharedState_yy.parseError === 'function') {
        this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {
            if (!ExceptionClass) {
                ExceptionClass = this.JisonParserError;
            }
            return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);
        };
    } else {
        this.parseError = this.originalParseError;
    }

    // Does the shared state override the default `quoteName` that already comes with this instance?
    if (typeof sharedState_yy.quoteName === 'function') {
        this.quoteName = function quoteNameAlt(id_str) {
            return sharedState_yy.quoteName.call(this, id_str);
        };
    } else {
        this.quoteName = this.originalQuoteName;
    }

    // set up the cleanup function; make it an API so that external code can re-use this one in case of
    // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which
    // case this parse() API method doesn't come with a `finally { ... }` block any more!
    //
    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `sharedState`, etc. references will be *wrong*!
    this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {
        var rv;

        if (invoke_post_methods) {
            var hash;

            if (sharedState_yy.post_parse || this.post_parse) {
                // create an error hash info instance: we re-use this API in a **non-error situation**
                // as this one delivers all parser internals ready for access by userland code.
                hash = this.constructParseErrorInfo(null /* no error! */, null /* no exception! */, null, false);
            }

            if (sharedState_yy.post_parse) {
                rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }
            if (this.post_parse) {
                rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }

            // cleanup:
            if (hash && hash.destroy) {
                hash.destroy();
            }
        }

        if (this.__reentrant_call_depth > 1) return resultValue;        // do not (yet) kill the sharedState when this is a reentrant run.

        // clean up the lingering lexer structures as well:
        if (lexer.cleanupAfterLex) {
            lexer.cleanupAfterLex(do_not_nuke_errorinfos);
        }

        // prevent lingering circular references from causing memory leaks:
        if (sharedState_yy) {
            sharedState_yy.lexer = undefined;
            sharedState_yy.parser = undefined;
            if (lexer.yy === sharedState_yy) {
                lexer.yy = undefined;
            }
        }
        sharedState_yy = undefined;
        this.parseError = this.originalParseError;
        this.quoteName = this.originalQuoteName;

        // nuke the vstack[] array at least as that one will still reference obsoleted user values.
        // To be safe, we nuke the other internal stack columns as well...
        stack.length = 0;               // fastest way to nuke an array without overly bothering the GC
        sstack.length = 0;

        vstack.length = 0;
        sp = 0;

        // nuke the error hash info instances created during this run.
        // Userland code must COPY any data/references
        // in the error hash instance(s) it is more permanently interested in.
        if (!do_not_nuke_errorinfos) {
            for (var i = this.__error_infos.length - 1; i >= 0; i--) {
                var el = this.__error_infos[i];
                if (el && typeof el.destroy === 'function') {
                    el.destroy();
                }
            }
            this.__error_infos.length = 0;


        }

        return resultValue;
    };






































































































































    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!
    this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {
        var pei = {
            errStr: msg,
            exception: ex,
            text: lexer.match,
            value: lexer.yytext,
            token: this.describeSymbol(symbol) || symbol,
            token_id: symbol,
            line: lexer.yylineno,

            expected: expected,
            recoverable: recoverable,
            state: state,
            action: action,
            new_state: newState,
            symbol_stack: stack,
            state_stack: sstack,
            value_stack: vstack,

            stack_pointer: sp,
            yy: sharedState_yy,
            lexer: lexer,
            parser: this,

            // and make sure the error info doesn't stay due to potential
            // ref cycle via userland code manipulations.
            // These would otherwise all be memory leak opportunities!
            //
            // Note that only array and object references are nuked as those
            // constitute the set of elements which can produce a cyclic ref.
            // The rest of the members is kept intact as they are harmless.
            destroy: function destructParseErrorInfo() {
                // remove cyclic references added to error info:
                // info.yy = null;
                // info.lexer = null;
                // info.value = null;
                // info.value_stack = null;
                // ...
                var rec = !!this.recoverable;
                for (var key in this) {
                    if (this.hasOwnProperty(key) && typeof key === 'object') {
                        this[key] = undefined;
                    }
                }
                this.recoverable = rec;
            }
        };
        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
        this.__error_infos.push(pei);
        return pei;
    };













    function getNonTerminalFromCode(symbol) {
        var tokenName = self.getSymbolName(symbol);
        if (!tokenName) {
            tokenName = symbol;
        }
        return tokenName;
    }


    function stdLex() {
        var token = lexer.lex();
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }

        return token || 1/* EOF */;
    }

    function fastLex() {
        var token = lexer.fastLex();
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }

        return token || 1/* EOF */;
    }

    var lex = stdLex;


    var state, action, r, t;
    var yyval = {
        $: true,
        _$: undefined,
        yy: sharedState_yy
    };
    var p;
    var yyrulelen;
    var this_production;
    var newState;
    var retval = false;


    try {
        this.__reentrant_call_depth++;

        lexer.setInput(input, sharedState_yy);

        // NOTE: we *assume* no lexer pre/post handlers are set up *after* 
        // this initial `setInput()` call: hence we can now check and decide
        // whether we'll go with the standard, slower, lex() API or the
        // `fast_lex()` one:
        if (typeof lexer.canIUse === 'function') {
            var lexerInfo = lexer.canIUse();
            if (lexerInfo.fastLex && typeof fastLex === 'function') {
                lex = fastLex;
            }
        } 



        vstack[sp] = null;
        sstack[sp] = 0;
        stack[sp] = 0;
        ++sp;





        if (this.pre_parse) {
            this.pre_parse.call(this, sharedState_yy);
        }
        if (sharedState_yy.pre_parse) {
            sharedState_yy.pre_parse.call(this, sharedState_yy);
        }

        newState = sstack[sp - 1];
        for (;;) {
            // retrieve state number from top of stack
            state = newState;               // sstack[sp - 1];

            // use default actions if available
            if (this.defaultActions[state]) {
                action = 2;
                newState = this.defaultActions[state];
            } else {
                // The single `==` condition below covers both these `===` comparisons in a single
                // operation:
                //
                //     if (symbol === null || typeof symbol === 'undefined') ...
                if (!symbol) {
                    symbol = lex();
                }
                // read action for current state and first input
                t = (table[state] && table[state][symbol]) || NO_ACTION;
                newState = t[1];
                action = t[0];











                // handle parse error
                if (!action) {
                    var errStr;
                    var errSymbolDescr = (this.describeSymbol(symbol) || symbol);
                    var expected = this.collect_expected_token_set(state);

                    // Report error
                    if (typeof lexer.yylineno === 'number') {
                        errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';
                    } else {
                        errStr = 'Parse error: ';
                    }
                    if (typeof lexer.showPosition === 'function') {
                        errStr += '\n' + lexer.showPosition(79 - 10, 10) + '\n';
                    }
                    if (expected.length) {
                        errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;
                    } else {
                        errStr += 'Unexpected ' + errSymbolDescr;
                    }
                    // we cannot recover from the error!
                    p = this.constructParseErrorInfo(errStr, null, expected, false);
                    r = this.parseError(p.errStr, p, this.JisonParserError);
                    if (typeof r !== 'undefined') {
                        retval = r;
                    }
                    break;
                }


            }










            switch (action) {
            // catch misc. parse failures:
            default:
                // this shouldn't happen, unless resolve defaults are off
                if (action instanceof Array) {
                    p = this.constructParseErrorInfo('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, null, null, false);
                    r = this.parseError(p.errStr, p, this.JisonParserError);
                    if (typeof r !== 'undefined') {
                        retval = r;
                    }
                    break;
                }
                // Another case of better safe than sorry: in case state transitions come out of another error recovery process
                // or a buggy LUT (LookUp Table):
                p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);
                r = this.parseError(p.errStr, p, this.JisonParserError);
                if (typeof r !== 'undefined') {
                    retval = r;
                }
                break;

            // shift:
            case 1:
                stack[sp] = symbol;
                vstack[sp] = lexer.yytext;

                sstack[sp] = newState; // push state

                ++sp;
                symbol = 0;




                // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:




                continue;

            // reduce:
            case 2:



                this_production = this.productions_[newState - 1];  // `this.productions_[]` is zero-based indexed while states start from 1 upwards...
                yyrulelen = this_production[1];










                r = this.performAction.call(yyval, newState, sp - 1, vstack);

                if (typeof r !== 'undefined') {
                    retval = r;
                    break;
                }

                // pop off stack
                sp -= yyrulelen;

                // don't overwrite the `symbol` variable: use a local var to speed things up:
                var ntsymbol = this_production[0];    // push nonterminal (reduce)
                stack[sp] = ntsymbol;
                vstack[sp] = yyval.$;

                // goto new state = table[STATE][NONTERMINAL]
                newState = table[sstack[sp - 1]][ntsymbol];
                sstack[sp] = newState;
                ++sp;









                continue;

            // accept:
            case 3:
                if (sp !== -2) {
                    retval = true;
                    // Return the `$accept` rule's `$$` result, if available.
                    //
                    // Also note that JISON always adds this top-most `$accept` rule (with implicit,
                    // default, action):
                    //
                    //     $accept: <startSymbol> $end
                    //                  %{ $$ = $1; @$ = @1; %}
                    //
                    // which, combined with the parse kernel's `$accept` state behaviour coded below,
                    // will produce the `$$` value output of the <startSymbol> rule as the parse result,
                    // IFF that result is *not* `undefined`. (See also the parser kernel code.)
                    //
                    // In code:
                    //
                    //                  %{
                    //                      @$ = @1;            // if location tracking support is included
                    //                      if (typeof $1 !== 'undefined')
                    //                          return $1;
                    //                      else
                    //                          return true;           // the default parse result if the rule actions don't produce anything
                    //                  %}
                    sp--;
                    if (typeof vstack[sp] !== 'undefined') {
                        retval = vstack[sp];
                    }
                }
                break;
            }

            // break out of loop: we accept or fail with error
            break;
        }
    } catch (ex) {
        // report exceptions through the parseError callback too, but keep the exception intact
        // if it is a known parser or lexer error which has been thrown by parseError() already:
        if (ex instanceof this.JisonParserError) {
            throw ex;
        }
        else if (lexer && typeof lexer.JisonLexerError === 'function' && ex instanceof lexer.JisonLexerError) {
            throw ex;
        }
        else {
            p = this.constructParseErrorInfo('Parsing aborted due to exception.', ex, null, false);
            retval = false;
            r = this.parseError(p.errStr, p, this.JisonParserError);
            if (typeof r !== 'undefined') {
                retval = r;
            }
        }
    } finally {
        retval = this.cleanupAfterParse(retval, true, true);
        this.__reentrant_call_depth--;
    }   // /finally

    return retval;
}
};
parser.originalParseError = parser.parseError;
parser.originalQuoteName = parser.quoteName;

// TODO
//
// - constant folding: any part of the stream, starting at an operator token, which does not involve variable references or volatile functions (such as rand())
//   should be marked up as a constant-folding calculation and the calculation should be done.
//
// - code de-duplication: recognize subexpression duplications in the stream: these always start at an operator and have
//   identical subtrees, hence identical streams (content/length): the duplicate should ideally reference the first
//   occurrence inside the expression. E.g. `a+b+a+b` -> `(r=a+b)+r` where `r` is an internal reference/register (plus error tracking spot; imagine
//   duplicate code as in `if (is_divide_by_zero_error(a+b+c)) then d else a+b+c+d endif` -> `if (is_error(r=a+b+c)) then d else r+d endif` where register `r`
//   must also store its accompanying error state: if the error coming out of `a+b+c` is something else then 'divide by zero', the error should propagate
//   into the `r+d` expression without a hitch!
//
//   Duplicate subexpressions can be found by chopping up the stream into Ngrams with variable N size, at opcode boundaries: same Ngram is same subtree.
//   Lookup Hashtable/dictionary and you're good to go.  When the token stream is actually a (Unicode) string, this activity becomes rather cheap too as
//   then it's all string cutting and copying and comparing, which is mostly native.
//;

function Parser() {
  this.yy = {};
}
Parser.prototype = parser;
parser.Parser = Parser;

return new Parser();
})();

        


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
  exports.parser = compiled_calc_sorcerer;
  exports.Parser = compiled_calc_sorcerer.Parser;
  exports.parse = function () {
    return compiled_calc_sorcerer.parse.apply(compiled_calc_sorcerer, arguments);
  };
  
}


// End Of Include by Jison: ./output/compiled_calc/compiled_calc_sorcerer.js



// Included by Jison: ./output/compiled_calc/compiled_calc_BURG.js:


/* parser generated by jison 0.6.1-214 */

/*
 * Returns a Parser object of the following structure:
 *
 *  Parser: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a derivative/copy of this one,
 *               not a direct reference!
 *  }
 *
 *  Parser.prototype: {
 *    yy: {},
 *    EOF: 1,
 *    TERROR: 2,
 *
 *    trace: function(errorMessage, ...),
 *
 *    JisonParserError: function(msg, hash),
 *
 *    quoteName: function(name),
 *               Helper function which can be overridden by user code later on: put suitable
 *               quotes around literal IDs in a description string.
 *
 *    originalQuoteName: function(name),
 *               The basic quoteName handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function
 *               at the end of the `parse()`.
 *
 *    describeSymbol: function(symbol),
 *               Return a more-or-less human-readable description of the given symbol, when
 *               available, or the symbol itself, serving as its own 'description' for lack
 *               of something better to serve up.
 *
 *               Return NULL when the symbol is unknown to the parser.
 *
 *    symbols_: {associative list: name ==> number},
 *    terminals_: {associative list: number ==> name},
 *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},
 *    terminal_descriptions_: (if there are any) {associative list: number ==> description},
 *    productions_: [...],
 *
 *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)
 *                             to store/reference the rule value `$$` and location info `@$`.
 *
 *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets
 *                 to see the same object via the `this` reference, i.e. if you wish to carry custom
 *                 data from one reduce action through to the next within a single parse run, then you
 *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.
 *
 *                 `this.yy` is a direct reference to the `yy` shared state object.
 *
 *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`
 *                 object at `parse()` start and are therefore available to the action code via the
 *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from
 *                 the %parse-param` list.
 *
 *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used
 *                             to match this rule. This is *not* the look-ahead token, but the last token
 *                             that's actually part of this rule.
 *
 *                 Formulated another way, `yytext` is the value of the token immediately preceeding
 *                 the current look-ahead token.
 *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.
 *
 *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.
 *
 *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.
 *
 *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.
 *
 *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead
 *                               of an empty object when no suitable location info can be provided.
 *
 *               - `yystate` : the current parser state number, used internally for dispatching and
 *                               executing the action code chunk matching the rule currently being reduced.
 *
 *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *                 Also note that you can access this and other stack index values using the new double-hash
 *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things
 *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.
 *                 This is made available to write very advanced grammar action rules, e.g. when you want
 *                 to investigate the parse state stack in your action code, which would, for example,
 *                 be relevant when you wish to implement error diagnostics and reporting schemes similar
 *                 to the work described here:
 *
 *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.
 *                   In Journées Francophones des Languages Applicatifs.
 *
 *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.
 *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631–640.
 *
 *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.
 *                             constructs.
 *
 *               - `yylstack`: reference to the parser token location stack. Also accessed via
 *                             the `@1` etc. constructs.
 *
 *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are
 *                             UNDEFINED rather than an empty (location) object, when the lexer/parser
 *                             action code did not provide a suitable location info object when such a
 *                             slot was filled!
 *
 *               - `yystack` : reference to the parser token id stack. Also accessed via the
 *                             `#1` etc. constructs.
 *
 *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to
 *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might
 *                 want access this array for your own purposes, such as error analysis as mentioned above!
 *
 *                 Note that this stack stores the current stack of *tokens*, that is the sequence of
 *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*
 *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and
 *                 *reduced*.
 *
 *               - `yysstack`: reference to the parser state stack. This one carries the internal parser
 *                             *states* such as the one in `yystate`, which are used to represent
 *                             the parser state machine in the *parse table*. *Very* *internal* stuff,
 *                             what can I say? If you access this one, you're clearly doing wicked things
 *
 *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your
 *                             grammar definition file.
 *
 *    table: [...],
 *               State transition table
 *               ----------------------
 *
 *               index levels are:
 *               - `state`  --> hash table
 *               - `symbol` --> action (number or array)
 *
 *                 If the `action` is an array, these are the elements' meaning:
 *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept
 *                 - index [1]: GOTO `state`
 *
 *                 If the `action` is a number, it is the GOTO `state`
 *
 *    defaultActions: {...},
 *
 *    parseError: function(str, hash, ExceptionClass),
 *    yyError: function(str, ...),
 *    yyRecovering: function(),
 *    yyErrOk: function(),
 *    yyClearIn: function(),
 *
 *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this parser kernel in many places; example usage:
 *
 *                   var infoObj = parser.constructParseErrorInfo('fail!', null,
 *                                     parser.collect_expected_token_set(state), true);
 *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);
 *
 *    originalParseError: function(str, hash, ExceptionClass),
 *               The basic `parseError` handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function
 *               at the end of the `parse()`.
 *
 *    options: { ... parser %options ... },
 *
 *    parse: function(input[, args...]),
 *               Parse the given `input` and return the parsed value (or `true` when none was provided by
 *               the root action, in which case the parser is acting as a *matcher*).
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the jison run-time;
 *               when such a collision is detected an exception is thrown to prevent the generated run-time
 *               from silently accepting this confusing and potentially hazardous situation!
 *
 *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in
 *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state
 *               object and any collision with those will be reported by the lexer via a thrown exception.
 *
 *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown
 *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY
 *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and
 *               the internal parser gets properly garbage collected under these particular circumstances.
 *
 *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API can be invoked to calculate a spanning `yylloc` location info object.
 *
 *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case
 *               this function will attempt to obtain a suitable location marker by inspecting the location stack
 *               backwards.
 *
 *               For more info see the documentation comment further below, immediately above this function's
 *               implementation.
 *
 *    lexer: {
 *        yy: {...},           A reference to the so-called "shared state" `yy` once
 *                             received via a call to the `.setInput(input, yy)` lexer API.
 *        EOF: 1,
 *        ERROR: 2,
 *        JisonLexerError: function(msg, hash),
 *        parseError: function(str, hash, ExceptionClass),
 *        setInput: function(input, [yy]),
 *        input: function(),
 *        unput: function(str),
 *        more: function(),
 *        reject: function(),
 *        less: function(n),
 *        pastInput: function(n),
 *        upcomingInput: function(n),
 *        showPosition: function(),
 *        test_match: function(regex_match_array, rule_index, ...),
 *        next: function(...),
 *        lex: function(...),
 *        begin: function(condition),
 *        pushState: function(condition),
 *        popState: function(),
 *        topState: function(),
 *        _currentRules: function(),
 *        stateStackSize: function(),
 *        cleanupAfterLex: function()
 *
 *        options: { ... lexer %options ... },
 *
 *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),
 *        rules: [...],
 *        conditions: {associative list: name ==> set},
 *    }
 *  }
 *
 *
 *  token location info (@$, _$, etc.): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer and
 * parser errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *  }
 *
 * parser (grammar) errors will also provide these additional members:
 *
 *  {
 *    expected:    (array describing the set of expected tokens;
 *                  may be UNDEFINED when we cannot easily produce such a set)
 *    state:       (integer (or array when the table includes grammar collisions);
 *                  represents the current internal state of the parser kernel.
 *                  can, for example, be used to pass to the `collect_expected_token_set()`
 *                  API to obtain the expected token set)
 *    action:      (integer; represents the current internal action which will be executed)
 *    new_state:   (integer; represents the next/planned internal state, once the current
 *                  action has executed)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *    parser:      (reference to the current parser instance)
 *  }
 *
 * while `this` will reference the current parser instance.
 *
 * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    lexer:       (reference to the current lexer instance which reported the error)
 *  }
 *
 * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired
 * from either the parser or lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    exception:   (reference to the exception thrown)
 *  }
 *
 * Please do note that in the latter situation, the `expected` field will be omitted as
 * this type of failure is assumed not to be due to *parse errors* but rather due to user
 * action code in either parser or lexer failing unexpectedly.
 *
 * ---
 *
 * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.
 * These options are available:
 *
 * ### options which are global for all parser instances
 *
 *  Parser.pre_parse: function(yy)
 *                 optional: you can specify a pre_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`.
 *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: you can specify a post_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`. When it does not return any value,
 *                 the parser will return the original `retval`.
 *
 * ### options which can be set up per parser instance
 *
 *  yy: {
 *      pre_parse:  function(yy)
 *                 optional: is invoked before the parse cycle starts (and before the first
 *                 invocation of `lex()`) but immediately after the invocation of
 *                 `parser.pre_parse()`).
 *      post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: is invoked when the parse terminates due to success ('accept')
 *                 or failure (even when exceptions are thrown).
 *                 `retval` contains the return value to be produced by `Parser.parse()`;
 *                 this function can override the return value by returning another.
 *                 When it does not return any value, the parser will return the original
 *                 `retval`.
 *                 This function is invoked immediately before `parser.post_parse()`.
 *
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *      quoteName: function(name),
 *                 optional: overrides the default `quoteName` function.
 *  }
 *
 *  parser.lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */

        
    
            var compiled_calc_BURG = (function () {

// See also:
// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
// with userland code which might access the derived class in a 'classic' way.
function JisonParserError(msg, hash) {
    Object.defineProperty(this, 'name', {
        enumerable: false,
        writable: false,
        value: 'JisonParserError'
    });

    if (msg == null) msg = '???';

    Object.defineProperty(this, 'message', {
        enumerable: false,
        writable: true,
        value: msg
    });

    this.hash = hash;

    var stacktrace;
    if (hash && hash.exception instanceof Error) {
        var ex2 = hash.exception;
        this.message = ex2.message || msg;
        stacktrace = ex2.stack;
    }
    if (!stacktrace) {
        if (Error.hasOwnProperty('captureStackTrace')) {        // V8/Chrome engine
            Error.captureStackTrace(this, this.constructor);
        } else {
            stacktrace = (new Error(msg)).stack;
        }
    }
    if (stacktrace) {
        Object.defineProperty(this, 'stack', {
            enumerable: false,
            writable: false,
            value: stacktrace
        });
    }
}

if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);
} else {
    JisonParserError.prototype = Object.create(Error.prototype);
}
JisonParserError.prototype.constructor = JisonParserError;
JisonParserError.prototype.name = 'JisonParserError';



        // helper: reconstruct the productions[] table
        function bp(s) {
            var rv = [];
            var p = s.pop;
            var r = s.rule;
            for (var i = 0, l = p.length; i < l; i++) {
                rv.push([
                    p[i],
                    r[i]
                ]);
            }
            return rv;
        }
    


        // helper: reconstruct the defaultActions[] table
        function bda(s) {
            var rv = {};
            var d = s.idx;
            var g = s.goto;
            for (var i = 0, l = d.length; i < l; i++) {
                var j = d[i];
                rv[j] = g[i];
            }
            return rv;
        }
    


        // helper: reconstruct the 'goto' table
        function bt(s) {
            var rv = [];
            var d = s.len;
            var y = s.symbol;
            var t = s.type;
            var a = s.state;
            var m = s.mode;
            var g = s.goto;
            for (var i = 0, l = d.length; i < l; i++) {
                var n = d[i];
                var q = {};
                for (var j = 0; j < n; j++) {
                    var z = y.shift();
                    switch (t.shift()) {
                    case 2:
                        q[z] = [
                            m.shift(),
                            g.shift()
                        ];
                        break;

                    case 0:
                        q[z] = a.shift();
                        break;

                    default:
                        // type === 1: accept
                        q[z] = [
                            3
                        ];
                    }
                }
                rv.push(q);
            }
            return rv;
        }
    


        // helper: runlength encoding with increment step: code, length: step (default step = 0)
        // `this` references an array
        function s(c, l, a) {
            a = a || 0;
            for (var i = 0; i < l; i++) {
                this.push(c);
                c += a;
            }
        }

        // helper: duplicate sequence from *relative* offset and length.
        // `this` references an array
        function c(i, l) {
            i = this.length - i;
            for (l += i; i < l; i++) {
                this.push(this[i]);
            }
        }

        // helper: unpack an array using helpers and data, all passed in an array argument 'a'.
        function u(a) {
            var rv = [];
            for (var i = 0, l = a.length; i < l; i++) {
                var e = a[i];
                // Is this entry a helper function?
                if (typeof e === 'function') {
                    i++;
                    e.apply(rv, a[i]);
                } else {
                    rv.push(e);
                }
            }
            return rv;
        }
    

var parser = {
    // Code Generator Information Report
    // ---------------------------------
    //
    // Options:
    //
    //   default action mode: ............. none,merge
    //   try..catch: ...................... false
    //   default resolve on conflict: ..... true
    //   on-demand look-ahead: ............ false
    //   error recovery token skip maximum: 3
    //   yyerror in parse actions is: ..... NOT recoverable,
    //   yyerror in lexer actions and other non-fatal lexer are:
    //   .................................. NOT recoverable,
    //   debug grammar/output: ............ false
    //   has partial LR conflict upgrade:   true
    //   rudimentary token-stack support:   false
    //   parser table compression mode: ... 2
    //   export debug tables: ............. false
    //   export *all* tables: ............. false
    //   module type: ..................... commonjs
    //   parser engine type: .............. lalr
    //   output main() in the module: ..... true
    //   has user-specified main(): ....... false
    //   has user-specified require()/import modules for main():
    //   .................................. false
    //   number of expected conflicts: .... 0
    //
    //
    // Parser Analysis flags:
    //
    //   no significant actions (parser is a language matcher only):
    //   .................................. false
    //   uses yyleng: ..................... false
    //   uses yylineno: ................... false
    //   uses yytext: ..................... false
    //   uses yylloc: ..................... false
    //   uses ParseError API: ............. false
    //   uses YYERROR: .................... false
    //   uses YYRECOVERING: ............... false
    //   uses YYERROK: .................... false
    //   uses YYCLEARIN: .................. false
    //   tracks rule values: .............. true
    //   assigns rule values: ............. true
    //   uses location tracking: .......... false
    //   assigns location: ................ false
    //   uses yystack: .................... false
    //   uses yysstack: ................... false
    //   uses yysp: ....................... true
    //   uses yyrulelength: ............... false
    //   uses yyMergeLocationInfo API: .... false
    //   has error recovery: .............. false
    //   has error reporting: ............. false
    //
    // --------- END OF REPORT -----------

trace: function no_op_trace() {},
JisonParserError: JisonParserError,
yy: {},
options: {
  type: "lalr",
  hasPartialLrUpgradeOnConflict: true,
  errorRecoveryTokenDiscardCount: 3
},
symbols_: {
  "!": 91,
  "$accept": 0,
  "$end": 1,
  "%": 90,
  "&": 82,
  "(": 72,
  ")": 75,
  "*": 87,
  "+": 84,
  ",": 96,
  "-": 85,
  "/": 89,
  ":": 95,
  "=": 71,
  "?": 93,
  "ADD": 43,
  "ADD_3": 80,
  "ADD_4": 4,
  "AND": 65,
  "AND_3": 5,
  "AND_4": 6,
  "ASSIGN": 7,
  "BITWISE_AND": 38,
  "BITWISE_NOT": 126,
  "BITWISE_OR": 124,
  "BITWISE_XOR": 94,
  "COMMENT": 97,
  "CONDITION": 63,
  "CONSTANT": 8,
  "DIVIDE": 47,
  "ELSE": 9,
  "END": 10,
  "EOF": 1,
  "EOL": 11,
  "EQ": 61,
  "ERROR": 3,
  "ERROR_AND_SKIP": 12,
  "EXCHANGE_A_R1": 13,
  "EXCHANGE_A_R2": 14,
  "EXCHANGE_R1_R2": 15,
  "EXEC": 16,
  "FACTORIAL": 17,
  "FALSE": 18,
  "FALSE_AND_SKIP": 19,
  "FUNCTION": 70,
  "FUNCTION_0": 48,
  "FUNCTION_1": 49,
  "FUNCTION_2": 50,
  "FUNCTION_3": 51,
  "FUNCTION_N": 57,
  "GEQ": 20,
  "GT": 62,
  "IF": 21,
  "IF_ELSE": 22,
  "LEQ": 23,
  "LT": 60,
  "MODULO": 37,
  "MOVE_ALL_TO_RX": 24,
  "MOVE_FROM_R1": 25,
  "MOVE_FROM_R2": 26,
  "MOVE_R2_TO_R1": 27,
  "MOVE_TO_R1": 28,
  "MOVE_TO_R2": 29,
  "MOVE_TO_RX": 30,
  "MULTIPLY": 42,
  "MULTIPLY_3": 77,
  "MULTIPLY_4": 31,
  "NEQ": 110,
  "NOP": 32,
  "NOT": 33,
  "NUM": 73,
  "NUM_AND_SKIP": 74,
  "OR": 79,
  "OR_3": 34,
  "OR_4": 35,
  "PERCENT": 36,
  "POP": 39,
  "POWER": 40,
  "PUSH": 44,
  "PUSH_NUMS": 78,
  "SHIFT_EX": 41,
  "SKIP": 83,
  "STRING": 46,
  "STRING_AND_SKIP": 52,
  "SUBTRACT": 45,
  "SUBTRACT_3": 53,
  "SUBTRACT_4": 54,
  "THEN": 98,
  "TRUE": 55,
  "TRUE_AND_SKIP": 56,
  "UMINUS": 58,
  "UNSHIFT_EX": 59,
  "UNSHIFT_RX_TO_ALL": 64,
  "UNSHIFT_RX_TO_R12": 66,
  "UPLUS": 67,
  "VAR": 86,
  "VAR_TO_VALUE": 68,
  "VAR_VALUE": 69,
  "XOR": 88,
  "^": 81,
  "arglist": 102,
  "error": 2,
  "exp": 101,
  "input": 99,
  "line": 100,
  "s": 103,
  "|": 76,
  "~": 92
},
terminals_: {
  1: "EOF",
  2: "error",
  3: "ERROR",
  4: "ADD_4",
  5: "AND_3",
  6: "AND_4",
  7: "ASSIGN",
  8: "CONSTANT",
  9: "ELSE",
  10: "END",
  11: "EOL",
  12: "ERROR_AND_SKIP",
  13: "EXCHANGE_A_R1",
  14: "EXCHANGE_A_R2",
  15: "EXCHANGE_R1_R2",
  16: "EXEC",
  17: "FACTORIAL",
  18: "FALSE",
  19: "FALSE_AND_SKIP",
  20: "GEQ",
  21: "IF",
  22: "IF_ELSE",
  23: "LEQ",
  24: "MOVE_ALL_TO_RX",
  25: "MOVE_FROM_R1",
  26: "MOVE_FROM_R2",
  27: "MOVE_R2_TO_R1",
  28: "MOVE_TO_R1",
  29: "MOVE_TO_R2",
  30: "MOVE_TO_RX",
  31: "MULTIPLY_4",
  32: "NOP",
  33: "NOT",
  34: "OR_3",
  35: "OR_4",
  36: "PERCENT",
  37: "MODULO",
  38: "BITWISE_AND",
  39: "POP",
  40: "POWER",
  41: "SHIFT_EX",
  42: "MULTIPLY",
  43: "ADD",
  44: "PUSH",
  45: "SUBTRACT",
  46: "STRING",
  47: "DIVIDE",
  48: "FUNCTION_0",
  49: "FUNCTION_1",
  50: "FUNCTION_2",
  51: "FUNCTION_3",
  52: "STRING_AND_SKIP",
  53: "SUBTRACT_3",
  54: "SUBTRACT_4",
  55: "TRUE",
  56: "TRUE_AND_SKIP",
  57: "FUNCTION_N",
  58: "UMINUS",
  59: "UNSHIFT_EX",
  60: "LT",
  61: "EQ",
  62: "GT",
  63: "CONDITION",
  64: "UNSHIFT_RX_TO_ALL",
  65: "AND",
  66: "UNSHIFT_RX_TO_R12",
  67: "UPLUS",
  68: "VAR_TO_VALUE",
  69: "VAR_VALUE",
  70: "FUNCTION",
  71: "=",
  72: "(",
  73: "NUM",
  74: "NUM_AND_SKIP",
  75: ")",
  76: "|",
  77: "MULTIPLY_3",
  78: "PUSH_NUMS",
  79: "OR",
  80: "ADD_3",
  81: "^",
  82: "&",
  83: "SKIP",
  84: "+",
  85: "-",
  86: "VAR",
  87: "*",
  88: "XOR",
  89: "/",
  90: "%",
  91: "!",
  92: "~",
  93: "?",
  94: "BITWISE_XOR",
  95: ":",
  96: ",",
  97: "COMMENT",
  98: "THEN",
  103: "s",
  110: "NEQ",
  124: "BITWISE_OR",
  126: "BITWISE_NOT"
},
TERROR: 2,
EOF: 1,

// internals: defined here so the object *structure* doesn't get modified by parse() et al,
// thus helping JIT compilers like Chrome V8.
originalQuoteName: null,
originalParseError: null,
cleanupAfterParse: null,
constructParseErrorInfo: null,
yyMergeLocationInfo: null,

__reentrant_call_depth: 0, // INTERNAL USE ONLY
__error_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup
__error_recovery_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup

// APIs which will be set up depending on user action code analysis:
//yyRecovering: 0,
//yyErrOk: 0,
//yyClearIn: 0,

// Helper APIs
// -----------

// Helper function which can be overridden by user code later on: put suitable quotes around
// literal IDs in a description string.
quoteName: function parser_quoteName(id_str) {
    return '"' + id_str + '"';
},

// Return the name of the given symbol (terminal or non-terminal) as a string, when available.
//
// Return NULL when the symbol is unknown to the parser.
getSymbolName: function parser_getSymbolName(symbol) {
    if (this.terminals_[symbol]) {
        return this.terminals_[symbol];
    }

    // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.
    //
    // An example of this may be where a rule's action code contains a call like this:
    //
    //      parser.getSymbolName(#$)
    //
    // to obtain a human-readable name of the current grammar rule.
    var s = this.symbols_;
    for (var key in s) {
        if (s[key] === symbol) {
            return key;
        }
    }
    return null;
},

// Return a more-or-less human-readable description of the given symbol, when available,
// or the symbol itself, serving as its own 'description' for lack of something better to serve up.
//
// Return NULL when the symbol is unknown to the parser.
describeSymbol: function parser_describeSymbol(symbol) {
    if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {
        return this.terminal_descriptions_[symbol];
    } else if (symbol === this.EOF) {
        return 'end of input';
    }
    var id = this.getSymbolName(symbol);
    if (id) {
        return this.quoteName(id);
    }
    return null;
},

// Produce a (more or less) human-readable list of expected tokens at the point of failure.
//
// The produced list may contain token or token set descriptions instead of the tokens
// themselves to help turning this output into something that easier to read by humans
// unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,
// expected terminals and nonterminals is produced.
//
// The returned list (array) will not contain any duplicate entries.
collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {
    var TERROR = this.TERROR;
    var tokenset = [];
    var check = {};
    // Has this (error?) state been outfitted with a custom expectations description text for human consumption?
    // If so, use that one instead of the less palatable token set.
    if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {
        return [this.state_descriptions_[state]];
    }
    for (var p in this.table[state]) {
        p = +p;
        if (p !== TERROR) {
            var d = do_not_describe ? p : this.describeSymbol(p);
            if (d && !check[d]) {
                tokenset.push(d);
                check[d] = true; // Mark this token description as already mentioned to prevent outputting duplicate entries.
            }
        }
    }
    return tokenset;
},
productions_: bp({
  pop: u([
  s,
  [99, 3],
  100,
  100,
  s,
  [101, 35],
  102,
  102
]),
  rule: u([
  0,
  3,
  3,
  s,
  [1, 5],
  2,
  1,
  3,
  2,
  3,
  4,
  s,
  [3, 17],
  2,
  2,
  c,
  [3, 3],
  2,
  2,
  4,
  3,
  1,
  2
])
}),
performAction: function parser__PerformAction(yystate /* action[1] */, yysp, yyvstack) {

          /* this == yyval */

          // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!
          var yy = this.yy;
          var yyparser = yy.parser;
          var yylexer = yy.lexer;

          

          switch (yystate) {
case 0:
    /*! Production::    $accept : input $end */

    // default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,-,-,-,-):
    this.$ = undefined;
    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,-,-,-,-)
    break;

case 1:
    /*! Production::    input : %epsilon */

    this.$ = [];
    break;

case 2:
    /*! Production::    input : input line EOL */

    yyvstack[yysp - 2].push(yyvstack[yysp - 1]);
    this.$ = yyvstack[yysp - 2];
    break;

case 3:
    /*! Production::    input : input COMMENT EOL */

    console.log('COMMENT line(s): ', yyvstack[yysp - 1]);
    this.$ = yyvstack[yysp - 2];
    break;

case 4:
    /*! Production::    line : exp */

    console.log('expression result value: ', yyvstack[yysp]);
    this.$ = yyvstack[yysp];
    break;

case 5:
    /*! Production::    line : ERROR */

    console.log('expression result value: ERROR - erroneous input line');
    this.$ = NaN;
    break;

case 6:
    /*! Production::    exp : NUM */

    this.$ = yyvstack[yysp];
    break;

case 7:
    /*! Production::    exp : CONSTANT */

    this.$ = yy.constants[yyvstack[yysp]].value;
    break;

case 8:
    /*! Production::    exp : VAR */

    this.$ = yy.variables[yyvstack[yysp]].value;
    break;

case 9:
    /*! Production::    exp : ASSIGN exp */

    /*
       Note: #assign is always to a simple variable, hence we don't need the `#VAR`
       token here: it is implicit as there's nothing else we can do.
    
       Technically, this is an AST optimization, but it's such a fundamental one
       we do it here instead of later.
    
       NOTE: #assign implies the presence of a VAR as lhs (left hand side) so it
       would only be cluttering the AST stream to have a #VAR# token in there:
       it is *implicit* to #assign!
     */
    this.$ = yy.variables[yyvstack[yysp - 1]].value = yyvstack[yysp];
    break;

case 10:
    /*! Production::    exp : FUNCTION_0 */

    this.$ = yy.functions[yyvstack[yysp]].func.call(globalSpace);
    break;

case 11:
    /*! Production::    exp : FUNCTION arglist END */

    /*
       A lot of functions have only a few arguments, which we later optimize in our AST
       by including that knowledge in the FUNCTION token by using derivative tokens
       FUNCTION_0, FUNCTION_1, etc.: this can help a smart optimizer to include
       special optimizations for these functions without having to re-discover
       the arglist length.
       As that approach already disambiguates the function-versus-statement
       situation by having encoded arglist length in the FUNCTION token, these
       tokens never require a sentinel token in the AST stream: small AST stream size.
    
       Also don't forget to FLATTEN the arglist! ==> `concat.apply(a, arglist)`
    
       NOTE: the #FUNCTION# rule in Polish Notation is ambiguous unless we terminate it
       (which is easy to parse in an LALR(1) grammar while adding a argument count is not!)
       as we would otherwise get confused over this scenario:
    
            ... PLUS FUNCTION exp exp exp ...
    
       - is this a function with one argument and that last `exp` in there the second term
         of a binary(?) opcode waiting in the leading `...`?
       - is this a function with two arguments and that last `exp` the second
         term of the PLUS?
       - is this a function with three arguments and is the second term of the PLUS
         waiting in the trailing `...`?
    
       This is the trouble with opcodes which accept a variable number of arguments:
       such opcodes always have to be terminated by a sentinel to make the AST grammar
       unambiguous.
    */
    this.$ = yy.functions[yyvstack[yysp - 2]].func.apply(globalSpace, yyvstack[yysp - 1]);
    break;

case 12:
    /*! Production::    exp : FUNCTION_1 exp */

    this.$ = yy.functions[yyvstack[yysp - 1]].func.call(globalSpace, yyvstack[yysp]);
    break;

case 13:
    /*! Production::    exp : FUNCTION_2 exp exp */

    this.$ = yy.functions[yyvstack[yysp - 2]].func.call(globalSpace, yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 14:
    /*! Production::    exp : FUNCTION_3 exp exp exp */

    this.$ = yy.functions[yyvstack[yysp - 3]].func.call(globalSpace, yyvstack[yysp - 2], yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 15:
    /*! Production::    exp : EQ exp exp */

    this.$ = yyvstack[yysp - 1] == yyvstack[yysp];
    break;

case 16:
    /*! Production::    exp : NEQ exp exp */

    this.$ = yyvstack[yysp - 1] != yyvstack[yysp];
    break;

case 17:
    /*! Production::    exp : LEQ exp exp */

    this.$ = yyvstack[yysp - 1] <= yyvstack[yysp];
    break;

case 18:
    /*! Production::    exp : GEQ exp exp */

    this.$ = yyvstack[yysp - 1] >= yyvstack[yysp];
    break;

case 19:
    /*! Production::    exp : LT exp exp */

    this.$ = yyvstack[yysp - 1] < yyvstack[yysp];
    break;

case 20:
    /*! Production::    exp : GT exp exp */

    this.$ = yyvstack[yysp - 1] > yyvstack[yysp];
    break;

case 21:
    /*! Production::    exp : OR exp exp */

    this.$ = yyvstack[yysp - 1] || yyvstack[yysp];
    break;

case 22:
    /*! Production::    exp : XOR exp exp */

    this.$ = !!(!!yyvstack[yysp - 1] ^ !!yyvstack[yysp]);
    break;

case 23:
    /*! Production::    exp : AND exp exp */

    this.$ = yyvstack[yysp - 1] && yyvstack[yysp];
    break;

case 24:
    /*! Production::    exp : BITWISE_OR exp exp */

    this.$ = yyvstack[yysp - 1] | yyvstack[yysp];
    break;

case 25:
    /*! Production::    exp : BITWISE_XOR exp exp */

    this.$ = yyvstack[yysp - 1] ^ yyvstack[yysp];
    break;

case 26:
    /*! Production::    exp : BITWISE_AND exp exp */

    this.$ = yyvstack[yysp - 1] & yyvstack[yysp];
    break;

case 27:
    /*! Production::    exp : ADD exp exp */

    this.$ = yyvstack[yysp - 1] + yyvstack[yysp];
    break;

case 28:
    /*! Production::    exp : SUBTRACT exp exp */

    this.$ = yyvstack[yysp - 1] - yyvstack[yysp];
    break;

case 29:
    /*! Production::    exp : MULTIPLY exp exp */

    this.$ = yyvstack[yysp - 1] * yyvstack[yysp];
    break;

case 30:
    /*! Production::    exp : DIVIDE exp exp */

    this.$ = yyvstack[yysp - 1] / yyvstack[yysp];
    break;

case 31:
    /*! Production::    exp : MODULO exp exp */

    this.$ = yyvstack[yysp - 1] % yyvstack[yysp];
    break;

case 32:
    /*! Production::    exp : UMINUS exp */

    this.$ = -yyvstack[yysp];
    break;

case 33:
    /*! Production::    exp : UPLUS exp */

    this.$ = +yyvstack[yysp];
    break;

case 34:
    /*! Production::    exp : POWER exp exp */

    this.$ = Math.pow(yyvstack[yysp - 1], yyvstack[yysp]);
    break;

case 35:
    /*! Production::    exp : PERCENT exp */

    this.$ = yyvstack[yysp] / 100;
    break;

case 36:
    /*! Production::    exp : FACTORIAL exp */

    this.$ = yy.predefined_functions.factorial.call(globalSpace, yyvstack[yysp]);
    break;

case 37:
    /*! Production::    exp : BITWISE_NOT exp */

    this.$ = ~yyvstack[yysp];
    break;

case 38:
    /*! Production::    exp : NOT exp */

    this.$ = !yyvstack[yysp];
    break;

case 39:
    /*! Production::    exp : IF_ELSE exp exp exp */

    if (yyvstack[yysp - 2]) {
      this.$ = yyvstack[yysp - 1];
    } else {
      this.$ = yyvstack[yysp];
    }
    break;

case 40:
    /*! Production::    exp : IF exp exp */

    if (yyvstack[yysp - 1]) {
      this.$ = yyvstack[yysp];
    } else {
      this.$ = 0;
    }
    break;

case 41:
    /*! Production::    arglist : exp */

    this.$ = [yyvstack[yysp]];
    break;

case 42:
    /*! Production::    arglist : arglist exp */

    this.$ = yyvstack[yysp - 1];
    this.$.push(yyvstack[yysp]);
    break;

}
},
table: bt({
  len: u([
  1,
  40,
  1,
  1,
  s,
  [0, 5],
  36,
  0,
  37,
  s,
  [36, 29],
  s,
  [0, 3],
  37,
  c,
  [38, 3],
  c,
  [25, 20],
  c,
  [28, 4],
  c,
  [26, 3],
  c,
  [69, 5],
  s,
  [0, 17],
  c,
  [19, 4]
]),
  symbol: u([
  99,
  1,
  3,
  7,
  8,
  17,
  s,
  [20, 4, 1],
  33,
  36,
  37,
  38,
  40,
  42,
  43,
  45,
  s,
  [47, 5, 1],
  58,
  60,
  61,
  62,
  65,
  67,
  70,
  73,
  79,
  86,
  88,
  94,
  97,
  100,
  101,
  110,
  124,
  126,
  11,
  11,
  c,
  [40, 32],
  c,
  [38, 4],
  c,
  [36, 33],
  102,
  c,
  [37, 36],
  c,
  [36, 1013],
  10,
  c,
  [901, 898]
]),
  type: u([
  0,
  1,
  s,
  [2, 34],
  0,
  0,
  s,
  [2, 37],
  c,
  [38, 36],
  c,
  [75, 37],
  c,
  [36, 1044],
  c,
  [901, 869]
]),
  state: u([
  1,
  2,
  4,
  43,
  45,
  44,
  s,
  [46, 29, 1],
  s,
  [76, 25, 1]
]),
  mode: u([
  s,
  [1, 2000]
]),
  goto: u([
  5,
  9,
  7,
  36,
  18,
  40,
  39,
  17,
  38,
  35,
  31,
  26,
  34,
  29,
  27,
  28,
  30,
  10,
  12,
  13,
  14,
  32,
  19,
  15,
  20,
  23,
  33,
  11,
  6,
  21,
  8,
  22,
  25,
  3,
  16,
  24,
  37,
  41,
  42,
  c,
  [38, 32],
  c,
  [37, 3],
  c,
  [35, 1052],
  75,
  c,
  [876, 873]
])
}),
defaultActions: bda({
  idx: u([
  0,
  s,
  [4, 5, 1],
  10,
  41,
  42,
  43,
  45,
  46,
  66,
  67,
  s,
  [69, 4, 1],
  75,
  76,
  77,
  s,
  [79, 18, 1],
  98,
  99,
  100
]),
  goto: u([
  1,
  s,
  [4, 5, 1],
  10,
  2,
  3,
  9,
  41,
  12,
  32,
  33,
  s,
  [35, 4, 1],
  11,
  42,
  13,
  s,
  [15, 17, 1],
  34,
  40,
  14,
  39
])
}),
parseError: function parseError(str, hash, ExceptionClass) {
    if (hash.recoverable) {
        if (typeof this.trace === 'function') {
            this.trace(str);
        }
        hash.destroy();             // destroy... well, *almost*!
    } else {
        if (typeof this.trace === 'function') {
            this.trace(str);
        }
        if (!ExceptionClass) {
            ExceptionClass = this.JisonParserError;
        }
        throw new ExceptionClass(str, hash);
    }
},
parse: function parse(input, globalSpace) {
    var self = this;
    var stack = new Array(128);         // token stack: stores token which leads to state at the same index (column storage)
    var sstack = new Array(128);        // state stack: stores states (column storage)

    var vstack = new Array(128);        // semantic value stack

    var table = this.table;
    var sp = 0;                         // 'stack pointer': index into the stacks


    


    var symbol = 0;



    var TERROR = this.TERROR;
    var EOF = this.EOF;
    var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = (this.options.errorRecoveryTokenDiscardCount | 0) || 3;
    var NO_ACTION = [0, 101 /* === table.length :: ensures that anyone using this new state will fail dramatically! */];

    var lexer;
    if (this.__lexer__) {
        lexer = this.__lexer__;
    } else {
        lexer = this.__lexer__ = Object.create(this.lexer);
    }

    var sharedState_yy = {
        parseError: undefined,
        quoteName: undefined,
        lexer: undefined,
        parser: undefined,
        pre_parse: undefined,
        post_parse: undefined,
        pre_lex: undefined,
        post_lex: undefined,
        globalSpace: globalSpace  // parseParams::globalSpace      // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!
    };

    var ASSERT;
    if (typeof assert !== 'function') {
        ASSERT = function JisonAssert(cond, msg) {
            if (!cond) {
                throw new Error('assertion failed: ' + (msg || '***'));
            }
        };
    } else {
        ASSERT = assert;
    }

    this.yyGetSharedState = function yyGetSharedState() {
        return sharedState_yy;
    };








    function shallow_copy_noclobber(dst, src) {
        for (var k in src) {
            if (typeof dst[k] === 'undefined' && Object.prototype.hasOwnProperty.call(src, k)) {
                dst[k] = src[k];
            }
        }
    }

    // copy state
    shallow_copy_noclobber(sharedState_yy, this.yy);

    sharedState_yy.lexer = lexer;
    sharedState_yy.parser = this;






    // Does the shared state override the default `parseError` that already comes with this instance?
    if (typeof sharedState_yy.parseError === 'function') {
        this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {
            if (!ExceptionClass) {
                ExceptionClass = this.JisonParserError;
            }
            return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);
        };
    } else {
        this.parseError = this.originalParseError;
    }

    // Does the shared state override the default `quoteName` that already comes with this instance?
    if (typeof sharedState_yy.quoteName === 'function') {
        this.quoteName = function quoteNameAlt(id_str) {
            return sharedState_yy.quoteName.call(this, id_str);
        };
    } else {
        this.quoteName = this.originalQuoteName;
    }

    // set up the cleanup function; make it an API so that external code can re-use this one in case of
    // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which
    // case this parse() API method doesn't come with a `finally { ... }` block any more!
    //
    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `sharedState`, etc. references will be *wrong*!
    this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {
        var rv;

        if (invoke_post_methods) {
            var hash;

            if (sharedState_yy.post_parse || this.post_parse) {
                // create an error hash info instance: we re-use this API in a **non-error situation**
                // as this one delivers all parser internals ready for access by userland code.
                hash = this.constructParseErrorInfo(null /* no error! */, null /* no exception! */, null, false);
            }

            if (sharedState_yy.post_parse) {
                rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }
            if (this.post_parse) {
                rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }

            // cleanup:
            if (hash && hash.destroy) {
                hash.destroy();
            }
        }




        // clean up the lingering lexer structures as well:
        if (lexer.cleanupAfterLex) {
            lexer.cleanupAfterLex(do_not_nuke_errorinfos);
        }

        // prevent lingering circular references from causing memory leaks:
        if (sharedState_yy) {
            sharedState_yy.lexer = undefined;
            sharedState_yy.parser = undefined;
            if (lexer.yy === sharedState_yy) {
                lexer.yy = undefined;
            }
        }
        sharedState_yy = undefined;
        this.parseError = this.originalParseError;
        this.quoteName = this.originalQuoteName;

        // nuke the vstack[] array at least as that one will still reference obsoleted user values.
        // To be safe, we nuke the other internal stack columns as well...
        stack.length = 0;               // fastest way to nuke an array without overly bothering the GC
        sstack.length = 0;

        vstack.length = 0;
        sp = 0;

        // nuke the error hash info instances created during this run.
        // Userland code must COPY any data/references
        // in the error hash instance(s) it is more permanently interested in.
        if (!do_not_nuke_errorinfos) {
            for (var i = this.__error_infos.length - 1; i >= 0; i--) {
                var el = this.__error_infos[i];
                if (el && typeof el.destroy === 'function') {
                    el.destroy();
                }
            }
            this.__error_infos.length = 0;


        }

        return resultValue;
    };






































































































































    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!
    this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {
        var pei = {
            errStr: msg,
            exception: ex,
            text: lexer.match,
            value: lexer.yytext,
            token: this.describeSymbol(symbol) || symbol,
            token_id: symbol,
            line: lexer.yylineno,

            expected: expected,
            recoverable: recoverable,
            state: state,
            action: action,
            new_state: newState,
            symbol_stack: stack,
            state_stack: sstack,
            value_stack: vstack,

            stack_pointer: sp,
            yy: sharedState_yy,
            lexer: lexer,
            parser: this,

            // and make sure the error info doesn't stay due to potential
            // ref cycle via userland code manipulations.
            // These would otherwise all be memory leak opportunities!
            //
            // Note that only array and object references are nuked as those
            // constitute the set of elements which can produce a cyclic ref.
            // The rest of the members is kept intact as they are harmless.
            destroy: function destructParseErrorInfo() {
                // remove cyclic references added to error info:
                // info.yy = null;
                // info.lexer = null;
                // info.value = null;
                // info.value_stack = null;
                // ...
                var rec = !!this.recoverable;
                for (var key in this) {
                    if (this.hasOwnProperty(key) && typeof key === 'object') {
                        this[key] = undefined;
                    }
                }
                this.recoverable = rec;
            }
        };
        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
        this.__error_infos.push(pei);
        return pei;
    };













    function getNonTerminalFromCode(symbol) {
        var tokenName = self.getSymbolName(symbol);
        if (!tokenName) {
            tokenName = symbol;
        }
        return tokenName;
    }


    function stdLex() {
        var token = lexer.lex();
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }

        return token || 1/* EOF */;
    }

    function fastLex() {
        var token = lexer.fastLex();
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }

        return token || 1/* EOF */;
    }

    var lex = stdLex;


    var state, action, r, t;
    var yyval = {
        $: true,
        _$: undefined,
        yy: sharedState_yy
    };
    var p;
    var yyrulelen;
    var this_production;
    var newState;
    var retval = false;




    lexer.setInput(input, sharedState_yy);

    // NOTE: we *assume* no lexer pre/post handlers are set up *after* 
    // this initial `setInput()` call: hence we can now check and decide
    // whether we'll go with the standard, slower, lex() API or the
    // `fast_lex()` one:
    if (typeof lexer.canIUse === 'function') {
        var lexerInfo = lexer.canIUse();
        if (lexerInfo.fastLex && typeof fastLex === 'function') {
            lex = fastLex;
        }
    } 



    vstack[sp] = null;
    sstack[sp] = 0;
    stack[sp] = 0;
    ++sp;





    if (this.pre_parse) {
        this.pre_parse.call(this, sharedState_yy);
    }
    if (sharedState_yy.pre_parse) {
        sharedState_yy.pre_parse.call(this, sharedState_yy);
    }

    newState = sstack[sp - 1];
    for (;;) {
        // retrieve state number from top of stack
        state = newState;               // sstack[sp - 1];

        // use default actions if available
        if (this.defaultActions[state]) {
            action = 2;
            newState = this.defaultActions[state];
        } else {
            // The single `==` condition below covers both these `===` comparisons in a single
            // operation:
            //
            //     if (symbol === null || typeof symbol === 'undefined') ...
            if (!symbol) {
                symbol = lex();
            }
            // read action for current state and first input
            t = (table[state] && table[state][symbol]) || NO_ACTION;
            newState = t[1];
            action = t[0];











            // handle parse error
            if (!action) {
                var errStr;
                var errSymbolDescr = (this.describeSymbol(symbol) || symbol);
                var expected = this.collect_expected_token_set(state);

                // Report error
                if (typeof lexer.yylineno === 'number') {
                    errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';
                } else {
                    errStr = 'Parse error: ';
                }
                if (typeof lexer.showPosition === 'function') {
                    errStr += '\n' + lexer.showPosition(79 - 10, 10) + '\n';
                }
                if (expected.length) {
                    errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;
                } else {
                    errStr += 'Unexpected ' + errSymbolDescr;
                }
                // we cannot recover from the error!
                p = this.constructParseErrorInfo(errStr, null, expected, false);
                r = this.parseError(p.errStr, p, this.JisonParserError);
                if (typeof r !== 'undefined') {
                    retval = r;
                }
                break;
            }


        }










        switch (action) {
        // catch misc. parse failures:
        default:
            // this shouldn't happen, unless resolve defaults are off
            if (action instanceof Array) {
                p = this.constructParseErrorInfo('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, null, null, false);
                r = this.parseError(p.errStr, p, this.JisonParserError);
                if (typeof r !== 'undefined') {
                    retval = r;
                }
                break;
            }
            // Another case of better safe than sorry: in case state transitions come out of another error recovery process
            // or a buggy LUT (LookUp Table):
            p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);
            r = this.parseError(p.errStr, p, this.JisonParserError);
            if (typeof r !== 'undefined') {
                retval = r;
            }
            break;

        // shift:
        case 1:
            stack[sp] = symbol;
            vstack[sp] = lexer.yytext;

            sstack[sp] = newState; // push state

            ++sp;
            symbol = 0;




            // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:




            continue;

        // reduce:
        case 2:



            this_production = this.productions_[newState - 1];  // `this.productions_[]` is zero-based indexed while states start from 1 upwards...
            yyrulelen = this_production[1];










            r = this.performAction.call(yyval, newState, sp - 1, vstack);

            if (typeof r !== 'undefined') {
                retval = r;
                break;
            }

            // pop off stack
            sp -= yyrulelen;

            // don't overwrite the `symbol` variable: use a local var to speed things up:
            var ntsymbol = this_production[0];    // push nonterminal (reduce)
            stack[sp] = ntsymbol;
            vstack[sp] = yyval.$;

            // goto new state = table[STATE][NONTERMINAL]
            newState = table[sstack[sp - 1]][ntsymbol];
            sstack[sp] = newState;
            ++sp;









            continue;

        // accept:
        case 3:
            if (sp !== -2) {
                retval = true;
                // Return the `$accept` rule's `$$` result, if available.
                //
                // Also note that JISON always adds this top-most `$accept` rule (with implicit,
                // default, action):
                //
                //     $accept: <startSymbol> $end
                //                  %{ $$ = $1; @$ = @1; %}
                //
                // which, combined with the parse kernel's `$accept` state behaviour coded below,
                // will produce the `$$` value output of the <startSymbol> rule as the parse result,
                // IFF that result is *not* `undefined`. (See also the parser kernel code.)
                //
                // In code:
                //
                //                  %{
                //                      @$ = @1;            // if location tracking support is included
                //                      if (typeof $1 !== 'undefined')
                //                          return $1;
                //                      else
                //                          return true;           // the default parse result if the rule actions don't produce anything
                //                  %}
                sp--;
                if (typeof vstack[sp] !== 'undefined') {
                    retval = vstack[sp];
                }
            }
            break;
        }

        // break out of loop: we accept or fail with error
        break;
    }
    
    // ... AND FINALLY ...

    retval = this.cleanupAfterParse(retval, true, true);


    

    return retval;
}
};
parser.originalParseError = parser.parseError;
parser.originalQuoteName = parser.quoteName;



function Parser() {
  this.yy = {};
}
Parser.prototype = parser;
parser.Parser = Parser;

return new Parser();
})();

        


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
  exports.parser = compiled_calc_BURG;
  exports.Parser = compiled_calc_BURG.Parser;
  exports.parse = function () {
    return compiled_calc_BURG.parse.apply(compiled_calc_BURG, arguments);
  };
  
}


// End Of Include by Jison: ./output/compiled_calc/compiled_calc_BURG.js



// The library of support functions, e.g. symbol table lookup services:

// Included by Jison: compiled_calc___support_functions_lib.js:

//
// Support functions for the 'compiled calculator' advanced example
// 


// Symbol table interface for constants, functions and variables:
// 
// Note the use of a local closure to keep track of 'global values' which
// are considered *internal* to the symbol table and library functions provided.
// 


// public interface methods

var lookup_constant;                        // function(name)
var lookup_function;                        // function(name)
var lookup_or_register_variable;            // function(name)
var mark_calculation_start;                 // function(round#)
var generate_opcode_param_count_table;      // function ()                                    


// The closure = symbol tables' setup function:
function init_symbol_tables() {
  // internal 'globals': these are what this closure was created for:
  var calc_round;
  var timestamp;

  // variables' symbol table / registry store:
  var variables = {}; 

  // set up the interface functions:

  lookup_constant = function lookup_constant_f(s) {
    return false;
  };

  lookup_function = function lookup_function_f(s) {
    return false;
  };

  lookup_or_register_variable = function lookup_or_register_variable_closure(s) {
    // if variable doesn't exist yet, create it and assign it the 'NaN' value
    if (variables[s] === undefined) {
      variables[s] = NaN;
    }
    return variables[s];
  };

  mark_calculation_start = function mark_calculation_start_f(round) {
    calc_round = round;

    // sample the time only once per calculus run: all date/time functions,
    // which reference 'current time' will refer to this cached timestamp!
    timestamp = new Date();
  };

  // produce a fast map for [opcode#]->number of arguments or given opcode
  generate_opcode_param_count_table = function generate_opcode_param_count_table_f() {
    var src = fast_opcode_def_table;
    var dst = [];

    for (var i = 0, len = src.length; i < len; i++) {
      var o = src[i];
      dst[o.id] = o.args.length;
    }
    return dst;
  };


  // ---------------------
  
  const fast_opcode_def_table = [
    {
      name: 'NUM',
      id: 73/* NUM */,
      args: [1/* OPA_VALUE */],
    },
    // shorthand for NUM+SKIP: this value is a constant-folded value, while the skipped part of the stream remains for formatter walkers...
    {
      name: 'NUM_AND_SKIP',
      id: 74/* NUM_AND_SKIP */,
      args: [1/* OPA_VALUE */, 2/* OPA_OFFSET */],
    },
    {
      name: 'STRING',
      id: 46/* STRING */,
      args: [3/* OPA_STRING */],
    },
    // shorthand for STRING+SKIP: this value is a constant-folded value, while the skipped part of the stream remains for formatter walkers...
    {
      name: 'STRING_AND_SKIP',
      id: 52/* STRING_AND_SKIP */,
      args: [3/* OPA_STRING */, 2/* OPA_OFFSET */],
    },
    // shorthand for TRUE+SKIP: this value is a constant-folded value, while the skipped part of the stream remains for formatter walkers...
    {
      name: 'TRUE_AND_SKIP',
      id: 56/* TRUE_AND_SKIP */,
      args: [2/* OPA_OFFSET */],
    },
    // shorthand for FALSE+SKIP: this value is a constant-folded value, while the skipped part of the stream remains for formatter walkers...
    {
      name: 'FALSE_AND_SKIP',
      id: 19/* FALSE_AND_SKIP */,
      args: [2/* OPA_OFFSET */],
    },
    {
      name: 'VAR',
      id: 86/* VAR */,
      args: [4/* OPA_VARIABLE_REF */],
    },
    // shorthand for VAR | VAR_TO_VALUE
    {
      name: 'VAR_VALUE',
      id: 69/* VAR_VALUE */,
      args: [4/* OPA_VARIABLE_REF */],
    },
    // rhs '=' lhs       -- '=' VAR exp      (variable reference for lhs VAR is implicit, i.e. included with this ASSIGN opcode)
    {
      name: 'ASSIGN',
      id: 7/* ASSIGN */,
      args: [4/* OPA_VARIABLE_REF */],
    },
    {
      name: 'FUNCTION_0',
      id: 48/* FUNCTION_0 */,
      args: [5/* OPA_FUNCTION_REF */],
    },
    {
      name: 'FUNCTION_1',
      id: 49/* FUNCTION_1 */,
      args: [5/* OPA_FUNCTION_REF */],
    },
    {
      name: 'FUNCTION_2',
      id: 50/* FUNCTION_2 */,
      args: [5/* OPA_FUNCTION_REF */],
    },
    {
      name: 'FUNCTION_3',
      id: 51/* FUNCTION_3 */,
      args: [5/* OPA_FUNCTION_REF */],
    },
    {
      name: 'FUNCTION_N',
      id: 57/* FUNCTION_N */,
      args: [5/* OPA_FUNCTION_REF */],
    },
    // cond '?' true ':' false -- check the conditional and self-modify stream to exec the correct branch
    {
      name: 'CONDITION',
      id: 63/* CONDITION */,
      args: [2/* OPA_OFFSET */],
    },
    // a SKIP which was turned into a NOT-SKIP
    {
      name: 'EXEC',
      id: 16/* EXEC */,
      args: [2/* OPA_OFFSET */],
    },
    // skip N opcodes; can also happen when the sorcerer has found a chunk which could be constant-folded: pretty-printers running off the same stream would still need the raw data within the skipped chunk!
    {
      name: 'SKIP',
      id: 83/* SKIP */,
      args: [2/* OPA_OFFSET */],
    },
    // flagged error part: shift the specified error unless one has already been set
    {
      name: 'ERROR',
      id: 3/* ERROR */,
      args: [6/* OPA_ERROR_INFO_OBJ */],
    },
    // shorthand for ERROR+SKIP opcodes; note the skip number comes first and includes the error value slot!
    {
      name: 'ERROR_AND_SKIP',
      id: 12/* ERROR_AND_SKIP */,
      args: [6/* OPA_ERROR_INFO_OBJ */],
    },
    // comment line
    {
      name: 'COMMENT',
      id: 97/* COMMENT */,
      args: [3/* OPA_STRING */],
    },
  ];
}


// and set up the closure:
init_symbol_tables();



// End Of Include by Jison: compiled_calc___support_functions_lib.js



// The hand-optimized variant of the above compiler/engine phases:
// This stuff is supposed to outperform the jison-generated code as
// we have geared these codes to have the least possible of
// code&call overhead:
// We still *parse* the text input using the parser from above,
// but now all other passes are fully re-engineered.
// Also note the introduction of a (very rudimentary)
// optimization phase, which still employs a jison-based tree walker.
//
// First, we have the PARSER which outputs a new AST suitable for
// the high-speed hand-optimized engine:

// Included by Jison: ./output/compiled_calc/compiled_calc_parse_for_fast_engine.js:


/* parser generated by jison 0.6.1-214 */

/*
 * Returns a Parser object of the following structure:
 *
 *  Parser: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a derivative/copy of this one,
 *               not a direct reference!
 *  }
 *
 *  Parser.prototype: {
 *    yy: {},
 *    EOF: 1,
 *    TERROR: 2,
 *
 *    trace: function(errorMessage, ...),
 *
 *    JisonParserError: function(msg, hash),
 *
 *    quoteName: function(name),
 *               Helper function which can be overridden by user code later on: put suitable
 *               quotes around literal IDs in a description string.
 *
 *    originalQuoteName: function(name),
 *               The basic quoteName handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function
 *               at the end of the `parse()`.
 *
 *    describeSymbol: function(symbol),
 *               Return a more-or-less human-readable description of the given symbol, when
 *               available, or the symbol itself, serving as its own 'description' for lack
 *               of something better to serve up.
 *
 *               Return NULL when the symbol is unknown to the parser.
 *
 *    symbols_: {associative list: name ==> number},
 *    terminals_: {associative list: number ==> name},
 *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},
 *    terminal_descriptions_: (if there are any) {associative list: number ==> description},
 *    productions_: [...],
 *
 *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)
 *                             to store/reference the rule value `$$` and location info `@$`.
 *
 *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets
 *                 to see the same object via the `this` reference, i.e. if you wish to carry custom
 *                 data from one reduce action through to the next within a single parse run, then you
 *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.
 *
 *                 `this.yy` is a direct reference to the `yy` shared state object.
 *
 *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`
 *                 object at `parse()` start and are therefore available to the action code via the
 *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from
 *                 the %parse-param` list.
 *
 *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used
 *                             to match this rule. This is *not* the look-ahead token, but the last token
 *                             that's actually part of this rule.
 *
 *                 Formulated another way, `yytext` is the value of the token immediately preceeding
 *                 the current look-ahead token.
 *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.
 *
 *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.
 *
 *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.
 *
 *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.
 *
 *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead
 *                               of an empty object when no suitable location info can be provided.
 *
 *               - `yystate` : the current parser state number, used internally for dispatching and
 *                               executing the action code chunk matching the rule currently being reduced.
 *
 *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *                 Also note that you can access this and other stack index values using the new double-hash
 *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things
 *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.
 *                 This is made available to write very advanced grammar action rules, e.g. when you want
 *                 to investigate the parse state stack in your action code, which would, for example,
 *                 be relevant when you wish to implement error diagnostics and reporting schemes similar
 *                 to the work described here:
 *
 *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.
 *                   In Journées Francophones des Languages Applicatifs.
 *
 *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.
 *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631–640.
 *
 *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.
 *                             constructs.
 *
 *               - `yylstack`: reference to the parser token location stack. Also accessed via
 *                             the `@1` etc. constructs.
 *
 *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are
 *                             UNDEFINED rather than an empty (location) object, when the lexer/parser
 *                             action code did not provide a suitable location info object when such a
 *                             slot was filled!
 *
 *               - `yystack` : reference to the parser token id stack. Also accessed via the
 *                             `#1` etc. constructs.
 *
 *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to
 *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might
 *                 want access this array for your own purposes, such as error analysis as mentioned above!
 *
 *                 Note that this stack stores the current stack of *tokens*, that is the sequence of
 *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*
 *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and
 *                 *reduced*.
 *
 *               - `yysstack`: reference to the parser state stack. This one carries the internal parser
 *                             *states* such as the one in `yystate`, which are used to represent
 *                             the parser state machine in the *parse table*. *Very* *internal* stuff,
 *                             what can I say? If you access this one, you're clearly doing wicked things
 *
 *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your
 *                             grammar definition file.
 *
 *    table: [...],
 *               State transition table
 *               ----------------------
 *
 *               index levels are:
 *               - `state`  --> hash table
 *               - `symbol` --> action (number or array)
 *
 *                 If the `action` is an array, these are the elements' meaning:
 *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept
 *                 - index [1]: GOTO `state`
 *
 *                 If the `action` is a number, it is the GOTO `state`
 *
 *    defaultActions: {...},
 *
 *    parseError: function(str, hash, ExceptionClass),
 *    yyError: function(str, ...),
 *    yyRecovering: function(),
 *    yyErrOk: function(),
 *    yyClearIn: function(),
 *
 *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this parser kernel in many places; example usage:
 *
 *                   var infoObj = parser.constructParseErrorInfo('fail!', null,
 *                                     parser.collect_expected_token_set(state), true);
 *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);
 *
 *    originalParseError: function(str, hash, ExceptionClass),
 *               The basic `parseError` handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function
 *               at the end of the `parse()`.
 *
 *    options: { ... parser %options ... },
 *
 *    parse: function(input[, args...]),
 *               Parse the given `input` and return the parsed value (or `true` when none was provided by
 *               the root action, in which case the parser is acting as a *matcher*).
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the jison run-time;
 *               when such a collision is detected an exception is thrown to prevent the generated run-time
 *               from silently accepting this confusing and potentially hazardous situation!
 *
 *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in
 *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state
 *               object and any collision with those will be reported by the lexer via a thrown exception.
 *
 *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown
 *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY
 *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and
 *               the internal parser gets properly garbage collected under these particular circumstances.
 *
 *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API can be invoked to calculate a spanning `yylloc` location info object.
 *
 *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case
 *               this function will attempt to obtain a suitable location marker by inspecting the location stack
 *               backwards.
 *
 *               For more info see the documentation comment further below, immediately above this function's
 *               implementation.
 *
 *    lexer: {
 *        yy: {...},           A reference to the so-called "shared state" `yy` once
 *                             received via a call to the `.setInput(input, yy)` lexer API.
 *        EOF: 1,
 *        ERROR: 2,
 *        JisonLexerError: function(msg, hash),
 *        parseError: function(str, hash, ExceptionClass),
 *        setInput: function(input, [yy]),
 *        input: function(),
 *        unput: function(str),
 *        more: function(),
 *        reject: function(),
 *        less: function(n),
 *        pastInput: function(n),
 *        upcomingInput: function(n),
 *        showPosition: function(),
 *        test_match: function(regex_match_array, rule_index, ...),
 *        next: function(...),
 *        lex: function(...),
 *        begin: function(condition),
 *        pushState: function(condition),
 *        popState: function(),
 *        topState: function(),
 *        _currentRules: function(),
 *        stateStackSize: function(),
 *        cleanupAfterLex: function()
 *
 *        options: { ... lexer %options ... },
 *
 *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),
 *        rules: [...],
 *        conditions: {associative list: name ==> set},
 *    }
 *  }
 *
 *
 *  token location info (@$, _$, etc.): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer and
 * parser errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *  }
 *
 * parser (grammar) errors will also provide these additional members:
 *
 *  {
 *    expected:    (array describing the set of expected tokens;
 *                  may be UNDEFINED when we cannot easily produce such a set)
 *    state:       (integer (or array when the table includes grammar collisions);
 *                  represents the current internal state of the parser kernel.
 *                  can, for example, be used to pass to the `collect_expected_token_set()`
 *                  API to obtain the expected token set)
 *    action:      (integer; represents the current internal action which will be executed)
 *    new_state:   (integer; represents the next/planned internal state, once the current
 *                  action has executed)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *    parser:      (reference to the current parser instance)
 *  }
 *
 * while `this` will reference the current parser instance.
 *
 * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    lexer:       (reference to the current lexer instance which reported the error)
 *  }
 *
 * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired
 * from either the parser or lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    exception:   (reference to the exception thrown)
 *  }
 *
 * Please do note that in the latter situation, the `expected` field will be omitted as
 * this type of failure is assumed not to be due to *parse errors* but rather due to user
 * action code in either parser or lexer failing unexpectedly.
 *
 * ---
 *
 * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.
 * These options are available:
 *
 * ### options which are global for all parser instances
 *
 *  Parser.pre_parse: function(yy)
 *                 optional: you can specify a pre_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`.
 *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: you can specify a post_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`. When it does not return any value,
 *                 the parser will return the original `retval`.
 *
 * ### options which can be set up per parser instance
 *
 *  yy: {
 *      pre_parse:  function(yy)
 *                 optional: is invoked before the parse cycle starts (and before the first
 *                 invocation of `lex()`) but immediately after the invocation of
 *                 `parser.pre_parse()`).
 *      post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: is invoked when the parse terminates due to success ('accept')
 *                 or failure (even when exceptions are thrown).
 *                 `retval` contains the return value to be produced by `Parser.parse()`;
 *                 this function can override the return value by returning another.
 *                 When it does not return any value, the parser will return the original
 *                 `retval`.
 *                 This function is invoked immediately before `parser.post_parse()`.
 *
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *      quoteName: function(name),
 *                 optional: overrides the default `quoteName` function.
 *  }
 *
 *  parser.lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */

        
    
            var compiled_calc_parse_for_fast_engine = (function () {

// See also:
// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
// with userland code which might access the derived class in a 'classic' way.
function JisonParserError(msg, hash) {
    Object.defineProperty(this, 'name', {
        enumerable: false,
        writable: false,
        value: 'JisonParserError'
    });

    if (msg == null) msg = '???';

    Object.defineProperty(this, 'message', {
        enumerable: false,
        writable: true,
        value: msg
    });

    this.hash = hash;

    var stacktrace;
    if (hash && hash.exception instanceof Error) {
        var ex2 = hash.exception;
        this.message = ex2.message || msg;
        stacktrace = ex2.stack;
    }
    if (!stacktrace) {
        if (Error.hasOwnProperty('captureStackTrace')) {        // V8/Chrome engine
            Error.captureStackTrace(this, this.constructor);
        } else {
            stacktrace = (new Error(msg)).stack;
        }
    }
    if (stacktrace) {
        Object.defineProperty(this, 'stack', {
            enumerable: false,
            writable: false,
            value: stacktrace
        });
    }
}

if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);
} else {
    JisonParserError.prototype = Object.create(Error.prototype);
}
JisonParserError.prototype.constructor = JisonParserError;
JisonParserError.prototype.name = 'JisonParserError';



        // helper: reconstruct the productions[] table
        function bp(s) {
            var rv = [];
            var p = s.pop;
            var r = s.rule;
            for (var i = 0, l = p.length; i < l; i++) {
                rv.push([
                    p[i],
                    r[i]
                ]);
            }
            return rv;
        }
    


        // helper: reconstruct the defaultActions[] table
        function bda(s) {
            var rv = {};
            var d = s.idx;
            var g = s.goto;
            for (var i = 0, l = d.length; i < l; i++) {
                var j = d[i];
                rv[j] = g[i];
            }
            return rv;
        }
    


        // helper: reconstruct the 'goto' table
        function bt(s) {
            var rv = [];
            var d = s.len;
            var y = s.symbol;
            var t = s.type;
            var a = s.state;
            var m = s.mode;
            var g = s.goto;
            for (var i = 0, l = d.length; i < l; i++) {
                var n = d[i];
                var q = {};
                for (var j = 0; j < n; j++) {
                    var z = y.shift();
                    switch (t.shift()) {
                    case 2:
                        q[z] = [
                            m.shift(),
                            g.shift()
                        ];
                        break;

                    case 0:
                        q[z] = a.shift();
                        break;

                    default:
                        // type === 1: accept
                        q[z] = [
                            3
                        ];
                    }
                }
                rv.push(q);
            }
            return rv;
        }
    


        // helper: runlength encoding with increment step: code, length: step (default step = 0)
        // `this` references an array
        function s(c, l, a) {
            a = a || 0;
            for (var i = 0; i < l; i++) {
                this.push(c);
                c += a;
            }
        }

        // helper: duplicate sequence from *relative* offset and length.
        // `this` references an array
        function c(i, l) {
            i = this.length - i;
            for (l += i; i < l; i++) {
                this.push(this[i]);
            }
        }

        // helper: unpack an array using helpers and data, all passed in an array argument 'a'.
        function u(a) {
            var rv = [];
            for (var i = 0, l = a.length; i < l; i++) {
                var e = a[i];
                // Is this entry a helper function?
                if (typeof e === 'function') {
                    i++;
                    e.apply(rv, a[i]);
                } else {
                    rv.push(e);
                }
            }
            return rv;
        }
    

var parser = {
    // Code Generator Information Report
    // ---------------------------------
    //
    // Options:
    //
    //   default action mode: ............. none,merge
    //   try..catch: ...................... false
    //   default resolve on conflict: ..... true
    //   on-demand look-ahead: ............ false
    //   error recovery token skip maximum: 3
    //   yyerror in parse actions is: ..... NOT recoverable,
    //   yyerror in lexer actions and other non-fatal lexer are:
    //   .................................. NOT recoverable,
    //   debug grammar/output: ............ false
    //   has partial LR conflict upgrade:   true
    //   rudimentary token-stack support:   false
    //   parser table compression mode: ... 2
    //   export debug tables: ............. false
    //   export *all* tables: ............. false
    //   module type: ..................... commonjs
    //   parser engine type: .............. lalr
    //   output main() in the module: ..... true
    //   has user-specified main(): ....... false
    //   has user-specified require()/import modules for main():
    //   .................................. false
    //   number of expected conflicts: .... 0
    //
    //
    // Parser Analysis flags:
    //
    //   no significant actions (parser is a language matcher only):
    //   .................................. false
    //   uses yyleng: ..................... false
    //   uses yylineno: ................... false
    //   uses yytext: ..................... false
    //   uses yylloc: ..................... false
    //   uses ParseError API: ............. false
    //   uses YYERROR: .................... false
    //   uses YYRECOVERING: ............... false
    //   uses YYERROK: .................... true
    //   uses YYCLEARIN: .................. true
    //   tracks rule values: .............. true
    //   assigns rule values: ............. true
    //   uses location tracking: .......... false
    //   assigns location: ................ false
    //   uses yystack: .................... false
    //   uses yysstack: ................... false
    //   uses yysp: ....................... true
    //   uses yyrulelength: ............... false
    //   uses yyMergeLocationInfo API: .... false
    //   has error recovery: .............. true
    //   has error reporting: ............. false
    //
    // --------- END OF REPORT -----------

trace: function no_op_trace() {},
JisonParserError: JisonParserError,
yy: {},
options: {
  type: "lalr",
  hasPartialLrUpgradeOnConflict: true,
  errorRecoveryTokenDiscardCount: 3,
  ebnf: true
},
symbols_: {
  "!": 91,
  "$accept": 0,
  "$end": 1,
  "%": 90,
  "&": 82,
  "(": 72,
  ")": 75,
  "*": 87,
  "+": 84,
  ",": 96,
  "-": 85,
  "/": 89,
  ":": 95,
  "=": 71,
  "?": 93,
  "ADD": 43,
  "ADD_3": 80,
  "ADD_4": 4,
  "AND": 65,
  "AND_3": 5,
  "AND_4": 6,
  "ASSIGN": 7,
  "BITWISE_AND": 38,
  "BITWISE_NOT": 126,
  "BITWISE_OR": 124,
  "BITWISE_XOR": 94,
  "COMMENT": 97,
  "CONDITION": 63,
  "CONSTANT": 8,
  "DIVIDE": 47,
  "ELSE": 9,
  "END": 10,
  "EOF": 1,
  "EOL": 11,
  "EQ": 61,
  "ERROR": 3,
  "ERROR_AND_SKIP": 12,
  "EXCHANGE_A_R1": 13,
  "EXCHANGE_A_R2": 14,
  "EXCHANGE_R1_R2": 15,
  "EXEC": 16,
  "FACTORIAL": 17,
  "FALSE": 18,
  "FALSE_AND_SKIP": 19,
  "FUNCTION": 70,
  "FUNCTION_0": 48,
  "FUNCTION_1": 49,
  "FUNCTION_2": 50,
  "FUNCTION_3": 51,
  "FUNCTION_N": 57,
  "GEQ": 20,
  "GT": 62,
  "IF": 21,
  "IF_ELSE": 22,
  "LEQ": 23,
  "LT": 60,
  "MODULO": 37,
  "MOVE_ALL_TO_RX": 24,
  "MOVE_FROM_R1": 25,
  "MOVE_FROM_R2": 26,
  "MOVE_R2_TO_R1": 27,
  "MOVE_TO_R1": 28,
  "MOVE_TO_R2": 29,
  "MOVE_TO_RX": 30,
  "MULTIPLY": 42,
  "MULTIPLY_3": 77,
  "MULTIPLY_4": 31,
  "NEQ": 110,
  "NOP": 32,
  "NOT": 33,
  "NUM": 73,
  "NUM_AND_SKIP": 74,
  "OR": 79,
  "OR_3": 34,
  "OR_4": 35,
  "PERCENT": 36,
  "POP": 39,
  "POWER": 40,
  "PUSH": 44,
  "PUSH_NUMS": 78,
  "SHIFT_EX": 41,
  "SKIP": 83,
  "STRING": 46,
  "STRING_AND_SKIP": 52,
  "SUBTRACT": 45,
  "SUBTRACT_3": 53,
  "SUBTRACT_4": 54,
  "THEN": 98,
  "TRUE": 55,
  "TRUE_AND_SKIP": 56,
  "UMINUS": 58,
  "UNSHIFT_EX": 59,
  "UNSHIFT_RX_TO_ALL": 64,
  "UNSHIFT_RX_TO_R12": 66,
  "UPLUS": 67,
  "VAR": 86,
  "VAR_TO_VALUE": 68,
  "VAR_VALUE": 69,
  "XOR": 88,
  "^": 81,
  "arglist": 102,
  "error": 2,
  "exp": 101,
  "input": 99,
  "line": 100,
  "s": 103,
  "|": 76,
  "~": 92
},
terminals_: {
  1: "EOF",
  2: "error",
  3: "ERROR",
  4: "ADD_4",
  5: "AND_3",
  6: "AND_4",
  7: "ASSIGN",
  8: "CONSTANT",
  9: "ELSE",
  10: "END",
  11: "EOL",
  12: "ERROR_AND_SKIP",
  13: "EXCHANGE_A_R1",
  14: "EXCHANGE_A_R2",
  15: "EXCHANGE_R1_R2",
  16: "EXEC",
  17: "FACTORIAL",
  18: "FALSE",
  19: "FALSE_AND_SKIP",
  20: "GEQ",
  21: "IF",
  22: "IF_ELSE",
  23: "LEQ",
  24: "MOVE_ALL_TO_RX",
  25: "MOVE_FROM_R1",
  26: "MOVE_FROM_R2",
  27: "MOVE_R2_TO_R1",
  28: "MOVE_TO_R1",
  29: "MOVE_TO_R2",
  30: "MOVE_TO_RX",
  31: "MULTIPLY_4",
  32: "NOP",
  33: "NOT",
  34: "OR_3",
  35: "OR_4",
  36: "PERCENT",
  37: "MODULO",
  38: "BITWISE_AND",
  39: "POP",
  40: "POWER",
  41: "SHIFT_EX",
  42: "MULTIPLY",
  43: "ADD",
  44: "PUSH",
  45: "SUBTRACT",
  46: "STRING",
  47: "DIVIDE",
  48: "FUNCTION_0",
  49: "FUNCTION_1",
  50: "FUNCTION_2",
  51: "FUNCTION_3",
  52: "STRING_AND_SKIP",
  53: "SUBTRACT_3",
  54: "SUBTRACT_4",
  55: "TRUE",
  56: "TRUE_AND_SKIP",
  57: "FUNCTION_N",
  58: "UMINUS",
  59: "UNSHIFT_EX",
  60: "LT",
  61: "EQ",
  62: "GT",
  63: "CONDITION",
  64: "UNSHIFT_RX_TO_ALL",
  65: "AND",
  66: "UNSHIFT_RX_TO_R12",
  67: "UPLUS",
  68: "VAR_TO_VALUE",
  69: "VAR_VALUE",
  70: "FUNCTION",
  71: "=",
  72: "(",
  73: "NUM",
  74: "NUM_AND_SKIP",
  75: ")",
  76: "|",
  77: "MULTIPLY_3",
  78: "PUSH_NUMS",
  79: "OR",
  80: "ADD_3",
  81: "^",
  82: "&",
  83: "SKIP",
  84: "+",
  85: "-",
  86: "VAR",
  87: "*",
  88: "XOR",
  89: "/",
  90: "%",
  91: "!",
  92: "~",
  93: "?",
  94: "BITWISE_XOR",
  95: ":",
  96: ",",
  97: "COMMENT",
  98: "THEN",
  110: "NEQ",
  124: "BITWISE_OR",
  126: "BITWISE_NOT"
},
TERROR: 2,
EOF: 1,

// internals: defined here so the object *structure* doesn't get modified by parse() et al,
// thus helping JIT compilers like Chrome V8.
originalQuoteName: null,
originalParseError: null,
cleanupAfterParse: null,
constructParseErrorInfo: null,
yyMergeLocationInfo: null,

__reentrant_call_depth: 0, // INTERNAL USE ONLY
__error_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup
__error_recovery_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup

// APIs which will be set up depending on user action code analysis:
//yyRecovering: 0,
//yyErrOk: 0,
//yyClearIn: 0,

// Helper APIs
// -----------

// Helper function which can be overridden by user code later on: put suitable quotes around
// literal IDs in a description string.
quoteName: function parser_quoteName(id_str) {
    return '"' + id_str + '"';
},

// Return the name of the given symbol (terminal or non-terminal) as a string, when available.
//
// Return NULL when the symbol is unknown to the parser.
getSymbolName: function parser_getSymbolName(symbol) {
    if (this.terminals_[symbol]) {
        return this.terminals_[symbol];
    }

    // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.
    //
    // An example of this may be where a rule's action code contains a call like this:
    //
    //      parser.getSymbolName(#$)
    //
    // to obtain a human-readable name of the current grammar rule.
    var s = this.symbols_;
    for (var key in s) {
        if (s[key] === symbol) {
            return key;
        }
    }
    return null;
},

// Return a more-or-less human-readable description of the given symbol, when available,
// or the symbol itself, serving as its own 'description' for lack of something better to serve up.
//
// Return NULL when the symbol is unknown to the parser.
describeSymbol: function parser_describeSymbol(symbol) {
    if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {
        return this.terminal_descriptions_[symbol];
    } else if (symbol === this.EOF) {
        return 'end of input';
    }
    var id = this.getSymbolName(symbol);
    if (id) {
        return this.quoteName(id);
    }
    return null;
},

// Produce a (more or less) human-readable list of expected tokens at the point of failure.
//
// The produced list may contain token or token set descriptions instead of the tokens
// themselves to help turning this output into something that easier to read by humans
// unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,
// expected terminals and nonterminals is produced.
//
// The returned list (array) will not contain any duplicate entries.
collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {
    var TERROR = this.TERROR;
    var tokenset = [];
    var check = {};
    // Has this (error?) state been outfitted with a custom expectations description text for human consumption?
    // If so, use that one instead of the less palatable token set.
    if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {
        return [this.state_descriptions_[state]];
    }
    for (var p in this.table[state]) {
        p = +p;
        if (p !== TERROR) {
            var d = do_not_describe ? p : this.describeSymbol(p);
            if (d && !check[d]) {
                tokenset.push(d);
                check[d] = true; // Mark this token description as already mentioned to prevent outputting duplicate entries.
            }
        }
    }
    return tokenset;
},
productions_: bp({
  pop: u([
  99,
  s,
  [100, 4],
  s,
  [101, 35],
  102,
  102,
  103,
  103
]),
  rule: u([
  3,
  0,
  s,
  [1, 6],
  3,
  3,
  4,
  s,
  [3, 17],
  2,
  2,
  c,
  [3, 3],
  s,
  [2, 3],
  3,
  5,
  6,
  4,
  1,
  3,
  0,
  3
])
}),
performAction: function parser__PerformAction(yystate /* action[1] */, yysp, yyvstack) {

          /* this == yyval */

          // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!
          var yy = this.yy;
          var yyparser = yy.parser;
          var yylexer = yy.lexer;

          

          switch (yystate) {
case 0:
    /*! Production::    $accept : input $end */

    // default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,-,-,-,-):
    this.$ = undefined;
    // END of default action (generated by JISON mode none/merge :: 1,VT,VA,-,-,-,-,-,-)
    break;

case 1:
    /*! Production::    input : s line EOF */

    var rv = null;
    for (var i = 0, len = yyvstack[yysp - 2].length; i < len; i++) {
      var line = yyvstack[yysp - 2][i][0];
      if (!rv) {
        rv = line;
      } else if (line.length) {
        // We MUST signal the end of an expression as otherwise our AST grammar
        // will be ambiguous (and thus our tree walkers confused and unable to
        // work) as we must be able to differentiate between 'end of function arglist'
        // and 'end of statement': since we expect more functions (and thus
        // arglist terminations) than statements, we choose to give the FUNCTION
        // arglist an implicit termination while the statement gets to have an
        // *explicit* termination (#EOL# token) so that we end up with a shorter
        // AST stream -- iff our assumption holds in actual use!
        //
        // NOTE: We only need to add a sentinel when multiple statements (lines)
        // are input: when there's only a single statement (line) it'll unambiguously
        // terminated by EOF!
        if (rv.length) {
          rv.push( /* EOL */ 11);
        }
        append.apply(rv, line);
      }
    }
    
    if (!rv) {
      rv = yyvstack[yysp - 1];
    } else if (yyvstack[yysp - 1].length) {
      // We MUST signal the end of an expression as otherwise our AST grammar
      // will be ambiguous (and thus our tree walkers confused and unable to
      // work) as we must be able to differentiate between 'end of function arglist'
      // and 'end of statement': since we expect more functions (and thus
      // arglist terminations) than statements, we choose to give the FUNCTION
      // arglist an implicit termination while the statement gets to have an
      // *explicit* termination (#EOL# token) so that we end up with a shorter
      // AST stream -- iff our assumption holds in actual use!
      //
      // NOTE: We only need to add a sentinel when multiple statements (lines)
      // are input: when there's only a single statement (line) it'll unambiguously
      // terminated by EOF!
      if (rv.length) {
        rv.push( /* EOL */ 11);
      }
      append.apply(rv, yyvstack[yysp - 1]);
    }
    
    // always make sure the AST stream is terminated by an EOL:
    // this makes the treewalker grammars a little easier as then a line is always
    // followed by an EOL!
    if (rv.length) {
      rv.push( /* EOL */ 11);
    }
    
    this.$ = rv;
    break;

case 2:
    /*! Production::    line : %epsilon */
case 43:
    /*! Production::    s : %epsilon */

    this.$ = [];
    break;

case 3:
    /*! Production::    line : exp */

    console.log('line: ', JSON.stringify(yyvstack[yysp], null, 2));
    this.$ = yyvstack[yysp];
    break;

case 4:
    /*! Production::    line : COMMENT */

    this.$ = [ /* COMMENT */ 97, yyvstack[yysp]];
    break;

case 5:
    /*! Production::    line : error */

    yyparser.yyErrOk();
    yyparser.yyClearIn();
    console.log('skipped erroneous input line', typeof yy.lastErrorInfo);
    this.$ = [ /* ERROR */ 3, yy.lastErrorInfo];
    break;

case 6:
    /*! Production::    exp : NUM */

    this.$ = [ /* NUM */ 73, yyvstack[yysp]];
    break;

case 7:
    /*! Production::    exp : CONSTANT */

    this.$ = [ /* CONSTANT */ 8, yyvstack[yysp]];
    break;

case 8:
    /*! Production::    exp : VAR */

    this.$ = [ /* VAR */ 86, yyvstack[yysp]];
    break;

case 9:
    /*! Production::    exp : VAR "=" exp */

    /*
       Note: #assign is always to a simple variable, hence we don't need the `#VAR`
       token here: it is implicit as there's nothing else we can do.
    
       Technically, this is an AST optimization, but it's such a fundamental one
       we do it here instead of later.
    
       NOTE: #assign implies the presence of a VAR as lhs (left hand side) so it
       would only be cluttering the AST stream to have a #VAR# token in there:
       it is *implicit* to #assign!
     */
    yyvstack[yysp].push( /* ASSIGN */ 7, yyvstack[yysp - 2]);
    this.$ = yyvstack[yysp];
    break;

case 10:
    /*! Production::    exp : FUNCTION "(" ")" */

    this.$ = [ /* FUNCTION_0 */ 48, yyvstack[yysp - 2]];
    break;

case 11:
    /*! Production::    exp : FUNCTION "(" arglist ")" */

    /*
       See the comment in the statement EOL rule above: to disambiguate a sequence
       of exp subtrees, we MUST add a terminator to either or both statement and
       function, otherwise the sequence `FUNCTION exp exp` is ambiguous: it could
       be:
    
       - a no-args functions and two more statements,
       - a single-arg function and one more statement,
       - a two-arg function.
    
       Of course, you may argue that adding 'number of arguments' knowledge to the
       FUNCTION token would also resolve this issue, and it would, but that would
       be a bit harder to encode in an LALR(1) grammar used as the treewalker core.
       It is easier to use a sentinel token in one or both spots.
    
       A lot of functions have only a few arguments, which we later optimize in our AST
       by including that knowledge in the FUNCTION token by using derivative tokens
       FUNCTION_0, FUNCTION_1, etc.: this can help a smart optimizer to include
       special optimizations for these functions without having to re-discover
       the arglist length.
       As that approach already disambiguates the function-versus-statement
       situation by having encoded arglist length in the FUNCTION token, these
       tokens never require a sentinel token in the AST stream: small AST stream size.
    
       NOTE:
       As every arg in the arglist comes with a #PUSH# token, we *might* have opted
       to push an extra #POP# token into the stream before the #FUNCTION# token,
       but we don't have to as that #POP# is *implicit# in the #FUNCTION# token
       (assuming the arglist is non-empty, of course).
    
       Now we let the optimizer deal with this when the time comes...
    
       Meanwhile, keep it as simple as possible in here!
    
       Also don't forget to FLATTEN the arglist! ==> `concat.apply(a, arglist)`
    
       NOTE: the #FUNCTION# rule in Reverse Polish Notation is ambiguous unless we 'terminate' it
       (which is easy to parse in an LALR(1) grammar while adding a argument count is not!)
       as we would otherwise get confused over this scenario:
    
            ... exp exp exp FUNCTION PLUS ...
    
       - is this a function with one argument and that first `exp` in there the second term
         of a binary(?) opcode waiting in the trailing `...`?
       - is this a function with two arguments and that first `exp` the second
         term of the PLUS?
       - is this a function with three arguments and is the second term of the PLUS
         hiding in the leading `...`?
    
       This is the trouble with opcodes which accept a variable number of arguments:
       such opcodes always have to be terminated by a sentinel to make the AST grammar
       unambiguous.
    
       ... On second thought, we can easily apply the FUNCTION_<N> AST optimization
       now, and it doesn't impact the AST rule set much, while it opens up other
       possibilities... (Also don't forget to POP the last PUSH in the $arglist:
       again that is another optimization that simplifies the interpreter and does not
       demand the full power of an AST optimizer!)
    */
    var opcode;
    var n = yyvstack[yysp - 1].length;
    switch (n) {
    default:
      // no #END# sentinel needed as we store the N = number of arguments
      // with the #FUNCTION# opcode itself (see further below)
      this.$ = flatten.apply([], yyvstack[yysp - 1]);
      opcode =  /* FUNCTION_N */ 57;
      break;
    
    case 1:
      this.$ = flatten.apply([], yyvstack[yysp - 1]);
      opcode =  /* FUNCTION_1 */ 49;
      n = 0;
      break;
    
    case 2:
      this.$ = flatten.apply([], yyvstack[yysp - 1]);
      opcode =  /* FUNCTION_2 */ 50;
      n = 0;
      break;
    
    case 3:
      this.$ = flatten.apply([], yyvstack[yysp - 1]);
      opcode =  /* FUNCTION_3 */ 51;
      n = 0;
      break;
    }
    // remove/pop last PUSH:
    this.$.pop();
    
    this.$.push(opcode);
    this.$.push(yyvstack[yysp - 3]);
    if (n) {
      this.$.push(n);
    }
    break;

case 12:
    /*! Production::    exp : exp EQ exp */

    yyvstack[yysp - 2].push( /* PUSH */ 44);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    yyvstack[yysp - 2].push( /* EQ */ 61);
    this.$ = yyvstack[yysp - 2];
    break;

case 13:
    /*! Production::    exp : exp NEQ exp */

    yyvstack[yysp - 2].push( /* PUSH */ 44);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    yyvstack[yysp - 2].push( /* NEQ */ 110);
    this.$ = yyvstack[yysp - 2];
    break;

case 14:
    /*! Production::    exp : exp LEQ exp */

    yyvstack[yysp - 2].push( /* PUSH */ 44);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    yyvstack[yysp - 2].push( /* LEQ */ 23);
    this.$ = yyvstack[yysp - 2];
    break;

case 15:
    /*! Production::    exp : exp GEQ exp */

    yyvstack[yysp - 2].push( /* PUSH */ 44);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    yyvstack[yysp - 2].push( /* GEQ */ 20);
    this.$ = yyvstack[yysp - 2];
    break;

case 16:
    /*! Production::    exp : exp LT exp */

    yyvstack[yysp - 2].push( /* PUSH */ 44);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    yyvstack[yysp - 2].push( /* LT */ 60);
    this.$ = yyvstack[yysp - 2];
    break;

case 17:
    /*! Production::    exp : exp GT exp */

    yyvstack[yysp - 2].push( /* PUSH */ 44);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    yyvstack[yysp - 2].push( /* GT */ 62);
    this.$ = yyvstack[yysp - 2];
    break;

case 18:
    /*! Production::    exp : exp OR exp */

    yyvstack[yysp - 2].push( /* PUSH */ 44);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    yyvstack[yysp - 2].push( /* OR */ 79);
    this.$ = yyvstack[yysp - 2];
    break;

case 19:
    /*! Production::    exp : exp XOR exp */

    yyvstack[yysp - 2].push( /* PUSH */ 44);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    yyvstack[yysp - 2].push( /* XOR */ 88);
    this.$ = yyvstack[yysp - 2];
    break;

case 20:
    /*! Production::    exp : exp AND exp */

    yyvstack[yysp - 2].push( /* PUSH */ 44);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    yyvstack[yysp - 2].push( /* AND */ 65);
    this.$ = yyvstack[yysp - 2];
    break;

case 21:
    /*! Production::    exp : exp "|" exp */

    yyvstack[yysp - 2].push( /* PUSH */ 44);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    yyvstack[yysp - 2].push( /* BITWISE_OR */ 124);
    this.$ = yyvstack[yysp - 2];
    break;

case 22:
    /*! Production::    exp : exp "^" exp */

    yyvstack[yysp - 2].push( /* PUSH */ 44);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    yyvstack[yysp - 2].push( /* BITWISE_XOR */ 94);
    this.$ = yyvstack[yysp - 2];
    break;

case 23:
    /*! Production::    exp : exp "&" exp */

    yyvstack[yysp - 2].push( /* PUSH */ 44);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    yyvstack[yysp - 2].push( /* BITWISE_AND */ 38);
    this.$ = yyvstack[yysp - 2];
    break;

case 24:
    /*! Production::    exp : exp "+" exp */

    yyvstack[yysp - 2].push( /* PUSH */ 44);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    yyvstack[yysp - 2].push( /* ADD */ 43);
    this.$ = yyvstack[yysp - 2];
    break;

case 25:
    /*! Production::    exp : exp "-" exp */

    yyvstack[yysp - 2].push( /* PUSH */ 44);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    yyvstack[yysp - 2].push( /* SUBTRACT */ 45);
    this.$ = yyvstack[yysp - 2];
    break;

case 26:
    /*! Production::    exp : exp "*" exp */

    yyvstack[yysp - 2].push( /* PUSH */ 44);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    yyvstack[yysp - 2].push( /* MULTIPLY */ 42);
    this.$ = yyvstack[yysp - 2];
    break;

case 27:
    /*! Production::    exp : exp "/" exp */

    yyvstack[yysp - 2].push( /* PUSH */ 44);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    yyvstack[yysp - 2].push( /* DIVIDE */ 47);
    this.$ = yyvstack[yysp - 2];
    break;

case 28:
    /*! Production::    exp : exp "%" exp */

    yyvstack[yysp - 2].push( /* PUSH */ 44);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    yyvstack[yysp - 2].push( /* MODULO */ 37);
    this.$ = yyvstack[yysp - 2];
    break;

case 29:
    /*! Production::    exp : "-" exp */

    yyvstack[yysp].push( /* UMINUS */ 58);
    this.$ = yyvstack[yysp];
    break;

case 30:
    /*! Production::    exp : "+" exp */

    yyvstack[yysp].push( /* UPLUS */ 67);
    this.$ = yyvstack[yysp];
    break;

case 31:
    /*! Production::    exp : exp POWER exp */

    yyvstack[yysp - 2].push( /* PUSH */ 44);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    yyvstack[yysp - 2].push( /* POWER */ 40);
    this.$ = yyvstack[yysp - 2];
    break;

case 32:
    /*! Production::    exp : exp "%" */

    yyvstack[yysp - 1].push( /* PERCENT */ 36);
    this.$ = yyvstack[yysp - 1];
    break;

case 33:
    /*! Production::    exp : exp "!" */

    yyvstack[yysp - 1].push( /* FACTORIAL */ 17);
    this.$ = yyvstack[yysp - 1];
    break;

case 34:
    /*! Production::    exp : "~" exp */

    yyvstack[yysp].push( /* BITWISE_NOT */ 126);
    this.$ = yyvstack[yysp];
    break;

case 35:
    /*! Production::    exp : "!" exp */
case 36:
    /*! Production::    exp : NOT exp */

    yyvstack[yysp].push( /* NOT */ 33);
    this.$ = yyvstack[yysp];
    break;

case 37:
    /*! Production::    exp : "(" exp ")" */

    this.$ = yyvstack[yysp - 1];
    break;

case 38:
    /*! Production::    exp : exp "?" exp ":" exp */
case 39:
    /*! Production::    exp : IF exp THEN exp ELSE exp */

    // $$ = $exp1.concat(#CONDITION#, $exp2.length + 1 + 2, $exp2, #SKIP#, $exp3.length + 1, $exp3);
    yyvstack[yysp - 4].push( /* CONDITION */ 63, yyvstack[yysp - 2].length + 1 + 2);
    append.apply(yyvstack[yysp - 4], yyvstack[yysp - 2]);
    yyvstack[yysp - 4].push( /* SKIP */ 83, yyvstack[yysp].length + 1);
    append.apply(yyvstack[yysp - 4], yyvstack[yysp]);
    this.$ = yyvstack[yysp - 4];
    break;

case 40:
    /*! Production::    exp : IF exp THEN exp */

    // $$ = $exp1.concat(#CONDITION#, $exp2.length + 1 + 2, $exp2, #SKIP#, 2 + 1, #NUM#, 0);
    yyvstack[yysp - 2].push( /* CONDITION */ 63, yyvstack[yysp].length + 1 + 2);
    append.apply(yyvstack[yysp - 2], yyvstack[yysp]);
    yyvstack[yysp - 2].push( /* SKIP */ 83, 2 + 1,  /* NUM */ 73, 0);
    this.$ = yyvstack[yysp - 2];
    break;

case 41:
    /*! Production::    arglist : exp */

    /*
       We do not *want* to be smart about the arglist here: we leave that to the FUNCTION rule
       as we can then have smarter optimizations of the AST streams than we can hope to
       accomplish here *and* we produce a simpler AST stream input for the optimizer, thus
       simplifying this code!
    
       Thus we *always* add a basic PUSH token to every function argument:
       the FUNCTION rule or optimizer can go and sort them out, optimizing them into customized pushes
       or register moves, depending on the context.
     */
    yyvstack[yysp].push( /* PUSH */ 44);
    this.$ = [yyvstack[yysp]];
    break;

case 42:
    /*! Production::    arglist : arglist "," exp */

    this.$ = yyvstack[yysp - 2];
    this.$.push(yyvstack[yysp]);
    break;

case 44:
    /*! Production::    s : s line EOL */

    yyvstack[yysp - 2].push([yyvstack[yysp - 1], yyvstack[yysp]]);
    this.$ = yyvstack[yysp - 2];
    break;

case 82:       // === NO_ACTION[1] :: ensures that anyone (but us) using this new state will fail dramatically!
                // error recovery reduction action (action generated by jison,
                // using the user-specified `%code error_recovery_reduction` %{...%}
                // code chunk below.

                
                break;
            
}
},
table: bt({
  len: u([
  17,
  1,
  17,
  2,
  22,
  2,
  2,
  27,
  27,
  28,
  1,
  s,
  [12, 7],
  1,
  15,
  s,
  [12, 16],
  36,
  12,
  27,
  12,
  12,
  14,
  s,
  [27, 5],
  21,
  21,
  s,
  [27, 18],
  c,
  [19, 3],
  2,
  22,
  c,
  [34, 3],
  27,
  12,
  27,
  27,
  22,
  12,
  27
]),
  symbol: u([
  1,
  2,
  8,
  11,
  21,
  33,
  70,
  72,
  73,
  84,
  85,
  86,
  91,
  92,
  97,
  99,
  103,
  1,
  c,
  [18, 15],
  100,
  101,
  1,
  11,
  1,
  11,
  20,
  23,
  40,
  60,
  61,
  62,
  65,
  76,
  79,
  81,
  82,
  84,
  85,
  s,
  [87, 5, 1],
  93,
  110,
  c,
  [24, 4],
  1,
  9,
  c,
  [27, 8],
  75,
  c,
  [28, 12],
  95,
  96,
  98,
  110,
  c,
  [27, 37],
  71,
  c,
  [28, 17],
  72,
  8,
  c,
  [125, 10],
  101,
  c,
  [12, 72],
  c,
  [213, 16],
  c,
  [100, 84],
  c,
  [12, 108],
  1,
  8,
  c,
  [322, 3],
  21,
  23,
  33,
  c,
  [324, 5],
  c,
  [22, 3],
  c,
  [326, 7],
  s,
  [86, 8, 1],
  c,
  [328, 3],
  101,
  110,
  c,
  [48, 13],
  c,
  [396, 26],
  c,
  [111, 30],
  75,
  c,
  [13, 6],
  102,
  c,
  [488, 64],
  c,
  [27, 71],
  c,
  [24, 20],
  c,
  [21, 8],
  c,
  [20, 12],
  c,
  [150, 110],
  c,
  [27, 378],
  c,
  [507, 19],
  95,
  c,
  [75, 55],
  75,
  96,
  c,
  [26, 20],
  96,
  c,
  [51, 28],
  c,
  [926, 25],
  c,
  [51, 38],
  c,
  [771, 74],
  96,
  c,
  [88, 40]
]),
  type: u([
  s,
  [2, 15],
  0,
  0,
  1,
  c,
  [18, 17],
  s,
  [2, 122],
  c,
  [123, 12],
  c,
  [12, 72],
  c,
  [100, 100],
  c,
  [12, 108],
  c,
  [215, 35],
  c,
  [48, 36],
  c,
  [99, 29],
  c,
  [516, 124],
  s,
  [2, 678],
  c,
  [926, 47],
  c,
  [39, 43],
  c,
  [139, 61],
  s,
  [2, 16]
]),
  state: u([
  s,
  [1, 4, 1],
  s,
  [42, 27, 1],
  71,
  70,
  77,
  78,
  79,
  81
]),
  mode: u([
  s,
  [2, 16],
  1,
  1,
  c,
  [3, 3],
  s,
  [1, 11],
  c,
  [18, 4],
  s,
  [1, 18],
  s,
  [2, 68],
  c,
  [69, 18],
  s,
  [1, 78],
  c,
  [94, 94],
  s,
  [1, 98],
  c,
  [289, 5],
  c,
  [6, 6],
  c,
  [189, 5],
  c,
  [311, 12],
  c,
  [14, 7],
  c,
  [402, 38],
  c,
  [299, 50],
  c,
  [470, 77],
  c,
  [27, 18],
  c,
  [602, 9],
  c,
  [10, 6],
  c,
  [221, 8],
  c,
  [476, 46],
  c,
  [69, 24],
  c,
  [27, 144],
  c,
  [450, 4],
  c,
  [27, 26],
  c,
  [8, 10],
  c,
  [81, 35],
  c,
  [323, 15],
  c,
  [533, 11],
  c,
  [33, 12],
  c,
  [27, 24],
  c,
  [583, 8],
  c,
  [27, 23],
  c,
  [114, 7],
  c,
  [27, 49],
  c,
  [16, 15],
  c,
  [27, 76],
  c,
  [507, 30],
  c,
  [1193, 14],
  c,
  [635, 30],
  c,
  [43, 10],
  c,
  [53, 14],
  c,
  [823, 50],
  c,
  [49, 38],
  c,
  [165, 30],
  c,
  [27, 19],
  c,
  [64, 12],
  c,
  [163, 15],
  c,
  [87, 38]
]),
  goto: u([
  s,
  [43, 15],
  2,
  6,
  8,
  2,
  17,
  15,
  10,
  16,
  7,
  12,
  11,
  9,
  14,
  13,
  5,
  18,
  19,
  3,
  3,
  23,
  22,
  37,
  24,
  20,
  25,
  28,
  29,
  26,
  s,
  [30, 5, 1],
  27,
  35,
  36,
  38,
  39,
  21,
  4,
  4,
  5,
  5,
  s,
  [6, 27],
  s,
  [7, 27],
  s,
  [8, 10],
  40,
  s,
  [8, 17],
  41,
  8,
  c,
  [123, 10],
  c,
  [11, 66],
  1,
  s,
  [44, 15],
  c,
  [93, 77],
  c,
  [11, 99],
  32,
  8,
  s,
  [32, 3],
  17,
  32,
  15,
  s,
  [32, 5],
  c,
  [21, 3],
  s,
  [32, 7],
  9,
  s,
  [32, 4],
  c,
  [30, 3],
  s,
  [32, 4],
  c,
  [46, 11],
  s,
  [33, 27],
  c,
  [106, 28],
  69,
  c,
  [12, 5],
  s,
  [29, 27],
  s,
  [30, 27],
  s,
  [34, 21],
  38,
  s,
  [34, 5],
  s,
  [35, 21],
  38,
  s,
  [35, 5],
  s,
  [36, 3],
  c,
  [594, 6],
  36,
  36,
  29,
  36,
  c,
  [595, 5],
  36,
  c,
  [595, 3],
  s,
  [36, 4],
  21,
  c,
  [618, 7],
  72,
  c,
  [619, 13],
  c,
  [639, 19],
  73,
  21,
  s,
  [12, 3],
  c,
  [24, 6],
  12,
  12,
  29,
  12,
  c,
  [25, 5],
  12,
  c,
  [25, 3],
  s,
  [12, 4],
  21,
  s,
  [13, 3],
  c,
  [27, 6],
  13,
  13,
  29,
  13,
  c,
  [27, 5],
  13,
  c,
  [27, 3],
  s,
  [13, 4],
  21,
  s,
  [14, 3],
  c,
  [27, 6],
  14,
  14,
  29,
  14,
  c,
  [27, 5],
  14,
  c,
  [27, 3],
  s,
  [14, 4],
  21,
  s,
  [15, 3],
  c,
  [27, 6],
  15,
  15,
  29,
  15,
  c,
  [27, 5],
  15,
  c,
  [27, 3],
  s,
  [15, 4],
  21,
  s,
  [16, 3],
  c,
  [27, 6],
  16,
  16,
  29,
  16,
  c,
  [27, 5],
  16,
  c,
  [27, 3],
  s,
  [16, 4],
  21,
  s,
  [17, 3],
  c,
  [27, 6],
  17,
  17,
  29,
  17,
  c,
  [27, 5],
  17,
  c,
  [27, 3],
  s,
  [17, 4],
  21,
  s,
  [18, 3],
  c,
  [186, 7],
  18,
  29,
  18,
  c,
  [27, 5],
  18,
  c,
  [27, 3],
  s,
  [18, 4],
  21,
  s,
  [19, 3],
  c,
  [27, 7],
  19,
  c,
  [214, 7],
  19,
  c,
  [27, 3],
  s,
  [19, 4],
  21,
  s,
  [20, 3],
  c,
  [27, 6],
  20,
  20,
  29,
  20,
  c,
  [27, 5],
  20,
  c,
  [27, 3],
  s,
  [20, 4],
  s,
  [21, 6],
  37,
  s,
  [21, 8],
  c,
  [27, 4],
  21,
  c,
  [27, 3],
  s,
  [21, 5],
  s,
  [22, 5],
  37,
  s,
  [22, 5],
  29,
  22,
  22,
  c,
  [27, 4],
  22,
  c,
  [27, 3],
  s,
  [22, 5],
  s,
  [23, 5],
  37,
  s,
  [23, 9],
  c,
  [27, 3],
  23,
  c,
  [27, 3],
  s,
  [23, 5],
  s,
  [24, 5],
  37,
  s,
  [24, 11],
  34,
  24,
  c,
  [27, 3],
  s,
  [24, 5],
  s,
  [25, 5],
  37,
  s,
  [25, 11],
  34,
  25,
  c,
  [27, 3],
  s,
  [25, 5],
  s,
  [26, 5],
  37,
  s,
  [26, 15],
  38,
  s,
  [26, 5],
  s,
  [27, 5],
  37,
  s,
  [27, 15],
  38,
  s,
  [27, 5],
  s,
  [28, 5],
  37,
  s,
  [28, 15],
  38,
  s,
  [28, 5],
  s,
  [31, 5],
  37,
  s,
  [31, 15],
  38,
  s,
  [31, 5],
  c,
  [507, 19],
  74,
  21,
  s,
  [9, 3],
  c,
  [24, 7],
  9,
  c,
  [25, 12],
  s,
  [9, 3],
  21,
  s,
  [10, 27],
  75,
  76,
  c,
  [53, 7],
  41,
  c,
  [53, 12],
  41,
  21,
  s,
  [37, 27],
  c,
  [823, 22],
  s,
  [11, 27],
  c,
  [38, 11],
  s,
  [40, 3],
  c,
  [112, 7],
  40,
  c,
  [112, 12],
  s,
  [40, 3],
  21,
  s,
  [38, 3],
  c,
  [27, 7],
  38,
  c,
  [27, 11],
  s,
  [38, 4],
  c,
  [747, 8],
  42,
  c,
  [51, 12],
  42,
  21,
  c,
  [87, 11],
  s,
  [39, 3],
  c,
  [36, 7],
  39,
  c,
  [36, 12],
  s,
  [39, 3],
  21
])
}),
defaultActions: bda({
  idx: u([
  0,
  s,
  [5, 4, 1],
  18,
  19,
  38,
  42,
  43,
  69,
  72,
  75
]),
  goto: u([
  43,
  s,
  [4, 4, 1],
  1,
  44,
  33,
  29,
  30,
  10,
  37,
  11
])
}),
parseError: function parseError(str, hash, ExceptionClass) {
    if (hash.recoverable) {
        if (typeof this.trace === 'function') {
            this.trace(str);
        }
        hash.destroy();             // destroy... well, *almost*!
    } else {
        if (typeof this.trace === 'function') {
            this.trace(str);
        }
        if (!ExceptionClass) {
            ExceptionClass = this.JisonParserError;
        }
        throw new ExceptionClass(str, hash);
    }
},
parse: function parse(input, globalSpace) {
    var self = this;
    var stack = new Array(128);         // token stack: stores token which leads to state at the same index (column storage)
    var sstack = new Array(128);        // state stack: stores states (column storage)

    var vstack = new Array(128);        // semantic value stack

    var table = this.table;
    var sp = 0;                         // 'stack pointer': index into the stacks


    


    var symbol = 0;
    var preErrorSymbol = 0;
    var lastEofErrorStateDepth = Infinity;
    var recoveringErrorInfo = null;
    var recovering = 0;                 // (only used when the grammar contains error recovery rules)
    var TERROR = this.TERROR;
    var EOF = this.EOF;
    var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = (this.options.errorRecoveryTokenDiscardCount | 0) || 3;
    var NO_ACTION = [0, 82 /* === table.length :: ensures that anyone using this new state will fail dramatically! */];

    var lexer;
    if (this.__lexer__) {
        lexer = this.__lexer__;
    } else {
        lexer = this.__lexer__ = Object.create(this.lexer);
    }

    var sharedState_yy = {
        parseError: undefined,
        quoteName: undefined,
        lexer: undefined,
        parser: undefined,
        pre_parse: undefined,
        post_parse: undefined,
        pre_lex: undefined,
        post_lex: undefined,
        globalSpace: globalSpace  // parseParams::globalSpace      // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!
    };

    var ASSERT;
    if (typeof assert !== 'function') {
        ASSERT = function JisonAssert(cond, msg) {
            if (!cond) {
                throw new Error('assertion failed: ' + (msg || '***'));
            }
        };
    } else {
        ASSERT = assert;
    }

    this.yyGetSharedState = function yyGetSharedState() {
        return sharedState_yy;
    };


    this.yyGetErrorInfoTrack = function yyGetErrorInfoTrack() {
        return recoveringErrorInfo;
    };


    // shallow clone objects, straight copy of simple `src` values
    // e.g. `lexer.yytext` MAY be a complex value object,
    // rather than a simple string/value.
    function shallow_copy(src) {
        if (typeof src === 'object') {
            var dst = {};
            for (var k in src) {
                if (Object.prototype.hasOwnProperty.call(src, k)) {
                    dst[k] = src[k];
                }
            }
            return dst;
        }
        return src;
    }
    function shallow_copy_noclobber(dst, src) {
        for (var k in src) {
            if (typeof dst[k] === 'undefined' && Object.prototype.hasOwnProperty.call(src, k)) {
                dst[k] = src[k];
            }
        }
    }

    // copy state
    shallow_copy_noclobber(sharedState_yy, this.yy);

    sharedState_yy.lexer = lexer;
    sharedState_yy.parser = this;





    // *Always* setup `yyError`, `YYRECOVERING`, `yyErrOk` and `yyClearIn` functions as it is paramount
    // to have *their* closure match ours -- if we only set them up once,
    // any subsequent `parse()` runs will fail in very obscure ways when
    // these functions are invoked in the user action code block(s) as
    // their closure will still refer to the `parse()` instance which set
    // them up. Hence we MUST set them up at the start of every `parse()` run!





    if (this.yyErrOk) {
        this.yyErrOk = function yyErrOk() {









            recovering = 0;

            // DO NOT reset/cleanup `recoveringErrorInfo` yet: userland code
            // MAY invoke this API before the error is actually fully
            // recovered, in which case the parser recovery code won't be able
            // to append the skipped tokens to this info object.
            // 
            // The rest of the kernel code is safe enough that it won't inadvertedly
            // re-use an old `recoveringErrorInfo` chunk so we'ld better wait
            // with destruction/cleanup until the end of the parse or until another
            // fresh parse error rears its ugly head...
            //
            // if (recoveringErrorInfo && typeof recoveringErrorInfo.destroy === 'function') {
            //     recoveringErrorInfo.destroy();
            //     recoveringErrorInfo = undefined;
            // }
        };
    }

    if (this.yyClearIn) {
        this.yyClearIn = function yyClearIn() {









            if (symbol === TERROR) {
                symbol = 0;



            }
            preErrorSymbol = 0;
        };
    }


    // Does the shared state override the default `parseError` that already comes with this instance?
    if (typeof sharedState_yy.parseError === 'function') {
        this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {
            if (!ExceptionClass) {
                ExceptionClass = this.JisonParserError;
            }
            return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);
        };
    } else {
        this.parseError = this.originalParseError;
    }

    // Does the shared state override the default `quoteName` that already comes with this instance?
    if (typeof sharedState_yy.quoteName === 'function') {
        this.quoteName = function quoteNameAlt(id_str) {
            return sharedState_yy.quoteName.call(this, id_str);
        };
    } else {
        this.quoteName = this.originalQuoteName;
    }

    // set up the cleanup function; make it an API so that external code can re-use this one in case of
    // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which
    // case this parse() API method doesn't come with a `finally { ... }` block any more!
    //
    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `sharedState`, etc. references will be *wrong*!
    this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {
        var rv;

        if (invoke_post_methods) {
            var hash;

            if (sharedState_yy.post_parse || this.post_parse) {
                // create an error hash info instance: we re-use this API in a **non-error situation**
                // as this one delivers all parser internals ready for access by userland code.
                hash = this.constructParseErrorInfo(null /* no error! */, null /* no exception! */, null, false);
            }

            if (sharedState_yy.post_parse) {
                rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }
            if (this.post_parse) {
                rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }

            // cleanup:
            if (hash && hash.destroy) {
                hash.destroy();
            }
        }




        // clean up the lingering lexer structures as well:
        if (lexer.cleanupAfterLex) {
            lexer.cleanupAfterLex(do_not_nuke_errorinfos);
        }

        // prevent lingering circular references from causing memory leaks:
        if (sharedState_yy) {
            sharedState_yy.lexer = undefined;
            sharedState_yy.parser = undefined;
            if (lexer.yy === sharedState_yy) {
                lexer.yy = undefined;
            }
        }
        sharedState_yy = undefined;
        this.parseError = this.originalParseError;
        this.quoteName = this.originalQuoteName;

        // nuke the vstack[] array at least as that one will still reference obsoleted user values.
        // To be safe, we nuke the other internal stack columns as well...
        stack.length = 0;               // fastest way to nuke an array without overly bothering the GC
        sstack.length = 0;

        vstack.length = 0;
        sp = 0;

        // nuke the error hash info instances created during this run.
        // Userland code must COPY any data/references
        // in the error hash instance(s) it is more permanently interested in.
        if (!do_not_nuke_errorinfos) {
            for (var i = this.__error_infos.length - 1; i >= 0; i--) {
                var el = this.__error_infos[i];
                if (el && typeof el.destroy === 'function') {
                    el.destroy();
                }
            }
            this.__error_infos.length = 0;


            for (var i = this.__error_recovery_infos.length - 1; i >= 0; i--) {
                var el = this.__error_recovery_infos[i];
                if (el && typeof el.destroy === 'function') {
                    el.destroy();
                }
            }
            this.__error_recovery_infos.length = 0;

            // `recoveringErrorInfo` is also part of the `__error_recovery_infos` array,
            // hence has been destroyed already: no need to do that *twice*.
            if (recoveringErrorInfo) {
                recoveringErrorInfo = undefined;
            }


        }

        return resultValue;
    };






































































































































    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!
    this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {
        var pei = {
            errStr: msg,
            exception: ex,
            text: lexer.match,
            value: lexer.yytext,
            token: this.describeSymbol(symbol) || symbol,
            token_id: symbol,
            line: lexer.yylineno,

            expected: expected,
            recoverable: recoverable,
            state: state,
            action: action,
            new_state: newState,
            symbol_stack: stack,
            state_stack: sstack,
            value_stack: vstack,

            stack_pointer: sp,
            yy: sharedState_yy,
            lexer: lexer,
            parser: this,

            // and make sure the error info doesn't stay due to potential
            // ref cycle via userland code manipulations.
            // These would otherwise all be memory leak opportunities!
            //
            // Note that only array and object references are nuked as those
            // constitute the set of elements which can produce a cyclic ref.
            // The rest of the members is kept intact as they are harmless.
            destroy: function destructParseErrorInfo() {
                // remove cyclic references added to error info:
                // info.yy = null;
                // info.lexer = null;
                // info.value = null;
                // info.value_stack = null;
                // ...
                var rec = !!this.recoverable;
                for (var key in this) {
                    if (this.hasOwnProperty(key) && typeof key === 'object') {
                        this[key] = undefined;
                    }
                }
                this.recoverable = rec;
            }
        };
        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
        this.__error_infos.push(pei);
        return pei;
    };

    // clone some parts of the (possibly enhanced!) errorInfo object
    // to give them some persistence.
    this.shallowCopyErrorInfo = function parser_shallowCopyErrorInfo(p) {
        var rv = shallow_copy(p);

        // remove the large parts which can only cause cyclic references
        // and are otherwise available from the parser kernel anyway.
        delete rv.sharedState_yy;
        delete rv.parser;
        delete rv.lexer;

        // lexer.yytext MAY be a complex value object, rather than a simple string/value:
        rv.value = shallow_copy(rv.value);




        // the 'expected' set won't be modified, so no need to clone it:
        //rv.expected = rv.expected.slice(0);

        //symbol stack is a simple array:
        rv.symbol_stack = rv.symbol_stack.slice(0);
        // ditto for state stack:
        rv.state_stack = rv.state_stack.slice(0);


        // and the value stack may carry both simple and complex values:
        // shallow-copy the latter.
        rv.value_stack = rv.value_stack.map(shallow_copy);

        // and we don't bother with the sharedState_yy reference:
        //delete rv.yy;

        // now we prepare for tracking the COMBINE actions
        // in the error recovery code path:
        //
        // as we want to keep the maximum error info context, we
        // *scan* the state stack to find the first *empty* slot.
        // This position will surely be AT OR ABOVE the current
        // stack pointer, but we want to keep the 'used but discarded'
        // part of the parse stacks *intact* as those slots carry
        // error context that may be useful when you want to produce
        // very detailed error diagnostic reports.
        //
        // ### Purpose of each stack pointer:
        //
        // - stack_pointer: points at the top of the parse stack
        //                  **as it existed at the time of the error
        //                  occurrence, i.e. at the time the stack
        //                  snapshot was taken and copied into the
        //                  errorInfo object.**
        // - base_pointer:  the bottom of the **empty part** of the
        //                  stack, i.e. **the start of the rest of
        //                  the stack space /above/ the existing
        //                  parse stack. This section will be filled
        //                  by the error recovery process as it
        //                  travels the parse state machine to
        //                  arrive at the resolving error recovery rule.**
        // - info_stack_pointer:
        //                  this stack pointer points to the **top of
        //                  the error ecovery tracking stack space**, i.e.
        //                  this stack pointer takes up the role of
        //                  the `stack_pointer` for the error recovery
        //                  process. Any mutations in the **parse stack**
        //                  are **copy-appended** to this part of the
        //                  stack space, keeping the bottom part of the
        //                  stack (the 'snapshot' part where the parse
        //                  state at the time of error occurrence was kept)
        //                  intact.
        // - root_failure_pointer:
        //                  copy of the `stack_pointer`...
        //
        for (var i = rv.stack_pointer; typeof rv.state_stack[i] !== 'undefined'; i++) {
            // empty
        }
        rv.base_pointer = i;
        rv.info_stack_pointer = i;

        rv.root_failure_pointer = rv.stack_pointer;

        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
        this.__error_recovery_infos.push(rv);

        return rv;
    };

    function getNonTerminalFromCode(symbol) {
        var tokenName = self.getSymbolName(symbol);
        if (!tokenName) {
            tokenName = symbol;
        }
        return tokenName;
    }


    function stdLex() {
        var token = lexer.lex();
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }

        return token || 1/* EOF */;
    }

    function fastLex() {
        var token = lexer.fastLex();
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }

        return token || 1/* EOF */;
    }

    var lex = stdLex;


    var state, action, r, t;
    var yyval = {
        $: true,
        _$: undefined,
        yy: sharedState_yy
    };
    var p;
    var yyrulelen;
    var this_production;
    var newState;
    var retval = false;


    // Return the rule stack depth where the nearest error rule can be found.
    // Return -1 when no error recovery rule was found.
    function locateNearestErrorRecoveryRule(state) {
        var stack_probe = sp - 1;
        var depth = 0;

        // try to recover from error
        while (stack_probe >= 0) {
            // check for error recovery rule in this state









            var t = table[state][TERROR] || NO_ACTION;
            if (t[0]) {
                // We need to make sure we're not cycling forever:
                // once we hit EOF, even when we `yyerrok()` an error, we must
                // prevent the core from running forever,
                // e.g. when parent rules are still expecting certain input to
                // follow after this, for example when you handle an error inside a set
                // of braces which are matched by a parent rule in your grammar.
                //
                // Hence we require that every error handling/recovery attempt
                // *after we've hit EOF* has a diminishing state stack: this means
                // we will ultimately have unwound the state stack entirely and thus
                // terminate the parse in a controlled fashion even when we have
                // very complex error/recovery code interplay in the core + user
                // action code blocks:









                if (symbol === 1/* EOF */) {
                    if (lastEofErrorStateDepth > sp - 1 - depth) {
                        lastEofErrorStateDepth = sp - 1 - depth;
                    } else {









                        --stack_probe; // popStack(1): [symbol, action]
                        state = sstack[stack_probe];
                        ++depth;
                        continue;
                    }
                }
                return depth;
            }
            if (state === 0 /* $accept rule */ || stack_probe < 1) {









                return -1; // No suitable error recovery rule available.
            }
            --stack_probe; // popStack(1): [symbol, action]
            state = sstack[stack_probe];
            ++depth;
        }









        return -1; // No suitable error recovery rule available.
    }




    lexer.setInput(input, sharedState_yy);

    // NOTE: we *assume* no lexer pre/post handlers are set up *after* 
    // this initial `setInput()` call: hence we can now check and decide
    // whether we'll go with the standard, slower, lex() API or the
    // `fast_lex()` one:
    if (typeof lexer.canIUse === 'function') {
        var lexerInfo = lexer.canIUse();
        if (lexerInfo.fastLex && typeof fastLex === 'function') {
            lex = fastLex;
        }
    } 



    vstack[sp] = null;
    sstack[sp] = 0;
    stack[sp] = 0;
    ++sp;





    if (this.pre_parse) {
        this.pre_parse.call(this, sharedState_yy);
    }
    if (sharedState_yy.pre_parse) {
        sharedState_yy.pre_parse.call(this, sharedState_yy);
    }

    newState = sstack[sp - 1];
    for (;;) {
        // retrieve state number from top of stack
        state = newState;               // sstack[sp - 1];

        // use default actions if available
        if (this.defaultActions[state]) {
            action = 2;
            newState = this.defaultActions[state];
        } else {
            // The single `==` condition below covers both these `===` comparisons in a single
            // operation:
            //
            //     if (symbol === null || typeof symbol === 'undefined') ...
            if (!symbol) {
                symbol = lex();
            }
            // read action for current state and first input
            t = (table[state] && table[state][symbol]) || NO_ACTION;
            newState = t[1];
            action = t[0];











            // handle parse error
            if (!action) {
                // first see if there's any chance at hitting an error recovery rule:
                var error_rule_depth = locateNearestErrorRecoveryRule(state);
                var errStr = null;
                var errSymbolDescr = (this.describeSymbol(symbol) || symbol);
                var expected = this.collect_expected_token_set(state);

                if (!recovering) {
                    // Report error
                    if (typeof lexer.yylineno === 'number') {
                        errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';
                    } else {
                        errStr = 'Parse error: ';
                    }

                    if (typeof lexer.showPosition === 'function') {
                        errStr += '\n' + lexer.showPosition(79 - 10, 10) + '\n';
                    }
                    if (expected.length) {
                        errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;
                    } else {
                        errStr += 'Unexpected ' + errSymbolDescr;
                    }

                    p = this.constructParseErrorInfo(errStr, null, expected, (error_rule_depth >= 0));

                    // DO NOT cleanup the old one before we start the new error info track:
                    // the old one will *linger* on the error stack and stay alive until we 
                    // invoke the parser's cleanup API!
                    recoveringErrorInfo = this.shallowCopyErrorInfo(p);

                    r = this.parseError(p.errStr, p, this.JisonParserError);









                    // Protect against overly blunt userland `parseError` code which *sets*
                    // the `recoverable` flag without properly checking first:
                    // we always terminate the parse when there's no recovery rule available anyhow!
                    if (!p.recoverable || error_rule_depth < 0) {
                        if (typeof r !== 'undefined') {
                            retval = r;
                        }
                        break;
                    } else {
                        // TODO: allow parseError callback to edit symbol and or state at the start of the error recovery process...
                    }
                }










                var esp = recoveringErrorInfo.info_stack_pointer;

                // just recovered from another error
                if (recovering === ERROR_RECOVERY_TOKEN_DISCARD_COUNT && error_rule_depth >= 0) {
                    // SHIFT current lookahead and grab another
                    recoveringErrorInfo.symbol_stack[esp] = symbol;
                    recoveringErrorInfo.value_stack[esp] = shallow_copy(lexer.yytext);

                    recoveringErrorInfo.state_stack[esp] = newState; // push state
                    ++esp;

                    // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:





                    preErrorSymbol = 0;
                    symbol = lex();









                }

                // try to recover from error
                if (error_rule_depth < 0) {
                    ASSERT(recovering > 0, "line 897");
                    recoveringErrorInfo.info_stack_pointer = esp;

                    // barf a fatal hairball when we're out of look-ahead symbols and none hit a match
                    // while we are still busy recovering from another error:
                    var po = this.__error_infos[this.__error_infos.length - 1];

                    // Report error
                    if (typeof lexer.yylineno === 'number') {
                        errStr = 'Parsing halted on line ' + (lexer.yylineno + 1) + ' while starting to recover from another error';
                    } else {
                        errStr = 'Parsing halted while starting to recover from another error';
                    }

                    if (po) {
                        errStr += ' -- previous error which resulted in this fatal result: ' + po.errStr;
                    } else {
                        errStr += ': ';
                    }

                    if (typeof lexer.showPosition === 'function') {
                        errStr += '\n' + lexer.showPosition(79 - 10, 10) + '\n';
                    }
                    if (expected.length) {
                        errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;
                    } else {
                        errStr += 'Unexpected ' + errSymbolDescr;
                    }

                    p = this.constructParseErrorInfo(errStr, null, expected, false);
                    if (po) {
                        p.extra_error_attributes = po;
                    }

                    r = this.parseError(p.errStr, p, this.JisonParserError);
                    if (typeof r !== 'undefined') {
                        retval = r;
                    }
                    break;
                }

                preErrorSymbol = (symbol === TERROR ? 0 : symbol); // save the lookahead token
                symbol = TERROR;            // insert generic error symbol as new lookahead

                const EXTRA_STACK_SAMPLE_DEPTH = 3;

                // REDUCE/COMBINE the pushed terms/tokens to a new ERROR token:
                recoveringErrorInfo.symbol_stack[esp] = preErrorSymbol;
                if (errStr) {
                    recoveringErrorInfo.value_stack[esp] = {
                        yytext: shallow_copy(lexer.yytext),
                        errorRuleDepth: error_rule_depth,
                        errStr: errStr,
                        errorSymbolDescr: errSymbolDescr,
                        expectedStr: expected,
                        stackSampleLength: error_rule_depth + EXTRA_STACK_SAMPLE_DEPTH
                    };









                } else {
                    recoveringErrorInfo.value_stack[esp] = {
                        yytext: shallow_copy(lexer.yytext),
                        errorRuleDepth: error_rule_depth,
                        stackSampleLength: error_rule_depth + EXTRA_STACK_SAMPLE_DEPTH
                    };
                }

                recoveringErrorInfo.state_stack[esp] = newState || NO_ACTION[1];

                ++esp;
                recoveringErrorInfo.info_stack_pointer = esp;

                yyval.$ = recoveringErrorInfo;


                yyrulelen = error_rule_depth;









                r = this.performAction.call(yyval, NO_ACTION[1], sp - 1, vstack);

                if (typeof r !== 'undefined') {
                    retval = r;
                    break;
                }

                // pop off stack
                sp -= yyrulelen;

                // and move the top entries + discarded part of the parse stacks onto the error info stack:
                for (var idx = sp - EXTRA_STACK_SAMPLE_DEPTH, top = idx + yyrulelen; idx < top; idx++, esp++) {
                    recoveringErrorInfo.symbol_stack[esp] = stack[idx];
                    recoveringErrorInfo.value_stack[esp] = shallow_copy(vstack[idx]);

                    recoveringErrorInfo.state_stack[esp] = sstack[idx];
                }

                recoveringErrorInfo.symbol_stack[esp] = TERROR;
                recoveringErrorInfo.value_stack[esp] = shallow_copy(yyval.$);


                // goto new state = table[STATE][NONTERMINAL]
                newState = sstack[sp - 1];

                if (this.defaultActions[newState]) {
                    recoveringErrorInfo.state_stack[esp] = this.defaultActions[newState];
                } else {
                    t = (table[newState] && table[newState][symbol]) || NO_ACTION;
                    recoveringErrorInfo.state_stack[esp] = t[1];
                }

                ++esp;
                recoveringErrorInfo.info_stack_pointer = esp;

                // allow N (default: 3) real symbols to be shifted before reporting a new error
                recovering = ERROR_RECOVERY_TOKEN_DISCARD_COUNT;










                // Now duplicate the standard parse machine here, at least its initial
                // couple of rounds until the TERROR symbol is **pushed onto the parse stack**,
                // as we wish to push something special then!
                //
                // Run the state machine in this copy of the parser state machine
                // until we *either* consume the error symbol (and its related information)
                // *or* we run into another error while recovering from this one
                // *or* we execute a `reduce` action which outputs a final parse
                // result (yes, that MAY happen!).
                //
                // We stay in this secondary parse loop until we have completed
                // the *error recovery phase* as the main parse loop (further below)
                // is optimized for regular parse operation and DOES NOT cope with
                // error recovery *at all*.
                //
                // We call the secondary parse loop just below the "slow parse loop",
                // while the main parse loop, which is an almost-duplicate of this one,
                // yet optimized for regular parse operation, is called the "fast
                // parse loop".
                //
                // Compare this to `bison` & (vanilla) `jison`, both of which have
                // only a single parse loop, which handles everything. Our goal is
                // to eke out every drop of performance in the main parse loop...

                ASSERT(recoveringErrorInfo, "line 1049");
                ASSERT(symbol === TERROR, "line 1050");
                ASSERT(!action, "line 1051");
                var errorSymbolFromParser = true;
                for (;;) {
                    // retrieve state number from top of stack
                    state = newState;               // sstack[sp - 1];

                    // use default actions if available
                    if (this.defaultActions[state]) {
                        action = 2;
                        newState = this.defaultActions[state];
                    } else {
                        // The single `==` condition below covers both these `===` comparisons in a single
                        // operation:
                        //
                        //     if (symbol === null || typeof symbol === 'undefined') ...
                        if (!symbol) {
                            symbol = lex();
                            // **Warning: Edge Case**: the *lexer* may produce
                            // TERROR tokens of its own volition: *those* TERROR
                            // tokens should be treated like *regular tokens*
                            // i.e. tokens which have a lexer-provided `yyvalue`

                            errorSymbolFromParser = false;
                        }
                        // read action for current state and first input
                        t = (table[state] && table[state][symbol]) || NO_ACTION;
                        newState = t[1];
                        action = t[0];










                        // encountered another parse error? If so, break out to main loop
                        // and take it from there!
                        if (!action) {










                            ASSERT(recoveringErrorInfo, "line 1087");

                            // Prep state variables so that upon breaking out of
                            // this "slow parse loop" and hitting the `continue;`
                            // statement in the outer "fast parse loop" we redo
                            // the exact same state table lookup as the one above
                            // so that the outer=main loop will also correctly
                            // detect the 'parse error' state (`!action`) we have
                            // just encountered above.
                            newState = state;
                            break;
                        }
                    }










                    switch (action) {
                    // catch misc. parse failures:
                    default:
                        // this shouldn't happen, unless resolve defaults are off
                        //
                        // SILENTLY SIGNAL that the outer "fast parse loop" should
                        // take care of this internal error condition:
                        // prevent useless code duplication now/here.
                        break;

                    // shift:
                    case 1:
                        stack[sp] = symbol;
                        // ### Note/Warning ###
                        //
                        // The *lexer* may also produce TERROR tokens on its own,
                        // so we specifically test for the TERROR we did set up
                        // in the error recovery logic further above!
                        if (symbol === TERROR && errorSymbolFromParser) {
                            // Push a special value onto the stack when we're
                            // shifting the `error` symbol that is related to the
                            // error we're recovering from.
                            ASSERT(recoveringErrorInfo, "line 1131");
                            vstack[sp] = recoveringErrorInfo;
                        } else {
                            ASSERT(symbol !== 0, "line 1135");
                            ASSERT(preErrorSymbol === 0, "line 1136");
                            vstack[sp] = lexer.yytext;

                        }
                        sstack[sp] = newState; // push state

                        ++sp;
                        symbol = 0;
                        // **Warning: Edge Case**: the *lexer* may have produced
                        // TERROR tokens of its own volition: *those* TERROR
                        // tokens should be treated like *regular tokens*
                        // i.e. tokens which have a lexer-provided `yyvalue`

                        errorSymbolFromParser = false;
                        if (!preErrorSymbol) { // normal execution / no error
                            // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:





                            if (recovering > 0) {
                                recovering--;









                            }
                        } else {
                            // error just occurred, resume old lookahead f/ before error, *unless* that drops us straight back into error mode:
                            ASSERT(recovering > 0, "line 1163");
                            symbol = preErrorSymbol;
                            preErrorSymbol = 0;









                            // read action for current state and first input
                            t = (table[newState] && table[newState][symbol]) || NO_ACTION;
                            if (!t[0] || symbol === TERROR) {
                                // forget about that symbol and move forward: this wasn't a 'forgot to insert' error type where
                                // (simple) stuff might have been missing before the token which caused the error we're
                                // recovering from now...
                                //
                                // Also check if the LookAhead symbol isn't the ERROR token we set as part of the error
                                // recovery, for then this we would we idling (cycling) on the error forever.
                                // Yes, this does not take into account the possibility that the *lexer* may have
                                // produced a *new* TERROR token all by itself, but that would be a very peculiar grammar!









                                symbol = 0;
                            }
                        }

                        // once we have pushed the special ERROR token value,
                        // we REMAIN in this inner, "slow parse loop" until
                        // the entire error recovery phase has completed.
                        //
                        // ### Note About Edge Case ###
                        //
                        // Userland action code MAY already have 'reset' the
                        // error recovery phase marker `recovering` to ZERO(0)
                        // while the error symbol hasn't been shifted onto
                        // the stack yet. Hence we only exit this "slow parse loop"
                        // when *both* conditions are met!
                        ASSERT(preErrorSymbol === 0, "line 1194");
                        if (recovering === 0) {
                            break;
                        }
                        continue;

                    // reduce:
                    case 2:
                        this_production = this.productions_[newState - 1];  // `this.productions_[]` is zero-based indexed while states start from 1 upwards...
                        yyrulelen = this_production[1];










                        r = this.performAction.call(yyval, newState, sp - 1, vstack);

                        if (typeof r !== 'undefined') {
                            // signal end of error recovery loop AND end of outer parse loop
                            action = 3;
                            sp = -2;      // magic number: signal outer "fast parse loop" ACCEPT state that we already have a properly set up `retval` parser return value.
                            retval = r;
                            break;
                        }

                        // pop off stack
                        sp -= yyrulelen;

                        // don't overwrite the `symbol` variable: use a local var to speed things up:
                        var ntsymbol = this_production[0];    // push nonterminal (reduce)
                        stack[sp] = ntsymbol;
                        vstack[sp] = yyval.$;

                        // goto new state = table[STATE][NONTERMINAL]
                        newState = table[sstack[sp - 1]][ntsymbol];
                        sstack[sp] = newState;
                        ++sp;









                        continue;

                    // accept:
                    case 3:
                        retval = true;
                        // Return the `$accept` rule's `$$` result, if available.
                        //
                        // Also note that JISON always adds this top-most `$accept` rule (with implicit,
                        // default, action):
                        //
                        //     $accept: <startSymbol> $end
                        //                  %{ $$ = $1; @$ = @1; %}
                        //
                        // which, combined with the parse kernel's `$accept` state behaviour coded below,
                        // will produce the `$$` value output of the <startSymbol> rule as the parse result,
                        // IFF that result is *not* `undefined`. (See also the parser kernel code.)
                        //
                        // In code:
                        //
                        //                  %{
                        //                      @$ = @1;            // if location tracking support is included
                        //                      if (typeof $1 !== 'undefined')
                        //                          return $1;
                        //                      else
                        //                          return true;           // the default parse result if the rule actions don't produce anything
                        //                  %}
                        sp--;
                        if (sp >= 0 && typeof vstack[sp] !== 'undefined') {
                            retval = vstack[sp];
                        }
                        sp = -2;      // magic number: signal outer "fast parse loop" ACCEPT state that we already have a properly set up `retval` parser return value.
                        break;
                    }

                    // break out of loop: we accept or fail with error
                    break;
                }

                // should we also break out of the regular/outer parse loop,
                // i.e. did the parser already produce a parse result in here?!
                // *or* did we hit an unsupported parse state, to be handled
                // in the `switch/default` code further below?
                ASSERT(action !== 2, "line 1272");
                if (!action || action === 1) {
                    continue;
                }
            }


        }










        switch (action) {
        // catch misc. parse failures:
        default:
            // this shouldn't happen, unless resolve defaults are off
            if (action instanceof Array) {
                p = this.constructParseErrorInfo('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, null, null, false);
                r = this.parseError(p.errStr, p, this.JisonParserError);
                if (typeof r !== 'undefined') {
                    retval = r;
                }
                break;
            }
            // Another case of better safe than sorry: in case state transitions come out of another error recovery process
            // or a buggy LUT (LookUp Table):
            p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);
            r = this.parseError(p.errStr, p, this.JisonParserError);
            if (typeof r !== 'undefined') {
                retval = r;
            }
            break;

        // shift:
        case 1:
            stack[sp] = symbol;
            vstack[sp] = lexer.yytext;

            sstack[sp] = newState; // push state

            ++sp;
            symbol = 0;

            ASSERT(preErrorSymbol === 0, "line 1352");         // normal execution / no error
            ASSERT(recovering === 0, "line 1353");             // normal execution / no error

            // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:




            continue;

        // reduce:
        case 2:
            ASSERT(preErrorSymbol === 0, "line 1364");         // normal execution / no error
            ASSERT(recovering === 0, "line 1365");             // normal execution / no error

            this_production = this.productions_[newState - 1];  // `this.productions_[]` is zero-based indexed while states start from 1 upwards...
            yyrulelen = this_production[1];










            r = this.performAction.call(yyval, newState, sp - 1, vstack);

            if (typeof r !== 'undefined') {
                retval = r;
                break;
            }

            // pop off stack
            sp -= yyrulelen;

            // don't overwrite the `symbol` variable: use a local var to speed things up:
            var ntsymbol = this_production[0];    // push nonterminal (reduce)
            stack[sp] = ntsymbol;
            vstack[sp] = yyval.$;

            // goto new state = table[STATE][NONTERMINAL]
            newState = table[sstack[sp - 1]][ntsymbol];
            sstack[sp] = newState;
            ++sp;









            continue;

        // accept:
        case 3:
            if (sp !== -2) {
                retval = true;
                // Return the `$accept` rule's `$$` result, if available.
                //
                // Also note that JISON always adds this top-most `$accept` rule (with implicit,
                // default, action):
                //
                //     $accept: <startSymbol> $end
                //                  %{ $$ = $1; @$ = @1; %}
                //
                // which, combined with the parse kernel's `$accept` state behaviour coded below,
                // will produce the `$$` value output of the <startSymbol> rule as the parse result,
                // IFF that result is *not* `undefined`. (See also the parser kernel code.)
                //
                // In code:
                //
                //                  %{
                //                      @$ = @1;            // if location tracking support is included
                //                      if (typeof $1 !== 'undefined')
                //                          return $1;
                //                      else
                //                          return true;           // the default parse result if the rule actions don't produce anything
                //                  %}
                sp--;
                if (typeof vstack[sp] !== 'undefined') {
                    retval = vstack[sp];
                }
            }
            break;
        }

        // break out of loop: we accept or fail with error
        break;
    }
    
    // ... AND FINALLY ...

    retval = this.cleanupAfterParse(retval, true, true);


    

    return retval;
},
yyErrOk: 1,
yyClearIn: 1
};
parser.originalParseError = parser.parseError;
parser.originalQuoteName = parser.quoteName;

// helper functions which will help us reduce garbage production cf. https://www.scirra.com/blog/76/how-to-write-low-garbage-real-time-javascript

// flatten arrays into one:
var flatten = [].concat;

// append array of items:
var append = [].push;

function Parser() {
  this.yy = {};
}
Parser.prototype = parser;
parser.Parser = Parser;

return new Parser();
})();

        


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
  exports.parser = compiled_calc_parse_for_fast_engine;
  exports.Parser = compiled_calc_parse_for_fast_engine.Parser;
  exports.parse = function () {
    return compiled_calc_parse_for_fast_engine.parse.apply(compiled_calc_parse_for_fast_engine, arguments);
  };
  
}


// End Of Include by Jison: ./output/compiled_calc/compiled_calc_parse_for_fast_engine.js


// Next, we have the straight-from-AST-stream INTERPRETER:

// Included by Jison: compiled_calc_fast_Pcode_interpreter.js:



// Sourcecode template for the P-code interpreter: this is a very basic
// bottom-up tree walker, or a very basic CPU simulation, if you are 
// inclined to look at it that way.
//
// The key here is that the 'sorcerer' tree-walker has run before and
// produced a suitable AST token stream for my kind particularly: me, I
// don't do 'shift', not really, I only do 'reduce', so the 'sorcerer'
// has to inject the 'which bits in there need shifting?' knowledge into
// the AST so that these points in the flow show up as 'reduce' actions
// for me. Of course, you may find a bit strange to talk about 'shift'
// and 'reduce' when we already seem to have left the grammar/language 
// realm in here, running some kind of 'assembly code' disguised as an
// 'AST token stream': yes, this is a classic 'tape', but 'assembly code'
// is itself yet another language, though probably a very simple one (SLR(0)?)
// and I want to emphasize the fact that you are **still** working with
// a language, hence a *grammar*, in here; you just happened to have
// translated language A (AST token stream produced by the expression parser)
// into language B (AST token stream which looks very much like 'assembly code'
// as produced by the 'sorcerer' tree walker).
//
// How do you develop such a beast?
//
// First, I came up with the P-code runner, a.k.a. 'interpreter' and checked
// if my ideas about fast and faster code actually worked more or less.
// Once that had been nailed down, I thus knew what 'assembly language' I
// had to feed this P-code interpreter and *that* drives the translation/transposition
// activity required from the 'sorcerer' middleware, so that one has
// been next. 
//
// After that, it's a couple of iterations to get everything working to my
// satisfaction, which I'ld say would be possibly be 'Agile' this day and age,
// but I say it's correct application of the control engineering feedback loop model
// (or Waterfall Model of old, just to get your knickers in a twist)   :-)
//
// Anyway, the key element is that the P-code runner must be as fast as possible,
// hence have the least bit of overhead, and we can help a lot accomplishing 
// just that by making sure we pick a better format for our 'incoming' P-code
// stream.


// critical condition: the P-code stream input is to be treated as **immutable**
// so it can be re-used time and again!
function exec_Pcode(stream, context) {
  // our accumulator and register bank:
  //      https://www.scirra.com/blog/76/how-to-write-low-garbage-real-time-javascript
  var a, r1, r2, rx = [];
  // our accumulator and register bank optimized for integers:
  var ai, ri1, ri2, rix = [];
  // our accumulator and register bank optimized for floating point values:
  var af, rf1, rf2, rfx = [];
  // our accumulator and register bank optimized for string values:
  var as, rs1, rs2, rsx = [];
  // our accumulator and register bank optimized for boolean values:
  var ab, rb1, rb2, rbx = [];
  // our accumulator and register bank optimized for variable references:
  var av, rv1, rv2, rvx = [];
  // our accumulator optimized for constant references:
  var cv;

  // our error-stack, where errors get shifted before we invoke error-filtering functions:
  // we 'unshift' errors into this stack so that the 'active error' is always at index 0,
  // which saves us the hassle of keeping track of the length of the array.
  // We ASSUME the number of error stack CHECKS is quite a bit higher than the number
  // of error stack PUSH+POP actions, so we decide a potentially less optimal 
  // unshift-and-shift-vs-push-and-pop is preferable.
  var ex = context.error_stack;

  // misc references to context/global tables:
  var vt = context.variables;
  var ct = context.constants;

  // function/procedure reference register
  var f;

  // scratch register
  var b;

  // skip/jump helpers:
  var n, n1, n2;

  // inline integer, floating point reconstruction helpers
  var irh, fprh;

  for (var i = 0, len = stream.length; i < len; ) {
    var opcode = stream[i++];

    // As we can 'inline' integers, indexes and floating point values using
    // at least *part* of the opcode word (for both short and long notation)
    // we can best first extract the general route via bitmask, after which
    // we do the appropriate work for the given section:
    // - opcode execution (all parameters come from registers or stack)
    // - integer / index extraction (long notation takes extra words) + opcode execution
    // - floating point extraction (long notation takes extra words) + opcode execution
    //
    // We want the fastest possible run-time, so we don't bitshift or otherwise
    // attempt to make the extracted parts more 'human developer readable' while
    // we work, hence the values in the switch/cases may be different from the
    // ones that the AST generator (parser, code optimizer, ...) has been using
    // to construct the opcode / word.
    // 
    // For the bit patterns, compare this one with the code in the benchmark.js repo
    // at:
    // 
    //     GerHobbelt/benchmark.js::/example/jsperf/fpcvt.js
    // 
    // 

    // As we expect most encodings to be regular numbers, those will be in 0x0000..0x7FFF and
    // we don't want to spend the least amount of time in the 'special values' overhead,
    // which would be added overhead if we did check for those *first* instead of at the *same time*
    // as we do here by looking at the top nibble immediately:
    // 
    // nibble value:
    // 0..7: regular 'long encoding' floating point values. Act as *implicit* NUM opcodes.
    // 8..C: 'short float' encoded floating point values. Act as *implicit* NUM opcodes.
    // D: part of this range is illegal ('DO NOT USE') but the lower half (0xD000..0xD7FF),
    //    about 2K codes worth, is used for the other opcodes.
    // E: rest of the range for 'short float' encoded floating point values. 
    //    Act as *implicit* NUM opcodes.
    // F: rest of the range for 'short float' encoded floating point values. 
    //    Act as *implicit* NUM opcodes. (0xF800..0xFFFF: reserved for future use) 
    switch (opcode & 0xF000) {
    // This range includes the Unicode extended character ranges ('Surrogates') and MUST NOT be used by us for 'binary encoding'
    // purposes as we would than clash with any potential Unicode validators out there! The key of the current
    // design is that the encoded output is, itself, *legal* Unicode -- though admittedly I don't bother with
    // the Unicode conditions surrounding shift characters such as these:
    // 
    // which reside in the other ranges that we DO employ for our own nefarious encoding purposes!
    // 
    // By the way: do note that the clash-potential is for the Surrogates range 0xD800-0xDFFF hence 
    // 0xD000-0xD7FF (2K) *is* at least theoretically available for our encoding. And we DO use them now
    // for encoding floating point 'special values'.
    case 0xD000:
      // specials: compared to `GerHobbelt/benchmark.js::/example/jsperf/fpcvt.js` we have 
      // extended the use of the 0xF000 range by placing all regular opcodes in there.
      switch (opcode) {
      case FPC_ENC_POSITIVE_ZERO:
        return 0;

      case FPC_ENC_NEGATIVE_ZERO:
        return -0;

      case FPC_ENC_POSITIVE_INFINITY:
        return Infinity;

      case FPC_ENC_NEGATIVE_INFINITY:
        return -Infinity;

      case FPC_ENC_NAN:
        return NaN;

      default:
        throw new Error('illegal fp encoding value in 0xDXXX unicode range');
      }
      break;

    case 0x8000:
    case 0x9000:
    case 0xA000:
    case 0xB000:
    case 0xC000:
      // 'human values' encoded as 'short floats':
      //
      // Bits in word:
      // - 0..9: integer mantissa; values 0..1023
      // - 10: sign
      // - 11..14: exponent 0..9 with offset -3 --> -3..+6
      // - 15: set to signal special values; this bit is also set for some special Unicode characters,
      //       so we can only set this bit and have particular values in bits 0..14 at the same time
      //       in order to prevent a collision with those Unicode specials at 0xD800..0xDFFF.
      //
      var dm = c0 & 0x03FF;      // 10 bits
      var ds = c0 & 0x0400;      // bit 10 = sign
      var dp = c0 & 0x7800;      // bits 11..14: exponent

      //console.log('decode-short-0', ds, dm, '0x' + dp.toString(16), dp >>> 11, c0, '0x' + c0.toString(16));
      dp >>>= 11;
      dp -= 3 + 2;

      var sflt = dm * Math.pow(10, dp);
      if (ds) {
        sflt = -sflt;
      }
      //console.log('decode-short-1', sflt, ds, dm, dp, c0, '0x' + c0.toString(16));
      return sflt;

    // (0xF800..0xFFFF: reserved for future use)
    case 0xE000:
    case 0xF000:
      // 'human values' encoded as 'short floats':
      //
      // Bits in word:
      // - 0..9: integer mantissa; values 0..1023
      // - 10: sign
      // - 11..14: exponent 10..12 with offset -3 --> 7..9
      // - 15: set to signal special values; this bit is also set for some special Unicode characters,
      //       so we can only set this bit and have particular values in bits 0..14 at the same time
      //       in order to prevent a collision with those Unicode specials at 0xD800..0xDFFF.
      //
      var dm = c0 & 0x03FF;      // 10 bits
      var ds = c0 & 0x0400;      // bit 10 = sign
      var dp = c0 & 0x7800;      // bits 11..14: exponent

      //console.log('decode-short-0C', ds, dm, '0x' + dp.toString(16), dp >>> 11, c0, '0x' + c0.toString(16));
      dp >>>= 11;
      dp -= 3 + 2 + 2;            // like above, but now also compensate for exponent bumping (0xA --> 0xC, ...)
      if (dp > 12) {
        throw new Error('illegal fp encoding value in 0xF8XX-0xFFXX unicode range');
      }

      var sflt = dm * Math.pow(10, dp);
      if (ds) {
        sflt = -sflt;
      }
      //console.log('decode-short-1C', sflt, ds, dm, dp, c0, '0x' + c0.toString(16));
      return sflt;

    default:
      // 'regular' floating point values:
      //
      // Bits in word:
      // - 0..11: exponent; values -1024..+1023 with an offset of 1024 to make them all positive numbers
      // - 12: sign
      // - 13,14: length 1..4: the number of words following to define the mantissa
      // - 15: 0 (zero)
      //
      var len = c0 & 0x6000;
      var vs = c0 & 0x1000;
      var p = c0 & 0x0FFF;

      p -= 1024;
      //console.log('decode-normal-0', vs, p, len, '0x' + len.toString(16), c0, '0x' + c0.toString(16));

      // we don't need to loop to decode the mantissa: we know how much stuff will be waiting for us still
      // so this is fundamentally an unrolled loop coded as a switch/case:
      var m;
      var im;
      // no need to shift len before switch()ing on it: it's still the same number of possible values anyway:
      switch (len) {
      case 0x0000:
        // 1 more 15-bit word:
        im = s.charCodeAt(1);
        m = im / FPC_ENC_MODULO;
        opt.consumed_length++;
        //console.log('decode-normal-len=1', m, s.charCodeAt(1));
        break;

      case 0x2000:
        // 2 more 15-bit words:
        im = s.charCodeAt(1);
        im <<= 15;
        im |= s.charCodeAt(2);
        m = im / (FPC_ENC_MODULO * FPC_ENC_MODULO);
        opt.consumed_length += 2;
        //console.log('decode-normal-len=2', m, s.charCodeAt(1), s.charCodeAt(2));
        break;

      case 0x4000:
        // 3 more 15-bit words: WARNING: this doesn't fit in an *integer* of 31 bits any more,
        // so we'll have to use floating point for at least one intermediate step!
        //
        // Oh, by the way, did you notice we use a Big Endian type encoding mechanism?  :-)
        im = s.charCodeAt(1);
        m = im / FPC_ENC_MODULO;
        im = s.charCodeAt(2);
        im <<= 15;
        im |= s.charCodeAt(3);
        m += im / (FPC_ENC_MODULO * FPC_ENC_MODULO * FPC_ENC_MODULO);
        opt.consumed_length += 3;
        //console.log('decode-normal-len=3', m, s.charCodeAt(1), s.charCodeAt(2), s.charCodeAt(3));
        break;

      case 0x6000:
        // 4 more 15-bit words, where the last one doesn't use all bits. We don't use
        // those surplus bits yet, so we're good to go when taking the entire word
        // as a value, no masking required there.
        //
        // WARNING: this doesn't fit in an *integer* of 31 bits any more,
        // so we'll have to use floating point for at least one intermediate step!
        im = s.charCodeAt(1);
        im <<= 15;
        im |= s.charCodeAt(2);
        m = im / (FPC_ENC_MODULO * FPC_ENC_MODULO);
        im = s.charCodeAt(3);
        im <<= 15;
        im |= s.charCodeAt(4);
        m += im / (FPC_ENC_MODULO * FPC_ENC_MODULO * FPC_ENC_MODULO * FPC_ENC_MODULO);
        opt.consumed_length += 4;
        //console.log('decode-normal-len=4', m, s.charCodeAt(1) / FPC_ENC_MODULO, s.charCodeAt(1), s.charCodeAt(2), s.charCodeAt(3), s.charCodeAt(4));
        break;
      }
      //console.log('decode-normal-1', vs, m, p, opt.consumed_length);
      m *= Math.pow(2, p);
      m *= 2;                       // we do this in two steps to allow handling even the largest floating point values, which have p=1023: Math.pow(2, p+1) would fail for those!
      if (vs) {
        m = -m;
      }
      //console.log('decode-normal-2', m);
      return m;
    }
  }












  for (; false; ) {
    switch (opcode & 0xF000) {
    case 0x0000:
      // This one section is special: it contains the regular opcodes 
      // (which are mostly ASCII-range numbers for the benefit of compression
      // (? that's a hypothesis which still needs to be field-tested! ?))
      // and direct NUM numbers.
    case 0x1000:
    case 0x2000:
    case 0x3000:
    case 0x4000:
    case 0x5000:
    case 0x6000:
    case 0x7000:
    case 0x8000:
    case 0x9000:
    case 0xA000:
    case 0xB000:
    case 0xC000:
    case 0xD000:
    case 0xE000:
    case 0xF000:

    } 
    switch (opcode) {
    case 8/* CONSTANT */:
      cv = stream[i++];
      a = ct[cv];
      continue;

    case 73/* NUM */:
      a = stream[i++];
      continue;

    // shorthand for NUM+SKIP: this value is a constant-folded value, while the skipped part of the stream remains for formatter walkers...
    case 74/* NUM_AND_SKIP */:
      a = stream[i++];
      i += stream[i];
      continue;

    case 46/* STRING */:
      a = stream[i++];
      continue;

    // shorthand for STRING+SKIP: this value is a constant-folded value, while the skipped part of the stream remains for formatter walkers...
    case 52/* STRING_AND_SKIP */:
      a = stream[i++];
      i += stream[i];
      continue;

    case 55/* TRUE */:
      a = true;
      continue;

    // shorthand for TRUE+SKIP: this value is a constant-folded value, while the skipped part of the stream remains for formatter walkers...
    case 56/* TRUE_AND_SKIP */:
      a = true;
      i += stream[i];
      continue;

    case 18/* FALSE */:
      a = false;
      continue;

    // shorthand for FALSE+SKIP: this value is a constant-folded value, while the skipped part of the stream remains for formatter walkers...
    case 19/* FALSE_AND_SKIP */:
      a = false;
      i += stream[i];
      continue;

    case 86/* VAR */:
      av = stream[i++];
      continue;

// Now follow a few opcodes which didn't show up in the AST language before 'sorcerer': these boys are here to 
// help us transform grammar 'shift's into 'reduce' actions after type and code analysis inside the sorcerer
// has done its job:

    case 68:          // [VAR_TO_VALUE]: assembly: fetch from address
      a = vt[av];
      continue;

    case 69:             // [VAR_VALUE]: shorthand for VAR | VAR_TO_VALUE
      a = vt[stream[i++]];
      continue;

    case 28:            // [MOVE_TO_R1]: ~ first 'shift' after another 'reduce'
      r1 = a;
      continue;

    case 29:            // [MOVE_TO_R2]: ~ second 'shift' after another 'reduce'
      r2 = a;
      continue;

    case 25/* MOVE_FROM_R1 */:
      a = r1;
      continue;

    case 26/* MOVE_FROM_R2 */:
      a = r2;
      continue;

    case 27/* MOVE_R2_TO_R1 */:
      r1 = r2;
      continue;

    case 15/* EXCHANGE_R1_R2 */:
      b = r2;
      r2 = r1;
      r1 = b;
      continue;

    case 13/* EXCHANGE_A_R1 */:
      b = r1;
      r1 = a;
      a = b;
      continue;

    case 14/* EXCHANGE_A_R2 */:
      b = r2;
      r2 = a;
      a = b;
      continue;

    case 24/* MOVE_ALL_TO_RX */:
      rx = [a, r1, r2];
      continue;

    case 30:            // [MOVE_TO_RX]: add one more arg to the rx[] register array
      rx.push(a);
      continue;

    case 64:     // [UNSHIFT_RX_TO_ALL]: can be used for example when doing long additions
      a = rx.unshift();
      r1 = rx.unshift();
      r2 = rx.unshift();
      continue;

    case 66:     // [UNSHIFT_RX_TO_R12]: keep the accumulator intact...
      r1 = rx.unshift();
      r2 = rx.unshift();
      continue;

    case 44:                 // [PUSH]: move all registers up by one: push accumulator onto the stack. Only our 'stack' consists of a few registers and then the overflow stack `rx[]`:
      rx.push(r2);
      r2 = r1;
      r1 = a;
      continue;

    case 39:                 // [POP]: move all registers down by one: pop accumulator from the stack. Only our 'stack' consists of a few registers and then the overflow stack `rx[]`:
      a = r1;
      r1 = r2;
      r2 = rx.pop();
      continue;

    case 41:              // [SHIFT_EX]: shift the active error to make room for a new incoming error: multiple sources each can track their own own error status into an error filter/select function.
      ex.unshift(false);
      continue;

    case 59/* UNSHIFT_EX */:
      a = ex.shift();
      continue;

// ------------------------------------------------

    case 7:                // [ASSIGN]: rhs '=' lhs       -- '=' VAR exp 
      av = stream[i++];
      vt[av] = a;
      continue;

    case 48:             // [FUNCTION_0]: function() call; can produce an error  
      f = stream[i++];
      a = f.call(context);
      continue;

    case 49:             // [FUNCTION_1]: function(arg) call; can produce / filter an error 
      f = stream[i++];
      a = f.call(context, a);
      // NOTE: error filtering / creation is happening inside those functions which are concerned by this, thanks to this flow: 
      //       all functions have access to the entire calculus context, which includes the error stack, hence no-one keeps 
      //       them from manipulating that stack if one of them finds this is necessary, while I don't get to burden
      //       everyone else involved as well: this is a significant overhead minimization.
      //       
      //       Also note that error PROPAGATION is completely implicit, taking ZERO statements to execute inside any function,
      //       thanks to this flow: as we track a separate error stack in the calculus context, any function which should
      //       propagate errors from input to output can simply do so by ... not caring at all! As the error stack will already
      //       have been set up before the function call, after exiting the function the error stack will still carry the same
      //       content, hence have propagated the error at precisely ZERO COST.
      //        
      //       The error stack tracking employed here could also be easily implemented in the alternative in the other example:
      //       the SLR(0)-based grammar-based tree walker-based calculator, so I don't consider it a 'win' for this particular
      //       Pcode interpreter over that one...
      continue;

    case 50:             // [FUNCTION_2]: function(arg, arg) call; can produce / filter an error 
      f = stream[i++];
      a = f.call(context, a, r1);
      continue;

    case 51:             // [FUNCTION_3]: function(arg, arg, arg) call; can produce / filter an error  
      f = stream[i++];
      a = f.call(context, a, r1, r2);
      continue;

    case 57:             // [FUNCTION_N]: function(arg, arg, arg, ...) call 
      f = stream[i++];
      n = stream[i++];
      a = f.apply(context, rx);   // all values are assumed to be waiting in the rx[] array already
      continue;

    case 61:                     // [EQ]: EQ arg arg 
      a = (a === r1);
      continue;

    case 110:                    // [NEQ]: NEQ arg arg 
      a = (a !== r1);
      continue;

    case 23:                    // [LEQ]: LEQ arg arg 
      a = (r1 <= a);
      continue;

    case 20:                    // [GEQ]: GEQ arg arg 
      a = (r1 >= a);
      continue;

    case 60:                     // [LT]: LT arg arg 
      a = (r1 < a);
      continue;

    case 62:                     // [GT]: GT arg arg 
      a = (r1 > a);
      continue;

    case 65:                    // [AND]: AND arg arg 
      a = (a && r1);
      continue;

    case 79:                     // [OR]: OR arg arg 
      a = (a || r1);
      continue;

    case 88:                     // [XOR]: XOR arg arg 
      a = !!(!!a ^ !!r1);
      continue;

    case 38:            // [BITWISE_AND]: BITWISE_AND arg arg 
      a = (a & r1);
      continue;

    case 124:             // [BITWISE_OR]: BITWISE_OR arg arg 
      a = (a | r1);
      continue;

    case 94:            // [BITWISE_XOR]: BITWISE_XOR arg arg 
      a = (a ^ r1);
      continue;

    case 43:                    // [ADD]: '+' arg arg 
      a += r1;
      continue;

    case 80:                  // [ADD_3]: '+' arg arg arg 
      a += r1 + r2;
      continue;

    case 45:               // [SUBTRACT]: '-' arg arg 
      a -= r1;
      continue;

    case 53:              // [SUBTRACT_3]: exp[r2] MOVE_TO_R2 exp[r1] MOVE_TO_R1 exp[a] SUBTRACT_3                         vs.    
                                  // exp[r2] MOVE_TO_R2 exp[r1] MOVE_TO_R1 exp[a] SUBTRACT MOVE_R2_TO_R1 SUBTRACT    vs.
                                  // exp[r2] MOVE_TO_R2 exp[r1] MOVE_TO_R1 exp[a] SUBTRACT SUBTRACT_R2               vs.
      a -= r1 + r2;              // a = a - r1 - r2  === a = a - (r1 + r2)
      continue;

    case 42:               // [MULTIPLY]: '*' arg arg 
      a *= r1;
      continue;

    case 77:               // [MULTIPLY_3]: '*' arg arg arg 
      a *= r1 * r2;
      continue;

    case 47:                // [DIVIDE]: '/' arg arg 
      b = a / r1;
      // WARNING: this operator can generate an error!
      if (isNaN(b) && !isNaN(a) && !isNaN(r1)) {
        // set error if not already set for this chunk:
        if (!ex[0]) {
          ex[0] = new Error("division by " + r1);
        }
      }
      a = b;
      continue;

    case 37:                // [MODULO]: '%' arg arg 
      b = a % r1;
      // WARNING: this operator can generate an error!
      if (isNaN(b) && !isNaN(a) && !isNaN(r1)) {
        // set error if not already set for this chunk:
        if (!ex[0]) {
          ex[0] = new Error("modulo by " + r1);
        }
      }
      a = b;
      continue;

    case 40:                 // [POWER]: '^' arg arg 
      b = Math.pow(a, r1);
      // WARNING: this operator can generate an error!
      if (isNaN(b) && !isNaN(a) && !isNaN(r1)) {
        // set error if not already set for this chunk:
        if (!ex[0]) {
          ex[0] = new Error("exponentiation by " + r1);
        }
      }
      a = b;
      continue;

    case 58:                // [UMINUS]: '-' arg 
      a = -a;
      continue;

    case 67:                 // [UPLUS]: '+' arg 
      a = +a;       // Shouldn't this be a no-op?  Not really, as STRING input gets cast to number here!
      continue;

    case 33:                   // [NOT]: '!' arg 
      a = !a;
      continue;

    case 126:           // [BITWISE_NOT]: '~' arg 
      a = ~a;
      continue;

    case 17:             // [FACTORIAL]: '!' arg 
      b = factorial(a);
      // WARNING: this operator can generate an error!
      if (isNaN(b) && !isNaN(a) && !isNaN(r1)) {
        // set error if not already set for this chunk:
        if (!ex[0]) {
          ex[0] = new Error("factorial by " + r1);
        }
      }
      a = b;
      continue;

    case 36:               // [PERCENT]: '%' arg 
      a /= 100;
      continue;

    case 63:             // [CONDITION]: cond '?' true ':' false -- check the conditional and self-modify stream to exec the correct branch
      if (a) {
        // take the branch and skip the ELSE:
        // skip the jump offset slot.
        i++;
      } else {
        // take the alternative branch and skip the IF:
        // use the jump offset (which is already corrected for this offset slot and the SKIP instruction at the end of the IF branch; see `compiled_calc_for_fast_engine.jison`.
        i += stream[i];
      }
      // NOTE: error propagation of the 'active branch only' is implicitly happening thanks to this flow: the inactive
      //       branch is simply skipped, hence no errors in there will ever be seen as we simply do not perform any of
      //       its calculus. 
      //       
      //       This is where our hand-optimized Pcode interpreter with Reverse Polish opcode stream *wins*
      //       significantly compared to the SLR(0)-based grammar-based tree walker-based calculator as shown in the
      //       compiled_calc_exec example: that one only decided which branch to pick AFTER both have their values calculated! 
      continue;

    case 16:                  // [EXEC]: a SKIP which was turned into a NOT-SKIP
      // gobble the length slot that accompanies this one!
      stream[i++];
      continue;

    case 83:                  // [SKIP]: skip N opcodes; can also happen when the sorcerer has found a chunk which could be constant-folded: pretty-printers running off the same stream would still need the raw data within the skipped chunk!
      i += stream[i];
      continue;

    case 3:                 // [ERROR]: flagged error part: shift the specified error unless one has already been set
      if (!ex[0]) {
        ex = stream[i];
      }
      i++;
      continue;

    case 12:        // [ERROR_AND_SKIP]: shorthand for ERROR+SKIP opcodes; note the skip number comes first and includes the error value slot!
      if (!ex[0]) {
        ex = stream[i + 1];
      }
      i += stream[i];
      continue;
    }
  }
}










// End Of Include by Jison: compiled_calc_fast_Pcode_interpreter.js


// Then we have the 'compile-to-native-code' code compiler engine:

// Included by Jison: compiled_calc_fast_Pcode_native_code_generator.js:



// Sourcecode template for the P-code interpreter: this is a very basic
// bottom-up tree walker, or a very basic CPU simulation, if you are 
// inclined to look at it that way.
//
// The key here is that the 'sorcerer' tree-walker has run before and
// produced a suitable AST token stream for my kind particularly: me, I
// don't do 'shift', not really, I only do 'reduce', so the 'sorcerer'
// has to inject the 'which bits in there need shifting?' knowledge into
// the AST so that these points in the flow show up as 'reduce' actions
// for me. Of course, you may find a bit strange to talk about 'shift'
// and 'reduce' when we already seem to have left the grammar/language 
// realm in here, running some kind of 'assembly code' disguised as an
// 'AST token stream': yes, this is a classic 'tape', but 'assembly code'
// is itself yet another language, though probably a very simple one (SLR(0)?)
// and I want to emphasize the fact that you are **still** working with
// a language, hence a *grammar*, in here; you just happened to have
// translated language A (AST token stream produced by the expression parser)
// into language B (AST token stream which looks very much like 'assembly code'
// as produced by the 'sorcerer' tree walker).
//
// How do you develop such a beast?
//
// First, I came up with the P-code runner, a.k.a. 'interpreter' and checked
// if my ideas about fast and faster code actually worked more or less.
// Once that had been nailed down, I thus knew what 'assembly language' I
// had to feed this P-code interpreter and *that* drives the translation/transposition
// activity required from the 'sorcerer' middleware, so that one has
// been next. 
//
// After that, it's a couple of iterations to get everything working to my
// satisfaction, which I'ld say would be possibly be 'Agile' this day and age,
// but I say it's correct application of the control engineering feedback loop model
// (or Waterfall Model of old, just to get your knickers in a twist)   :-)
//
// Anyway, the key element is that the P-code runner must be as fast as possible,
// hence have the least bit of overhead, and we can help a lot accomplishing 
// just that by making sure we pick a better format for our 'incoming' P-code
// stream.


// critical condition: the P-code stream input is to be treated as **immutable**
// so it can be re-used time and again!
function generate_native_code_for_Pcode(stream, context) {
  // our error-stack, where errors get shifted before we invoke error-filtering functions:
  // we 'unshift' errors into this stack so that the 'active error' is always at index 0,
  // which saves us the hassle of keeping track of the length of the array.
  // We ASSUME the number of error stack CHECKS is quite a bit higher than the number
  // of error stack PUSH+POP actions, so we decide a potentially less optimal 
  // unshift-and-shift-vs-push-and-pop is preferable.
  var ex = context.error_stack;

  // misc references to context/global tables:
  var vt = context.variables;
  var ct = context.constants;

  var sourcecode = {
    fetch_variables: {},      // hash map! every variable that is used, is loaded only once, at the start!
    store_variables: {},      // hash map! every variable that is written is stored only once, at the end!
    body: [],
  };

  var scratch = [];

  function string_escape(s) {
    return s.replace(/["]/g, '\\"');
  }

  for (var i = 0, len = stream.length; i < len; ) {
    var opcode = stream[i++];
    switch (opcode) {
    case 8/* CONSTANT */:
      cv = stream[i++];
      a = ct[cv];
      continue;

    case 73/* NUM */:
      scratch.push(stream[i++]);
      continue;

    // shorthand for NUM+SKIP: this value is a constant-folded value, while the skipped part of the stream remains for formatter walkers...
    case 74/* NUM_AND_SKIP */:
      scratch.push(stream[i++]);
      i += stream[i];
      continue;

    case 46/* STRING */:
      scratch.push('"' + string_escape(stream[i++]) + '"');
      continue;

    // shorthand for STRING+SKIP: this value is a constant-folded value, while the skipped part of the stream remains for formatter walkers...
    case 52/* STRING_AND_SKIP */:
      a = stream[i++];
      i += stream[i];
      continue;

    case 55/* TRUE */:
      a = true;
      continue;

    // shorthand for TRUE+SKIP: this value is a constant-folded value, while the skipped part of the stream remains for formatter walkers...
    case 56/* TRUE_AND_SKIP */:
      a = true;
      i += stream[i];
      continue;

    case 18/* FALSE */:
      a = false;
      continue;

    // shorthand for FALSE+SKIP: this value is a constant-folded value, while the skipped part of the stream remains for formatter walkers...
    case 19/* FALSE_AND_SKIP */:
      a = false;
      i += stream[i];
      continue;

    case 86/* VAR */:
      av = stream[i++];
      continue;

// Now follow a few opcodes which didn't show up in the AST language before 'sorcerer': these boys are here to 
// help us transform grammar 'shift's into 'reduce' actions after type and code analysis inside the sorcerer
// has done its job:

    case 68:          // [VAR_TO_VALUE]: assembly: fetch from address
      a = vt[av];
      continue;

    case 69:             // [VAR_VALUE]: shorthand for VAR | VAR_TO_VALUE
      a = vt[stream[i++]];
      continue;

    case 28:            // [MOVE_TO_R1]: ~ first 'shift' after another 'reduce'
      r1 = a;
      continue;

    case 29:            // [MOVE_TO_R2]: ~ second 'shift' after another 'reduce'
      r2 = a;
      continue;

    case 25/* MOVE_FROM_R1 */:
      a = r1;
      continue;

    case 26/* MOVE_FROM_R2 */:
      a = r2;
      continue;

    case 27/* MOVE_R2_TO_R1 */:
      r1 = r2;
      continue;

    case 15/* EXCHANGE_R1_R2 */:
      b = r2;
      r2 = r1;
      r1 = b;
      continue;

    case 13/* EXCHANGE_A_R1 */:
      b = r1;
      r1 = a;
      a = b;
      continue;

    case 14/* EXCHANGE_A_R2 */:
      b = r2;
      r2 = a;
      a = b;
      continue;

    case 24/* MOVE_ALL_TO_RX */:
      rx = [a, r1, r2];
      continue;

    case 30:            // [MOVE_TO_RX]: add one more arg to the rx[] register array
      rx.push(a);
      continue;

    case 64:     // [UNSHIFT_RX_TO_ALL]: can be used for example when doing long additions
      a = rx.unshift();
      r1 = rx.unshift();
      r2 = rx.unshift();
      continue;

    case 66:     // [UNSHIFT_RX_TO_R12]: keep the accumulator intact...
      r1 = rx.unshift();
      r2 = rx.unshift();
      continue;

    case 44:                 // [PUSH]: move all registers up by one: push accumulator onto the stack. Only our 'stack' consists of a few registers and then the overflow stack `rx[]`:
      rx.push(r2);
      r2 = r1;
      r1 = a;
      continue;

    case 39:                 // [POP]: move all registers down by one: pop accumulator from the stack. Only our 'stack' consists of a few registers and then the overflow stack `rx[]`:
      a = r1;
      r1 = r2;
      r2 = rx.pop();
      continue;

    case 41:              // [SHIFT_EX]: shift the active error to make room for a new incoming error: multiple sources each can track their own own error status into an error filter/select function.
      ex.unshift(false);
      continue;

    case 59/* UNSHIFT_EX */:
      a = ex.shift();
      continue;

// ------------------------------------------------

    case 7:                // [ASSIGN]: rhs '=' lhs       -- '=' VAR exp 
      av = stream[i++];
      vt[av] = a;
      continue;

    case 48:             // [FUNCTION_0]: function() call; can produce an error  
      f = stream[i++];
      a = f.call(context);
      continue;

    case 49:             // [FUNCTION_1]: function(arg) call; can produce / filter an error 
      f = stream[i++];
      a = f.call(context, a);
      // NOTE: error filtering / creation is happening inside those functions which are concerned by this, thanks to this flow: 
      //       all functions have access to the entire calculus context, which includes the error stack, hence no-one keeps 
      //       them from manipulating that stack if one of them finds this is necessary, while I don't get to burden
      //       everyone else involved as well: this is a significant overhead minimization.
      //       
      //       Also note that error PROPAGATION is completely implicit, taking ZERO statements to execute inside any function,
      //       thanks to this flow: as we track a separate error stack in the calculus context, any function which should
      //       propagate errors from input to output can simply do so by ... not caring at all! As the error stack will already
      //       have been set up before the function call, after exiting the function the error stack will still carry the same
      //       content, hence have propagated the error at precisely ZERO COST.
      //        
      //       The error stack tracking employed here could also be easily implemented in the alternative in the other example:
      //       the SLR(0)-based grammar-based tree walker-based calculator, so I don't consider it a 'win' for this particular
      //       Pcode interpreter over that one...
      continue;

    case 50:             // [FUNCTION_2]: function(arg, arg) call; can produce / filter an error 
      f = stream[i++];
      a = f.call(context, a, r1);
      continue;

    case 51:             // [FUNCTION_3]: function(arg, arg, arg) call; can produce / filter an error  
      f = stream[i++];
      a = f.call(context, a, r1, r2);
      continue;

    case 57:             // [FUNCTION_N]: function(arg, arg, arg, ...) call 
      f = stream[i++];
      a = f.apply(context, rx);   // all values are assumed to be waiting in the rx[] array already
      continue;

    case 61:                     // [EQ]: EQ arg arg 
      a = (a === r1);
      continue;

    case 110:                    // [NEQ]: NEQ arg arg 
      a = (a !== r1);
      continue;

    case 23:                    // [LEQ]: LEQ arg arg 
      a = (r1 <= a);
      continue;

    case 20:                    // [GEQ]: GEQ arg arg 
      a = (r1 >= a);
      continue;

    case 60:                     // [LT]: LT arg arg 
      a = (r1 < a);
      continue;

    case 62:                     // [GT]: GT arg arg 
      a = (r1 > a);
      continue;

    case 65:                    // [AND]: AND arg arg 
      a = (a && r1);
      continue;

    case 79:                     // [OR]: OR arg arg 
      a = (a || r1);
      continue;

    case 88:                     // [XOR]: XOR arg arg 
      a = !!(!!a ^ !!r1);
      continue;

    case 38:            // [BITWISE_AND]: BITWISE_AND arg arg 
      a = (a & r1);
      continue;

    case 124:             // [BITWISE_OR]: BITWISE_OR arg arg 
      a = (a | r1);
      continue;

    case 94:            // [BITWISE_XOR]: BITWISE_XOR arg arg 
      a = (a ^ r1);
      continue;

    case 43:                    // [ADD]: '+' arg arg 
      a += r1;
      continue;

    case 80:                  // [ADD_3]: '+' arg arg arg 
      a += r1 + r2;
      continue;

    case 45:               // [SUBTRACT]: '-' arg arg 
      a -= r1;
      continue;

    case 53:              // [SUBTRACT_3]: exp[r2] MOVE_TO_R2 exp[r1] MOVE_TO_R1 exp[a] SUBTRACT_3                         vs.    
                                  // exp[r2] MOVE_TO_R2 exp[r1] MOVE_TO_R1 exp[a] SUBTRACT MOVE_R2_TO_R1 SUBTRACT    vs.
                                  // exp[r2] MOVE_TO_R2 exp[r1] MOVE_TO_R1 exp[a] SUBTRACT SUBTRACT_R2               vs.
      a -= r1 + r2;              // a = a - r1 - r2  === a = a - (r1 + r2)
      continue;

    case 42:               // [MULTIPLY]: '*' arg arg 
      a *= r1;
      continue;

    case 77:               // [MULTIPLY_3]: '*' arg arg arg 
      a *= r1 * r2;
      continue;

    case 47:                // [DIVIDE]: '/' arg arg 
      b = a / r1;
      // WARNING: this operator can generate an error!
      if (isNaN(b) && !isNaN(a) && !isNaN(r1)) {
        // set error if not already set for this chunk:
        if (!ex[0]) {
          ex[0] = new Error("division by " + r1);
        }
      }
      a = b;
      continue;

    case 37:                // [MODULO]: '%' arg arg 
      b = a % r1;
      // WARNING: this operator can generate an error!
      if (isNaN(b) && !isNaN(a) && !isNaN(r1)) {
        // set error if not already set for this chunk:
        if (!ex[0]) {
          ex[0] = new Error("modulo by " + r1);
        }
      }
      a = b;
      continue;

    case 40:                 // [POWER]: '^' arg arg 
      b = Math.pow(a, r1);
      // WARNING: this operator can generate an error!
      if (isNaN(b) && !isNaN(a) && !isNaN(r1)) {
        // set error if not already set for this chunk:
        if (!ex[0]) {
          ex[0] = new Error("exponentiation by " + r1);
        }
      }
      a = b;
      continue;

    case 58:                // [UMINUS]: '-' arg 
      a = -a;
      continue;

    case 67:                 // [UPLUS]: '+' arg 
      a = +a;       // Shouldn't this be a no-op?  Not really, as STRING input gets cast to number here!
      continue;

    case 33:                   // [NOT]: '!' arg 
      a = !a;
      continue;

    case 126:           // [BITWISE_NOT]: '~' arg 
      a = ~a;
      continue;

    case 17:             // [FACTORIAL]: '!' arg 
      b = factorial(a);
      // WARNING: this operator can generate an error!
      if (isNaN(b) && !isNaN(a) && !isNaN(r1)) {
        // set error if not already set for this chunk:
        if (!ex[0]) {
          ex[0] = new Error("factorial by " + r1);
        }
      }
      a = b;
      continue;

    case 36:               // [PERCENT]: '%' arg 
      a /= 100;
      continue;

    case 63:             // [CONDITION]: cond '?' true ':' false -- check the conditional and self-modify stream to exec the correct branch
      if (a) {
        // take the branch and skip the ELSE:
        // skip the jump offset slot.
        i++;
      } else {
        // take the alternative branch and skip the IF:
        // use the jump offset (which is already corrected for this offset slot and the SKIP instruction at the end of the IF branch; see `compiled_calc_for_fast_engine.jison`.
        i += stream[i];
      }
      // NOTE: error propagation of the 'active branch only' is implicitly happening thanks to this flow: the inactive
      //       branch is simply skipped, hence no errors in there will ever be seen as we simply do not perform any of
      //       its calculus. 
      //       
      //       This is where our hand-optimized Pcode interpreter with Reverse Polish opcode stream *wins*
      //       significantly compared to the SLR(0)-based grammar-based tree walker-based calculator as shown in the
      //       compiled_calc_exec example: that one only decided which branch to pick AFTER both have their values calculated! 
      continue;

    case 16:                  // [EXEC]: a SKIP which was turned into a NOT-SKIP
      // gobble the length slot that accompanies this one!
      stream[i++];
      continue;

    case 83:                  // [SKIP]: skip N opcodes; can also happen when the sorcerer has found a chunk which could be constant-folded: pretty-printers running off the same stream would still need the raw data within the skipped chunk!
      i += stream[i];
      continue;

    case 3:                 // [ERROR]: flagged error part: shift the specified error unless one has already been set
      if (!ex[0]) {
        ex = stream[i];
      }
      i++;
      continue;

    case 12:        // [ERROR_AND_SKIP]: shorthand for ERROR+SKIP opcodes; note the skip number comes first and includes the error value slot!
      if (!ex[0]) {
        ex = stream[i + 1];
      }
      i += stream[i];
      continue;
    }
  }
}










// End Of Include by Jison: compiled_calc_fast_Pcode_native_code_generator.js


// And we end this series with the hand-optimized pretty printer:

// Included by Jison: compiled_calc_fast_Pcode_pretty_printer.js:



// Sourcecode template for the P-code interpreter: this is a very basic
// bottom-up tree walker, or a very basic CPU simulation, if you are 
// inclined to look at it that way.
//
// The key here is that the 'sorcerer' tree-walker has run before and
// produced a suitable AST token stream for my kind particularly: me, I
// don't do 'shift', not really, I only do 'reduce', so the 'sorcerer'
// has to inject the 'which bits in there need shifting?' knowledge into
// the AST so that these points in the flow show up as 'reduce' actions
// for me. Of course, you may find a bit strange to talk about 'shift'
// and 'reduce' when we already seem to have left the grammar/language 
// realm in here, running some kind of 'assembly code' disguised as an
// 'AST token stream': yes, this is a classic 'tape', but 'assembly code'
// is itself yet another language, though probably a very simple one (SLR(0)?)
// and I want to emphasize the fact that you are **still** working with
// a language, hence a *grammar*, in here; you just happened to have
// translated language A (AST token stream produced by the expression parser)
// into language B (AST token stream which looks very much like 'assembly code'
// as produced by the 'sorcerer' tree walker).
//
// How do you develop such a beast?
//
// First, I came up with the P-code runner, a.k.a. 'interpreter' and checked
// if my ideas about fast and faster code actually worked more or less.
// Once that had been nailed down, I thus knew what 'assembly language' I
// had to feed this P-code interpreter and *that* drives the translation/transposition
// activity required from the 'sorcerer' middleware, so that one has
// been next. 
//
// After that, it's a couple of iterations to get everything working to my
// satisfaction, which I'ld say would be possibly be 'Agile' this day and age,
// but I say it's correct application of the control engineering feedback loop model
// (or Waterfall Model of old, just to get your knickers in a twist)   :-)
//
// Anyway, the key element is that the P-code runner must be as fast as possible,
// hence have the least bit of overhead, and we can help a lot accomplishing 
// just that by making sure we pick a better format for our 'incoming' P-code
// stream.


// critical condition: the P-code stream input is to be treated as **immutable**
// so it can be re-used time and again!
function generate_human_readable_statement_for_Pcode(stream, context) {
  // our accumulator and register bank:
  //      https://www.scirra.com/blog/76/how-to-write-low-garbage-real-time-javascript
  var a, r1, r2, rx = [];
  // our accumulator and register bank optimized for integers:
  var ai, ri1, ri2, rix = [];
  // our accumulator and register bank optimized for floating point values:
  var af, rf1, rf2, rfx = [];
  // our accumulator and register bank optimized for string values:
  var as, rs1, rs2, rsx = [];
  // our accumulator and register bank optimized for boolean values:
  var ab, rb1, rb2, rbx = [];
  // our accumulator and register bank optimized for variable references:
  var av, rv1, rv2, rvx = [];
  // our accumulator optimized for constant references:
  var cv;

  // our error-stack, where errors get shifted before we invoke error-filtering functions:
  // we 'unshift' errors into this stack so that the 'active error' is always at index 0,
  // which saves us the hassle of keeping track of the length of the array.
  // We ASSUME the number of error stack CHECKS is quite a bit higher than the number
  // of error stack PUSH+POP actions, so we decide a potentially less optimal 
  // unshift-and-shift-vs-push-and-pop is preferable.
  var ex = context.error_stack;

  // misc references to context/global tables:
  var vt = context.variables;
  var ct = context.constants;

  // function/procedure reference register
  var f;

  // scratch register
  var b;

  // skip/jump helpers:
  var n, n1, n2;

  for (var i = 0, len = stream.length; i < len; ) {
    var opcode = stream[i++];
    switch (opcode) {
    case 8/* CONSTANT */:
      cv = stream[i++];
      a = ct[cv];
      continue;

    case 73/* NUM */:
      a = stream[i++];
      continue;

    // shorthand for NUM+SKIP: this value is a constant-folded value, while the skipped part of the stream remains for formatter walkers...
    case 74/* NUM_AND_SKIP */:
      a = stream[i++];
      i += stream[i];
      continue;

    case 46/* STRING */:
      a = stream[i++];
      continue;

    // shorthand for STRING+SKIP: this value is a constant-folded value, while the skipped part of the stream remains for formatter walkers...
    case 52/* STRING_AND_SKIP */:
      a = stream[i++];
      i += stream[i];
      continue;

    case 55/* TRUE */:
      a = true;
      continue;

    // shorthand for TRUE+SKIP: this value is a constant-folded value, while the skipped part of the stream remains for formatter walkers...
    case 56/* TRUE_AND_SKIP */:
      a = true;
      i += stream[i];
      continue;

    case 18/* FALSE */:
      a = false;
      continue;

    // shorthand for FALSE+SKIP: this value is a constant-folded value, while the skipped part of the stream remains for formatter walkers...
    case 19/* FALSE_AND_SKIP */:
      a = false;
      i += stream[i];
      continue;

    case 86/* VAR */:
      av = stream[i++];
      continue;

// Now follow a few opcodes which didn't show up in the AST language before 'sorcerer': these boys are here to 
// help us transform grammar 'shift's into 'reduce' actions after type and code analysis inside the sorcerer
// has done its job:

    case 68:          // [VAR_TO_VALUE]: assembly: fetch from address
      a = vt[av];
      continue;

    case 69:             // [VAR_VALUE]: shorthand for VAR | VAR_TO_VALUE
      a = vt[stream[i++]];
      continue;

    case 28:            // [MOVE_TO_R1]: ~ first 'shift' after another 'reduce'
      r1 = a;
      continue;

    case 29:            // [MOVE_TO_R2]: ~ second 'shift' after another 'reduce'
      r2 = a;
      continue;

    case 25/* MOVE_FROM_R1 */:
      a = r1;
      continue;

    case 26/* MOVE_FROM_R2 */:
      a = r2;
      continue;

    case 27/* MOVE_R2_TO_R1 */:
      r1 = r2;
      continue;

    case 15/* EXCHANGE_R1_R2 */:
      b = r2;
      r2 = r1;
      r1 = b;
      continue;

    case 13/* EXCHANGE_A_R1 */:
      b = r1;
      r1 = a;
      a = b;
      continue;

    case 14/* EXCHANGE_A_R2 */:
      b = r2;
      r2 = a;
      a = b;
      continue;

    case 24/* MOVE_ALL_TO_RX */:
      rx = [a, r1, r2];
      continue;

    case 30:            // [MOVE_TO_RX]: add one more arg to the rx[] register array
      rx.push(a);
      continue;

    case 64:     // [UNSHIFT_RX_TO_ALL]: can be used for example when doing long additions
      a = rx.unshift();
      r1 = rx.unshift();
      r2 = rx.unshift();
      continue;

    case 66:     // [UNSHIFT_RX_TO_R12]: keep the accumulator intact...
      r1 = rx.unshift();
      r2 = rx.unshift();
      continue;

    case 44:                 // [PUSH]: move all registers up by one: push accumulator onto the stack. Only our 'stack' consists of a few registers and then the overflow stack `rx[]`:
      rx.push(r2);
      r2 = r1;
      r1 = a;
      continue;

    case 39:                 // [POP]: move all registers down by one: pop accumulator from the stack. Only our 'stack' consists of a few registers and then the overflow stack `rx[]`:
      a = r1;
      r1 = r2;
      r2 = rx.pop();
      continue;

    case 41:              // [SHIFT_EX]: shift the active error to make room for a new incoming error: multiple sources each can track their own own error status into an error filter/select function.
      ex.unshift(false);
      continue;

    case 59/* UNSHIFT_EX */:
      a = ex.shift();
      continue;

// ------------------------------------------------

    case 7:                // [ASSIGN]: rhs '=' lhs       -- '=' VAR exp 
      av = stream[i++];
      vt[av] = a;
      continue;

    case 48:             // [FUNCTION_0]: function() call; can produce an error  
      f = stream[i++];
      a = f.call(context);
      continue;

    case 49:             // [FUNCTION_1]: function(arg) call; can produce / filter an error 
      f = stream[i++];
      a = f.call(context, a);
      // NOTE: error filtering / creation is happening inside those functions which are concerned by this, thanks to this flow: 
      //       all functions have access to the entire calculus context, which includes the error stack, hence no-one keeps 
      //       them from manipulating that stack if one of them finds this is necessary, while I don't get to burden
      //       everyone else involved as well: this is a significant overhead minimization.
      //       
      //       Also note that error PROPAGATION is completely implicit, taking ZERO statements to execute inside any function,
      //       thanks to this flow: as we track a separate error stack in the calculus context, any function which should
      //       propagate errors from input to output can simply do so by ... not caring at all! As the error stack will already
      //       have been set up before the function call, after exiting the function the error stack will still carry the same
      //       content, hence have propagated the error at precisely ZERO COST.
      //        
      //       The error stack tracking employed here could also be easily implemented in the alternative in the other example:
      //       the SLR(0)-based grammar-based tree walker-based calculator, so I don't consider it a 'win' for this particular
      //       Pcode interpreter over that one...
      continue;

    case 50:             // [FUNCTION_2]: function(arg, arg) call; can produce / filter an error 
      f = stream[i++];
      a = f.call(context, a, r1);
      continue;

    case 51:             // [FUNCTION_3]: function(arg, arg, arg) call; can produce / filter an error  
      f = stream[i++];
      a = f.call(context, a, r1, r2);
      continue;

    case 57:             // [FUNCTION_N]: function(arg, arg, arg, ...) call 
      f = stream[i++];
      n = stream[i++];
      a = f.apply(context, rx);   // all values are assumed to be waiting in the rx[] array already
      continue;

    case 61:                     // [EQ]: EQ arg arg 
      a = (a === r1);
      continue;

    case 110:                    // [NEQ]: NEQ arg arg 
      a = (a !== r1);
      continue;

    case 23:                    // [LEQ]: LEQ arg arg 
      a = (r1 <= a);
      continue;

    case 20:                    // [GEQ]: GEQ arg arg 
      a = (r1 >= a);
      continue;

    case 60:                     // [LT]: LT arg arg 
      a = (r1 < a);
      continue;

    case 62:                     // [GT]: GT arg arg 
      a = (r1 > a);
      continue;

    case 65:                    // [AND]: AND arg arg 
      a = (a && r1);
      continue;

    case 79:                     // [OR]: OR arg arg 
      a = (a || r1);
      continue;

    case 88:                     // [XOR]: XOR arg arg 
      a = !!(!!a ^ !!r1);
      continue;

    case 38:            // [BITWISE_AND]: BITWISE_AND arg arg 
      a = (a & r1);
      continue;

    case 124:             // [BITWISE_OR]: BITWISE_OR arg arg 
      a = (a | r1);
      continue;

    case 94:            // [BITWISE_XOR]: BITWISE_XOR arg arg 
      a = (a ^ r1);
      continue;

    case 43:                    // [ADD]: '+' arg arg 
      a += r1;
      continue;

    case 80:                  // [ADD_3]: '+' arg arg arg 
      a += r1 + r2;
      continue;

    case 45:               // [SUBTRACT]: '-' arg arg 
      a -= r1;
      continue;

    case 53:              // [SUBTRACT_3]: exp[r2] MOVE_TO_R2 exp[r1] MOVE_TO_R1 exp[a] SUBTRACT_3                         vs.    
                                  // exp[r2] MOVE_TO_R2 exp[r1] MOVE_TO_R1 exp[a] SUBTRACT MOVE_R2_TO_R1 SUBTRACT    vs.
                                  // exp[r2] MOVE_TO_R2 exp[r1] MOVE_TO_R1 exp[a] SUBTRACT SUBTRACT_R2               vs.
      a -= r1 + r2;              // a = a - r1 - r2  === a = a - (r1 + r2)
      continue;

    case 42:               // [MULTIPLY]: '*' arg arg 
      a *= r1;
      continue;

    case 77:               // [MULTIPLY_3]: '*' arg arg arg 
      a *= r1 * r2;
      continue;

    case 47:                // [DIVIDE]: '/' arg arg 
      b = a / r1;
      // WARNING: this operator can generate an error!
      if (isNaN(b) && !isNaN(a) && !isNaN(r1)) {
        // set error if not already set for this chunk:
        if (!ex[0]) {
          ex[0] = new Error("division by " + r1);
        }
      }
      a = b;
      continue;

    case 37:                // [MODULO]: '%' arg arg 
      b = a % r1;
      // WARNING: this operator can generate an error!
      if (isNaN(b) && !isNaN(a) && !isNaN(r1)) {
        // set error if not already set for this chunk:
        if (!ex[0]) {
          ex[0] = new Error("modulo by " + r1);
        }
      }
      a = b;
      continue;

    case 40:                 // [POWER]: '^' arg arg 
      b = Math.pow(a, r1);
      // WARNING: this operator can generate an error!
      if (isNaN(b) && !isNaN(a) && !isNaN(r1)) {
        // set error if not already set for this chunk:
        if (!ex[0]) {
          ex[0] = new Error("exponentiation by " + r1);
        }
      }
      a = b;
      continue;

    case 58:                // [UMINUS]: '-' arg 
      a = -a;
      continue;

    case 67:                 // [UPLUS]: '+' arg 
      a = +a;       // Shouldn't this be a no-op?  Not really, as STRING input gets cast to number here!
      continue;

    case 33:                   // [NOT]: '!' arg 
      a = !a;
      continue;

    case 126:           // [BITWISE_NOT]: '~' arg 
      a = ~a;
      continue;

    case 17:             // [FACTORIAL]: '!' arg 
      b = factorial(a);
      // WARNING: this operator can generate an error!
      if (isNaN(b) && !isNaN(a) && !isNaN(r1)) {
        // set error if not already set for this chunk:
        if (!ex[0]) {
          ex[0] = new Error("factorial by " + r1);
        }
      }
      a = b;
      continue;

    case 36:               // [PERCENT]: '%' arg 
      a /= 100;
      continue;

    case 63:             // [CONDITION]: cond '?' true ':' false -- check the conditional and self-modify stream to exec the correct branch
      if (a) {
        // take the branch and skip the ELSE:
        // skip the jump offset slot.
        i++;
      } else {
        // take the alternative branch and skip the IF:
        // use the jump offset (which is already corrected for this offset slot and the SKIP instruction at the end of the IF branch; see `compiled_calc_for_fast_engine.jison`.
        i += stream[i];
      }
      // NOTE: error propagation of the 'active branch only' is implicitly happening thanks to this flow: the inactive
      //       branch is simply skipped, hence no errors in there will ever be seen as we simply do not perform any of
      //       its calculus. 
      //       
      //       This is where our hand-optimized Pcode interpreter with Reverse Polish opcode stream *wins*
      //       significantly compared to the SLR(0)-based grammar-based tree walker-based calculator as shown in the
      //       compiled_calc_exec example: that one only decided which branch to pick AFTER both have their values calculated! 
      continue;

    case 16:                  // [EXEC]: a SKIP which was turned into a NOT-SKIP
      // gobble the length slot that accompanies this one!
      stream[i++];
      continue;

    case 83:                  // [SKIP]: skip N opcodes; can also happen when the sorcerer has found a chunk which could be constant-folded: pretty-printers running off the same stream would still need the raw data within the skipped chunk!
      i += stream[i];
      continue;

    case 3:                 // [ERROR]: flagged error part: shift the specified error unless one has already been set
      if (!ex[0]) {
        ex = stream[i];
      }
      i++;
      continue;

    case 12:        // [ERROR_AND_SKIP]: shorthand for ERROR+SKIP opcodes; note the skip number comes first and includes the error value slot!
      if (!ex[0]) {
        ex = stream[i + 1];
      }
      i += stream[i];
      continue;
    }
  }
}










// End Of Include by Jison: compiled_calc_fast_Pcode_pretty_printer.js




// Included by Jison: benchmark.js:


/**
 * Provide a generic performance timer, which strives to produce highest possible accuracy time measurements.
 * 
 * methods:
 * 
 * - `start()` (re)starts the timer and 'marks' the current time for ID="start". 
 *   `.start()` also CLEARS ALL .mark_delta() timers!
 *
 * - `mark(ID)` calculates the elapsed time for the current timer in MILLISECONDS (floating point) 
 *   since `.start()`. `.mark_delta()` then updates the 'start/mark time' for the given ID.
 *
 *   ID *may* be NULL, in which case `.mark()` will not update any 'start/mark time'.
 *    
 * - `mark_delta(ID, START_ID)` calculates the elapsed time for the current timer in MILLISECONDS (floating point) since 
 *   the last call to `.mark_delta()` or `.mark()` with the same ID. `.mark_delta()` then updates the 
 *   'start/mark time' for the given ID.
 *
 *   When the optional START_ID is specified, the delta is calculated against the last marked time 
 *   for that START_ID.
 *
 *   When the ID is NULL or not specified, then the default ID of "start" will be assumed.
 *   
 *   This results in consecutive calls to `.mark_delta()` with the same ID to produce 
 *   each of the time intervals between the calls, while consecutive calls to
 *   `.mark()` with he same ID would produce an increase each time instead as the time 
 *   between the `.mark()` call and the original `.start()` increases.
 * 
 * Notes:
 * 
 * - when you invoke `.mark()` or `.mark_delta()` without having called .start() before, 
 *   then the timer is started at the mark.
 * 
 * - `.start()` will erase all stored 'start/mark times' which may have been
 *   set by `.mark()` or `.mark_delta()` before -- you may call `.start()` multiple times for
 *   the same timer instance, after all.
 * 
 * - you are responsible to manage the IDs for `.mark()` and `.mark_delta()`. The ID MUST NOT be "start" 
 *   as ID = "start" identifies the .start() timer.
 * 
 * References for the internal implementation:
 * 
 *    - http://updates.html5rocks.com/2012/08/When-milliseconds-are-not-enough-performance-now
 *    - http://ejohn.org/blog/accuracy-of-javascript-time/
 *
 * @class 
 * @constructor
 */
function PerformanceTimer() {
  /* @private */ var start_time = false;
  var obj = {
  };
  // feature detect:
  /* @private */ var f, tv;
  /* @private */ var p = (typeof window !== 'undefined' && window.performance);
  if (p && p.timing.navigationStart && p.now) {
    f = function () {
      return p.now();
    };
  } else if (p && typeof p.webkitNow === 'function') {
    f = function () {
      return p.webkitNow();
    };
  } else {
    p = (typeof process !== 'undefined' && process.hrtime);
    if (typeof p === 'function') {
      tv = p();
      if (tv && tv.length === 2) {
        f = function () {
          var rv = p();
          return rv[0] * 1e3 + rv[1] * 1e-6;
        };
      } 
    } 
    if (!f) {
      f = function () {
        return Date.now();
      };
      try {
        f();
      } catch (ex) {
        f = function () {
          return +new Date();
        };
      }
    }
  }

  obj.start = function () {
    start_time = {
      start: f()
    };
    return obj;
  };
  
  obj.mark = function (id, start_id) {
    if (start_time === false) this.start();
    var end_time = f();
    var begin_time = start_time[start_id || id || "start"];
    if (!begin_time) {
      begin_time = end_time;
    }
    var rv = end_time - begin_time;
    if (id) {
      start_time[id] = end_time;
    }
    return rv;
  };
  
  obj.mark_delta = function (id) {
    if (start_time === false) this.start();
    id = id || "start";
    var end_time = f();
    var begin_time = start_time[id];
    if (!begin_time) {
      begin_time = end_time;
    }
    var rv = end_time - begin_time;
    start_time[id] = end_time;
    return rv;
  };
  
  obj.reset_mark = function (id) {
    id = id || "start";
    start_time[id] = null;
    return obj;
  };

  obj.get_mark = function (id) {
    id = id || "start";
    return start_time[id];
  };

  obj.mark_sample_and_hold = function (id) {
    if (start_time === false) this.start();
    id = id || "start";
    // sample ...
    var end_time = f();
    var begin_time = start_time[id];
    if (!begin_time) {
      begin_time = end_time;
      // ... and hold
      start_time[id] = begin_time;
    }
    var rv = end_time - begin_time;
    return rv;
  };

  return obj;
}

var perf = PerformanceTimer();



// round to the number of decimal digits:
function r(v, n) {
    var m = Math.pow(10, n | 0);
    v *= m;
    v = Math.round(v);
    return v / m;
}

// run the benchmark on function `f` for at least 5 seconds.
function bench(f, n, minimum_run_time, setup_f, destroy_f) {
    var factor = 50;
    var run = 1;         // factor of 50 !  
    n |= 0;
    n /= run;
    n |= 0;
    n = Math.max(n, 1); // --> minimum number of tests: 1*run*factor
    
    minimum_run_time |= 0;
    if (!minimum_run_time) {
        // default: 5 seconds minimum run time:
        minimum_run_time = 5000 * 1.01 /* overhead compensation */;     
    }
    minimum_run_time = Math.max(minimum_run_time, 1000);    // absolute minimum run time: 1 second

    perf.mark('monitor');

    if (setup_f) {
        setup_f(f, n, minimum_run_time);
    }

    // measure a short run and determine the run count based on this result:
    perf.mark('bench');
    // 50 x f(): that seems a sort of 'sweet spot' for NodeJS v5, at least for some benchmarks...
    f();
    f();
    f();
    f();
    f();
    f();
    f();
    f();
    f();
    f();

    f();
    f();
    f();
    f();
    f();
    f();
    f();
    f();
    f();
    f();

    f();
    f();
    f();
    f();
    f();
    f();
    f();
    f();
    f();
    f();

    f();
    f();
    f();
    f();
    f();
    f();
    f();
    f();
    f();
    f();

    f();
    f();
    f();
    f();
    f();
    f();
    f();
    f();
    f();
    f();

    var sample1 = perf.mark('bench');
    var fmultiplier = 250 / sample1;
    var multiplier = Math.max(1, (fmultiplier + 0.5) | 0);
    run = Math.max(run, multiplier);
    console.log("run multiplier: ", run);

    // get the number of tests internal to the test function: 1 or more
    var internal_cnt = f();
    if (typeof internal_cnt === 'number' && (internal_cnt | 0) === internal_cnt) {
        factor *= internal_cnt;
    }

    var last_report = 500;
    var ts = [];
    for (var i = 0; i < n; i++) {
        perf.mark('bench');
        for (var j = 0; j < run; j++) {
            // 50 x f(): that seems a sort of 'sweet spot' for NodeJS v5, at least for some benchmarks...
            f();
            f();
            f();
            f();
            f();
            f();
            f();
            f();
            f();
            f();

            f();
            f();
            f();
            f();
            f();
            f();
            f();
            f();
            f();
            f();

            f();
            f();
            f();
            f();
            f();
            f();
            f();
            f();
            f();
            f();

            f();
            f();
            f();
            f();
            f();
            f();
            f();
            f();
            f();
            f();

            f();
            f();
            f();
            f();
            f();
            f();
            f();
            f();
            f();
            f();
        }
        ts.push(perf.mark('bench'));
        var consumed = perf.mark_sample_and_hold('monitor');
        //console.log('consumed', consumed, ts[ts.length - 1], i);
        if (last_report <= consumed) {
            console.log('#' + (ts.length * factor));
            last_report = consumed + 1000;
        }
        if (consumed < minimum_run_time || ts.length < 10) {
            // stay in the loop until 5 seconds have expired or at least 10 rounds have been executed!
            i = Math.min(i, n - 2);
        }
    }

    if (destroy_f) {
        destroy_f(f, n, minimum_run_time);
    }

    var consumed = perf.mark_sample_and_hold('monitor');
    
    var sum = 0;
    for (var i = 0, cnt = ts.length; i < cnt; i++) {
        sum += ts[i];
    }
    var avg = sum / cnt;

    var dev = 0;
    var peak = 0;
    for (var i = 0; i < cnt; i++) {
        var delta = Math.abs(ts[i] - avg);
        dev += delta;
        peak = Math.max(peak, delta);
    }
    dev /= cnt;
    var sample_size = run * factor;
    console.log(["Time: total: ", r(sum, 0) + 'ms',
        ", sample_count: ", cnt,
        ", # runs: ", cnt * sample_size,
        ", # runs/sec: ", r(cnt * sample_size * 1000 / sum, 1),
        ", average: ", r(avg / sample_size, 4) + 'ms',
        ", deviation: ", r(100 * dev / avg, 2) + '%',
        ", peak_deviation: ", r(100 * peak / avg, 2) + '%',
        ", total overhead: ", r(consumed - sum, 0) + 'ms'].join('')
    );
}


// End Of Include by Jison: benchmark.js







// ------------------- with custom lexer -----------------------

parser.main = function compiledRunner(args) {
    if (!args[1]) {
        console.log('Usage: ' + args[0] + ' FILE');
        return 1;
    }

    /*
     * What you see happening here is:
     *
     * - the first parser parsed the text input and turns it into a token stream (a
     *   serialized AST, as it were)
     * - then the second parser (defined above) is executed, while it is fed the token stream produced
     *   by the first parser:
     *   + the second parser comes with its own minimal, CUSTOM, lexer (see code below)
     *   + the second parser can be made to be ultra-fast as it doesn't need to mind
     *     about detecting human errors (the front-side = first parser took care of that!)
     *     and it doesn't need to mind about human readable notation either: it takes
     *     a AST/token-stream as input which 'happens to be' prepped by the first parser
     *     to be perfect for a Reverse Polish Notation grammar: both parsers have the
     *     same language power, but the second has simpler rules (note that the
     *     '( exp )' subrule is absent as RPN doesn't need such bracketed priority kludges!)
     *
     *   + A THIRD parser COULD be provided to take the token stream from the first
     *     parser and produce human-readable text output from hat stream: this is just
     *     another use of the same power.
     *
     * What is ultimately shown here is a multi-stage compiler/engine:
     *
     * - the first parser is the 'front end' which is facing human input
     * - the second / third / ... parsers are really slightly sophisticated 'tree walkers'
     *   which take the serialized 'intermediate format' (the token stream) and process
     *   it, as fast as possible.
     *
     * When is this useful?
     *
     * For example, when you need to calculate or otherwise machine-process your parsed
     * input many times, and fast, (e.g. when calculating the expression values) while
     * human input parsing costs would be in the way during such calculus processes:
     * now it is separated into a real 'front end'; the 'odd' thing we did here is re-use
     * yacc/jison to also produce the 'internal' stream/tree walkers as well:
     * quite often those are hand-coded, but I chose to showcase the new `%import symbols`
     * feature of JISON, together with the new #TOKEN and #TOKEN# references, both of
     * which are geared towards this specific usage of JISON and your grammars: this way
     * you can use JISON as an advanced tree walker generator for machine format processing too!
     */


    var source = require('fs').readFileSync(require('path').normalize(args[1]), 'utf8');

    console.warn("\n\n\n@@@ 1 : FRONT-END PARSE PHASE @@@\n\n\n");

    // Front End parse: read human input and produce a token stream i.e. serialized AST:
    compiled_calc_parse.yy.parseError = function (msg, info) {
      //compiled_calc_parse.originalParseError(msg, info);
      console.log('### parse Error: ', msg, {
        text: info.text,
        matched_already: info.lexer && info.lexer.matched
      });
      if (info.yy) {
        // prevent reference cycle (memory leak opportunity!): create a new object instead of just referencing `info`:
        info.yy.lastErrorInfo = {
          errStr: msg,
          exception: info.exception,
          text: info.text,
          value: info.value,
          token: info.token,
          token_id: info.token_id,
          line: info.line,
          loc: info.loc,
          expected: info.expected,
          recoverable: info.recoverable,
          state: info.state,
          action: info.action,
          new_state: info.new_state,
          // and limit the stacks to the valid portion, i.e. index [0..stack_pointer-1]:
          symbol_stack: info.symbol_stack && info.symbol_stack.slice(0, info.stack_pointer),
          state_stack: info.state_stack && info.state_stack.slice(0, info.stack_pointer),
          value_stack: info.value_stack && info.value_stack.slice(0, info.stack_pointer).map(function (v) {
            // and remove any cyclic self-references from the vstack copy:
            if (v && v === info.yy.lastErrorInfo) {
              return NaN;
            }
          }),
          location_stack: info.location_stack && info.location_stack.slice(0, info.stack_pointer),
          stack_pointer: info.stack_pointer,
          //yy: info.yy,
          //lexer: info.lexer,
        };
      }

      // and prevent memory leaks via ref cycles:
      info.destroy();
    };
    var toklst = compiled_calc_parse.parse(source);

    console.log('parsed token list: ', JSON.stringify(toklst, null, 2));

    console.warn("\n\n\n@@@ 2 : INTERPRETER BACK-END PARSE PHASE @@@\n\n\n");
    
    const param_count_per_opcode = generate_opcode_param_count_table();

    // Now set up the second parser's custom lexer: this bugger should munch the token stream. Fast!
    parser.__lexer__ = {
      // internals:
      __input__: null,                                      // input array of (tokens + values), set up by `setInput()` API
      __input_length__: 0,                                  // cached length of input, set up by `setInput()` API
      __cursor_pos__: 0,                                    // index position of next token to deliver

      // ## API
      yytext: null,

      setInput: function setInput2(input, yy) {
        console.log('set input to from token list: ', input);
        this.__input__ = input;
        this.__input_length__ = input.length;
        // reset cursor position:
        this.__cursor_pos__ = 0;
      },

      lex: function lex2() {
        console.log('LEX: input token list: ', this.__input__.slice(this.__cursor_pos__), '@cursor:', this.__cursor_pos__);
        if (this.__input_length__ - this.__cursor_pos__ > 0) {
          var l = this.__input__;
          var c = this.__cursor_pos__;
          var t = l[c];
          c++;

          console.log('shift TOKEN from token list: ', t, parser.describeSymbol(Math.abs(t)));

          // marked token ID indicates that a VALUE is following on its heels...
          var n = param_count_per_opcode[t];
          if (n) {
            // also pop value:
            var v = l[c];
            c++;

            // and set it up for lex() to feed it to the parser engine properly:
            this.yytext = v;

            console.log('shift VALUE from token list: ', v);
          }
          this.__cursor_pos__ = c;
          return t;
        }
        // end of stream: keep spitting out EOF tokens until Kingdom Come:
        return parser.EOF;
      }
    };

    // Execute the second parser: takes a formula/expression token stream as input and
    // spits out the calculated value per line:
    var calc_output = parser.parse(toklst);
    console.log('calculated result from interpreter: ', calc_output);


    console.warn("\n\n\n@@@ 3 : COMPILER BACK-END PARSE PHASE @@@\n\n\n");
    

    // Now set up the third parser's custom lexer: this bugger should munch the token stream. Fast!
    compiled_calc_codegen.__lexer__ = parser.__lexer__;

    // Execute the third parser: : takes a formula/expression token stream as input and
    // spits out native JavaScript code ready to calculate the formula per line:
    var sourcecode = compiled_calc_codegen.parse(toklst);
    console.log('generated source code: ', sourcecode);


    console.warn("\n\n\n@@@ 4 : PRETTY-PRINTING BACK-END PARSE PHASE @@@\n\n\n");
    

    // Now set up the fourth parser's custom lexer: this bugger should munch the token stream. Fast!
    compiled_calc_print.__lexer__ = parser.__lexer__;
    compiled_calc_print.options.debug = true;

    // Execute the fourth parser: : takes a formula/expression token stream as input and
    // spits out the human-readable formatted formula per line:
    var human_output = compiled_calc_print.parse(toklst);
    console.log('generated human-readable pretty-print output: ', human_output);

    return 2;
};

function Parser() {
  this.yy = {};
}
Parser.prototype = parser;
parser.Parser = Parser;

return new Parser();
})();

        


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
  exports.parser = compiled_calc_exec;
  exports.Parser = compiled_calc_exec.Parser;
  exports.parse = function () {
    return compiled_calc_exec.parse.apply(compiled_calc_exec, arguments);
  };
  


var fs = require('fs');
var path = require('path');


exports.main = function (args) {
    // When the parser comes with its own `main` function, then use that one:
    if (typeof exports.parser.main === 'function') {
      return exports.parser.main(args);
    }

    if (!args[1]) {
        console.log('Usage:', path.basename(args[0]) + ' FILE');
        process.exit(1);
    }
    var source = fs.readFileSync(path.normalize(args[1]), 'utf8');
    var dst = exports.parser.parse(source);
    console.log('parser output:\n\n', {
        type: typeof dst,
        value: dst
    });
    try {
        console.log("\n\nor as JSON:\n", JSON.stringify(dst, null, 2));
    } catch (e) { /* ignore crashes; output MAY not be serializable! We are a generic bit of code, after all... */ }
    var rv = 0;
    if (typeof dst === 'number' || typeof dst === 'boolean') {
        rv = dst;
    }
    return dst;
};

// IFF this is the main module executed by NodeJS,
// then run 'main()' immediately:
if (typeof module !== 'undefined' && require.main === module) {
  exports.main(process.argv.slice(1));
}

}
