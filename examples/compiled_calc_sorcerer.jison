//
// Stage 2(META) parser: Code Generator Generator
//
//
// Text file defines the action per 'opcode'.
//
// This parser parses that text file and generates a FAST AST walker around it.
//
// Benefit: ONE place where the AST structure is known in detail: the text files
// have no code duplication, while they serve different purposes, yet walk
// the same AST.
//
// Benefit 2: when the AST format changes, all we need to adjust accordingly is
// the tree walker generator here.
//
//
// 1. P-code interpreter: performs calculus straight off the AST.
// 2. human-readable printer: produces a human-legible representation of the AST.
//    Variants which include color-coding and other embellishments are an option.
// 3. Compiler: generates native code from the AST.
//
//
// What about constant folding?
// What about superformulas for the simulations? Where ASTs reference one another
// and thus could construct a 'superformula': combine formulas into one.
// What about static type analysis and using those results in the code generator?
//
//
// This code generator takes the symbol list from the parse grammar and replaces all token IDs
// in the input with the number instead: no variable/constant lookup in the AST walker.
//
//
// Constant folding in AST is done by injecting JUMP token, which carries result value
// and number of tokens to skip: those skipped tokens are necessary for the pretty-printer,
// while P-code interpreter and P-code compiler benefit from the constant-folding -->
// only outer-most constant-fold should be stored in the AST.
//
//
// Constant-folding should be separate from parse phase as superformulas also require
// folding and when we feed/import pre-parsed input, e.g. own project reload
// after save, then const-fold may need to be re-executed on incoming ASTs, which
// have not gone through the regular parser then!
//
//
//
// -------------------------------------------------------------------------
//
// This one represents the classic textbook 'parser/tokenizer' backend:
// using a 'tree walker' to generate 'object code output': in this case
// the 'backend' is tasked to calculate the value for the given formula,
// acting as an Interpreter (of the P-code a.k.a. IR a.k.a. AST Stream),
// rather than as Compiler (see compile_calc_codegen example for that alternative).
//
// The AST is stored in an array and since the AST acts as the INTERFACE
// between front-end and backend of the compiler/engine, its precise format
// is known to both 'parsers': the compile_calc_parse front-end and this
// back-end, plus additional back-ends which feed off the same AST for
// different purposes.
//
// This 'Interpreter' is designed to be FAST, hence the AST stream has been
// constructed the way it is, using a Polish Notation simile: this takes
// the fewest AST nodes and the fewest number of grammar rules to express
// the entire formula calculation power.
//
// We also assume the AST is always valid (errors can be encoded in there, but
// we will exit HARD when your front-end screwed up the AST 'internal structure'
// in any way!), the result of which is that we now have enabled jison to
// recognize the absence of all and any error checking and reporting facilities,
// which our JISON takes as an opportunity to create a severely stripped down,
// FAST grammar parser, hence a very fast 'tree walker'.
//
// Of course, the usual process is to write such a 'tree walker' by hand,
// but I want to showcase the concept here and there's something to say for
// readability as now AST format and actions performed on the atoms is
// nicely separated! :-)
//
// ---
//
// A crucial detail is the use of the `%import` jison feature which allows
// us to import the symbol table generated by jison as part of the front-end
// parser engine: that way we have a guaranteed good set of token #IDs which we
// can use at both ends of the AST stream interface: this allows us to use
// the other JISON feature which is `#<name>` in the action blocks everywhere:
// this will be expanded into the numeric ID of the given token by jison,
// saving us from having to generate and maintain a separate table of IDs
// for our AST objects!
//
// ---
//
// This example also uses the new JISON `%include` feature which allows us
// to include any given source file *verbatim* in our generated jison output.
// Thus we will produce a complete, working, app in a single file here.
// (See near bottom of this jison file.)




// one grammar is MASTER for our common symbol set:
%import symbols  "./output/compiled_calc/compiled_calc_parse.js"







%token      NUM             // Simple double precision number
%token      VAR FUNCTION    // Variable and Function
%token      CONSTANT        // Predefined Constant Value, e.g. PI or E
%token      ERROR           // Mark error in statement

%token      END             // token to mark the end of a function argument list in the output token stream
%token      FUNCTION_0      // optimization: function without any input parameters
%token      FUNCTION_1      // optimization: function with one input parameter
%token      FUNCTION_2      // optimization: function with two input parameters
%token      FUNCTION_3      // optimization: function with three input parameters

%nonassoc   IF_ELSE         // IF ... THEN ... ELSE ...
%nonassoc   IF              // IF ... THEN ... (ELSE nil) -- the 'dangling else' issue has already been resolved by the *parser* hence this AST input stream doesn't suffer from that issue any more!


// %right      '='
%nonassoc   ASSIGN

%nonassoc   XOR
%nonassoc   OR
%nonassoc   AND

%nonassoc   EQ NEQ GEQ LEQ GT LT

// %left       '^'
// %left       '|'
// %left       '&'
%nonassoc   BITWISE_XOR
%nonassoc   BITWISE_OR
%nonassoc   BITWISE_AND

// %left       '-' '+'
// %left       '*' '/' '%'
// %right      POWER
// %right      '~'
// %right      '!' NOT
%nonassoc   ADD SUBTRACT
%nonassoc   MULTIPLY DIVIDE MODULO
%nonassoc   POWER
%nonassoc   BITWISE_NOT
%nonassoc   NOT
%nonassoc   FACTORIAL
%nonassoc   UMINUS     /* Negation--unary minus */
%nonassoc   UPLUS      /* unary plus */
%nonassoc   PERCENT    /* unary percentage */




/* Grammar follows */

%start input



%options default-action-mode=none,merge     // JISON shouldn't bother injecting the default `$$ = $1` action anywhere!

%parse-param globalSpace                    // extra function parameter for the generated parse() API; we use this one to pass in a reference to our workspace for the functions to play with.



%%


input:
  Îµ                             /* empty */
                                {
                                  $$ = [];
                                }
| input line
                                {
                                  if ($line.length) {
                                    // We MUST signal the end of an expression as otherwise our AST grammar
                                    // will be ambiguous (and thus our tree walkers confused and unable to
                                    // work) as we must be able to differentiate between 'end of function arglist'
                                    // and 'end of statement': since we expect more functions (and thus
                                    // arglist terminations) than statements, we choose to give the FUNCTION
                                    // arglist an implicit termination while the statement gets to have an
                                    // *explicit* termination (#EOL# token) so that we end up with a shorter
                                    // AST stream -- iff our assumption holds in actual use!
                                    //
                                    // NOTE: We only need to add a sentinel when multiple statements (lines)
                                    // are input: when there's only a single statement (line) it'll unambguously
                                    // terminated by EOF!
                                    if (01 && $input.length) {
                                      $line.push(#EOL#);
                                    }
                                    $$ = $input.concat($line);
                                  } else {
                                    $$ = $input;
                                  }
                                }
;

line:
  exp EOL
                                {
                                  $$ = $exp;
                                }
| ERROR EOL
                                {
                                  $$ = [#ERROR#, #EOL#];
                                }
;

exp:
  NUM
                                { $$ = [#NUM, $NUM]; }
| CONSTANT
                                { $$ = [#CONSTANT, $CONSTANT]; }
| VAR
                                { $$ = [#VAR, $VAR]; }
| ASSIGN exp
                                {
                                  /*
                                     Note: #assign is always to a simple variable, hence we don't need the `#VAR`
                                     token here: it is implicit as there's nothing else we can do.

                                     Technically, this is an AST optimization, but it's such a fundamental one
                                     we do it here instead of later.

                                     NOTE: #assign implies the presence of a VAR as lhs (left hand side) so it
                                     would only be cluttering the AST stream to have a #VAR# token in there:
                                     it is *implicit* to #assign!
                                   */
                                  $$ = [#ASSIGN#, $ASSIGN].concat($exp);
                                }
| FUNCTION_0
                                { $$ = [#FUNCTION_0#, $FUNCTION_0]; }
| FUNCTION arglist END
                                {
                                  /*
                                     See the comment in the statement EOL rule above: to disambiguate a sequence
                                     of exp subtrees, we MUST add a terminator to either or both statement and
                                     function, otherwise the sequence `FUNCTION exp exp` is ambiguous: it could
                                     be:

                                     - a no-args functions and two more statements,
                                     - a single-arg function and one more statement,
                                     - a two-arg function.

                                     Of course, you may argue that adding 'number of arguments' knowledge to the
                                     FUNCTION token would also resolve this issue, and it would, but that would
                                     be a bit harder to encode in an LALR(1) grammar used as the treewalker core.
                                     It is easier to use a sentinel token in one or both spots.

                                     A lot of functions have only a few arguments, which we later optimize in our AST
                                     by including that knowledge in the FUNCTION token by using derivative tokens
                                     FUNCTION_0, FUNCTION_1, etc.: this can help a smart optimizer to include
                                     special optimizations for these functions without having to re-discover
                                     the arglist length.
                                     As that approach already disambiguates the function-versus-statement
                                     situation by having encoded arglist length in the FUNCTION token, these
                                     tokens never require a sentinel token in the AST stream: small AST stream size.

                                     Now we let the optimizer deal with this when the time comes...

                                     Meanwhile, keep it as simple as possible in here!

                                     Also don't forget to FLATTEN the arglist! ==> `concat.apply(a, arglist)`

                                     NOTE: the #FUNCTION# rule in Polish Notation is ambiguous unless we terminate it
                                     (which is easy to parse in an LALR(1) grammar while adding a argument count is not!)
                                     as we would otherwise get confused over this scenario:

                                          ... PLUS FUNCTION exp exp exp ...

                                     - is this a function with one argument and that last `exp` in there the second term
                                       of a binary(?) opcode waiting in the leading `...`?
                                     - is this a function with two arguments and that last `exp` the second
                                       term of the PLUS?
                                     - is this a function with three arguments and is the second term of the PLUS
                                       waiting in the trailing `...`?

                                     This is the trouble with opcodes which accept a variable number of arguments:
                                     such opcodes always have to be terminated by a sentinel to make the AST grammar
                                     unambiguous.
                                  */
                                  $$ = [].concat.apply([#FUNCTION#, $FUNCTION], $arglist);
                                  $$.push(#END#);

                                }
| FUNCTION_1 exp
                                {
                                  $$ = [#FUNCTION_1#, $FUNCTION_1].concat($exp);
                                }
| FUNCTION_2 exp exp
                                {
                                  $$ = [#FUNCTION_2#, $FUNCTION_2].concat($exp1, $exp2);
                                }
| FUNCTION_3 exp exp exp
                                {
                                  $$ = [#FUNCTION_3#, $FUNCTION_3].concat($exp1, $exp2, $exp3);
                                }

| EQ exp exp
                                { $$ = [#EQ].concat($exp1, $exp2); }
| NEQ exp exp
                                { $$ = [#NEQ].concat($exp1, $exp2); }
| LEQ exp exp
                                { $$ = [#LEQ].concat($exp1, $exp2); }
| GEQ exp exp
                                { $$ = [#GEQ].concat($exp1, $exp2); }
| LT exp exp
                                { $$ = [#LT].concat($exp1, $exp2); }
| GT exp exp
                                { $$ = [#GT].concat($exp1, $exp2); }
| OR exp exp
                                { $$ = [#OR].concat($exp1, $exp2); }
| XOR exp exp
                                { $$ = [#XOR].concat($exp1, $exp2); }
| AND exp exp
                                { $$ = [#AND].concat($exp1, $exp2); }

| BITWISE_OR exp exp
                                { $$ = [#BITWISE_OR#].concat($exp1, $exp2); }
| BITWISE_XOR exp exp
                                { $$ = [#BITWISE_XOR#].concat($exp1, $exp2); }
| BITWISE_AND exp exp
                                { $$ = [#BITWISE_AND#].concat($exp1, $exp2); }

| ADD exp exp
                                { $$ = [#ADD#].concat($exp1, $exp2); }
| SUBTRACT exp exp
                                { $$ = [#SUBTRACT#].concat($exp1, $exp2); }
| MULTIPLY exp exp
                                { $$ = [#MULTIPLY#].concat($exp1, $exp2); }
| DIVIDE exp exp
                                { $$ = [#DIVIDE#].concat($exp1, $exp2); }
| MODULO exp exp
                                { $$ = [#MODULO#].concat($exp1, $exp2); }
| UMINUS exp
                                { $$ = [#UMINUS#].concat($exp); }
| UPLUS exp
                                { $$ = [#UPLUS#].concat($exp); }
| POWER exp exp
                                { $$ = [#POWER#].concat($exp1, $exp2); }
| PERCENT exp
                                { $$ = [#PERCENT#].concat($exp); }
| FACTORIAL exp
                                { $$ = [#FACTORIAL#].concat($exp); }

| BITWISE_NOT exp
                                { $$ = [#BITWISE_NOT#].concat($exp); }
| NOT exp
                                { $$ = [#NOT#].concat($exp); }


| IF_ELSE exp exp exp
                                {
                                  $$ = [#IF_ELSE#].concat($exp1, $exp2, $exp3);
                                }
| IF exp exp
                                {
                                  $$ = [#IF#].concat($exp1, $exp2);
                                }
;

arglist:
  exp
                                { $$ = [$exp]; }
| arglist exp
                                {
                                  $$ = $arglist;
                                  $$.push($exp);
                                }
;





/* End of grammar */


%%




// TODO
//
// - constant folding: any part of the stream, starting at an operator token, which does not involve variable references or volatile functions (such as rand())
//   should be marked up as a constant-folding calculation and the calculation should be done.
//
// - code de-duplication: recognize subexpression duplications in the stream: these always start at an operator and have
//   identical subtrees, hence identical streams (content/length): the duplicate should ideally reference the first
//   occurrence inside the expression. E.g. `a+b+a+b` -> `(r=a+b)+r` where `r` is an internal reference/register (plus error tracking spot; imagine
//   duplicate code as in `if (is_divide_by_zero_error(a+b+c)) then d else a+b+c+d endif` -> `if (is_error(r=a+b+c)) then d else r+d endif` where register `r`
//   must also store its accompanying error state: if the error coming out of `a+b+c` is something else then 'divide by zero', the error should propagate
//   into the `r+d` expression without a hitch!
//
//   Duplicate subexpressions can be found by chopping up the stream into Ngrams with variable N size, at opcode boundaries: same Ngram is same subtree.
//   Lookup Hashtable/dictionary and you're good to go.  When the token stream is actually a (Unicode) string, this activity becomes rather cheap too as
//   then it's all string cutting and copying and comparing, which is mostly native.
//



