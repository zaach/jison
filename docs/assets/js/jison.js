(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (process){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _templateObject = _taggedTemplateLiteral(['\n        There\'s an error in your lexer regex rules or epilogue.\n        Maybe you did not correctly separate the lexer sections with a \'%%\'\n        on an otherwise empty line?\n        The lexer spec file should have this structure:\n    \n                definitions\n                %%\n                rules\n                %%                  // <-- optional!\n                extra_module_code   // <-- optional epilogue!\n    \n          Erroneous code:\n        ', '\n    \n          Technical error report:\n        ', '\n    '], ['\n        There\'s an error in your lexer regex rules or epilogue.\n        Maybe you did not correctly separate the lexer sections with a \'%%\'\n        on an otherwise empty line?\n        The lexer spec file should have this structure:\n    \n                definitions\n                %%\n                rules\n                %%                  // <-- optional!\n                extra_module_code   // <-- optional epilogue!\n    \n          Erroneous code:\n        ', '\n    \n          Technical error report:\n        ', '\n    ']),
    _templateObject2 = _taggedTemplateLiteral(['\n        There\'s probably an error in one or more of your lexer regex rules.\n        The lexer rule spec should have this structure:\n    \n                regex  action_code\n    \n        where \'regex\' is a lex-style regex expression (see the\n        jison and jison-lex documentation) which is intended to match a chunk\n        of the input to lex, while the \'action_code\' block is the JS code\n        which will be invoked when the regex is matched. The \'action_code\' block\n        may be any (indented!) set of JS statements, optionally surrounded\n        by \'{...}\' curly braces or otherwise enclosed in a \'%{...%}\' block.\n    \n          Erroneous code:\n        ', '\n    \n          Technical error report:\n        ', '\n    '], ['\n        There\'s probably an error in one or more of your lexer regex rules.\n        The lexer rule spec should have this structure:\n    \n                regex  action_code\n    \n        where \'regex\' is a lex-style regex expression (see the\n        jison and jison-lex documentation) which is intended to match a chunk\n        of the input to lex, while the \'action_code\' block is the JS code\n        which will be invoked when the regex is matched. The \'action_code\' block\n        may be any (indented!) set of JS statements, optionally surrounded\n        by \'{...}\' curly braces or otherwise enclosed in a \'%{...%}\' block.\n    \n          Erroneous code:\n        ', '\n    \n          Technical error report:\n        ', '\n    ']),
    _templateObject3 = _taggedTemplateLiteral(['\n        There\'s an error in your lexer epilogue a.k.a. \'extra_module_code\' block.\n    \n          Erroneous code:\n        ', '\n    \n          Technical error report:\n        ', '\n    '], ['\n        There\'s an error in your lexer epilogue a.k.a. \'extra_module_code\' block.\n    \n          Erroneous code:\n        ', '\n    \n          Technical error report:\n        ', '\n    ']),
    _templateObject4 = _taggedTemplateLiteral(['\n            Encountered an unsupported definition type: ', '.\n    \n              Erroneous area:\n            ', '\n          '], ['\n            Encountered an unsupported definition type: ', '.\n    \n              Erroneous area:\n            ', '\n          ']),
    _templateObject5 = _taggedTemplateLiteral(['\n            The \'%{...%}\' lexer setup action code section does not compile: ', '\n    \n              Erroneous area:\n            ', '\n        '], ['\n            The \'%{...%}\' lexer setup action code section does not compile: ', '\n    \n              Erroneous area:\n            ', '\n        ']),
    _templateObject6 = _taggedTemplateLiteral(['\n        You did not specify a legal file path for the \'%import\' initialization code statement, which must have the format:\n            %import qualifier_name file_path\n    \n          Erroneous code:\n        ', '\n    \n          Technical error report:\n        ', '\n    '], ['\n        You did not specify a legal file path for the \'%import\' initialization code statement, which must have the format:\n            %import qualifier_name file_path\n    \n          Erroneous code:\n        ', '\n    \n          Technical error report:\n        ', '\n    ']),
    _templateObject7 = _taggedTemplateLiteral(['\n        %import name or source filename missing maybe?\n    \n        Note: each \'%import\'-ed initialization code section must be qualified by a name, e.g. \'required\' before the import path itself:\n            %import qualifier_name file_path\n    \n          Erroneous code:\n        ', '\n    \n          Technical error report:\n        ', '\n    '], ['\n        %import name or source filename missing maybe?\n    \n        Note: each \'%import\'-ed initialization code section must be qualified by a name, e.g. \'required\' before the import path itself:\n            %import qualifier_name file_path\n    \n          Erroneous code:\n        ', '\n    \n          Technical error report:\n        ', '\n    ']),
    _templateObject8 = _taggedTemplateLiteral(['\n            The \'%code ', '\' action code section does not compile: ', '\n    \n            ', '\n    \n              Erroneous area:\n            ', '\n        '], ['\n            The \'%code ', '\' action code section does not compile: ', '\n    \n            ', '\n    \n              Erroneous area:\n            ', '\n        ']),
    _templateObject9 = _taggedTemplateLiteral(['\n        Each \'%code\' initialization code section must be qualified by a name, e.g. \'required\' before the action code itself:\n            %code qualifier_name {action code}\n    \n          Erroneous code:\n        ', '\n    \n          Technical error report:\n        ', '\n    '], ['\n        Each \'%code\' initialization code section must be qualified by a name, e.g. \'required\' before the action code itself:\n            %code qualifier_name {action code}\n    \n          Erroneous code:\n        ', '\n    \n          Technical error report:\n        ', '\n    ']),
    _templateObject10 = _taggedTemplateLiteral(['\n        Seems you made a mistake while specifying one of the lexer rules inside\n        the start condition\n           <', '> { rules... }\n        block.\n    \n          Erroneous area:\n        ', '\n    \n          Technical error report:\n        ', '\n    '], ['\n        Seems you made a mistake while specifying one of the lexer rules inside\n        the start condition\n           <', '> { rules... }\n        block.\n    \n          Erroneous area:\n        ', '\n    \n          Technical error report:\n        ', '\n    ']),
    _templateObject11 = _taggedTemplateLiteral(['\n        Seems you did not correctly bracket a lexer rules set inside\n        the start condition\n          <', '> { rules... }\n        as a terminating curly brace \'}\' could not be found.\n    \n          Erroneous area:\n        ', '\n    \n          Technical error report:\n        ', '\n    '], ['\n        Seems you did not correctly bracket a lexer rules set inside\n        the start condition\n          <', '> { rules... }\n        as a terminating curly brace \'}\' could not be found.\n    \n          Erroneous area:\n        ', '\n    \n          Technical error report:\n        ', '\n    ']),
    _templateObject12 = _taggedTemplateLiteral(['\n            The rule\'s action code section does not compile: ', '\n    \n              Erroneous area:\n            ', '\n        '], ['\n            The rule\'s action code section does not compile: ', '\n    \n              Erroneous area:\n            ', '\n        ']),
    _templateObject13 = _taggedTemplateLiteral(['\n        Lexer rule regex action code declaration error?\n    \n          Erroneous code:\n        ', '\n    \n          Technical error report:\n        ', '\n    '], ['\n        Lexer rule regex action code declaration error?\n    \n          Erroneous code:\n        ', '\n    \n          Technical error report:\n        ', '\n    ']),
    _templateObject14 = _taggedTemplateLiteral(['\n        Missing curly braces: seems you did not correctly bracket a lexer rule action block in curly braces: \'{ ... }\'.\n    \n          Offending action body:\n        ', '\n    '], ['\n        Missing curly braces: seems you did not correctly bracket a lexer rule action block in curly braces: \'{ ... }\'.\n    \n          Offending action body:\n        ', '\n    ']),
    _templateObject15 = _taggedTemplateLiteral(['\n        Too many curly braces: seems you did not correctly bracket a lexer rule action block in curly braces: \'{ ... }\'.\n    \n          Offending action body:\n        ', '\n    '], ['\n        Too many curly braces: seems you did not correctly bracket a lexer rule action block in curly braces: \'{ ... }\'.\n    \n          Offending action body:\n        ', '\n    ']),
    _templateObject16 = _taggedTemplateLiteral(['\n        You may place the \'%include\' instruction only at the start/front of a line.\n    \n          Its use is not permitted at this position:\n        ', '\n    '], ['\n        You may place the \'%include\' instruction only at the start/front of a line.\n    \n          Its use is not permitted at this position:\n        ', '\n    ']),
    _templateObject17 = _taggedTemplateLiteral(['\n        Seems you did not correctly match curly braces \'{ ... }\' in a lexer rule action block.\n    \n          Erroneous code:\n        ', '\n    \n          Technical error report:\n        ', '\n    '], ['\n        Seems you did not correctly match curly braces \'{ ... }\' in a lexer rule action block.\n    \n          Erroneous code:\n        ', '\n    \n          Technical error report:\n        ', '\n    ']),
    _templateObject18 = _taggedTemplateLiteral(['\n        Seems you did not correctly terminate the start condition set <', ',???> with a terminating \'>\'\n    \n          Erroneous code:\n        ', '\n    \n          Technical error report:\n        ', '\n    '], ['\n        Seems you did not correctly terminate the start condition set <', ',???> with a terminating \'>\'\n    \n          Erroneous code:\n        ', '\n    \n          Technical error report:\n        ', '\n    ']),
    _templateObject19 = _taggedTemplateLiteral(['\n        Seems you did not correctly bracket a lex rule regex part in \'(...)\' braces.\n    \n          Unterminated regex part:\n        ', '\n    \n          Technical error report:\n        ', '\n    '], ['\n        Seems you did not correctly bracket a lex rule regex part in \'(...)\' braces.\n    \n          Unterminated regex part:\n        ', '\n    \n          Technical error report:\n        ', '\n    ']),
    _templateObject20 = _taggedTemplateLiteral(['\n        Seems you did not correctly bracket a lex rule regex set in \'[...]\' brackets.\n    \n          Unterminated regex set:\n        ', '\n    \n          Technical error report:\n        ', '\n    '], ['\n        Seems you did not correctly bracket a lex rule regex set in \'[...]\' brackets.\n    \n          Unterminated regex set:\n        ', '\n    \n          Technical error report:\n        ', '\n    ']),
    _templateObject21 = _taggedTemplateLiteral(['\n        Internal error: option "', '" value assignment failure.\n    \n          Erroneous area:\n        ', '\n    \n          Technical error report:\n        ', '\n    '], ['\n        Internal error: option "', '" value assignment failure.\n    \n          Erroneous area:\n        ', '\n    \n          Technical error report:\n        ', '\n    ']),
    _templateObject22 = _taggedTemplateLiteral(['\n        Expected a valid option name (with optional value assignment).\n    \n          Erroneous area:\n        ', '\n    \n          Technical error report:\n        ', '\n    '], ['\n        Expected a valid option name (with optional value assignment).\n    \n          Erroneous area:\n        ', '\n    \n          Technical error report:\n        ', '\n    ']),
    _templateObject23 = _taggedTemplateLiteral(['\n            The extra lexer module code section (a.k.a. \'epilogue\') does not compile: ', '\n    \n              Erroneous area:\n            ', '\n        '], ['\n            The extra lexer module code section (a.k.a. \'epilogue\') does not compile: ', '\n    \n              Erroneous area:\n            ', '\n        ']),
    _templateObject24 = _taggedTemplateLiteral(['\n            The source code %include-d into the extra lexer module code section (a.k.a. \'epilogue\') does not compile: ', '\n    \n              Erroneous area:\n            ', '\n        '], ['\n            The source code %include-d into the extra lexer module code section (a.k.a. \'epilogue\') does not compile: ', '\n    \n              Erroneous area:\n            ', '\n        ']),
    _templateObject25 = _taggedTemplateLiteral(['\n        %include MUST be followed by a valid file path.\n    \n          Erroneous path:\n        ', '\n    \n          Technical error report:\n        ', '\n    '], ['\n        %include MUST be followed by a valid file path.\n    \n          Erroneous path:\n        ', '\n    \n          Technical error report:\n        ', '\n    ']),
    _templateObject26 = _taggedTemplateLiteral(['\n        Module code declaration error?\n    \n          Erroneous code:\n        ', '\n    \n          Technical error report:\n        ', '\n    '], ['\n        Module code declaration error?\n    \n          Erroneous code:\n        ', '\n    \n          Technical error report:\n        ', '\n    ']),
    _templateObject27 = _taggedTemplateLiteral(['\n                                                    %include statements must occur on a line on their own and cannot occur inside an %{...%} action code block.\n                                                    Its use is not permitted at this position.\n\n                                                      Erroneous area:\n                                                    '], ['\n                                                    %include statements must occur on a line on their own and cannot occur inside an %{...%} action code block.\n                                                    Its use is not permitted at this position.\n\n                                                      Erroneous area:\n                                                    ']),
    _templateObject28 = _taggedTemplateLiteral(['\n                                                    too many closing curly braces in lexer rule action block.\n\n                                                    Note: the action code chunk may be too complex for jison to parse\n                                                    easily; we suggest you wrap the action code chunk in \'%{...%}\'\n                                                    to help jison grok more or less complex action code chunks.\n\n                                                      Erroneous area:\n                                                    '], ['\n                                                    too many closing curly braces in lexer rule action block.\n\n                                                    Note: the action code chunk may be too complex for jison to parse\n                                                    easily; we suggest you wrap the action code chunk in \'%{...%}\'\n                                                    to help jison grok more or less complex action code chunks.\n\n                                                      Erroneous area:\n                                                    ']),
    _templateObject29 = _taggedTemplateLiteral(['\n                                                    missing ', ' closing curly braces in lexer rule action block.\n\n                                                    Note: the action code chunk may be too complex for jison to parse\n                                                    easily; we suggest you wrap the action code chunk in \'%{...%}\'\n                                                    to help jison grok more or less complex action code chunks.\n\n                                                      Erroneous area:\n                                                    '], ['\n                                                    missing ', ' closing curly braces in lexer rule action block.\n\n                                                    Note: the action code chunk may be too complex for jison to parse\n                                                    easily; we suggest you wrap the action code chunk in \'%{...%}\'\n                                                    to help jison grok more or less complex action code chunks.\n\n                                                      Erroneous area:\n                                                    ']),
    _templateObject30 = _taggedTemplateLiteral(['\n                                                LEX: ignoring unsupported lexer option ', '\n                                                while lexing in ', ' state.\n\n                                                  Erroneous area:\n                                                '], ['\n                                                LEX: ignoring unsupported lexer option ', '\n                                                while lexing in ', ' state.\n\n                                                  Erroneous area:\n                                                ']),
    _templateObject31 = _taggedTemplateLiteral(['\n                                            unterminated string constant in lexer rule action block.\n\n                                              Erroneous area:\n                                            '], ['\n                                            unterminated string constant in lexer rule action block.\n\n                                              Erroneous area:\n                                            ']),
    _templateObject32 = _taggedTemplateLiteral(['\n                                            unterminated string constant in %options entry.\n\n                                              Erroneous area:\n                                            '], ['\n                                            unterminated string constant in %options entry.\n\n                                              Erroneous area:\n                                            ']),
    _templateObject33 = _taggedTemplateLiteral(['\n                                            unterminated string constant  encountered while lexing\n                                            ', '.\n\n                                              Erroneous area:\n                                            '], ['\n                                            unterminated string constant  encountered while lexing\n                                            ', '.\n\n                                              Erroneous area:\n                                            ']),
    _templateObject34 = _taggedTemplateLiteral(['\n                                                unsupported lexer input encountered while lexing\n                                                ', ' (i.e. jison lex regexes).\n\n                                                    NOTE: When you want this input to be interpreted as a LITERAL part\n                                                          of a lex rule regex, you MUST enclose it in double or\n                                                          single quotes.\n\n                                                          If not, then know that this input is not accepted as a valid\n                                                          regex expression here in jison-lex ', '.\n\n                                                  Erroneous area:\n                                                '], ['\n                                                unsupported lexer input encountered while lexing\n                                                ', ' (i.e. jison lex regexes).\n\n                                                    NOTE: When you want this input to be interpreted as a LITERAL part\n                                                          of a lex rule regex, you MUST enclose it in double or\n                                                          single quotes.\n\n                                                          If not, then know that this input is not accepted as a valid\n                                                          regex expression here in jison-lex ', '.\n\n                                                  Erroneous area:\n                                                ']),
    _templateObject35 = _taggedTemplateLiteral(['\n                                                unsupported lexer input: ', '\n                                                while lexing in ', ' state.\n\n                                                  Erroneous area:\n                                                '], ['\n                                                unsupported lexer input: ', '\n                                                while lexing in ', ' state.\n\n                                                  Erroneous area:\n                                                ']),
    _templateObject36 = _taggedTemplateLiteral(['\n        var __hacky_counter__ = 0;\n\n        /**\n         * @constructor\n         * @nocollapse\n         */\n        function XRegExp(re, f) {\n            this.re = re;\n            this.flags = f;\n            this._getUnicodeProperty = function (k) {};\n            var fake = /./;    // WARNING: this exact \'fake\' is also depended upon by the xregexp unit test!\n            __hacky_counter__++;\n            fake.__hacky_backy__ = __hacky_counter__;\n            return fake;\n        }\n    '], ['\n        var __hacky_counter__ = 0;\n\n        /**\n         * @constructor\n         * @nocollapse\n         */\n        function XRegExp(re, f) {\n            this.re = re;\n            this.flags = f;\n            this._getUnicodeProperty = function (k) {};\n            var fake = /./;    // WARNING: this exact \'fake\' is also depended upon by the xregexp unit test!\n            __hacky_counter__++;\n            fake.__hacky_backy__ = __hacky_counter__;\n            return fake;\n        }\n    ']),
    _templateObject37 = _taggedTemplateLiteral(['\n    return ', ';\n'], ['\n    return ', ';\n']),
    _templateObject38 = _taggedTemplateLiteral(['\n        // Code Generator Information Report\n        // ---------------------------------\n        //\n        // Options:\n        //\n        //   backtracking: .................... ', '\n        //   location.ranges: ................. ', '\n        //   location line+column tracking: ... ', '\n        //\n        //\n        // Forwarded Parser Analysis flags:\n        //\n        //   uses yyleng: ..................... ', '\n        //   uses yylineno: ................... ', '\n        //   uses yytext: ..................... ', '\n        //   uses yylloc: ..................... ', '\n        //   uses lexer values: ............... ', ' / ', '\n        //   location tracking: ............... ', '\n        //   location assignment: ............. ', '\n        //\n        //\n        // Lexer Analysis flags:\n        //\n        //   uses yyleng: ..................... ', '\n        //   uses yylineno: ................... ', '\n        //   uses yytext: ..................... ', '\n        //   uses yylloc: ..................... ', '\n        //   uses ParseError API: ............. ', '\n        //   uses yyerror: .................... ', '\n        //   uses location tracking & editing:  ', '\n        //   uses more() API: ................. ', '\n        //   uses unput() API: ................ ', '\n        //   uses reject() API: ............... ', '\n        //   uses less() API: ................. ', '\n        //   uses display APIs pastInput(), upcomingInput(), showPosition():\n        //        ............................. ', '\n        //   uses describeYYLLOC() API: ....... ', '\n        //\n        // --------- END OF REPORT -----------\n\n    '], ['\n        // Code Generator Information Report\n        // ---------------------------------\n        //\n        // Options:\n        //\n        //   backtracking: .................... ', '\n        //   location.ranges: ................. ', '\n        //   location line+column tracking: ... ', '\n        //\n        //\n        // Forwarded Parser Analysis flags:\n        //\n        //   uses yyleng: ..................... ', '\n        //   uses yylineno: ................... ', '\n        //   uses yytext: ..................... ', '\n        //   uses yylloc: ..................... ', '\n        //   uses lexer values: ............... ', ' / ', '\n        //   location tracking: ............... ', '\n        //   location assignment: ............. ', '\n        //\n        //\n        // Lexer Analysis flags:\n        //\n        //   uses yyleng: ..................... ', '\n        //   uses yylineno: ................... ', '\n        //   uses yytext: ..................... ', '\n        //   uses yylloc: ..................... ', '\n        //   uses ParseError API: ............. ', '\n        //   uses yyerror: .................... ', '\n        //   uses location tracking & editing:  ', '\n        //   uses more() API: ................. ', '\n        //   uses unput() API: ................ ', '\n        //   uses reject() API: ............... ', '\n        //   uses less() API: ................. ', '\n        //   uses display APIs pastInput(), upcomingInput(), showPosition():\n        //        ............................. ', '\n        //   uses describeYYLLOC() API: ....... ', '\n        //\n        // --------- END OF REPORT -----------\n\n    ']),
    _templateObject39 = _taggedTemplateLiteral(['\n            var lexer = {\n            '], ['\n            var lexer = {\n            ']),
    _templateObject40 = _taggedTemplateLiteral([',\n            JisonLexerError: JisonLexerError,\n            performAction: ', ',\n            simpleCaseActionClusters: ', ',\n            rules: [\n                ', '\n            ],\n            conditions: ', '\n        };\n        '], [',\n            JisonLexerError: JisonLexerError,\n            performAction: ', ',\n            simpleCaseActionClusters: ', ',\n            rules: [\n                ', '\n            ],\n            conditions: ', '\n        };\n        ']),
    _templateObject41 = _taggedTemplateLiteral(['\n    /* lexer generated by jison-lex ', ' */\n\n    /*\n     * Returns a Lexer object of the following structure:\n     *\n     *  Lexer: {\n     *    yy: {}     The so-called "shared state" or rather the *source* of it;\n     *               the real "shared state" `yy` passed around to\n     *               the rule actions, etc. is a direct reference!\n     *\n     *               This "shared context" object was passed to the lexer by way of \n     *               the `lexer.setInput(str, yy)` API before you may use it.\n     *\n     *               This "shared context" object is passed to the lexer action code in `performAction()`\n     *               so userland code in the lexer actions may communicate with the outside world \n     *               and/or other lexer rules\' actions in more or less complex ways.\n     *\n     *  }\n     *\n     *  Lexer.prototype: {\n     *    EOF: 1,\n     *    ERROR: 2,\n     *\n     *    yy:        The overall "shared context" object reference.\n     *\n     *    JisonLexerError: function(msg, hash),\n     *\n     *    performAction: function lexer__performAction(yy, yyrulenumber, YY_START),\n     *\n     *               The function parameters and `this` have the following value/meaning:\n     *               - `this`    : reference to the `lexer` instance. \n     *                               `yy_` is an alias for `this` lexer instance reference used internally.\n     *\n     *               - `yy`      : a reference to the `yy` "shared state" object which was passed to the lexer\n     *                             by way of the `lexer.setInput(str, yy)` API before.\n     *\n     *                             Note:\n     *                             The extra arguments you specified in the `%parse-param` statement in your\n     *                             **parser** grammar definition file are passed to the lexer via this object\n     *                             reference as member variables.\n     *\n     *               - `yyrulenumber`   : index of the matched lexer rule (regex), used internally.\n     *\n     *               - `YY_START`: the current lexer "start condition" state.\n     *\n     *    parseError: function(str, hash, ExceptionClass),\n     *\n     *    constructLexErrorInfo: function(error_message, is_recoverable),\n     *               Helper function.\n     *               Produces a new errorInfo \'hash object\' which can be passed into `parseError()`.\n     *               See it\'s use in this lexer kernel in many places; example usage:\n     *\n     *                   var infoObj = lexer.constructParseErrorInfo(\'fail!\', true);\n     *                   var retVal = lexer.parseError(infoObj.errStr, infoObj, lexer.JisonLexerError);\n     *\n     *    options: { ... lexer %options ... },\n     *\n     *    lex: function(),\n     *               Produce one token of lexed input, which was passed in earlier via the `lexer.setInput()` API.\n     *               You MAY use the additional `args...` parameters as per `%parse-param` spec of the **lexer** grammar:\n     *               these extra `args...` are added verbatim to the `yy` object reference as member variables.\n     *\n     *               WARNING:\n     *               Lexer\'s additional `args...` parameters (via lexer\'s `%parse-param`) MAY conflict with\n     *               any attributes already added to `yy` by the **parser** or the jison run-time; \n     *               when such a collision is detected an exception is thrown to prevent the generated run-time \n     *               from silently accepting this confusing and potentially hazardous situation! \n     *\n     *    cleanupAfterLex: function(do_not_nuke_errorinfos),\n     *               Helper function.\n     *\n     *               This helper API is invoked when the **parse process** has completed: it is the responsibility\n     *               of the **parser** (or the calling userland code) to invoke this method once cleanup is desired. \n     *\n     *               This helper may be invoked by user code to ensure the internal lexer gets properly garbage collected.\n     *\n     *    setInput: function(input, [yy]),\n     *\n     *\n     *    input: function(),\n     *\n     *\n     *    unput: function(str),\n     *\n     *\n     *    more: function(),\n     *\n     *\n     *    reject: function(),\n     *\n     *\n     *    less: function(n),\n     *\n     *\n     *    pastInput: function(n),\n     *\n     *\n     *    upcomingInput: function(n),\n     *\n     *\n     *    showPosition: function(),\n     *\n     *\n     *    test_match: function(regex_match_array, rule_index),\n     *\n     *\n     *    next: function(),\n     *\n     *\n     *    begin: function(condition),\n     *\n     *\n     *    pushState: function(condition),\n     *\n     *\n     *    popState: function(),\n     *\n     *\n     *    topState: function(),\n     *\n     *\n     *    _currentRules: function(),\n     *\n     *\n     *    stateStackSize: function(),\n     *\n     *\n     *    performAction: function(yy, yy_, yyrulenumber, YY_START),\n     *\n     *\n     *    rules: [...],\n     *\n     *\n     *    conditions: {associative list: name ==> set},\n     *  }\n     *\n     *\n     *  token location info (`yylloc`): {\n     *    first_line: n,\n     *    last_line: n,\n     *    first_column: n,\n     *    last_column: n,\n     *    range: [start_number, end_number]\n     *               (where the numbers are indexes into the input string, zero-based)\n     *  }\n     *\n     * ---\n     *\n     * The `parseError` function receives a \'hash\' object with these members for lexer errors:\n     *\n     *  {\n     *    text:        (matched text)\n     *    token:       (the produced terminal token, if any)\n     *    token_id:    (the produced terminal token numeric ID, if any)\n     *    line:        (yylineno)\n     *    loc:         (yylloc)\n     *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule\n     *                  available for this particular error)\n     *    yy:          (object: the current parser internal "shared state" `yy`\n     *                  as is also available in the rule actions; this can be used,\n     *                  for instance, for advanced error analysis and reporting)\n     *    lexer:       (reference to the current lexer instance used by the parser)\n     *  }\n     *\n     * while `this` will reference the current lexer instance.\n     *\n     * When `parseError` is invoked by the lexer, the default implementation will\n     * attempt to invoke `yy.parser.parseError()`; when this callback is not provided\n     * it will try to invoke `yy.parseError()` instead. When that callback is also not\n     * provided, a `JisonLexerError` exception will be thrown containing the error\n     * message and `hash`, as constructed by the `constructLexErrorInfo()` API.\n     *\n     * Note that the lexer\'s `JisonLexerError` error class is passed via the\n     * `ExceptionClass` argument, which is invoked to construct the exception\n     * instance to be thrown, so technically `parseError` will throw the object\n     * produced by the `new ExceptionClass(str, hash)` JavaScript expression.\n     *\n     * ---\n     *\n     * You can specify lexer options by setting / modifying the `.options` object of your Lexer instance.\n     * These options are available:\n     *\n     * (Options are permanent.)\n     *  \n     *  yy: {\n     *      parseError: function(str, hash, ExceptionClass)\n     *                 optional: overrides the default `parseError` function.\n     *  }\n     *\n     *  lexer.options: {\n     *      pre_lex:  function()\n     *                 optional: is invoked before the lexer is invoked to produce another token.\n     *                 `this` refers to the Lexer object.\n     *      post_lex: function(token) { return token; }\n     *                 optional: is invoked when the lexer has produced a token `token`;\n     *                 this function can override the returned token value by returning another.\n     *                 When it does not return any (truthy) value, the lexer will return\n     *                 the original `token`.\n     *                 `this` refers to the Lexer object.\n     *\n     * WARNING: the next set of options are not meant to be changed. They echo the abilities of\n     * the lexer as per when it was compiled!\n     *\n     *      ranges: boolean\n     *                 optional: `true` ==> token location info will include a .range[] member.\n     *      flex: boolean\n     *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested\n     *                 exhaustively to find the longest match.\n     *      backtrack_lexer: boolean\n     *                 optional: `true` ==> lexer regexes are tested in order and for invoked;\n     *                 the lexer terminates the scan when a token is returned by the action code.\n     *      xregexp: boolean\n     *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the\n     *                 `XRegExp` library. When this %option has not been specified at compile time, all lexer\n     *                 rule regexes have been written as standard JavaScript RegExp expressions.\n     *  }\n     */\n     '], ['\n    /* lexer generated by jison-lex ', ' */\n\n    /*\n     * Returns a Lexer object of the following structure:\n     *\n     *  Lexer: {\n     *    yy: {}     The so-called "shared state" or rather the *source* of it;\n     *               the real "shared state" \\`yy\\` passed around to\n     *               the rule actions, etc. is a direct reference!\n     *\n     *               This "shared context" object was passed to the lexer by way of \n     *               the \\`lexer.setInput(str, yy)\\` API before you may use it.\n     *\n     *               This "shared context" object is passed to the lexer action code in \\`performAction()\\`\n     *               so userland code in the lexer actions may communicate with the outside world \n     *               and/or other lexer rules\' actions in more or less complex ways.\n     *\n     *  }\n     *\n     *  Lexer.prototype: {\n     *    EOF: 1,\n     *    ERROR: 2,\n     *\n     *    yy:        The overall "shared context" object reference.\n     *\n     *    JisonLexerError: function(msg, hash),\n     *\n     *    performAction: function lexer__performAction(yy, yyrulenumber, YY_START),\n     *\n     *               The function parameters and \\`this\\` have the following value/meaning:\n     *               - \\`this\\`    : reference to the \\`lexer\\` instance. \n     *                               \\`yy_\\` is an alias for \\`this\\` lexer instance reference used internally.\n     *\n     *               - \\`yy\\`      : a reference to the \\`yy\\` "shared state" object which was passed to the lexer\n     *                             by way of the \\`lexer.setInput(str, yy)\\` API before.\n     *\n     *                             Note:\n     *                             The extra arguments you specified in the \\`%parse-param\\` statement in your\n     *                             **parser** grammar definition file are passed to the lexer via this object\n     *                             reference as member variables.\n     *\n     *               - \\`yyrulenumber\\`   : index of the matched lexer rule (regex), used internally.\n     *\n     *               - \\`YY_START\\`: the current lexer "start condition" state.\n     *\n     *    parseError: function(str, hash, ExceptionClass),\n     *\n     *    constructLexErrorInfo: function(error_message, is_recoverable),\n     *               Helper function.\n     *               Produces a new errorInfo \\\'hash object\\\' which can be passed into \\`parseError()\\`.\n     *               See it\\\'s use in this lexer kernel in many places; example usage:\n     *\n     *                   var infoObj = lexer.constructParseErrorInfo(\\\'fail!\\\', true);\n     *                   var retVal = lexer.parseError(infoObj.errStr, infoObj, lexer.JisonLexerError);\n     *\n     *    options: { ... lexer %options ... },\n     *\n     *    lex: function(),\n     *               Produce one token of lexed input, which was passed in earlier via the \\`lexer.setInput()\\` API.\n     *               You MAY use the additional \\`args...\\` parameters as per \\`%parse-param\\` spec of the **lexer** grammar:\n     *               these extra \\`args...\\` are added verbatim to the \\`yy\\` object reference as member variables.\n     *\n     *               WARNING:\n     *               Lexer\'s additional \\`args...\\` parameters (via lexer\'s \\`%parse-param\\`) MAY conflict with\n     *               any attributes already added to \\`yy\\` by the **parser** or the jison run-time; \n     *               when such a collision is detected an exception is thrown to prevent the generated run-time \n     *               from silently accepting this confusing and potentially hazardous situation! \n     *\n     *    cleanupAfterLex: function(do_not_nuke_errorinfos),\n     *               Helper function.\n     *\n     *               This helper API is invoked when the **parse process** has completed: it is the responsibility\n     *               of the **parser** (or the calling userland code) to invoke this method once cleanup is desired. \n     *\n     *               This helper may be invoked by user code to ensure the internal lexer gets properly garbage collected.\n     *\n     *    setInput: function(input, [yy]),\n     *\n     *\n     *    input: function(),\n     *\n     *\n     *    unput: function(str),\n     *\n     *\n     *    more: function(),\n     *\n     *\n     *    reject: function(),\n     *\n     *\n     *    less: function(n),\n     *\n     *\n     *    pastInput: function(n),\n     *\n     *\n     *    upcomingInput: function(n),\n     *\n     *\n     *    showPosition: function(),\n     *\n     *\n     *    test_match: function(regex_match_array, rule_index),\n     *\n     *\n     *    next: function(),\n     *\n     *\n     *    begin: function(condition),\n     *\n     *\n     *    pushState: function(condition),\n     *\n     *\n     *    popState: function(),\n     *\n     *\n     *    topState: function(),\n     *\n     *\n     *    _currentRules: function(),\n     *\n     *\n     *    stateStackSize: function(),\n     *\n     *\n     *    performAction: function(yy, yy_, yyrulenumber, YY_START),\n     *\n     *\n     *    rules: [...],\n     *\n     *\n     *    conditions: {associative list: name ==> set},\n     *  }\n     *\n     *\n     *  token location info (\\`yylloc\\`): {\n     *    first_line: n,\n     *    last_line: n,\n     *    first_column: n,\n     *    last_column: n,\n     *    range: [start_number, end_number]\n     *               (where the numbers are indexes into the input string, zero-based)\n     *  }\n     *\n     * ---\n     *\n     * The \\`parseError\\` function receives a \\\'hash\\\' object with these members for lexer errors:\n     *\n     *  {\n     *    text:        (matched text)\n     *    token:       (the produced terminal token, if any)\n     *    token_id:    (the produced terminal token numeric ID, if any)\n     *    line:        (yylineno)\n     *    loc:         (yylloc)\n     *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule\n     *                  available for this particular error)\n     *    yy:          (object: the current parser internal "shared state" \\`yy\\`\n     *                  as is also available in the rule actions; this can be used,\n     *                  for instance, for advanced error analysis and reporting)\n     *    lexer:       (reference to the current lexer instance used by the parser)\n     *  }\n     *\n     * while \\`this\\` will reference the current lexer instance.\n     *\n     * When \\`parseError\\` is invoked by the lexer, the default implementation will\n     * attempt to invoke \\`yy.parser.parseError()\\`; when this callback is not provided\n     * it will try to invoke \\`yy.parseError()\\` instead. When that callback is also not\n     * provided, a \\`JisonLexerError\\` exception will be thrown containing the error\n     * message and \\`hash\\`, as constructed by the \\`constructLexErrorInfo()\\` API.\n     *\n     * Note that the lexer\\\'s \\`JisonLexerError\\` error class is passed via the\n     * \\`ExceptionClass\\` argument, which is invoked to construct the exception\n     * instance to be thrown, so technically \\`parseError\\` will throw the object\n     * produced by the \\`new ExceptionClass(str, hash)\\` JavaScript expression.\n     *\n     * ---\n     *\n     * You can specify lexer options by setting / modifying the \\`.options\\` object of your Lexer instance.\n     * These options are available:\n     *\n     * (Options are permanent.)\n     *  \n     *  yy: {\n     *      parseError: function(str, hash, ExceptionClass)\n     *                 optional: overrides the default \\`parseError\\` function.\n     *  }\n     *\n     *  lexer.options: {\n     *      pre_lex:  function()\n     *                 optional: is invoked before the lexer is invoked to produce another token.\n     *                 \\`this\\` refers to the Lexer object.\n     *      post_lex: function(token) { return token; }\n     *                 optional: is invoked when the lexer has produced a token \\`token\\`;\n     *                 this function can override the returned token value by returning another.\n     *                 When it does not return any (truthy) value, the lexer will return\n     *                 the original \\`token\\`.\n     *                 \\`this\\` refers to the Lexer object.\n     *\n     * WARNING: the next set of options are not meant to be changed. They echo the abilities of\n     * the lexer as per when it was compiled!\n     *\n     *      ranges: boolean\n     *                 optional: \\`true\\` ==> token location info will include a .range[] member.\n     *      flex: boolean\n     *                 optional: \\`true\\` ==> flex-like lexing behaviour where the rules are tested\n     *                 exhaustively to find the longest match.\n     *      backtrack_lexer: boolean\n     *                 optional: \\`true\\` ==> lexer regexes are tested in order and for invoked;\n     *                 the lexer terminates the scan when a token is returned by the action code.\n     *      xregexp: boolean\n     *                 optional: \\`true\\` ==> lexer rule regexes are "extended regex format" requiring the\n     *                 \\`XRegExp\\` library. When this %option has not been specified at compile time, all lexer\n     *                 rule regexes have been written as standard JavaScript RegExp expressions.\n     *  }\n     */\n     ']),
    _templateObject42 = _taggedTemplateLiteral(['\n            export {\n                lexer,\n                yylex as lex\n            };\n        '], ['\n            export {\n                lexer,\n                yylex as lex\n            };\n        ']),
    _templateObject43 = _taggedTemplateLiteral(['\n        Maybe you did not correctly separate trailing code from the grammar rule set with a \'%%\' marker on an otherwise empty line?\n    \n          Erroneous area:\n        ', '\n    '], ['\n        Maybe you did not correctly separate trailing code from the grammar rule set with a \'%%\' marker on an otherwise empty line?\n    \n          Erroneous area:\n        ', '\n    ']),
    _templateObject44 = _taggedTemplateLiteral(['\n        Maybe you did not correctly separate the parse \'header section\' (token definitions, options, lexer spec, etc.) from the grammar rule set with a \'%%\' on an otherwise empty line?\n    \n          Erroneous area:\n        ', '\n    '], ['\n        Maybe you did not correctly separate the parse \'header section\' (token definitions, options, lexer spec, etc.) from the grammar rule set with a \'%%\' on an otherwise empty line?\n    \n          Erroneous area:\n        ', '\n    ']),
    _templateObject45 = _taggedTemplateLiteral(['\n            The extra parser module code section (a.k.a. \'epilogue\') does not compile: ', '\n    \n              Erroneous area:\n            ', '\n        '], ['\n            The extra parser module code section (a.k.a. \'epilogue\') does not compile: ', '\n    \n              Erroneous area:\n            ', '\n        ']),
    _templateObject46 = _taggedTemplateLiteral(['\n            action header code block does not compile: ', '\n    \n              Erroneous area:\n            ', '\n        '], ['\n            action header code block does not compile: ', '\n    \n              Erroneous area:\n            ', '\n        ']),
    _templateObject47 = _taggedTemplateLiteral(['\n        declaration list error?\n    \n          Erroneous area:\n        ', '\n    '], ['\n        declaration list error?\n    \n          Erroneous area:\n        ', '\n    ']),
    _templateObject48 = _taggedTemplateLiteral(['\n            action code block does not compile: ', '\n    \n              Erroneous area:\n            ', '\n        '], ['\n            action code block does not compile: ', '\n    \n              Erroneous area:\n            ', '\n        ']),
    _templateObject49 = _taggedTemplateLiteral(['\n        You did not specify a legal file path for the \'%import\' initialization code statement, which must have the format:\n    \n            %import qualifier_name file_path\n    \n          Erroneous area:\n        ', '\n    '], ['\n        You did not specify a legal file path for the \'%import\' initialization code statement, which must have the format:\n    \n            %import qualifier_name file_path\n    \n          Erroneous area:\n        ', '\n    ']),
    _templateObject50 = _taggedTemplateLiteral(['\n        Each \'%import\'-ed initialization code section must be qualified by a name, e.g. \'required\' before the import path itself:\n    \n            %import qualifier_name file_path\n    \n          Erroneous area:\n        ', '\n    '], ['\n        Each \'%import\'-ed initialization code section must be qualified by a name, e.g. \'required\' before the import path itself:\n    \n            %import qualifier_name file_path\n    \n          Erroneous area:\n        ', '\n    ']),
    _templateObject51 = _taggedTemplateLiteral(['\n            %code "', '" initialization section action code block does not compile: ', '\n    \n              Erroneous area:\n            ', '\n        '], ['\n            %code "', '" initialization section action code block does not compile: ', '\n    \n              Erroneous area:\n            ', '\n        ']),
    _templateObject52 = _taggedTemplateLiteral(['\n        Each \'%code\' initialization code section must be qualified by a name, e.g. \'required\' before the action code itself:\n    \n            %code qualifier_name {action code}\n    \n          Erroneous area:\n        ', '\n    '], ['\n        Each \'%code\' initialization code section must be qualified by a name, e.g. \'required\' before the action code itself:\n    \n            %code qualifier_name {action code}\n    \n          Erroneous area:\n        ', '\n    ']),
    _templateObject53 = _taggedTemplateLiteral(['\n        %start token error?\n    \n          Erroneous area:\n        ', '\n    '], ['\n        %start token error?\n    \n          Erroneous area:\n        ', '\n    ']),
    _templateObject54 = _taggedTemplateLiteral(['\n        %token definition list error?\n    \n          Erroneous area:\n        ', '\n    '], ['\n        %token definition list error?\n    \n          Erroneous area:\n        ', '\n    ']),
    _templateObject55 = _taggedTemplateLiteral(['\n        %import name or source filename missing maybe?\n    \n          Erroneous area:\n        ', '\n    '], ['\n        %import name or source filename missing maybe?\n    \n          Erroneous area:\n        ', '\n    ']),
    _templateObject56 = _taggedTemplateLiteral(['\n        %options ill defined / error?\n    \n          Erroneous area:\n        ', '\n    '], ['\n        %options ill defined / error?\n    \n          Erroneous area:\n        ', '\n    ']),
    _templateObject57 = _taggedTemplateLiteral(['\n        %options don\'t seem terminated?\n    \n          Erroneous area:\n        ', '\n    '], ['\n        %options don\'t seem terminated?\n    \n          Erroneous area:\n        ', '\n    ']),
    _templateObject58 = _taggedTemplateLiteral(['\n        named %option value error for ', '?\n    \n          Erroneous area:\n        ', '\n    '], ['\n        named %option value error for ', '?\n    \n          Erroneous area:\n        ', '\n    ']),
    _templateObject59 = _taggedTemplateLiteral(['\n        named %option value assignment error?\n    \n          Erroneous area:\n        ', '\n    '], ['\n        named %option value assignment error?\n    \n          Erroneous area:\n        ', '\n    ']),
    _templateObject60 = _taggedTemplateLiteral(['\n        %parse-params declaration error?\n    \n          Erroneous area:\n        ', '\n    '], ['\n        %parse-params declaration error?\n    \n          Erroneous area:\n        ', '\n    ']),
    _templateObject61 = _taggedTemplateLiteral(['\n        %parser-type declaration error?\n    \n          Erroneous area:\n        ', '\n    '], ['\n        %parser-type declaration error?\n    \n          Erroneous area:\n        ', '\n    ']),
    _templateObject62 = _taggedTemplateLiteral(['\n        operator token list error in an associativity statement?\n    \n          Erroneous area:\n        ', '\n    '], ['\n        operator token list error in an associativity statement?\n    \n          Erroneous area:\n        ', '\n    ']),
    _templateObject63 = _taggedTemplateLiteral(['\n        rule production declaration error?\n    \n          Erroneous area:\n        ', '\n    '], ['\n        rule production declaration error?\n    \n          Erroneous area:\n        ', '\n    ']),
    _templateObject64 = _taggedTemplateLiteral(['\n        rule production declaration error: did you terminate the rule production set with a semicolon?\n    \n          Erroneous area:\n        ', '\n    '], ['\n        rule production declaration error: did you terminate the rule production set with a semicolon?\n    \n          Erroneous area:\n        ', '\n    ']),
    _templateObject65 = _taggedTemplateLiteral(['\n        rule id should be followed by a colon, but that one seems missing?\n    \n          Erroneous area:\n        ', '\n    '], ['\n        rule id should be followed by a colon, but that one seems missing?\n    \n          Erroneous area:\n        ', '\n    ']),
    _templateObject66 = _taggedTemplateLiteral(['\n        rule alternative production declaration error?\n    \n          Erroneous area:\n        ', '\n    '], ['\n        rule alternative production declaration error?\n    \n          Erroneous area:\n        ', '\n    ']),
    _templateObject67 = _taggedTemplateLiteral(['\n        multiple alternative rule productions should be separated by a \'|\' pipe character, not a \':\' colon!\n    \n          Erroneous area:\n        ', '\n    '], ['\n        multiple alternative rule productions should be separated by a \'|\' pipe character, not a \':\' colon!\n    \n          Erroneous area:\n        ', '\n    ']),
    _templateObject68 = _taggedTemplateLiteral(['\n                production rule action code block does not compile: ', '\n    \n                  Erroneous area:\n                ', '\n            '], ['\n                production rule action code block does not compile: ', '\n    \n                  Erroneous area:\n                ', '\n            ']),
    _templateObject69 = _taggedTemplateLiteral(['\n                You cannot specify a precedence override for an epsilon (a.k.a. empty) rule!\n    \n                  Erroneous area:\n                ', '\n            '], ['\n                You cannot specify a precedence override for an epsilon (a.k.a. empty) rule!\n    \n                  Erroneous area:\n                ', '\n            ']),
    _templateObject70 = _taggedTemplateLiteral(['\n                epsilon production rule action code block does not compile: ', '\n    \n                  Erroneous area:\n                ', '\n            '], ['\n                epsilon production rule action code block does not compile: ', '\n    \n                  Erroneous area:\n                ', '\n            ']),
    _templateObject71 = _taggedTemplateLiteral(['\n        %epsilon rule action declaration error?\n    \n          Erroneous area:\n        ', '\n    '], ['\n        %epsilon rule action declaration error?\n    \n          Erroneous area:\n        ', '\n    ']),
    _templateObject72 = _taggedTemplateLiteral(['\n        Seems you did not correctly bracket a grammar rule sublist in \'( ... )\' brackets.\n    \n          Erroneous area:\n        ', '\n    '], ['\n        Seems you did not correctly bracket a grammar rule sublist in \'( ... )\' brackets.\n    \n          Erroneous area:\n        ', '\n    ']),
    _templateObject73 = _taggedTemplateLiteral(['\n        %prec precedence override declaration error?\n    \n          Erroneous precedence declaration:\n        ', '\n    '], ['\n        %prec precedence override declaration error?\n    \n          Erroneous precedence declaration:\n        ', '\n    ']),
    _templateObject74 = _taggedTemplateLiteral(['\n        Seems you did not correctly bracket a parser rule action block in curly braces: \'{ ... }\'.\n    \n          Erroneous area:\n        ', '\n    '], ['\n        Seems you did not correctly bracket a parser rule action block in curly braces: \'{ ... }\'.\n    \n          Erroneous area:\n        ', '\n    ']),
    _templateObject75 = _taggedTemplateLiteral(['\n        Seems you did not correctly match curly braces \'{ ... }\' in a parser rule action block.\n    \n          Erroneous area:\n        ', '\n    '], ['\n        Seems you did not correctly match curly braces \'{ ... }\' in a parser rule action block.\n    \n          Erroneous area:\n        ', '\n    ']),
    _templateObject76 = _taggedTemplateLiteral(['\n            included action code file "', '" does not compile: ', '\n    \n              Erroneous area:\n            ', '\n        '], ['\n            included action code file "', '" does not compile: ', '\n    \n              Erroneous area:\n            ', '\n        ']),
    _templateObject77 = _taggedTemplateLiteral(['\n    %include MUST be followed by a valid file path.\n    \n      Erroneous path:\n    '], ['\n    %include MUST be followed by a valid file path.\n    \n      Erroneous path:\n    ']),
    _templateObject78 = _taggedTemplateLiteral(['\n        module code declaration error?\n    \n          Erroneous area:\n        '], ['\n        module code declaration error?\n    \n          Erroneous area:\n        ']),
    _templateObject79 = _taggedTemplateLiteral(['\n                                                EBNF: ignoring unsupported parser option ', '\n                                                while lexing in ', ' state.\n\n                                                  Erroneous area:\n                                                '], ['\n                                                EBNF: ignoring unsupported parser option ', '\n                                                while lexing in ', ' state.\n\n                                                  Erroneous area:\n                                                ']),
    _templateObject80 = _taggedTemplateLiteral(['\n                                                unsupported parser input: ', '\n                                                while lexing in ', ' state.\n                                                \n                                                  Erroneous area:\n                                                '], ['\n                                                unsupported parser input: ', '\n                                                while lexing in ', ' state.\n                                                \n                                                  Erroneous area:\n                                                ']),
    _templateObject81 = _taggedTemplateLiteral(['\n                // macros:\n            '], ['\n                // macros:\n            ']),
    _templateObject82 = _taggedTemplateLiteral(['\n                // END of the lexer macros.\n            '], ['\n                // END of the lexer macros.\n            ']),
    _templateObject83 = _taggedTemplateLiteral(['\n                // unknown declarations:\n            '], ['\n                // unknown declarations:\n            ']),
    _templateObject84 = _taggedTemplateLiteral(['\n                // END of unknown declarations.\n            '], ['\n                // END of unknown declarations.\n            ']),
    _templateObject85 = _taggedTemplateLiteral(['\n                // options:\n            '], ['\n                // options:\n            ']),
    _templateObject86 = _taggedTemplateLiteral(['\n                /*\n                 * Lexer stuff that\'s unknown to the JISON prettyPrint service:\n                 *\n                 * ', '\n                 */\n                \n            '], ['\n                /*\n                 * Lexer stuff that\'s unknown to the JISON prettyPrint service:\n                 *\n                 * ', '\n                 */\n                \n            ']),
    _templateObject87 = _taggedTemplateLiteral(['\n\n            %%\n\n        '], ['\n\n            %%\n\n        ']),
    _templateObject88 = _taggedTemplateLiteral(['\n\n                %%\n\n            '], ['\n\n                %%\n\n            ']),
    _templateObject89 = _taggedTemplateLiteral(['\n            // unknown declarations:\n        '], ['\n            // unknown declarations:\n        ']),
    _templateObject90 = _taggedTemplateLiteral(['\n            // END of unknown declarations.\n        '], ['\n            // END of unknown declarations.\n        ']),
    _templateObject91 = _taggedTemplateLiteral(['\n            // ============================== START lexer section =========================== \n            \n            %lex\n            \n            ', '\n\n            /lex\n\n            // ============================== END lexer section =============================\n\n        '], ['\n            // ============================== START lexer section =========================== \n            \n            %lex\n            \n            ', '\n\n            /lex\n\n            // ============================== END lexer section =============================\n\n        ']),
    _templateObject92 = _taggedTemplateLiteral(['\n            /*\n             * Parser stuff that\'s unknown to the JISON prettyPrint service:\n             *\n             * ', '\n             */\n            \n        '], ['\n            /*\n             * Parser stuff that\'s unknown to the JISON prettyPrint service:\n             *\n             * ', '\n             */\n            \n        ']),
    _templateObject93 = _taggedTemplateLiteral(['\n                    //\n                    // JISON says:\n                    //\n                    // This is a EBNF grammar. The resulting **BNF** grammar has been\n                    // reproduced here for your convenience:\n                    //\n                    // ---------------------------- START ---------------------------\n                    ', '\n                    // ---------------------------- END OF BNF grammar --------------\n                    //\n\n\n                '], ['\n                    //\n                    // JISON says:\n                    //\n                    // This is a EBNF grammar. The resulting **BNF** grammar has been\n                    // reproduced here for your convenience:\n                    //\n                    // ---------------------------- START ---------------------------\n                    ', '\n                    // ---------------------------- END OF BNF grammar --------------\n                    //\n\n\n                ']),
    _templateObject94 = _taggedTemplateLiteral(['\n            //\n            // JISON says:\n            //\n            // The JISON ', ' has been\n            // reproduced here for your convenience:\n            //\n            // ---------------------------- START ---------------------------\n            ', '\n            // ---------------------------- END -----------------------------\n            //\n\n        '], ['\n            //\n            // JISON says:\n            //\n            // The JISON ', ' has been\n            // reproduced here for your convenience:\n            //\n            // ---------------------------- START ---------------------------\n            ', '\n            // ---------------------------- END -----------------------------\n            //\n\n        ']),
    _templateObject95 = _taggedTemplateLiteral(['\n\n                    // START code section "', '"\n                    ', '\n                    // END code section "', '"\n\n                '], ['\n\n                    // START code section "', '"\n                    ', '\n                    // END code section "', '"\n\n                ']),
    _templateObject96 = _taggedTemplateLiteral(['\n\n            ', '\n\n            var yymain = ', ';\n\n            function yyExecMain() {\n              yymain(process.argv.slice(1));\n            }\n        '], ['\n\n            ', '\n\n            var yymain = ', ';\n\n            function yyExecMain() {\n              yymain(process.argv.slice(1));\n            }\n        ']),
    _templateObject97 = _taggedTemplateLiteral(['\n            // IFF this is the main module executed by NodeJS,\n            // then run \'main()\' immediately:\n            if (typeof module !== \'undefined\' && require.main === module) {\n              yyExecMain();\n            }\n        '], ['\n            // IFF this is the main module executed by NodeJS,\n            // then run \'main()\' immediately:\n            if (typeof module !== \'undefined\' && require.main === module) {\n              yyExecMain();\n            }\n        ']),
    _templateObject98 = _taggedTemplateLiteral(['\n        function Parser() {\n            this.yy = {};\n        }\n        Parser.prototype = parser;\n        parser.Parser = Parser;\n\n        function yyparse() {\n            return parser.parse.apply(parser, arguments);\n        }\n\n        ', '\n\n        export default {\n            parser,\n            Parser,\n            parse: yyparse,\n            ', '\n        };\n    '], ['\n        function Parser() {\n            this.yy = {};\n        }\n        Parser.prototype = parser;\n        parser.Parser = Parser;\n\n        function yyparse() {\n            return parser.parse.apply(parser, arguments);\n        }\n\n        ', '\n\n        export default {\n            parser,\n            Parser,\n            parse: yyparse,\n            ', '\n        };\n    ']),
    _templateObject99 = _taggedTemplateLiteral(['\n\n            ', '\n\n            exports.main = ', ';\n\n            // IFF this is the main module executed by NodeJS,\n            // then run \'main()\' immediately:\n            if (typeof module !== \'undefined\' && require.main === module) {\n              exports.main(process.argv.slice(1));\n            }\n        '], ['\n\n            ', '\n\n            exports.main = ', ';\n\n            // IFF this is the main module executed by NodeJS,\n            // then run \'main()\' immediately:\n            if (typeof module !== \'undefined\' && require.main === module) {\n              exports.main(process.argv.slice(1));\n            }\n        ']),
    _templateObject100 = _taggedTemplateLiteral(['\n\n\n        if (typeof require !== \'undefined\' && typeof exports !== \'undefined\') {\n          exports.parser = ', ';\n          exports.Parser = ', '.Parser;\n          exports.parse = function () {\n            return ', '.parse.apply(', ', arguments);\n          };\n          ', '\n        }\n        '], ['\n\n\n        if (typeof require !== \'undefined\' && typeof exports !== \'undefined\') {\n          exports.parser = ', ';\n          exports.Parser = ', '.Parser;\n          exports.parse = function () {\n            return ', '.parse.apply(', ', arguments);\n          };\n          ', '\n        }\n        ']),
    _templateObject101 = _taggedTemplateLiteral(['\n        ', '\n\n        var yy__parser = ', ';\n\n        // produce the generated parser function/class as the last value\n        // in this chunk of code so that we can be sure to produce *that*\n        // one as the \'return value\' of the `eval()` call we\'ll submit\n        // this code to.\n        //\n        // See also: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval\n\n        yy__parser;\n    '], ['\n        ', '\n\n        var yy__parser = ', ';\n\n        // produce the generated parser function/class as the last value\n        // in this chunk of code so that we can be sure to produce *that*\n        // one as the \'return value\' of the \\`eval()\\` call we\'ll submit\n        // this code to.\n        //\n        // See also: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval\n\n        yy__parser;\n    ']);

function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _interopDefault(ex) {
    return ex && (typeof ex === 'undefined' ? 'undefined' : _typeof(ex)) === 'object' && 'default' in ex ? ex['default'] : ex;
}

var assert = _interopDefault(require('assert'));
var XRegExp = _interopDefault(require('@gerhobbelt/xregexp'));
var json5 = _interopDefault(require('@gerhobbelt/json5'));
var fs = _interopDefault(require('fs'));
var path = _interopDefault(require('path'));
var recast = _interopDefault(require('@gerhobbelt/recast'));
var astUtils = _interopDefault(require('@gerhobbelt/ast-util'));

/*
 * Introduces a typal object to make classical/prototypal patterns easier
 * Plus some AOP sugar
 *
 * By Zachary Carter <zach@carter.name>
 * MIT Licensed
 */

var create = Object.create || function (o) {
    function F() {}
    F.prototype = o;
    return new F();
};
var position = /^(before|after)/;

// basic method layering
// always returns original method's return value
function layerMethod(pos, key, prop, fun) {
    if (pos === 'after') {
        return function () {
            var ret = prop.apply(this, arguments);
            var args = [].slice.call(arguments);
            args.splice(0, 0, ret);
            fun.apply(this, args);
            return ret;
        };
    } else if (pos === 'before') {
        return function () {
            fun.apply(this, arguments);
            var ret = prop.apply(this, arguments);
            return ret;
        };
    }
    return fun;
}

// mixes each argument's own properties into calling object,
// overwriting them or layering them. i.e. an object method 'meth' is
// layered by mixin methods 'beforemeth' or 'aftermeth'
function typal_mix() {
    var i, o, k;
    for (i = 0; i < arguments.length; i++) {
        o = arguments[i];
        if (!o) continue;
        if (Object.prototype.hasOwnProperty.call(o, 'constructor')) {
            this.constructor = o.constructor;
        }
        if (Object.prototype.hasOwnProperty.call(o, 'toString')) {
            this.toString = o.toString;
        }
        for (k in o) {
            if (Object.prototype.hasOwnProperty.call(o, k)) {
                var match = k.match(position);
                var key = k.replace(position, '');
                if (match && typeof this[key] === 'function') {
                    this[key] = layerMethod(match[0], key, this[key], o[k]);
                } else {
                    this[k] = o[k];
                }
            }
        }
    }
    return this;
}

// Same as typal_mix but also camelCases every object member and 'standardizes' the key set of every input
// argument through a caLLback function.
// 
// This is useful for processing options with dashes in their key, e.g. `token-stack` --> tokenStack.
function typal_camel_mix(cb) {
    var i, o, k;

    // Convert dashed option keys to Camel Case, e.g. `camelCase('camels-have-one-hump')` => `'camelsHaveOneHump'` 
    function camelCase(s) {
        return s.replace(/-\w/g, function (match) {
            return match.charAt(1).toUpperCase();
        });
    }

    // Convert first character to lowercase
    function lcase0(s) {
        return s.replace(/^\w/, function (match) {
            return match.toLowerCase();
        });
    }

    for (i = 1; i < arguments.length; i++) {
        o = arguments[i];
        if (!o) continue;
        if (Object.prototype.hasOwnProperty.call(o, 'constructor')) {
            this.constructor = o.constructor;
        }
        if (Object.prototype.hasOwnProperty.call(o, 'toString')) {
            this.toString = o.toString;
        }
        if (cb) {
            o = cb(o);
        }
        for (k in o) {
            if (Object.prototype.hasOwnProperty.call(o, k)) {
                var nk = camelCase(k);
                var match = k.match(position);
                var key = k.replace(position, '');
                // This anticipates before/after members to be camelcased already, e.g.
                // 'afterParse()' for layering 'parse()': 
                var alt_key = lcase0(key);
                if (match && typeof this[key] === 'function') {
                    this[key] = layerMethod(match[0], key, this[key], o[k]);
                } else if (match && typeof this[alt_key] === 'function') {
                    this[alt_key] = layerMethod(match[0], alt_key, this[alt_key], o[k]);
                } else {
                    this[nk] = o[k];
                }
            }
        }
    }
    return this;
}

var typal = {
    // extend object with own properties of each argument
    mix: typal_mix,

    camelMix: typal_camel_mix,

    // sugar for object begetting and mixing
    // - Object.create(typal).mix(etc, etc);
    // + typal.beget(etc, etc);
    beget: function typal_beget() {
        return arguments.length ? typal_mix.apply(create(this), arguments) : create(this);
    },

    // Creates a new Class function based on an object with a constructor method
    construct: function typal_construct() {
        var o = typal_mix.apply(create(this), arguments);
        var constructor = o.constructor;
        var Klass = o.constructor = function () {
            return constructor.apply(this, arguments);
        };
        Klass.prototype = o;
        Klass.mix = typal_mix; // allow for easy singleton property extension
        return Klass;
    },

    // no op
    constructor: function typal_constructor() {
        return this;
    }
};

// Set class to wrap arrays

var setMixin = {
    constructor: function Set_constructor(set, raw) {
        this._items = [];
        if (set && set.constructor === Array) {
            this._items = raw ? set : set.slice(0);
        } else if (arguments.length) {
            this._items = [].slice.call(arguments, 0);
        }
    },
    concat: function concat(setB) {
        this._items.push.apply(this._items, setB._items || setB);
        return this;
    },
    eq: function eq(set) {
        return this._items.length === set._items.length && this.subset(set) && this.superset(set);
    },
    indexOf: function indexOf(item) {
        if (item && item.eq) {
            for (var k = 0; k < this._items.length; k++) {
                if (item.eq(this._items[k])) {
                    return k;
                }
            }
            return -1;
        }
        return this._items.indexOf(item);
    },
    intersection: function intersection(set) {
        return this.filter(function intersection_filter(elm) {
            return set.contains(elm);
        });
    },
    complement: function complement(set) {
        var that = this;
        return set.filter(function sub_complement(elm) {
            return !that.contains(elm);
        });
    },
    subset: function subset(set) {
        var cont = true;
        for (var i = 0; i < this._items.length && cont; i++) {
            cont = cont && set.contains(this._items[i]);
        }
        return cont;
    },
    superset: function superset(set) {
        return set.subset(this);
    },
    joinSet: function joinSet(set) {
        return this.concat(this.complement(set));
    },
    contains: function contains(item) {
        return this.indexOf(item) !== -1;
    },
    item: function item(v) {
        return this._items[v];
    },
    i: function i(v) {
        return this._items[v];
    },
    assign: function assign(index, value) {
        this._items[index] = value;
        return this;
    },
    first: function first() {
        return this._items[0];
    },
    last: function last() {
        return this._items[this._items.length - 1];
    },
    size: function size() {
        return this._items.length;
    },
    isEmpty: function isEmpty() {
        return this._items.length === 0;
    },
    copy: function copy() {
        return new Set(this._items);
    },
    toString: function toString() {
        return this._items.toString();
    }
};

'push shift unshift forEach some every join sort'.split(' ').forEach(function (e, i) {
    setMixin[e] = function () {
        return Array.prototype[e].apply(this._items, arguments);
    };
    //setMixin[e].name = e;
});
'filter slice map'.split(' ').forEach(function (e, i) {
    setMixin[e] = function () {
        return new Set(Array.prototype[e].apply(this._items, arguments), true);
    };
    //setMixin[e].name = e;
});

var Set = typal.construct(setMixin);

// Return TRUE if `src` starts with `searchString`. 
function startsWith(src, searchString) {
    return src.substr(0, searchString.length) === searchString;
}

// tagged template string helper which removes the indentation common to all
// non-empty lines: that indentation was added as part of the source code
// formatting of this lexer spec file and must be removed to produce what
// we were aiming for.
//
// Each template string starts with an optional empty line, which should be
// removed entirely, followed by a first line of error reporting content text,
// which should not be indented at all, i.e. the indentation of the first
// non-empty line should be treated as the 'common' indentation and thus
// should also be removed from all subsequent lines in the same template string.
//
// See also: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals
function rmCommonWS$3(strings) {
    // As `strings[]` is an array of strings, each potentially consisting
    // of multiple lines, followed by one(1) value, we have to split each
    // individual string into lines to keep that bit of information intact.
    // 
    // We assume clean code style, hence no random mix of tabs and spaces, so every
    // line MUST have the same indent style as all others, so `length` of indent
    // should suffice, but the way we coded this is stricter checking as we look
    // for the *exact* indenting=leading whitespace in each line.
    var indent_str = null;
    var src = strings.map(function splitIntoLines(s) {
        var a = s.split('\n');

        indent_str = a.reduce(function analyzeLine(indent_str, line, index) {
            // only check indentation of parts which follow a NEWLINE:
            if (index !== 0) {
                var m = /^(\s*)\S/.exec(line);
                // only non-empty ~ content-carrying lines matter re common indent calculus:
                if (m) {
                    if (!indent_str) {
                        indent_str = m[1];
                    } else if (m[1].length < indent_str.length) {
                        indent_str = m[1];
                    }
                }
            }
            return indent_str;
        }, indent_str);

        return a;
    });

    // Also note: due to the way we format the template strings in our sourcecode,
    // the last line in the entire template must be empty when it has ANY trailing
    // whitespace:
    var a = src[src.length - 1];
    a[a.length - 1] = a[a.length - 1].replace(/\s+$/, '');

    // Done removing common indentation.
    // 
    // Process template string partials now, but only when there's
    // some actual UNindenting to do:
    if (indent_str) {
        for (var i = 0, len = src.length; i < len; i++) {
            var a = src[i];
            // only correct indentation at start of line, i.e. only check for
            // the indent after every NEWLINE ==> start at j=1 rather than j=0
            for (var j = 1, linecnt = a.length; j < linecnt; j++) {
                if (startsWith(a[j], indent_str)) {
                    a[j] = a[j].substr(indent_str.length);
                }
            }
        }
    }

    // now merge everything to construct the template result:
    var rv = [];

    for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        values[_key - 1] = arguments[_key];
    }

    for (var i = 0, len = values.length; i < len; i++) {
        rv.push(src[i].join('\n'));
        rv.push(values[i]);
    }
    // the last value is always followed by a last template string partial:
    rv.push(src[i].join('\n'));

    var sv = rv.join('');
    return sv;
}

// Convert dashed option keys to Camel Case, e.g. `camelCase('camels-have-one-hump')` => `'camelsHaveOneHump'`
/** @public */
function camelCase$2(s) {
    // Convert first character to lowercase
    return s.replace(/^\w/, function (match) {
        return match.toLowerCase();
    }).replace(/-\w/g, function (match) {
        return match.charAt(1).toUpperCase();
    });
}

// properly quote and escape the given input string
function dquote$1(s) {
    var sq = s.indexOf('\'') >= 0;
    var dq = s.indexOf('"') >= 0;
    if (sq && dq) {
        s = s.replace(/"/g, '\\"');
        dq = false;
    }
    if (dq) {
        s = '\'' + s + '\'';
    } else {
        s = '"' + s + '"';
    }
    return s;
}

//
// Helper library for safe code execution/compilation, including dumping offending code to file for further error analysis
// (the idea was originally coded in https://github.com/GerHobbelt/jison/commit/85e367d03b977780516d2b643afbe6f65ee758f2 )
//
// MIT Licensed
//
//
// This code is intended to help test and diagnose arbitrary chunks of code, answering questions like this:
//
// the given code fails, but where exactly and why? It's precise failure conditions are 'hidden' due to 
// the stuff running inside an `eval()` or `Function(...)` call, so we want the code dumped to file so that
// we can test the code in a different environment so that we can see what precisely is causing the failure.
// 


// Helper function: pad number with leading zeroes
function pad(n, p) {
    p = p || 2;
    var rv = '0000' + n;
    return rv.slice(-p);
}

// attempt to dump in one of several locations: first winner is *it*!
function dumpSourceToFile(sourcecode, errname, err_id, options, ex) {
    var dumpfile;

    try {
        var dumpPaths = [options.outfile ? path.dirname(options.outfile) : null, options.inputPath, process.cwd()];
        var dumpName = path.basename(options.inputFilename || options.moduleName || (options.outfile ? path.dirname(options.outfile) : null) || options.defaultModuleName || errname).replace(/\.[a-z]{1,5}$/i, '') // remove extension .y, .yacc, .jison, ...whatever
        .replace(/[^a-z0-9_]/ig, '_'); // make sure it's legal in the destination filesystem: the least common denominator.
        if (dumpName === '' || dumpName === '_') {
            dumpName = '__bugger__';
        }
        err_id = err_id || 'XXX';

        var ts = new Date();
        var tm = ts.getUTCFullYear() + '_' + pad(ts.getUTCMonth() + 1) + '_' + pad(ts.getUTCDate()) + 'T' + pad(ts.getUTCHours()) + '' + pad(ts.getUTCMinutes()) + '' + pad(ts.getUTCSeconds()) + '.' + pad(ts.getUTCMilliseconds(), 3) + 'Z';

        dumpName += '.fatal_' + err_id + '_dump_' + tm + '.js';

        for (var i = 0, l = dumpPaths.length; i < l; i++) {
            if (!dumpPaths[i]) {
                continue;
            }

            try {
                dumpfile = path.normalize(dumpPaths[i] + '/' + dumpName);
                fs.writeFileSync(dumpfile, sourcecode, 'utf8');
                console.error("****** offending generated " + errname + " source code dumped into file: ", dumpfile);
                break; // abort loop once a dump action was successful!
            } catch (ex3) {
                //console.error("generated " + errname + " source code fatal DUMPING error ATTEMPT: ", i, " = ", ex3.message, " -- while attempting to dump into file: ", dumpfile, "\n", ex3.stack);
                if (i === l - 1) {
                    throw ex3;
                }
            }
        }
    } catch (ex2) {
        console.error("generated " + errname + " source code fatal DUMPING error: ", ex2.message, " -- while attempting to dump into file: ", dumpfile, "\n", ex2.stack);
    }

    // augment the exception info, when available:
    if (ex) {
        ex.offending_source_code = sourcecode;
        ex.offending_source_title = errname;
        ex.offending_source_dumpfile = dumpfile;
    }
}

//
// `code_execution_rig` is a function which gets executed, while it is fed the `sourcecode` as a parameter.
// When the `code_execution_rig` crashes, its failure is caught and (using the `options`) the sourcecode
// is dumped to file for later diagnosis.
//
// Two options drive the internal behaviour:
//
// - options.dumpSourceCodeOnFailure        -- default: FALSE
// - options.throwErrorOnCompileFailure     -- default: FALSE
//
// Dumpfile naming and path are determined through these options:
//
// - options.outfile
// - options.inputPath
// - options.inputFilename
// - options.moduleName
// - options.defaultModuleName
//
function exec_and_diagnose_this_stuff(sourcecode, code_execution_rig, options, title) {
    options = options || {};
    var errname = "" + (title || "exec_test");
    var err_id = errname.replace(/[^a-z0-9_]/ig, "_");
    if (err_id.length === 0) {
        err_id = "exec_crash";
    }
    var debug = 0;

    if (debug) console.warn('generated ' + errname + ' code under EXEC TEST.');
    if (debug > 1) console.warn('\n        ######################## source code ##########################\n        ' + sourcecode + '\n        ######################## source code ##########################\n        ');

    var p;
    try {
        // p = eval(sourcecode);
        if (typeof code_execution_rig !== 'function') {
            throw new Error("safe-code-exec-and-diag: code_execution_rig MUST be a JavaScript function");
        }
        p = code_execution_rig.call(this, sourcecode, options, errname, debug);
    } catch (ex) {
        if (debug > 1) console.log("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");

        if (debug) console.log("generated " + errname + " source code fatal error: ", ex.message);

        if (debug > 1) console.log("exec-and-diagnose options:", options);

        if (debug > 1) console.log("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");

        if (options.dumpSourceCodeOnFailure) {
            dumpSourceToFile(sourcecode, errname, err_id, options, ex);
        }

        if (options.throwErrorOnCompileFailure) {
            throw ex;
        }
    }
    return p;
}

var code_exec$2 = {
    exec: exec_and_diagnose_this_stuff,
    dump: dumpSourceToFile
};

//
// Parse a given chunk of code to an AST.
//
// MIT Licensed
//
//
// This code is intended to help test and diagnose arbitrary chunks of code, answering questions like this:
//
// would the given code compile and possibly execute correctly, when included in a lexer, parser or other engine?
// 


//import astUtils from '@gerhobbelt/ast-util';
assert(recast);
var types = recast.types;
assert(types);
var namedTypes = types.namedTypes;
assert(namedTypes);
var b = types.builders;
assert(b);
// //assert(astUtils);


function parseCodeChunkToAST(src, options) {
    // src = src
    // .replace(/@/g, '\uFFDA')
    // .replace(/#/g, '\uFFDB')
    // ;
    var ast = recast.parse(src);
    return ast;
}

function prettyPrintAST(ast, options) {
    var new_src;
    var s = recast.prettyPrint(ast, {
        tabWidth: 2,
        quote: 'single',
        arrowParensAlways: true,

        // Do not reuse whitespace (or anything else, for that matter)
        // when printing generically.
        reuseWhitespace: false
    });
    new_src = s.code;

    new_src = new_src.replace(/\r\n|\n|\r/g, '\n') // platform dependent EOL fixup
    // // backpatch possible jison variables extant in the prettified code:
    // .replace(/\uFFDA/g, '@')
    // .replace(/\uFFDB/g, '#')
    ;

    return new_src;
}

// validate the given JavaScript snippet: does it compile?
// 
// Return either the parsed AST (object) or an error message (string). 
function checkActionBlock$1(src, yylloc) {
    // make sure reasonable line numbers, etc. are reported in any
    // potential parse errors by pushing the source code down:
    if (yylloc && yylloc.first_line > 0) {
        var cnt = yylloc.first_line;
        var lines = new Array(cnt);
        src = lines.join('\n') + src;
    }
    if (!src.trim()) {
        return false;
    }

    try {
        var rv = parseCodeChunkToAST(src);
        return false;
    } catch (ex) {
        return ex.message || "code snippet cannot be parsed";
    }
}

var parse2AST = {
    parseCodeChunkToAST: parseCodeChunkToAST,
    prettyPrintAST: prettyPrintAST,
    checkActionBlock: checkActionBlock$1
};

/// HELPER FUNCTION: print the function in source code form, properly indented.
/** @public */
function printFunctionSourceCode(f) {
    return String(f);
}

/// HELPER FUNCTION: print the function **content** in source code form, properly indented.
/** @public */
function printFunctionSourceCodeContainer(f) {
    return String(f).replace(/^[\s\r\n]*function\b[^\{]+\{/, '').replace(/\}[\s\r\n]*$/, '');
}

var stringifier = {
    printFunctionSourceCode: printFunctionSourceCode,
    printFunctionSourceCodeContainer: printFunctionSourceCodeContainer
};

var helpers = {
    rmCommonWS: rmCommonWS$3,
    camelCase: camelCase$2,
    dquote: dquote$1,

    exec: code_exec$2.exec,
    dump: code_exec$2.dump,

    parseCodeChunkToAST: parse2AST.parseCodeChunkToAST,
    prettyPrintAST: parse2AST.prettyPrintAST,
    checkActionBlock: parse2AST.checkActionBlock,

    printFunctionSourceCode: stringifier.printFunctionSourceCode,
    printFunctionSourceCodeContainer: stringifier.printFunctionSourceCodeContainer
};

// hack:
var assert$1;

/* parser generated by jison 0.6.1-210 */

/*
 * Returns a Parser object of the following structure:
 *
 *  Parser: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a derivative/copy of this one,
 *               not a direct reference!
 *  }
 *
 *  Parser.prototype: {
 *    yy: {},
 *    EOF: 1,
 *    TERROR: 2,
 *
 *    trace: function(errorMessage, ...),
 *
 *    JisonParserError: function(msg, hash),
 *
 *    quoteName: function(name),
 *               Helper function which can be overridden by user code later on: put suitable
 *               quotes around literal IDs in a description string.
 *
 *    originalQuoteName: function(name),
 *               The basic quoteName handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function
 *               at the end of the `parse()`.
 *
 *    describeSymbol: function(symbol),
 *               Return a more-or-less human-readable description of the given symbol, when
 *               available, or the symbol itself, serving as its own 'description' for lack
 *               of something better to serve up.
 *
 *               Return NULL when the symbol is unknown to the parser.
 *
 *    symbols_: {associative list: name ==> number},
 *    terminals_: {associative list: number ==> name},
 *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},
 *    terminal_descriptions_: (if there are any) {associative list: number ==> description},
 *    productions_: [...],
 *
 *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)
 *                             to store/reference the rule value `$$` and location info `@$`.
 *
 *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets
 *                 to see the same object via the `this` reference, i.e. if you wish to carry custom
 *                 data from one reduce action through to the next within a single parse run, then you
 *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.
 *
 *                 `this.yy` is a direct reference to the `yy` shared state object.
 *
 *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`
 *                 object at `parse()` start and are therefore available to the action code via the
 *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from
 *                 the %parse-param` list.
 *
 *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used
 *                             to match this rule. This is *not* the look-ahead token, but the last token
 *                             that's actually part of this rule.
 *
 *                 Formulated another way, `yytext` is the value of the token immediately preceeding
 *                 the current look-ahead token.
 *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.
 *
 *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.
 *
 *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.
 *
 *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.
 *
 *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead
 *                               of an empty object when no suitable location info can be provided.
 *
 *               - `yystate` : the current parser state number, used internally for dispatching and
 *                               executing the action code chunk matching the rule currently being reduced.
 *
 *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *                 Also note that you can access this and other stack index values using the new double-hash
 *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things
 *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.
 *                 This is made available to write very advanced grammar action rules, e.g. when you want
 *                 to investigate the parse state stack in your action code, which would, for example,
 *                 be relevant when you wish to implement error diagnostics and reporting schemes similar
 *                 to the work described here:
 *
 *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.
 *                   In Journes Francophones des Languages Applicatifs.
 *
 *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.
 *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631640.
 *
 *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.
 *                             constructs.
 *
 *               - `yylstack`: reference to the parser token location stack. Also accessed via
 *                             the `@1` etc. constructs.
 *
 *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are
 *                             UNDEFINED rather than an empty (location) object, when the lexer/parser
 *                             action code did not provide a suitable location info object when such a
 *                             slot was filled!
 *
 *               - `yystack` : reference to the parser token id stack. Also accessed via the
 *                             `#1` etc. constructs.
 *
 *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to
 *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might
 *                 want access this array for your own purposes, such as error analysis as mentioned above!
 *
 *                 Note that this stack stores the current stack of *tokens*, that is the sequence of
 *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*
 *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and
 *                 *reduced*.
 *
 *               - `yysstack`: reference to the parser state stack. This one carries the internal parser
 *                             *states* such as the one in `yystate`, which are used to represent
 *                             the parser state machine in the *parse table*. *Very* *internal* stuff,
 *                             what can I say? If you access this one, you're clearly doing wicked things
 *
 *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your
 *                             grammar definition file.
 *
 *    table: [...],
 *               State transition table
 *               ----------------------
 *
 *               index levels are:
 *               - `state`  --> hash table
 *               - `symbol` --> action (number or array)
 *
 *                 If the `action` is an array, these are the elements' meaning:
 *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept
 *                 - index [1]: GOTO `state`
 *
 *                 If the `action` is a number, it is the GOTO `state`
 *
 *    defaultActions: {...},
 *
 *    parseError: function(str, hash, ExceptionClass),
 *    yyError: function(str, ...),
 *    yyRecovering: function(),
 *    yyErrOk: function(),
 *    yyClearIn: function(),
 *
 *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this parser kernel in many places; example usage:
 *
 *                   var infoObj = parser.constructParseErrorInfo('fail!', null,
 *                                     parser.collect_expected_token_set(state), true);
 *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);
 *
 *    originalParseError: function(str, hash, ExceptionClass),
 *               The basic `parseError` handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function
 *               at the end of the `parse()`.
 *
 *    options: { ... parser %options ... },
 *
 *    parse: function(input[, args...]),
 *               Parse the given `input` and return the parsed value (or `true` when none was provided by
 *               the root action, in which case the parser is acting as a *matcher*).
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the jison run-time;
 *               when such a collision is detected an exception is thrown to prevent the generated run-time
 *               from silently accepting this confusing and potentially hazardous situation!
 *
 *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in
 *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state
 *               object and any collision with those will be reported by the lexer via a thrown exception.
 *
 *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown
 *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY
 *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and
 *               the internal parser gets properly garbage collected under these particular circumstances.
 *
 *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API can be invoked to calculate a spanning `yylloc` location info object.
 *
 *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case
 *               this function will attempt to obtain a suitable location marker by inspecting the location stack
 *               backwards.
 *
 *               For more info see the documentation comment further below, immediately above this function's
 *               implementation.
 *
 *    lexer: {
 *        yy: {...},           A reference to the so-called "shared state" `yy` once
 *                             received via a call to the `.setInput(input, yy)` lexer API.
 *        EOF: 1,
 *        ERROR: 2,
 *        JisonLexerError: function(msg, hash),
 *        parseError: function(str, hash, ExceptionClass),
 *        setInput: function(input, [yy]),
 *        input: function(),
 *        unput: function(str),
 *        more: function(),
 *        reject: function(),
 *        less: function(n),
 *        pastInput: function(n),
 *        upcomingInput: function(n),
 *        showPosition: function(),
 *        test_match: function(regex_match_array, rule_index, ...),
 *        next: function(...),
 *        lex: function(...),
 *        begin: function(condition),
 *        pushState: function(condition),
 *        popState: function(),
 *        topState: function(),
 *        _currentRules: function(),
 *        stateStackSize: function(),
 *        cleanupAfterLex: function()
 *
 *        options: { ... lexer %options ... },
 *
 *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),
 *        rules: [...],
 *        conditions: {associative list: name ==> set},
 *    }
 *  }
 *
 *
 *  token location info (@$, _$, etc.): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer and
 * parser errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *  }
 *
 * parser (grammar) errors will also provide these additional members:
 *
 *  {
 *    expected:    (array describing the set of expected tokens;
 *                  may be UNDEFINED when we cannot easily produce such a set)
 *    state:       (integer (or array when the table includes grammar collisions);
 *                  represents the current internal state of the parser kernel.
 *                  can, for example, be used to pass to the `collect_expected_token_set()`
 *                  API to obtain the expected token set)
 *    action:      (integer; represents the current internal action which will be executed)
 *    new_state:   (integer; represents the next/planned internal state, once the current
 *                  action has executed)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *    parser:      (reference to the current parser instance)
 *  }
 *
 * while `this` will reference the current parser instance.
 *
 * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    lexer:       (reference to the current lexer instance which reported the error)
 *  }
 *
 * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired
 * from either the parser or lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    exception:   (reference to the exception thrown)
 *  }
 *
 * Please do note that in the latter situation, the `expected` field will be omitted as
 * this type of failure is assumed not to be due to *parse errors* but rather due to user
 * action code in either parser or lexer failing unexpectedly.
 *
 * ---
 *
 * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.
 * These options are available:
 *
 * ### options which are global for all parser instances
 *
 *  Parser.pre_parse: function(yy)
 *                 optional: you can specify a pre_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`.
 *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: you can specify a post_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`. When it does not return any value,
 *                 the parser will return the original `retval`.
 *
 * ### options which can be set up per parser instance
 *
 *  yy: {
 *      pre_parse:  function(yy)
 *                 optional: is invoked before the parse cycle starts (and before the first
 *                 invocation of `lex()`) but immediately after the invocation of
 *                 `parser.pre_parse()`).
 *      post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: is invoked when the parse terminates due to success ('accept')
 *                 or failure (even when exceptions are thrown).
 *                 `retval` contains the return value to be produced by `Parser.parse()`;
 *                 this function can override the return value by returning another.
 *                 When it does not return any value, the parser will return the original
 *                 `retval`.
 *                 This function is invoked immediately before `parser.post_parse()`.
 *
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *      quoteName: function(name),
 *                 optional: overrides the default `quoteName` function.
 *  }
 *
 *  parser.lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */

// See also:
// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
// with userland code which might access the derived class in a 'classic' way.
function JisonParserError(msg, hash) {
    Object.defineProperty(this, 'name', {
        enumerable: false,
        writable: false,
        value: 'JisonParserError'
    });

    if (msg == null) msg = '???';

    Object.defineProperty(this, 'message', {
        enumerable: false,
        writable: true,
        value: msg
    });

    this.hash = hash;

    var stacktrace;
    if (hash && hash.exception instanceof Error) {
        var ex2 = hash.exception;
        this.message = ex2.message || msg;
        stacktrace = ex2.stack;
    }
    if (!stacktrace) {
        if (Error.hasOwnProperty('captureStackTrace')) {
            // V8/Chrome engine
            Error.captureStackTrace(this, this.constructor);
        } else {
            stacktrace = new Error(msg).stack;
        }
    }
    if (stacktrace) {
        Object.defineProperty(this, 'stack', {
            enumerable: false,
            writable: false,
            value: stacktrace
        });
    }
}

if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);
} else {
    JisonParserError.prototype = Object.create(Error.prototype);
}
JisonParserError.prototype.constructor = JisonParserError;
JisonParserError.prototype.name = 'JisonParserError';

// helper: reconstruct the productions[] table
function bp(s) {
    var rv = [];
    var p = s.pop;
    var r = s.rule;
    for (var i = 0, l = p.length; i < l; i++) {
        rv.push([p[i], r[i]]);
    }
    return rv;
}

// helper: reconstruct the defaultActions[] table
function bda(s) {
    var rv = {};
    var d = s.idx;
    var g = s.goto;
    for (var i = 0, l = d.length; i < l; i++) {
        var j = d[i];
        rv[j] = g[i];
    }
    return rv;
}

// helper: reconstruct the 'goto' table
function bt(s) {
    var rv = [];
    var d = s.len;
    var y = s.symbol;
    var t = s.type;
    var a = s.state;
    var m = s.mode;
    var g = s.goto;
    for (var i = 0, l = d.length; i < l; i++) {
        var n = d[i];
        var q = {};
        for (var j = 0; j < n; j++) {
            var z = y.shift();
            switch (t.shift()) {
                case 2:
                    q[z] = [m.shift(), g.shift()];
                    break;

                case 0:
                    q[z] = a.shift();
                    break;

                default:
                    // type === 1: accept
                    q[z] = [3];
            }
        }
        rv.push(q);
    }
    return rv;
}

// helper: runlength encoding with increment step: code, length: step (default step = 0)
// `this` references an array
function s(c, l, a) {
    a = a || 0;
    for (var i = 0; i < l; i++) {
        this.push(c);
        c += a;
    }
}

// helper: duplicate sequence from *relative* offset and length.
// `this` references an array
function c(i, l) {
    i = this.length - i;
    for (l += i; i < l; i++) {
        this.push(this[i]);
    }
}

// helper: unpack an array using helpers and data, all passed in an array argument 'a'.
function u(a) {
    var rv = [];
    for (var i = 0, l = a.length; i < l; i++) {
        var e = a[i];
        // Is this entry a helper function?
        if (typeof e === 'function') {
            i++;
            e.apply(rv, a[i]);
        } else {
            rv.push(e);
        }
    }
    return rv;
}

var parser$1 = {
    // Code Generator Information Report
    // ---------------------------------
    //
    // Options:
    //
    //   default action mode: ............. classic,merge
    //   try..catch: ...................... true
    //   default resolve on conflict: ..... true
    //   on-demand look-ahead: ............ false
    //   error recovery token skip maximum: 3
    //   yyerror in parse actions is: ..... NOT recoverable,
    //   yyerror in lexer actions and other non-fatal lexer are:
    //   .................................. NOT recoverable,
    //   debug grammar/output: ............ false
    //   has partial LR conflict upgrade:   true
    //   rudimentary token-stack support:   false
    //   parser table compression mode: ... 2
    //   export debug tables: ............. false
    //   export *all* tables: ............. false
    //   module type: ..................... es
    //   parser engine type: .............. lalr
    //   output main() in the module: ..... true
    //   has user-specified main(): ....... false
    //   has user-specified require()/import modules for main():
    //   .................................. false
    //   number of expected conflicts: .... 0
    //
    //
    // Parser Analysis flags:
    //
    //   no significant actions (parser is a language matcher only):
    //   .................................. false
    //   uses yyleng: ..................... false
    //   uses yylineno: ................... false
    //   uses yytext: ..................... false
    //   uses yylloc: ..................... false
    //   uses ParseError API: ............. false
    //   uses YYERROR: .................... true
    //   uses YYRECOVERING: ............... false
    //   uses YYERROK: .................... false
    //   uses YYCLEARIN: .................. false
    //   tracks rule values: .............. true
    //   assigns rule values: ............. true
    //   uses location tracking: .......... true
    //   assigns location: ................ true
    //   uses yystack: .................... false
    //   uses yysstack: ................... false
    //   uses yysp: ....................... true
    //   uses yyrulelength: ............... false
    //   uses yyMergeLocationInfo API: .... true
    //   has error recovery: .............. true
    //   has error reporting: ............. true
    //
    // --------- END OF REPORT -----------

    trace: function no_op_trace() {},
    JisonParserError: JisonParserError,
    yy: {},
    options: {
        type: "lalr",
        hasPartialLrUpgradeOnConflict: true,
        errorRecoveryTokenDiscardCount: 3
    },
    symbols_: {
        "$": 17,
        "$accept": 0,
        "$end": 1,
        "%%": 19,
        "(": 10,
        ")": 11,
        "*": 7,
        "+": 12,
        ",": 8,
        ".": 15,
        "/": 14,
        "/!": 39,
        "<": 5,
        "=": 18,
        ">": 6,
        "?": 13,
        "ACTION": 32,
        "ACTION_BODY": 33,
        "ACTION_BODY_CPP_COMMENT": 35,
        "ACTION_BODY_C_COMMENT": 34,
        "ACTION_BODY_WHITESPACE": 36,
        "ACTION_END": 31,
        "ACTION_START": 28,
        "BRACKET_MISSING": 29,
        "BRACKET_SURPLUS": 30,
        "CHARACTER_LIT": 46,
        "CODE": 53,
        "EOF": 1,
        "ESCAPE_CHAR": 44,
        "IMPORT": 24,
        "INCLUDE": 51,
        "INCLUDE_PLACEMENT_ERROR": 37,
        "INIT_CODE": 25,
        "NAME": 20,
        "NAME_BRACE": 40,
        "OPTIONS": 47,
        "OPTIONS_END": 48,
        "OPTION_STRING_VALUE": 49,
        "OPTION_VALUE": 50,
        "PATH": 52,
        "RANGE_REGEX": 45,
        "REGEX_SET": 43,
        "REGEX_SET_END": 42,
        "REGEX_SET_START": 41,
        "SPECIAL_GROUP": 38,
        "START_COND": 27,
        "START_EXC": 22,
        "START_INC": 21,
        "STRING_LIT": 26,
        "UNKNOWN_DECL": 23,
        "^": 16,
        "action": 68,
        "action_body": 69,
        "any_group_regex": 78,
        "definition": 58,
        "definitions": 57,
        "error": 2,
        "escape_char": 81,
        "extra_lexer_module_code": 87,
        "import_name": 60,
        "import_path": 61,
        "include_macro_code": 88,
        "init": 56,
        "init_code_name": 59,
        "lex": 54,
        "module_code_chunk": 89,
        "name_expansion": 77,
        "name_list": 71,
        "names_exclusive": 63,
        "names_inclusive": 62,
        "nonempty_regex_list": 74,
        "option": 86,
        "option_list": 85,
        "optional_module_code_chunk": 90,
        "options": 84,
        "range_regex": 82,
        "regex": 72,
        "regex_base": 76,
        "regex_concat": 75,
        "regex_list": 73,
        "regex_set": 79,
        "regex_set_atom": 80,
        "rule": 67,
        "rule_block": 66,
        "rules": 64,
        "rules_and_epilogue": 55,
        "rules_collective": 65,
        "start_conditions": 70,
        "string": 83,
        "{": 3,
        "|": 9,
        "}": 4
    },
    terminals_: {
        1: "EOF",
        2: "error",
        3: "{",
        4: "}",
        5: "<",
        6: ">",
        7: "*",
        8: ",",
        9: "|",
        10: "(",
        11: ")",
        12: "+",
        13: "?",
        14: "/",
        15: ".",
        16: "^",
        17: "$",
        18: "=",
        19: "%%",
        20: "NAME",
        21: "START_INC",
        22: "START_EXC",
        23: "UNKNOWN_DECL",
        24: "IMPORT",
        25: "INIT_CODE",
        26: "STRING_LIT",
        27: "START_COND",
        28: "ACTION_START",
        29: "BRACKET_MISSING",
        30: "BRACKET_SURPLUS",
        31: "ACTION_END",
        32: "ACTION",
        33: "ACTION_BODY",
        34: "ACTION_BODY_C_COMMENT",
        35: "ACTION_BODY_CPP_COMMENT",
        36: "ACTION_BODY_WHITESPACE",
        37: "INCLUDE_PLACEMENT_ERROR",
        38: "SPECIAL_GROUP",
        39: "/!",
        40: "NAME_BRACE",
        41: "REGEX_SET_START",
        42: "REGEX_SET_END",
        43: "REGEX_SET",
        44: "ESCAPE_CHAR",
        45: "RANGE_REGEX",
        46: "CHARACTER_LIT",
        47: "OPTIONS",
        48: "OPTIONS_END",
        49: "OPTION_STRING_VALUE",
        50: "OPTION_VALUE",
        51: "INCLUDE",
        52: "PATH",
        53: "CODE"
    },
    TERROR: 2,
    EOF: 1,

    // internals: defined here so the object *structure* doesn't get modified by parse() et al,
    // thus helping JIT compilers like Chrome V8.
    originalQuoteName: null,
    originalParseError: null,
    cleanupAfterParse: null,
    constructParseErrorInfo: null,
    yyMergeLocationInfo: null,

    __reentrant_call_depth: 0, // INTERNAL USE ONLY
    __error_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup
    __error_recovery_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup

    // APIs which will be set up depending on user action code analysis:
    //yyRecovering: 0,
    //yyErrOk: 0,
    //yyClearIn: 0,

    // Helper APIs
    // -----------

    // Helper function which can be overridden by user code later on: put suitable quotes around
    // literal IDs in a description string.
    quoteName: function parser_quoteName(id_str) {
        return '"' + id_str + '"';
    },

    // Return the name of the given symbol (terminal or non-terminal) as a string, when available.
    //
    // Return NULL when the symbol is unknown to the parser.
    getSymbolName: function parser_getSymbolName(symbol) {
        if (this.terminals_[symbol]) {
            return this.terminals_[symbol];
        }

        // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.
        //
        // An example of this may be where a rule's action code contains a call like this:
        //
        //      parser.getSymbolName(#$)
        //
        // to obtain a human-readable name of the current grammar rule.
        var s = this.symbols_;
        for (var key in s) {
            if (s[key] === symbol) {
                return key;
            }
        }
        return null;
    },

    // Return a more-or-less human-readable description of the given symbol, when available,
    // or the symbol itself, serving as its own 'description' for lack of something better to serve up.
    //
    // Return NULL when the symbol is unknown to the parser.
    describeSymbol: function parser_describeSymbol(symbol) {
        if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {
            return this.terminal_descriptions_[symbol];
        } else if (symbol === this.EOF) {
            return 'end of input';
        }
        var id = this.getSymbolName(symbol);
        if (id) {
            return this.quoteName(id);
        }
        return null;
    },

    // Produce a (more or less) human-readable list of expected tokens at the point of failure.
    //
    // The produced list may contain token or token set descriptions instead of the tokens
    // themselves to help turning this output into something that easier to read by humans
    // unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,
    // expected terminals and nonterminals is produced.
    //
    // The returned list (array) will not contain any duplicate entries.
    collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {
        var TERROR = this.TERROR;
        var tokenset = [];
        var check = {};
        // Has this (error?) state been outfitted with a custom expectations description text for human consumption?
        // If so, use that one instead of the less palatable token set.
        if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {
            return [this.state_descriptions_[state]];
        }
        for (var p in this.table[state]) {
            p = +p;
            if (p !== TERROR) {
                var d = do_not_describe ? p : this.describeSymbol(p);
                if (d && !check[d]) {
                    tokenset.push(d);
                    check[d] = true; // Mark this token description as already mentioned to prevent outputting duplicate entries.
                }
            }
        }
        return tokenset;
    },
    productions_: bp({
        pop: u([54, 54, s, [55, 6], 56, 57, 57, s, [58, 11], 59, 59, 60, 60, 61, 61, 62, 62, 63, 63, 64, 64, s, [65, 4], 66, 66, 67, 67, s, [68, 3], s, [69, 9], s, [70, 4], 71, 71, 72, s, [73, 4], s, [74, 4], 75, 75, s, [76, 17], 77, 78, 78, 79, 79, 80, s, [80, 4, 1], 83, 84, 85, 85, s, [86, 6], 87, 87, 88, 88, s, [89, 3], 90, 90]),
        rule: u([s, [4, 3], s, [5, 4, -1], 0, 0, 2, 0, s, [2, 3], s, [1, 3], 3, 3, 2, 3, 3, s, [1, 7], 2, 1, 2, c, [23, 3], 4, c, [32, 4], 2, c, [22, 3], 3, s, [2, 8], 0, s, [3, 3], 0, 1, 3, 1, s, [3, 4, -1], c, [21, 3], c, [40, 3], s, [3, 4], s, [2, 5], c, [12, 3], s, [1, 6], c, [16, 3], c, [10, 8], c, [9, 3], s, [3, 4], c, [10, 4], c, [82, 4], 1, 0])
    }),
    performAction: function parser__PerformAction(yyloc, yystate /* action[1] */, yysp, yyvstack, yylstack) {

        /* this == yyval */

        // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!
        var yy = this.yy;
        var yyparser = yy.parser;
        var yylexer = yy.lexer;

        switch (yystate) {
            case 0:
                /*! Production::    $accept : lex $end */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 1];
                this._$ = yylstack[yysp - 1];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,LT,LA,-,-)
                break;

            case 1:
                /*! Production::    lex : init definitions rules_and_epilogue EOF */

                // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
                // END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 1];
                for (var key in yyvstack[yysp - 2]) {
                    this.$[key] = yyvstack[yysp - 2][key];
                }

                // if there are any options, add them all, otherwise set options to NULL:
                // can't check for 'empty object' by `if (yy.options) ...` so we do it this way:
                for (key in yy.options) {
                    this.$.options = yy.options;
                    break;
                }

                if (yy.actionInclude) {
                    var asrc = yy.actionInclude.join('\n\n');
                    // Only a non-empty action code chunk should actually make it through:
                    if (asrc.trim() !== '') {
                        this.$.actionInclude = asrc;
                    }
                }

                delete yy.options;
                delete yy.actionInclude;
                return this.$;
                break;

            case 2:
                /*! Production::    lex : init definitions error EOF */

                // default action (generated by JISON mode classic/merge :: 4,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 3];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
                // END of default action (generated by JISON mode classic/merge :: 4,VT,VA,-,-,LT,LA,-,-)


                yyparser.yyError(rmCommonWS$2(_templateObject, yylexer.prettyPrintRange(yylstack[yysp - 1]), yyvstack[yysp - 1].errStr));
                break;

            case 3:
                /*! Production::    rules_and_epilogue : "%%" rules "%%" extra_lexer_module_code */

                // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
                // END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)


                if (yyvstack[yysp].trim() !== '') {
                    this.$ = { rules: yyvstack[yysp - 2], moduleInclude: yyvstack[yysp] };
                } else {
                    this.$ = { rules: yyvstack[yysp - 2] };
                }
                break;

            case 4:
                /*! Production::    rules_and_epilogue : "%%" error rules "%%" extra_lexer_module_code */

                // default action (generated by JISON mode classic/merge :: 5,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 4];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
                // END of default action (generated by JISON mode classic/merge :: 5,VT,VA,-,-,LT,LA,-,-)


                yyparser.yyError(rmCommonWS$2(_templateObject2, yylexer.prettyPrintRange(yylstack[yysp - 3]), yyvstack[yysp - 3].errStr));
                break;

            case 5:
                /*! Production::    rules_and_epilogue : "%%" rules "%%" error */

                // default action (generated by JISON mode classic/merge :: 4,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 3];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
                // END of default action (generated by JISON mode classic/merge :: 4,VT,VA,-,-,LT,LA,-,-)


                yyparser.yyError(rmCommonWS$2(_templateObject3, yylexer.prettyPrintRange(yylstack[yysp]), yyvstack[yysp].errStr));
                break;

            case 6:
                /*! Production::    rules_and_epilogue : "%%" error rules */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 2];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-)


                yyparser.yyError(rmCommonWS$2(_templateObject2, yylexer.prettyPrintRange(yylstack[yysp - 1]), yyvstack[yysp - 1].errStr));
                break;

            case 7:
                /*! Production::    rules_and_epilogue : "%%" rules */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = { rules: yyvstack[yysp] };
                break;

            case 8:
                /*! Production::    rules_and_epilogue : %epsilon */

                // default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(null, null, null, null, true);
                // END of default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-)


                this.$ = { rules: [] };
                break;

            case 9:
                /*! Production::    init : %epsilon */

                // default action (generated by JISON mode classic/merge :: 0,VT,VA,-,-,LT,LA,-,-):
                this.$ = undefined;
                this._$ = yyparser.yyMergeLocationInfo(null, null, null, null, true);
                // END of default action (generated by JISON mode classic/merge :: 0,VT,VA,-,-,LT,LA,-,-)


                yy.actionInclude = [];
                if (!yy.options) yy.options = {};
                break;

            case 10:
                /*! Production::    definitions : definitions definition */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 1];
                if (yyvstack[yysp] != null) {
                    if ('length' in yyvstack[yysp]) {
                        this.$.macros[yyvstack[yysp][0]] = yyvstack[yysp][1];
                    } else {
                        switch (yyvstack[yysp].type) {
                            case 'names':
                                for (var name in yyvstack[yysp].names) {
                                    this.$.startConditions[name] = yyvstack[yysp].names[name];
                                }
                                break;

                            case 'unknown':
                                this.$.unknownDecls.push(yyvstack[yysp].body);
                                break;

                            case 'imports':
                                this.$.importDecls.push(yyvstack[yysp].body);
                                break;

                            case 'codeSection':
                                this.$.codeSections.push(yyvstack[yysp].body);
                                break;

                            default:
                                yyparser.yyError(rmCommonWS$2(_templateObject4, yyvstack[yysp].type, yylexer.prettyPrintRange(yylstack[yysp])));
                                break;
                        }
                    }
                }
                break;

            case 11:
                /*! Production::    definitions : %epsilon */

                // default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(null, null, null, null, true);
                // END of default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-)


                this.$ = {
                    macros: {}, // { hash table }
                    startConditions: {}, // { hash table }
                    codeSections: [], // [ array of {qualifier,include} pairs ]
                    importDecls: [], // [ array of {name,path} pairs ]
                    unknownDecls: [] // [ array of {name,value} pairs ]
                };
                break;

            case 12:
                /*! Production::    definition : NAME regex */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = [yyvstack[yysp - 1], yyvstack[yysp]];
                break;

            case 13:
            /*! Production::    definition : START_INC names_inclusive */
            case 14:
                /*! Production::    definition : START_EXC names_exclusive */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp];
                break;

            case 15:
                /*! Production::    definition : action */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                var rv = checkActionBlock(yyvstack[yysp], yylstack[yysp]);
                if (rv) {
                    yyparser.yyError(rmCommonWS$2(_templateObject5, rv, yylexer.prettyPrintRange(yylstack[yysp])));
                }
                yy.actionInclude.push(yyvstack[yysp]);
                this.$ = null;
                break;

            case 16:
            /*! Production::    definition : options */
            case 102:
                /*! Production::    option_list : option */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = null;
                break;

            case 17:
                /*! Production::    definition : UNKNOWN_DECL */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = {
                    type: 'unknown',
                    body: yyvstack[yysp]
                };
                break;

            case 18:
                /*! Production::    definition : IMPORT import_name import_path */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)


                this.$ = {
                    type: 'imports',
                    body: {
                        name: yyvstack[yysp - 1],
                        path: yyvstack[yysp]
                    }
                };
                break;

            case 19:
                /*! Production::    definition : IMPORT import_name error */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 2];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-)


                yyparser.yyError(rmCommonWS$2(_templateObject6, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 2]), yyvstack[yysp].errStr));
                break;

            case 20:
                /*! Production::    definition : IMPORT error */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 1];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-)


                yyparser.yyError(rmCommonWS$2(_templateObject7, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 1]), yyvstack[yysp].errStr));
                break;

            case 21:
                /*! Production::    definition : INIT_CODE init_code_name action */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)


                var rv = checkActionBlock(yyvstack[yysp], yylstack[yysp]);
                var name = yyvstack[yysp - 1];
                var code = yyvstack[yysp];
                if (rv) {
                    yyparser.yyError(rmCommonWS$2(_templateObject8, name, rv, code, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 2])));
                }
                this.$ = {
                    type: 'codeSection',
                    body: {
                        qualifier: yyvstack[yysp - 1],
                        include: yyvstack[yysp]
                    }
                };
                break;

            case 22:
                /*! Production::    definition : INIT_CODE error action */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 2];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-)


                yyparser.yyError(rmCommonWS$2(_templateObject9, yylexer.prettyPrintRange(yylstack[yysp - 1], yylstack[yysp - 2], yylstack[yysp]), yyvstack[yysp - 1].errStr));
                break;

            case 23:
            /*! Production::    init_code_name : NAME */
            case 24:
            /*! Production::    init_code_name : STRING_LIT */
            case 25:
            /*! Production::    import_name : NAME */
            case 26:
            /*! Production::    import_name : STRING_LIT */
            case 27:
            /*! Production::    import_path : NAME */
            case 28:
            /*! Production::    import_path : STRING_LIT */
            case 64:
            /*! Production::    regex_list : regex_concat */
            case 69:
            /*! Production::    nonempty_regex_list : regex_concat */
            case 71:
            /*! Production::    regex_concat : regex_base */
            case 96:
            /*! Production::    escape_char : ESCAPE_CHAR */
            case 97:
            /*! Production::    range_regex : RANGE_REGEX */
            case 113:
            /*! Production::    module_code_chunk : CODE */
            case 116:
                /*! Production::    optional_module_code_chunk : module_code_chunk */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp];
                break;

            case 29:
                /*! Production::    names_inclusive : START_COND */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = { type: 'names', names: {} };this.$.names[yyvstack[yysp]] = 0;
                break;

            case 30:
                /*! Production::    names_inclusive : names_inclusive START_COND */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 1];this.$.names[yyvstack[yysp]] = 0;
                break;

            case 31:
                /*! Production::    names_exclusive : START_COND */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = { type: 'names', names: {} };this.$.names[yyvstack[yysp]] = 1;
                break;

            case 32:
                /*! Production::    names_exclusive : names_exclusive START_COND */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 1];this.$.names[yyvstack[yysp]] = 1;
                break;

            case 33:
                /*! Production::    rules : rules rules_collective */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 1].concat(yyvstack[yysp]);
                break;

            case 34:
            /*! Production::    rules : %epsilon */
            case 40:
                /*! Production::    rule_block : %epsilon */

                // default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(null, null, null, null, true);
                // END of default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-)


                this.$ = [];
                break;

            case 35:
                /*! Production::    rules_collective : start_conditions rule */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                if (yyvstack[yysp - 1]) {
                    yyvstack[yysp].unshift(yyvstack[yysp - 1]);
                }
                this.$ = [yyvstack[yysp]];
                break;

            case 36:
                /*! Production::    rules_collective : start_conditions "{" rule_block "}" */

                // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
                // END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)


                if (yyvstack[yysp - 3]) {
                    yyvstack[yysp - 1].forEach(function (d) {
                        d.unshift(yyvstack[yysp - 3]);
                    });
                }
                this.$ = yyvstack[yysp - 1];
                break;

            case 37:
                /*! Production::    rules_collective : start_conditions "{" error "}" */

                // default action (generated by JISON mode classic/merge :: 4,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 3];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
                // END of default action (generated by JISON mode classic/merge :: 4,VT,VA,-,-,LT,LA,-,-)


                yyparser.yyError(rmCommonWS$2(_templateObject10, yyvstack[yysp - 3].join(','), yylexer.prettyPrintRange(yylexer.mergeLocationInfo(yysp - 3, yysp), yylstack[yysp - 3]), yyvstack[yysp - 1].errStr));
                break;

            case 38:
                /*! Production::    rules_collective : start_conditions "{" error */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 2];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-)


                yyparser.yyError(rmCommonWS$2(_templateObject11, yyvstack[yysp - 2].join(','), yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 2]), yyvstack[yysp].errStr));
                break;

            case 39:
                /*! Production::    rule_block : rule_block rule */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 1];this.$.push(yyvstack[yysp]);
                break;

            case 41:
                /*! Production::    rule : regex action */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                var rv = checkActionBlock(yyvstack[yysp], yylstack[yysp]);
                if (rv) {
                    yyparser.yyError(rmCommonWS$2(_templateObject12, rv, yylexer.prettyPrintRange(yylstack[yysp])));
                }
                this.$ = [yyvstack[yysp - 1], yyvstack[yysp]];
                break;

            case 42:
                /*! Production::    rule : regex error */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = [yyvstack[yysp - 1], yyvstack[yysp]];
                yyparser.yyError(rmCommonWS$2(_templateObject13, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 1]), yyvstack[yysp].errStr));
                break;

            case 43:
                /*! Production::    action : ACTION_START action_body BRACKET_MISSING */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 2];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-)


                yyparser.yyError(rmCommonWS$2(_templateObject14, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 2])));
                break;

            case 44:
                /*! Production::    action : ACTION_START action_body BRACKET_SURPLUS */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 2];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-)


                yyparser.yyError(rmCommonWS$2(_templateObject15, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 2])));
                break;

            case 45:
                /*! Production::    action : ACTION_START action_body ACTION_END */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)


                var s = yyvstack[yysp - 1].trim();
                // remove outermost set of braces UNLESS there's
                // a curly brace in there anywhere: in that case
                // we should leave it up to the sophisticated
                // code analyzer to simplify the code!
                //
                // This is a very rough check as it will also look
                // inside code comments, which should not have
                // any influence.
                //
                // Nevertheless: this is a *safe* transform!
                if (s[0] === '{' && s.indexOf('}') === s.length - 1) {
                    this.$ = s.substring(1, s.length - 1).trim();
                } else {
                    this.$ = s;
                }
                break;

            case 46:
            /*! Production::    action_body : action_body ACTION */
            case 51:
                /*! Production::    action_body : action_body include_macro_code */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 1] + '\n\n' + yyvstack[yysp] + '\n\n';
                break;

            case 47:
            /*! Production::    action_body : action_body ACTION_BODY */
            case 48:
            /*! Production::    action_body : action_body ACTION_BODY_C_COMMENT */
            case 49:
            /*! Production::    action_body : action_body ACTION_BODY_CPP_COMMENT */
            case 50:
            /*! Production::    action_body : action_body ACTION_BODY_WHITESPACE */
            case 70:
            /*! Production::    regex_concat : regex_concat regex_base */
            case 82:
            /*! Production::    regex_base : regex_base range_regex */
            case 92:
            /*! Production::    regex_set : regex_set regex_set_atom */
            case 114:
                /*! Production::    module_code_chunk : module_code_chunk CODE */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 1] + yyvstack[yysp];
                break;

            case 52:
                /*! Production::    action_body : action_body INCLUDE_PLACEMENT_ERROR */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 1];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-)


                yyparser.yyError(rmCommonWS$2(_templateObject16, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 1])));
                break;

            case 53:
                /*! Production::    action_body : action_body error */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 1];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-)


                yyparser.yyError(rmCommonWS$2(_templateObject17, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 1]), yyvstack[yysp].errStr));
                break;

            case 54:
            /*! Production::    action_body : %epsilon */
            case 65:
            /*! Production::    regex_list : %epsilon */
            case 117:
                /*! Production::    optional_module_code_chunk : %epsilon */

                // default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(null, null, null, null, true);
                // END of default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-)


                this.$ = '';
                break;

            case 55:
                /*! Production::    start_conditions : "<" name_list ">" */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 1];
                break;

            case 56:
                /*! Production::    start_conditions : "<" name_list error */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 2];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-)


                yyparser.yyError(rmCommonWS$2(_templateObject18, yyvstack[yysp - 1].join(','), yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 2]), yyvstack[yysp].errStr));
                break;

            case 57:
                /*! Production::    start_conditions : "<" "*" ">" */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)


                this.$ = ['*'];
                break;

            case 58:
                /*! Production::    start_conditions : %epsilon */

                // default action (generated by JISON mode classic/merge :: 0,VT,VA,-,-,LT,LA,-,-):
                this.$ = undefined;
                this._$ = yyparser.yyMergeLocationInfo(null, null, null, null, true);
                // END of default action (generated by JISON mode classic/merge :: 0,VT,VA,-,-,LT,LA,-,-)
                break;

            case 59:
                /*! Production::    name_list : NAME */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = [yyvstack[yysp]];
                break;

            case 60:
                /*! Production::    name_list : name_list "," NAME */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 2];this.$.push(yyvstack[yysp]);
                break;

            case 61:
                /*! Production::    regex : nonempty_regex_list */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                // Detect if the regex ends with a pure (Unicode) word;
                // we *do* consider escaped characters which are 'alphanumeric'
                // to be equivalent to their non-escaped version, hence these are
                // all valid 'words' for the 'easy keyword rules' option:
                //
                // - hello_kitty
                // - __
                // - \u03B3\u03B5\u03B9\u03B1_\u03C3\u03BF\u03C5_\u03B3\u03B1\u03C4\u03BF\u03CD\u03BB\u03B1
                //
                // http://stackoverflow.com/questions/7885096/how-do-i-decode-a-string-with-escaped-unicode#12869914
                //
                // As we only check the *tail*, we also accept these as
                // 'easy keywords':
                //
                // - %options
                // - %foo-bar
                // - +++a:b:c1
                //
                // Note the dash in that last example: there the code will consider
                // `bar` to be the keyword, which is fine with us as we're only
                // interested in the trailing boundary and patching that one for
                // the `easy_keyword_rules` option.
                this.$ = yyvstack[yysp];
                if (yy.options.easy_keyword_rules) {
                    // We need to 'protect' `eval` here as keywords are allowed
                    // to contain double-quotes and other leading cruft.
                    // `eval` *does* gobble some escapes (such as `\b`) but
                    // we protect against that through a simple replace regex:
                    // we're not interested in the special escapes' exact value
                    // anyway.
                    // It will also catch escaped escapes (`\\`), which are not
                    // word characters either, so no need to worry about
                    // `eval(str)` 'correctly' converting convoluted constructs
                    // like '\\\\\\\\\\b' in here.
                    this.$ = this.$.replace(/\\\\/g, '.').replace(/"/g, '.').replace(/\\c[A-Z]/g, '.').replace(/\\[^xu0-9]/g, '.');

                    try {
                        // Convert Unicode escapes and other escapes to their literal characters
                        // BEFORE we go and check whether this item is subject to the
                        // `easy_keyword_rules` option.
                        this.$ = JSON.parse('"' + this.$ + '"');
                    } catch (ex) {
                        yyparser.warn('easy-keyword-rule FAIL on eval: ', ex);

                        // make the next keyword test fail:
                        this.$ = '.';
                    }
                    // a 'keyword' starts with an alphanumeric character,
                    // followed by zero or more alphanumerics or digits:
                    var re = new XRegExp('\\w[\\w\\d]*$');
                    if (XRegExp.match(this.$, re)) {
                        this.$ = yyvstack[yysp] + "\\b";
                    } else {
                        this.$ = yyvstack[yysp];
                    }
                }
                break;

            case 62:
            /*! Production::    regex_list : regex_list "|" regex_concat */
            case 66:
                /*! Production::    nonempty_regex_list : nonempty_regex_list "|" regex_concat */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 2] + '|' + yyvstack[yysp];
                break;

            case 63:
            /*! Production::    regex_list : regex_list "|" */
            case 67:
                /*! Production::    nonempty_regex_list : nonempty_regex_list "|" */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 1] + '|';
                break;

            case 68:
                /*! Production::    nonempty_regex_list : "|" regex_concat */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = '|' + yyvstack[yysp];
                break;

            case 72:
                /*! Production::    regex_base : "(" regex_list ")" */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)


                this.$ = '(' + yyvstack[yysp - 1] + ')';
                break;

            case 73:
                /*! Production::    regex_base : SPECIAL_GROUP regex_list ")" */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 2] + yyvstack[yysp - 1] + ')';
                break;

            case 74:
            /*! Production::    regex_base : "(" regex_list error */
            case 75:
                /*! Production::    regex_base : SPECIAL_GROUP regex_list error */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 2];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-)


                yyparser.yyError(rmCommonWS$2(_templateObject19, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 2]), yyvstack[yysp].errStr));
                break;

            case 76:
                /*! Production::    regex_base : regex_base "+" */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 1] + '+';
                break;

            case 77:
                /*! Production::    regex_base : regex_base "*" */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 1] + '*';
                break;

            case 78:
                /*! Production::    regex_base : regex_base "?" */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 1] + '?';
                break;

            case 79:
                /*! Production::    regex_base : "/" regex_base */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = '(?=' + yyvstack[yysp] + ')';
                break;

            case 80:
                /*! Production::    regex_base : "/!" regex_base */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = '(?!' + yyvstack[yysp] + ')';
                break;

            case 81:
            /*! Production::    regex_base : name_expansion */
            case 83:
            /*! Production::    regex_base : any_group_regex */
            case 87:
            /*! Production::    regex_base : string */
            case 88:
            /*! Production::    regex_base : escape_char */
            case 89:
            /*! Production::    name_expansion : NAME_BRACE */
            case 93:
            /*! Production::    regex_set : regex_set_atom */
            case 94:
            /*! Production::    regex_set_atom : REGEX_SET */
            case 99:
                /*! Production::    string : CHARACTER_LIT */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp];
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,LT,LA,-,-)
                break;

            case 84:
                /*! Production::    regex_base : "." */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = '.';
                break;

            case 85:
                /*! Production::    regex_base : "^" */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = '^';
                break;

            case 86:
                /*! Production::    regex_base : "$" */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = '$';
                break;

            case 90:
                /*! Production::    any_group_regex : REGEX_SET_START regex_set REGEX_SET_END */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 2] + yyvstack[yysp - 1] + yyvstack[yysp];
                break;

            case 91:
                /*! Production::    any_group_regex : REGEX_SET_START regex_set error */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 2];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-)


                yyparser.yyError(rmCommonWS$2(_templateObject20, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 2]), yyvstack[yysp].errStr));
                break;

            case 95:
                /*! Production::    regex_set_atom : name_expansion */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                if (XRegExp._getUnicodeProperty(yyvstack[yysp].replace(/[{}]/g, '')) && yyvstack[yysp].toUpperCase() !== yyvstack[yysp]) {
                    // treat this as part of an XRegExp `\p{...}` Unicode 'General Category' Property cf. http://unicode.org/reports/tr18/#Categories
                    this.$ = yyvstack[yysp];
                } else {
                    this.$ = yyvstack[yysp];
                }
                //yyparser.log("name expansion for: ", { name: $name_expansion, redux: $name_expansion.replace(/[{}]/g, ''), output: $$ });
                break;

            case 98:
                /*! Production::    string : STRING_LIT */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = prepareString(yyvstack[yysp]);
                break;

            case 100:
                /*! Production::    options : OPTIONS option_list OPTIONS_END */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)


                this.$ = null;
                break;

            case 101:
                /*! Production::    option_list : option option_list */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = null;
                break;

            case 103:
                /*! Production::    option : NAME */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp];
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,LT,LA,-,-)


                yy.options[yyvstack[yysp]] = true;
                break;

            case 104:
                /*! Production::    option : NAME "=" OPTION_STRING_VALUE */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 2];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-)


                yy.options[yyvstack[yysp - 2]] = yyvstack[yysp];
                break;

            case 105:
            /*! Production::    option : NAME "=" OPTION_VALUE */
            case 106:
                /*! Production::    option : NAME "=" NAME */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 2];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-)


                yy.options[yyvstack[yysp - 2]] = parseValue(yyvstack[yysp]);
                break;

            case 107:
                /*! Production::    option : NAME "=" error */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 2];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-)


                // TODO ...
                yyparser.yyError(rmCommonWS$2(_templateObject21, $option, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 2]), yyvstack[yysp].errStr));
                break;

            case 108:
                /*! Production::    option : error */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp];
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,LT,LA,-,-)


                // TODO ...
                yyparser.yyError(rmCommonWS$2(_templateObject22, yylexer.prettyPrintRange(yylstack[yysp]), yyvstack[yysp].errStr));
                break;

            case 109:
                /*! Production::    extra_lexer_module_code : optional_module_code_chunk */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                var rv = checkActionBlock(yyvstack[yysp], yylstack[yysp]);
                if (rv) {
                    yyparser.yyError(rmCommonWS$2(_templateObject23, rv, yylexer.prettyPrintRange(yylstack[yysp])));
                }
                this.$ = yyvstack[yysp];
                break;

            case 110:
                /*! Production::    extra_lexer_module_code : extra_lexer_module_code include_macro_code optional_module_code_chunk */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)


                // Each of the 3 chunks should be parse-able as a JS snippet on its own.
                //
                // Note: we have already checked the first section in a previous reduction
                // of this rule, so we don't need to check that one again!
                var rv = checkActionBlock(yyvstack[yysp - 1], yylstack[yysp - 1]);
                if (rv) {
                    yyparser.yyError(rmCommonWS$2(_templateObject24, rv, yylexer.prettyPrintRange(yylstack[yysp - 1])));
                }
                rv = checkActionBlock(yyvstack[yysp], yylstack[yysp]);
                if (rv) {
                    yyparser.yyError(rmCommonWS$2(_templateObject23, rv, yylexer.prettyPrintRange(yylstack[yysp])));
                }
                this.$ = yyvstack[yysp - 2] + yyvstack[yysp - 1] + yyvstack[yysp];
                break;

            case 111:
                /*! Production::    include_macro_code : INCLUDE PATH */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                var fileContent = fs.readFileSync(yyvstack[yysp], { encoding: 'utf-8' });
                // And no, we don't support nested '%include':
                this.$ = '\n// Included by Jison: ' + yyvstack[yysp] + ':\n\n' + fileContent + '\n\n// End Of Include by Jison: ' + yyvstack[yysp] + '\n\n';
                break;

            case 112:
                /*! Production::    include_macro_code : INCLUDE error */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 1];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-)


                yyparser.yyError(rmCommonWS$2(_templateObject25, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 1]), yyvstack[yysp].errStr));
                break;

            case 115:
                /*! Production::    module_code_chunk : error CODE */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 1];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-)


                // TODO ...
                yyparser.yyError(rmCommonWS$2(_templateObject26, yylexer.prettyPrintRange(yylstack[yysp - 1]), yyvstack[yysp - 1].errStr));
                break;

            case 151:
                // === NO_ACTION[1] :: ensures that anyone (but us) using this new state will fail dramatically!
                // error recovery reduction action (action generated by jison,
                // using the user-specified `%code error_recovery_reduction` %{...%}
                // code chunk below.


                break;

        }
    },
    table: bt({
        len: u([13, 1, 12, 15, 1, 1, 11, 19, 21, 2, 2, s, [11, 3], 4, 4, 12, 4, 1, 1, 19, 18, 11, 12, 18, 29, 30, 22, 22, 17, 17, s, [29, 7], 31, 5, s, [29, 3], s, [12, 4], 4, 11, 3, 3, 2, 2, 1, 1, 12, 1, 5, 4, 3, 7, 17, 23, 3, 19, 30, 29, 30, s, [29, 5], 3, 20, 3, 30, 30, 6, s, [4, 3], 12, 12, s, [11, 6], s, [27, 3], s, [11, 8], 2, 11, 1, 4, c, [55, 3], 3, 3, 17, 16, 3, 3, 1, 3, 7, s, [29, 3], 21, s, [29, 4], 4, 13, 13, s, [3, 4], 6, 3, 3, 23, s, [18, 3], 14, 14, 1, 14, 3, 1, 20, 2, 17, 14, 17, 3]),
        symbol: u([1, 2, s, [19, 7, 1], 28, 47, 54, 56, 1, c, [14, 11], 57, c, [12, 11], 55, 58, 68, 84, s, [1, 3], c, [17, 10], 1, 2, 3, 5, 9, 10, s, [14, 4, 1], 19, 26, s, [38, 4, 1], 44, 46, 64, c, [15, 6], c, [14, 7], 72, s, [74, 5, 1], 81, 83, 27, 62, 27, 63, c, [55, 13], c, [11, 20], 2, 20, 26, 60, c, [4, 3], 59, 2, s, [29, 9, 1], 51, 69, 2, 20, 85, 86, s, [1, 3], c, [102, 16], 65, 70, c, [19, 17], 64, c, [85, 13], 9, c, [12, 9], c, [143, 12], c, [141, 6], c, [30, 3], c, [58, 6], s, [20, 7, 1], 28, c, [29, 6], 47, c, [29, 7], 7, s, [9, 9, 1], c, [33, 14], 45, 46, 47, 82, c, [58, 3], 11, c, [80, 11], 73, c, [81, 6], c, [22, 22], c, [121, 12], c, [17, 22], c, [108, 29], c, [29, 199], s, [42, 6, 1], 40, 43, 77, 79, 80, c, [123, 89], c, [19, 7], 27, c, [590, 11], c, [12, 27], c, [611, 3], 61, c, [630, 14], c, [3, 3], 28, 68, 28, 68, 28, 28, c, [634, 11], 88, 48, 2, 20, 48, 85, 86, 2, 18, 20, c, [9, 4], 1, 2, 51, 53, 87, 89, 90, c, [629, 17], 3, c, [750, 13], 67, c, [751, 8], 7, 20, 71, c, [691, 20], c, [632, 23], c, [662, 65], c, [526, 145], 2, 9, 11, c, [788, 15], c, [808, 7], 11, c, [201, 59], 82, 2, 40, 42, 43, 77, 80, c, [6, 4], c, [4, 8], c, [495, 33], c, [11, 59], 3, 4, c, [449, 8], c, [401, 15], c, [27, 54], c, [603, 11], c, [11, 78], 52, c, [182, 11], c, [683, 3], 49, 50, 1, 51, 88, 1, 53, 1, 51, 1, 51, c, [5, 3], 53, c, [647, 17], 2, 4, c, [691, 13], 66, 2, 28, 68, 2, 6, 8, 6, c, [4, 3], c, [740, 8], c, [648, 57], c, [531, 31], c, [528, 13], c, [756, 8], c, [668, 115], c, [568, 5], c, [321, 10], 53, c, [13, 13], c, [1004, 3], c, [3, 9], c, [273, 4], c, [272, 3], c, [328, 5], c, [310, 14], c, [1001, 9], 1, c, [496, 10], c, [27, 7], c, [18, 36], c, [1078, 14], c, [14, 14], 20, c, [15, 14], c, [461, 3], 53, c, [843, 20], c, [480, 3], c, [474, 16], c, [163, 14], c, [505, 18], 6, 8]),
        type: u([s, [2, 11], 0, 0, 1, c, [14, 12], c, [26, 13], 0, c, [15, 12], s, [2, 20], c, [32, 14], s, [0, 8], c, [23, 3], c, [57, 32], c, [62, 9], c, [113, 13], c, [67, 4], c, [40, 20], c, [21, 18], c, [96, 36], c, [141, 7], c, [30, 28], c, [221, 43], c, [223, 9], c, [22, 34], c, [17, 34], s, [2, 224], c, [239, 141], c, [139, 19], c, [673, 16], c, [14, 5], c, [180, 13], c, [764, 35], c, [751, 9], c, [98, 19], c, [632, 31], c, [662, 75], c, [511, 151], c, [513, 34], c, [231, 35], c, [821, 238], c, [735, 74], c, [43, 27], c, [740, 39], c, [1202, 78], c, [756, 30], c, [696, 140], c, [1001, 31], c, [461, 114], c, [121, 58]]),
        state: u([s, [1, 4, 1], 6, 11, 12, 20, 22, 23, 25, 26, 31, 32, 37, 36, 43, 45, 47, 51, 55, 56, 57, 61, 62, 64, 66, c, [16, 5], 67, c, [5, 4], 71, 73, 74, c, [13, 5], 75, c, [7, 6], 76, c, [5, 4], 77, c, [5, 4], 81, 78, 79, 84, 88, 89, 98, 103, 57, 105, 108, 107, 110, 112, c, [67, 7], 113, 61, 62, 117, c, [60, 11], c, [6, 6], 71, 81, 125, 132, 135, 137, 143, 108, 107, c, [15, 5], 145, c, [32, 5], 108, 146, 148, c, [52, 8], 132, c, [23, 5]]),
        mode: u([s, [2, 23], s, [1, 12], c, [24, 13], c, [41, 28], c, [44, 15], c, [89, 27], c, [17, 13], c, [88, 11], c, [64, 34], c, [38, 14], c, [123, 15], c, [92, 12], 1, c, [107, 10], c, [27, 6], c, [72, 23], c, [40, 8], c, [45, 7], c, [15, 13], s, [1, 24], s, [2, 234], c, [236, 98], c, [97, 24], c, [24, 15], c, [374, 20], c, [432, 5], c, [409, 15], c, [585, 9], c, [47, 20], c, [45, 25], c, [36, 14], c, [578, 18], c, [602, 53], c, [459, 145], c, [735, 19], c, [797, 33], c, [29, 25], c, [776, 238], c, [813, 51], c, [289, 5], c, [648, 7], c, [298, 21], c, [738, 18], c, [621, 8], c, [376, 7], c, [651, 22], c, [874, 59], c, [1219, 170], c, [960, 9], c, [947, 23], c, [1151, 89], c, [805, 17], s, [2, 53]]),
        goto: u([s, [9, 11], s, [11, 11], 8, 5, s, [7, 4, 1], s, [13, 7, 1], s, [10, 11], 34, 21, s, [34, 16], 24, 27, 29, 33, 34, 35, 40, 28, 30, 38, 39, 42, 41, 44, 46, s, [15, 11], s, [16, 11], s, [17, 11], 48, 49, 50, 52, 53, s, [54, 12], 59, 58, 1, 2, 7, 58, 63, s, [58, 6], 60, s, [58, 7], s, [34, 17], s, [12, 11], 61, 61, 65, s, [61, 9], c, [125, 12], s, [69, 3], c, [15, 5], s, [69, 7], 40, 69, c, [23, 7], 71, 71, c, [3, 3], 71, 68, 70, s, [71, 18], 72, 71, 71, 65, 65, 27, 65, c, [68, 11], c, [15, 15], c, [95, 12], c, [12, 12], s, [81, 29], s, [83, 29], s, [84, 29], s, [85, 29], s, [86, 29], s, [87, 29], s, [88, 29], s, [89, 31], 38, 80, s, [98, 29], s, [99, 29], s, [96, 29], s, [13, 9], 82, 13, 13, s, [29, 12], s, [14, 9], 83, 14, 14, s, [31, 12], 85, 86, 87, s, [20, 11], s, [25, 3], s, [26, 3], 16, 16, 23, 24, 100, s, [90, 8, 1], 99, 101, 102, 59, 58, 102, 103, 104, 103, 103, s, [108, 3], 117, 106, 117, 109, s, [33, 17], 111, c, [684, 13], 114, 115, 6, c, [630, 8], 116, s, [58, 7], s, [67, 3], c, [34, 5], s, [67, 7], 40, 67, c, [42, 6], 67, s, [68, 3], c, [24, 5], s, [68, 7], 40, 68, c, [24, 6], 68, 70, 70, 69, s, [70, 3], c, [7, 3], s, [70, 17], 72, 70, 70, s, [76, 29], s, [77, 29], s, [78, 29], s, [82, 29], s, [97, 29], 119, 120, 118, 64, 64, 27, 64, c, [259, 11], 122, 120, 121, 79, 79, 69, s, [79, 3], 68, 70, s, [79, 18], 72, 79, 79, 80, 80, 69, s, [80, 3], 68, 70, s, [80, 18], 72, 80, 80, 124, 38, 123, 80, s, [93, 4], s, [94, 4], s, [95, 4], s, [30, 12], s, [32, 12], s, [18, 11], s, [19, 11], s, [27, 11], s, [28, 11], s, [21, 11], s, [22, 11], s, [43, 27], s, [44, 27], s, [45, 27], s, [46, 11], s, [47, 11], s, [48, 11], s, [49, 11], s, [50, 11], s, [51, 11], s, [52, 11], s, [53, 11], 127, 126, s, [100, 11], 101, 131, 130, 128, 129, 3, 101, 5, 133, 109, 109, 116, 116, 134, s, [113, 3], s, [35, 17], 136, s, [40, 14], 138, 16, 140, 139, 141, 142, s, [59, 3], 117, 144, 117, 109, s, [66, 3], c, [627, 5], s, [66, 7], 40, 66, c, [434, 6], 66, s, [72, 29], s, [74, 29], 63, 63, 27, 63, c, [508, 11], s, [73, 29], s, [75, 29], s, [90, 29], s, [91, 29], s, [92, 4], s, [111, 13], s, [112, 13], s, [104, 3], s, [105, 3], s, [106, 3], s, [107, 3], c, [259, 4], s, [115, 3], s, [114, 3], 147, c, [949, 13], 38, 38, 149, s, [38, 15], s, [41, 18], s, [42, 18], s, [55, 14], s, [56, 14], 150, s, [57, 14], 4, 101, 133, 62, 62, 27, 62, c, [115, 11], 110, 110, s, [36, 17], s, [39, 14], s, [37, 17], s, [60, 3]])
    }),
    defaultActions: bda({
        idx: u([0, 2, 6, 11, 12, 13, 16, 18, 19, 21, 22, s, [31, 8, 1], 40, 41, s, [42, 4, 2], 49, 50, 53, 54, 59, 61, s, [68, 5, 1], s, [79, 22, 1], 102, 103, 107, 109, 110, 115, 118, 119, s, [121, 11, 1], 133, 134, s, [137, 4, 1], 142, s, [146, 5, 1]]),
        goto: u([9, 11, 10, 15, 16, 17, 54, 1, 2, 34, 12, 81, s, [83, 7, 1], 98, 99, 96, 29, 31, 20, 25, 26, 23, 24, 108, 33, 76, 77, 78, 82, 97, 93, 94, 95, 30, 32, 18, 19, 27, 28, 21, 22, s, [43, 11, 1], 100, 101, 109, 113, 35, 59, 72, 74, 73, 75, 90, 91, 92, 111, 112, s, [104, 4, 1], 115, 114, 41, 42, 55, 56, 57, 110, 36, 39, 37, 60])
    }),
    parseError: function parseError(str, hash, ExceptionClass) {
        if (hash.recoverable) {
            if (typeof this.trace === 'function') {
                this.trace(str);
            }
            hash.destroy(); // destroy... well, *almost*!
        } else {
            if (typeof this.trace === 'function') {
                this.trace(str);
            }
            if (!ExceptionClass) {
                ExceptionClass = this.JisonParserError;
            }
            throw new ExceptionClass(str, hash);
        }
    },
    parse: function parse(input) {
        var self = this;
        var stack = new Array(128); // token stack: stores token which leads to state at the same index (column storage)
        var sstack = new Array(128); // state stack: stores states (column storage)

        var vstack = new Array(128); // semantic value stack
        var lstack = new Array(128); // location stack
        var table = this.table;
        var sp = 0; // 'stack pointer': index into the stacks
        var yyloc;

        var symbol = 0;
        var preErrorSymbol = 0;
        var lastEofErrorStateDepth = Infinity;
        var recoveringErrorInfo = null;
        var recovering = 0; // (only used when the grammar contains error recovery rules)
        var TERROR = this.TERROR;
        var EOF = this.EOF;
        var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = this.options.errorRecoveryTokenDiscardCount | 0 || 3;
        var NO_ACTION = [0, 151 /* === table.length :: ensures that anyone using this new state will fail dramatically! */];

        var lexer;
        if (this.__lexer__) {
            lexer = this.__lexer__;
        } else {
            lexer = this.__lexer__ = Object.create(this.lexer);
        }

        var sharedState_yy = {
            parseError: undefined,
            quoteName: undefined,
            lexer: undefined,
            parser: undefined,
            pre_parse: undefined,
            post_parse: undefined,
            pre_lex: undefined,
            post_lex: undefined // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!
        };

        var ASSERT;
        if (typeof assert$1 !== 'function') {
            ASSERT = function JisonAssert(cond, msg) {
                if (!cond) {
                    throw new Error('assertion failed: ' + (msg || '***'));
                }
            };
        } else {
            ASSERT = assert$1;
        }

        this.yyGetSharedState = function yyGetSharedState() {
            return sharedState_yy;
        };

        this.yyGetErrorInfoTrack = function yyGetErrorInfoTrack() {
            return recoveringErrorInfo;
        };

        // shallow clone objects, straight copy of simple `src` values
        // e.g. `lexer.yytext` MAY be a complex value object,
        // rather than a simple string/value.
        function shallow_copy(src) {
            if ((typeof src === 'undefined' ? 'undefined' : _typeof(src)) === 'object') {
                var dst = {};
                for (var k in src) {
                    if (Object.prototype.hasOwnProperty.call(src, k)) {
                        dst[k] = src[k];
                    }
                }
                return dst;
            }
            return src;
        }
        function shallow_copy_noclobber(dst, src) {
            for (var k in src) {
                if (typeof dst[k] === 'undefined' && Object.prototype.hasOwnProperty.call(src, k)) {
                    dst[k] = src[k];
                }
            }
        }
        function copy_yylloc(loc) {
            var rv = shallow_copy(loc);
            if (rv && rv.range) {
                rv.range = rv.range.slice(0);
            }
            return rv;
        }

        // copy state
        shallow_copy_noclobber(sharedState_yy, this.yy);

        sharedState_yy.lexer = lexer;
        sharedState_yy.parser = this;

        // *Always* setup `yyError`, `YYRECOVERING`, `yyErrOk` and `yyClearIn` functions as it is paramount
        // to have *their* closure match ours -- if we only set them up once,
        // any subsequent `parse()` runs will fail in very obscure ways when
        // these functions are invoked in the user action code block(s) as
        // their closure will still refer to the `parse()` instance which set
        // them up. Hence we MUST set them up at the start of every `parse()` run!
        if (this.yyError) {
            this.yyError = function yyError(str /*, ...args */) {

                var error_rule_depth = this.options.parserErrorsAreRecoverable ? locateNearestErrorRecoveryRule(state) : -1;
                var expected = this.collect_expected_token_set(state);
                var hash = this.constructParseErrorInfo(str, null, expected, error_rule_depth >= 0);
                // append to the old one?
                if (recoveringErrorInfo) {
                    var esp = recoveringErrorInfo.info_stack_pointer;

                    recoveringErrorInfo.symbol_stack[esp] = symbol;
                    var v = this.shallowCopyErrorInfo(hash);
                    v.yyError = true;
                    v.errorRuleDepth = error_rule_depth;
                    v.recovering = recovering;
                    // v.stackSampleLength = error_rule_depth + EXTRA_STACK_SAMPLE_DEPTH;

                    recoveringErrorInfo.value_stack[esp] = v;
                    recoveringErrorInfo.location_stack[esp] = copy_yylloc(lexer.yylloc);
                    recoveringErrorInfo.state_stack[esp] = newState || NO_ACTION[1];

                    ++esp;
                    recoveringErrorInfo.info_stack_pointer = esp;
                } else {
                    recoveringErrorInfo = this.shallowCopyErrorInfo(hash);
                    recoveringErrorInfo.yyError = true;
                    recoveringErrorInfo.errorRuleDepth = error_rule_depth;
                    recoveringErrorInfo.recovering = recovering;
                }

                // Add any extra args to the hash under the name `extra_error_attributes`:
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length) {
                    hash.extra_error_attributes = args;
                }

                var r = this.parseError(str, hash, this.JisonParserError);
                return r;
            };
        }

        // Does the shared state override the default `parseError` that already comes with this instance?
        if (typeof sharedState_yy.parseError === 'function') {
            this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {
                if (!ExceptionClass) {
                    ExceptionClass = this.JisonParserError;
                }
                return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);
            };
        } else {
            this.parseError = this.originalParseError;
        }

        // Does the shared state override the default `quoteName` that already comes with this instance?
        if (typeof sharedState_yy.quoteName === 'function') {
            this.quoteName = function quoteNameAlt(id_str) {
                return sharedState_yy.quoteName.call(this, id_str);
            };
        } else {
            this.quoteName = this.originalQuoteName;
        }

        // set up the cleanup function; make it an API so that external code can re-use this one in case of
        // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which
        // case this parse() API method doesn't come with a `finally { ... }` block any more!
        //
        // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
        //       or else your `sharedState`, etc. references will be *wrong*!
        this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {
            var rv;

            if (invoke_post_methods) {
                var hash;

                if (sharedState_yy.post_parse || this.post_parse) {
                    // create an error hash info instance: we re-use this API in a **non-error situation**
                    // as this one delivers all parser internals ready for access by userland code.
                    hash = this.constructParseErrorInfo(null /* no error! */, null /* no exception! */, null, false);
                }

                if (sharedState_yy.post_parse) {
                    rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);
                    if (typeof rv !== 'undefined') resultValue = rv;
                }
                if (this.post_parse) {
                    rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);
                    if (typeof rv !== 'undefined') resultValue = rv;
                }

                // cleanup:
                if (hash && hash.destroy) {
                    hash.destroy();
                }
            }

            if (this.__reentrant_call_depth > 1) return resultValue; // do not (yet) kill the sharedState when this is a reentrant run.

            // clean up the lingering lexer structures as well:
            if (lexer.cleanupAfterLex) {
                lexer.cleanupAfterLex(do_not_nuke_errorinfos);
            }

            // prevent lingering circular references from causing memory leaks:
            if (sharedState_yy) {
                sharedState_yy.lexer = undefined;
                sharedState_yy.parser = undefined;
                if (lexer.yy === sharedState_yy) {
                    lexer.yy = undefined;
                }
            }
            sharedState_yy = undefined;
            this.parseError = this.originalParseError;
            this.quoteName = this.originalQuoteName;

            // nuke the vstack[] array at least as that one will still reference obsoleted user values.
            // To be safe, we nuke the other internal stack columns as well...
            stack.length = 0; // fastest way to nuke an array without overly bothering the GC
            sstack.length = 0;
            lstack.length = 0;
            vstack.length = 0;
            sp = 0;

            // nuke the error hash info instances created during this run.
            // Userland code must COPY any data/references
            // in the error hash instance(s) it is more permanently interested in.
            if (!do_not_nuke_errorinfos) {
                for (var i = this.__error_infos.length - 1; i >= 0; i--) {
                    var el = this.__error_infos[i];
                    if (el && typeof el.destroy === 'function') {
                        el.destroy();
                    }
                }
                this.__error_infos.length = 0;

                for (var i = this.__error_recovery_infos.length - 1; i >= 0; i--) {
                    var el = this.__error_recovery_infos[i];
                    if (el && typeof el.destroy === 'function') {
                        el.destroy();
                    }
                }
                this.__error_recovery_infos.length = 0;

                // `recoveringErrorInfo` is also part of the `__error_recovery_infos` array,
                // hence has been destroyed already: no need to do that *twice*.
                if (recoveringErrorInfo) {
                    recoveringErrorInfo = undefined;
                }
            }

            return resultValue;
        };

        // merge yylloc info into a new yylloc instance.
        //
        // `first_index` and `last_index` MAY be UNDEFINED/NULL or these are indexes into the `lstack[]` location stack array.
        //
        // `first_yylloc` and `last_yylloc` MAY be UNDEFINED/NULL or explicit (custom or regular) `yylloc` instances, in which
        // case these override the corresponding first/last indexes.
        //
        // `dont_look_back` is an optional flag (default: FALSE), which instructs this merge operation NOT to search
        // through the parse location stack for a location, which would otherwise be used to construct the new (epsilon!)
        // yylloc info.
        //
        // Note: epsilon rule's yylloc situation is detected by passing both `first_index` and `first_yylloc` as UNDEFINED/NULL.
        this.yyMergeLocationInfo = function parser_yyMergeLocationInfo(first_index, last_index, first_yylloc, last_yylloc, dont_look_back) {
            var i1 = first_index | 0,
                i2 = last_index | 0;
            var l1 = first_yylloc,
                l2 = last_yylloc;
            var rv;

            // rules:
            // - first/last yylloc entries override first/last indexes

            if (!l1) {
                if (first_index != null) {
                    for (var i = i1; i <= i2; i++) {
                        l1 = lstack[i];
                        if (l1) {
                            break;
                        }
                    }
                }
            }

            if (!l2) {
                if (last_index != null) {
                    for (var i = i2; i >= i1; i--) {
                        l2 = lstack[i];
                        if (l2) {
                            break;
                        }
                    }
                }
            }

            // - detect if an epsilon rule is being processed and act accordingly:
            if (!l1 && first_index == null) {
                // epsilon rule span merger. With optional look-ahead in l2.
                if (!dont_look_back) {
                    for (var i = (i1 || sp) - 1; i >= 0; i--) {
                        l1 = lstack[i];
                        if (l1) {
                            break;
                        }
                    }
                }
                if (!l1) {
                    if (!l2) {
                        // when we still don't have any valid yylloc info, we're looking at an epsilon rule
                        // without look-ahead and no preceding terms and/or `dont_look_back` set:
                        // in that case we ca do nothing but return NULL/UNDEFINED:
                        return undefined;
                    } else {
                        // shallow-copy L2: after all, we MAY be looking
                        // at unconventional yylloc info objects...
                        rv = shallow_copy(l2);
                        if (rv.range) {
                            // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
                            rv.range = rv.range.slice(0);
                        }
                        return rv;
                    }
                } else {
                    // shallow-copy L1, then adjust first col/row 1 column past the end.
                    rv = shallow_copy(l1);
                    rv.first_line = rv.last_line;
                    rv.first_column = rv.last_column;
                    if (rv.range) {
                        // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
                        rv.range = rv.range.slice(0);
                        rv.range[0] = rv.range[1];
                    }

                    if (l2) {
                        // shallow-mixin L2, then adjust last col/row accordingly.
                        shallow_copy_noclobber(rv, l2);
                        rv.last_line = l2.last_line;
                        rv.last_column = l2.last_column;
                        if (rv.range && l2.range) {
                            rv.range[1] = l2.range[1];
                        }
                    }
                    return rv;
                }
            }

            if (!l1) {
                l1 = l2;
                l2 = null;
            }
            if (!l1) {
                return undefined;
            }

            // shallow-copy L1|L2, before we try to adjust the yylloc values: after all, we MAY be looking
            // at unconventional yylloc info objects...
            rv = shallow_copy(l1);

            // first_line: ...,
            // first_column: ...,
            // last_line: ...,
            // last_column: ...,
            if (rv.range) {
                // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
                rv.range = rv.range.slice(0);
            }

            if (l2) {
                shallow_copy_noclobber(rv, l2);
                rv.last_line = l2.last_line;
                rv.last_column = l2.last_column;
                if (rv.range && l2.range) {
                    rv.range[1] = l2.range[1];
                }
            }

            return rv;
        };

        // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
        //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!
        this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {
            var pei = {
                errStr: msg,
                exception: ex,
                text: lexer.match,
                value: lexer.yytext,
                token: this.describeSymbol(symbol) || symbol,
                token_id: symbol,
                line: lexer.yylineno,
                loc: copy_yylloc(lexer.yylloc),
                expected: expected,
                recoverable: recoverable,
                state: state,
                action: action,
                new_state: newState,
                symbol_stack: stack,
                state_stack: sstack,
                value_stack: vstack,
                location_stack: lstack,
                stack_pointer: sp,
                yy: sharedState_yy,
                lexer: lexer,
                parser: this,

                // and make sure the error info doesn't stay due to potential
                // ref cycle via userland code manipulations.
                // These would otherwise all be memory leak opportunities!
                //
                // Note that only array and object references are nuked as those
                // constitute the set of elements which can produce a cyclic ref.
                // The rest of the members is kept intact as they are harmless.
                destroy: function destructParseErrorInfo() {
                    // remove cyclic references added to error info:
                    // info.yy = null;
                    // info.lexer = null;
                    // info.value = null;
                    // info.value_stack = null;
                    // ...
                    var rec = !!this.recoverable;
                    for (var key in this) {
                        if (this.hasOwnProperty(key) && (typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {
                            this[key] = undefined;
                        }
                    }
                    this.recoverable = rec;
                }
            };
            // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
            this.__error_infos.push(pei);
            return pei;
        };

        // clone some parts of the (possibly enhanced!) errorInfo object
        // to give them some persistence.
        this.shallowCopyErrorInfo = function parser_shallowCopyErrorInfo(p) {
            var rv = shallow_copy(p);

            // remove the large parts which can only cause cyclic references
            // and are otherwise available from the parser kernel anyway.
            delete rv.sharedState_yy;
            delete rv.parser;
            delete rv.lexer;

            // lexer.yytext MAY be a complex value object, rather than a simple string/value:
            rv.value = shallow_copy(rv.value);

            // yylloc info:
            rv.loc = copy_yylloc(rv.loc);

            // the 'expected' set won't be modified, so no need to clone it:
            //rv.expected = rv.expected.slice(0);

            //symbol stack is a simple array:
            rv.symbol_stack = rv.symbol_stack.slice(0);
            // ditto for state stack:
            rv.state_stack = rv.state_stack.slice(0);
            // clone the yylloc's in the location stack?:
            rv.location_stack = rv.location_stack.map(copy_yylloc);
            // and the value stack may carry both simple and complex values:
            // shallow-copy the latter.
            rv.value_stack = rv.value_stack.map(shallow_copy);

            // and we don't bother with the sharedState_yy reference:
            //delete rv.yy;

            // now we prepare for tracking the COMBINE actions
            // in the error recovery code path:
            //
            // as we want to keep the maximum error info context, we
            // *scan* the state stack to find the first *empty* slot.
            // This position will surely be AT OR ABOVE the current
            // stack pointer, but we want to keep the 'used but discarded'
            // part of the parse stacks *intact* as those slots carry
            // error context that may be useful when you want to produce
            // very detailed error diagnostic reports.
            //
            // ### Purpose of each stack pointer:
            //
            // - stack_pointer: points at the top of the parse stack
            //                  **as it existed at the time of the error
            //                  occurrence, i.e. at the time the stack
            //                  snapshot was taken and copied into the
            //                  errorInfo object.**
            // - base_pointer:  the bottom of the **empty part** of the
            //                  stack, i.e. **the start of the rest of
            //                  the stack space /above/ the existing
            //                  parse stack. This section will be filled
            //                  by the error recovery process as it
            //                  travels the parse state machine to
            //                  arrive at the resolving error recovery rule.**
            // - info_stack_pointer:
            //                  this stack pointer points to the **top of
            //                  the error ecovery tracking stack space**, i.e.
            //                  this stack pointer takes up the role of
            //                  the `stack_pointer` for the error recovery
            //                  process. Any mutations in the **parse stack**
            //                  are **copy-appended** to this part of the
            //                  stack space, keeping the bottom part of the
            //                  stack (the 'snapshot' part where the parse
            //                  state at the time of error occurrence was kept)
            //                  intact.
            // - root_failure_pointer:
            //                  copy of the `stack_pointer`...
            //
            for (var i = rv.stack_pointer; typeof rv.state_stack[i] !== 'undefined'; i++) {
                // empty
            }
            rv.base_pointer = i;
            rv.info_stack_pointer = i;

            rv.root_failure_pointer = rv.stack_pointer;

            // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
            this.__error_recovery_infos.push(rv);

            return rv;
        };

        function stdLex() {
            var token = lexer.lex();
            // if token isn't its numeric value, convert
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }

            return token || EOF;
        }

        function fastLex() {
            var token = lexer.fastLex();
            // if token isn't its numeric value, convert
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }

            return token || EOF;
        }

        var lex = stdLex;

        var state, action, r, t;
        var yyval = {
            $: true,
            _$: undefined,
            yy: sharedState_yy
        };
        var p;
        var yyrulelen;
        var this_production;
        var newState;
        var retval = false;

        // Return the rule stack depth where the nearest error rule can be found.
        // Return -1 when no error recovery rule was found.
        function locateNearestErrorRecoveryRule(state) {
            var stack_probe = sp - 1;
            var depth = 0;

            // try to recover from error
            while (stack_probe >= 0) {
                // check for error recovery rule in this state


                var t = table[state][TERROR] || NO_ACTION;
                if (t[0]) {
                    // We need to make sure we're not cycling forever:
                    // once we hit EOF, even when we `yyerrok()` an error, we must
                    // prevent the core from running forever,
                    // e.g. when parent rules are still expecting certain input to
                    // follow after this, for example when you handle an error inside a set
                    // of braces which are matched by a parent rule in your grammar.
                    //
                    // Hence we require that every error handling/recovery attempt
                    // *after we've hit EOF* has a diminishing state stack: this means
                    // we will ultimately have unwound the state stack entirely and thus
                    // terminate the parse in a controlled fashion even when we have
                    // very complex error/recovery code interplay in the core + user
                    // action code blocks:


                    if (symbol === EOF) {
                        if (lastEofErrorStateDepth > sp - 1 - depth) {
                            lastEofErrorStateDepth = sp - 1 - depth;
                        } else {

                            --stack_probe; // popStack(1): [symbol, action]
                            state = sstack[stack_probe];
                            ++depth;
                            continue;
                        }
                    }
                    return depth;
                }
                if (state === 0 /* $accept rule */ || stack_probe < 1) {

                    return -1; // No suitable error recovery rule available.
                }
                --stack_probe; // popStack(1): [symbol, action]
                state = sstack[stack_probe];
                ++depth;
            }

            return -1; // No suitable error recovery rule available.
        }

        try {
            this.__reentrant_call_depth++;

            lexer.setInput(input, sharedState_yy);

            // NOTE: we *assume* no lexer pre/post handlers are set up *after* 
            // this initial `setInput()` call: hence we can now check and decide
            // whether we'll go with the standard, slower, lex() API or the
            // `fast_lex()` one:
            if (typeof lexer.canIUse === 'function') {
                var lexerInfo = lexer.canIUse();
                if (lexerInfo.fastLex && typeof fastLex === 'function') {
                    lex = fastLex;
                }
            }

            yyloc = lexer.yylloc;
            lstack[sp] = yyloc;
            vstack[sp] = null;
            sstack[sp] = 0;
            stack[sp] = 0;
            ++sp;

            if (this.pre_parse) {
                this.pre_parse.call(this, sharedState_yy);
            }
            if (sharedState_yy.pre_parse) {
                sharedState_yy.pre_parse.call(this, sharedState_yy);
            }

            newState = sstack[sp - 1];
            for (;;) {
                // retrieve state number from top of stack
                state = newState; // sstack[sp - 1];

                // use default actions if available
                if (this.defaultActions[state]) {
                    action = 2;
                    newState = this.defaultActions[state];
                } else {
                    // The single `==` condition below covers both these `===` comparisons in a single
                    // operation:
                    //
                    //     if (symbol === null || typeof symbol === 'undefined') ...
                    if (!symbol) {
                        symbol = lex();
                    }
                    // read action for current state and first input
                    t = table[state] && table[state][symbol] || NO_ACTION;
                    newState = t[1];
                    action = t[0];

                    // handle parse error
                    if (!action) {
                        // first see if there's any chance at hitting an error recovery rule:
                        var error_rule_depth = locateNearestErrorRecoveryRule(state);
                        var errStr = null;
                        var errSymbolDescr = this.describeSymbol(symbol) || symbol;
                        var expected = this.collect_expected_token_set(state);

                        if (!recovering) {
                            // Report error
                            if (typeof lexer.yylineno === 'number') {
                                errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';
                            } else {
                                errStr = 'Parse error: ';
                            }

                            if (typeof lexer.showPosition === 'function') {
                                errStr += '\n' + lexer.showPosition(79 - 10, 10) + '\n';
                            }
                            if (expected.length) {
                                errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;
                            } else {
                                errStr += 'Unexpected ' + errSymbolDescr;
                            }

                            p = this.constructParseErrorInfo(errStr, null, expected, error_rule_depth >= 0);

                            // DO NOT cleanup the old one before we start the new error info track:
                            // the old one will *linger* on the error stack and stay alive until we 
                            // invoke the parser's cleanup API!
                            recoveringErrorInfo = this.shallowCopyErrorInfo(p);

                            r = this.parseError(p.errStr, p, this.JisonParserError);

                            // Protect against overly blunt userland `parseError` code which *sets*
                            // the `recoverable` flag without properly checking first:
                            // we always terminate the parse when there's no recovery rule available anyhow!
                            if (!p.recoverable || error_rule_depth < 0) {
                                if (typeof r !== 'undefined') {
                                    retval = r;
                                }
                                break;
                            } else {
                                // TODO: allow parseError callback to edit symbol and or state at the start of the error recovery process...
                            }
                        }

                        var esp = recoveringErrorInfo.info_stack_pointer;

                        // just recovered from another error
                        if (recovering === ERROR_RECOVERY_TOKEN_DISCARD_COUNT && error_rule_depth >= 0) {
                            // SHIFT current lookahead and grab another
                            recoveringErrorInfo.symbol_stack[esp] = symbol;
                            recoveringErrorInfo.value_stack[esp] = shallow_copy(lexer.yytext);
                            recoveringErrorInfo.location_stack[esp] = copy_yylloc(lexer.yylloc);
                            recoveringErrorInfo.state_stack[esp] = newState; // push state
                            ++esp;

                            // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:


                            yyloc = lexer.yylloc;

                            preErrorSymbol = 0;
                            symbol = lex();
                        }

                        // try to recover from error
                        if (error_rule_depth < 0) {
                            ASSERT(recovering > 0, "line 897");
                            recoveringErrorInfo.info_stack_pointer = esp;

                            // barf a fatal hairball when we're out of look-ahead symbols and none hit a match
                            // while we are still busy recovering from another error:
                            var po = this.__error_infos[this.__error_infos.length - 1];

                            // Report error
                            if (typeof lexer.yylineno === 'number') {
                                errStr = 'Parsing halted on line ' + (lexer.yylineno + 1) + ' while starting to recover from another error';
                            } else {
                                errStr = 'Parsing halted while starting to recover from another error';
                            }

                            if (po) {
                                errStr += ' -- previous error which resulted in this fatal result: ' + po.errStr;
                            } else {
                                errStr += ': ';
                            }

                            if (typeof lexer.showPosition === 'function') {
                                errStr += '\n' + lexer.showPosition(79 - 10, 10) + '\n';
                            }
                            if (expected.length) {
                                errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;
                            } else {
                                errStr += 'Unexpected ' + errSymbolDescr;
                            }

                            p = this.constructParseErrorInfo(errStr, null, expected, false);
                            if (po) {
                                p.extra_error_attributes = po;
                            }

                            r = this.parseError(p.errStr, p, this.JisonParserError);
                            if (typeof r !== 'undefined') {
                                retval = r;
                            }
                            break;
                        }

                        preErrorSymbol = symbol === TERROR ? 0 : symbol; // save the lookahead token
                        symbol = TERROR; // insert generic error symbol as new lookahead

                        var EXTRA_STACK_SAMPLE_DEPTH = 3;

                        // REDUCE/COMBINE the pushed terms/tokens to a new ERROR token:
                        recoveringErrorInfo.symbol_stack[esp] = preErrorSymbol;
                        if (errStr) {
                            recoveringErrorInfo.value_stack[esp] = {
                                yytext: shallow_copy(lexer.yytext),
                                errorRuleDepth: error_rule_depth,
                                errStr: errStr,
                                errorSymbolDescr: errSymbolDescr,
                                expectedStr: expected,
                                stackSampleLength: error_rule_depth + EXTRA_STACK_SAMPLE_DEPTH
                            };
                        } else {
                            recoveringErrorInfo.value_stack[esp] = {
                                yytext: shallow_copy(lexer.yytext),
                                errorRuleDepth: error_rule_depth,
                                stackSampleLength: error_rule_depth + EXTRA_STACK_SAMPLE_DEPTH
                            };
                        }
                        recoveringErrorInfo.location_stack[esp] = copy_yylloc(lexer.yylloc);
                        recoveringErrorInfo.state_stack[esp] = newState || NO_ACTION[1];

                        ++esp;
                        recoveringErrorInfo.info_stack_pointer = esp;

                        yyval.$ = recoveringErrorInfo;
                        yyval._$ = undefined;

                        yyrulelen = error_rule_depth;

                        r = this.performAction.call(yyval, yyloc, NO_ACTION[1], sp - 1, vstack, lstack);

                        if (typeof r !== 'undefined') {
                            retval = r;
                            break;
                        }

                        // pop off stack
                        sp -= yyrulelen;

                        // and move the top entries + discarded part of the parse stacks onto the error info stack:
                        for (var idx = sp - EXTRA_STACK_SAMPLE_DEPTH, top = idx + yyrulelen; idx < top; idx++, esp++) {
                            recoveringErrorInfo.symbol_stack[esp] = stack[idx];
                            recoveringErrorInfo.value_stack[esp] = shallow_copy(vstack[idx]);
                            recoveringErrorInfo.location_stack[esp] = copy_yylloc(lstack[idx]);
                            recoveringErrorInfo.state_stack[esp] = sstack[idx];
                        }

                        recoveringErrorInfo.symbol_stack[esp] = TERROR;
                        recoveringErrorInfo.value_stack[esp] = shallow_copy(yyval.$);
                        recoveringErrorInfo.location_stack[esp] = copy_yylloc(yyval._$);

                        // goto new state = table[STATE][NONTERMINAL]
                        newState = sstack[sp - 1];

                        if (this.defaultActions[newState]) {
                            recoveringErrorInfo.state_stack[esp] = this.defaultActions[newState];
                        } else {
                            t = table[newState] && table[newState][symbol] || NO_ACTION;
                            recoveringErrorInfo.state_stack[esp] = t[1];
                        }

                        ++esp;
                        recoveringErrorInfo.info_stack_pointer = esp;

                        // allow N (default: 3) real symbols to be shifted before reporting a new error
                        recovering = ERROR_RECOVERY_TOKEN_DISCARD_COUNT;

                        // Now duplicate the standard parse machine here, at least its initial
                        // couple of rounds until the TERROR symbol is **pushed onto the parse stack**,
                        // as we wish to push something special then!
                        //
                        // Run the state machine in this copy of the parser state machine
                        // until we *either* consume the error symbol (and its related information)
                        // *or* we run into another error while recovering from this one
                        // *or* we execute a `reduce` action which outputs a final parse
                        // result (yes, that MAY happen!).
                        //
                        // We stay in this secondary parse loop until we have completed
                        // the *error recovery phase* as the main parse loop (further below)
                        // is optimized for regular parse operation and DOES NOT cope with
                        // error recovery *at all*.
                        //
                        // We call the secondary parse loop just below the "slow parse loop",
                        // while the main parse loop, which is an almost-duplicate of this one,
                        // yet optimized for regular parse operation, is called the "fast
                        // parse loop".
                        //
                        // Compare this to `bison` & (vanilla) `jison`, both of which have
                        // only a single parse loop, which handles everything. Our goal is
                        // to eke out every drop of performance in the main parse loop...

                        ASSERT(recoveringErrorInfo, "line 1049");
                        ASSERT(symbol === TERROR, "line 1050");
                        ASSERT(!action, "line 1051");
                        var errorSymbolFromParser = true;
                        for (;;) {
                            // retrieve state number from top of stack
                            state = newState; // sstack[sp - 1];

                            // use default actions if available
                            if (this.defaultActions[state]) {
                                action = 2;
                                newState = this.defaultActions[state];
                            } else {
                                // The single `==` condition below covers both these `===` comparisons in a single
                                // operation:
                                //
                                //     if (symbol === null || typeof symbol === 'undefined') ...
                                if (!symbol) {
                                    symbol = lex();
                                    // **Warning: Edge Case**: the *lexer* may produce
                                    // TERROR tokens of its own volition: *those* TERROR
                                    // tokens should be treated like *regular tokens*
                                    // i.e. tokens which have a lexer-provided `yyvalue`
                                    // and `yylloc`:
                                    errorSymbolFromParser = false;
                                }
                                // read action for current state and first input
                                t = table[state] && table[state][symbol] || NO_ACTION;
                                newState = t[1];
                                action = t[0];

                                // encountered another parse error? If so, break out to main loop
                                // and take it from there!
                                if (!action) {

                                    ASSERT(recoveringErrorInfo, "line 1087");

                                    // Prep state variables so that upon breaking out of
                                    // this "slow parse loop" and hitting the `continue;`
                                    // statement in the outer "fast parse loop" we redo
                                    // the exact same state table lookup as the one above
                                    // so that the outer=main loop will also correctly
                                    // detect the 'parse error' state (`!action`) we have
                                    // just encountered above.
                                    newState = state;
                                    break;
                                }
                            }

                            switch (action) {
                                // catch misc. parse failures:
                                default:
                                    // this shouldn't happen, unless resolve defaults are off
                                    //
                                    // SILENTLY SIGNAL that the outer "fast parse loop" should
                                    // take care of this internal error condition:
                                    // prevent useless code duplication now/here.
                                    break;

                                // shift:
                                case 1:
                                    stack[sp] = symbol;
                                    // ### Note/Warning ###
                                    //
                                    // The *lexer* may also produce TERROR tokens on its own,
                                    // so we specifically test for the TERROR we did set up
                                    // in the error recovery logic further above!
                                    if (symbol === TERROR && errorSymbolFromParser) {
                                        // Push a special value onto the stack when we're
                                        // shifting the `error` symbol that is related to the
                                        // error we're recovering from.
                                        ASSERT(recoveringErrorInfo, "line 1131");
                                        vstack[sp] = recoveringErrorInfo;
                                        lstack[sp] = this.yyMergeLocationInfo(null, null, recoveringErrorInfo.loc, lexer.yylloc, true);
                                    } else {
                                        ASSERT(symbol !== 0, "line 1135");
                                        ASSERT(preErrorSymbol === 0, "line 1136");
                                        vstack[sp] = lexer.yytext;
                                        lstack[sp] = copy_yylloc(lexer.yylloc);
                                    }
                                    sstack[sp] = newState; // push state

                                    ++sp;
                                    symbol = 0;
                                    // **Warning: Edge Case**: the *lexer* may have produced
                                    // TERROR tokens of its own volition: *those* TERROR
                                    // tokens should be treated like *regular tokens*
                                    // i.e. tokens which have a lexer-provided `yyvalue`
                                    // and `yylloc`:
                                    errorSymbolFromParser = false;
                                    if (!preErrorSymbol) {
                                        // normal execution / no error
                                        // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:


                                        yyloc = lexer.yylloc;

                                        if (recovering > 0) {
                                            recovering--;
                                        }
                                    } else {
                                        // error just occurred, resume old lookahead f/ before error, *unless* that drops us straight back into error mode:
                                        ASSERT(recovering > 0, "line 1163");
                                        symbol = preErrorSymbol;
                                        preErrorSymbol = 0;

                                        // read action for current state and first input
                                        t = table[newState] && table[newState][symbol] || NO_ACTION;
                                        if (!t[0] || symbol === TERROR) {
                                            // forget about that symbol and move forward: this wasn't a 'forgot to insert' error type where
                                            // (simple) stuff might have been missing before the token which caused the error we're
                                            // recovering from now...
                                            //
                                            // Also check if the LookAhead symbol isn't the ERROR token we set as part of the error
                                            // recovery, for then this we would we idling (cycling) on the error forever.
                                            // Yes, this does not take into account the possibility that the *lexer* may have
                                            // produced a *new* TERROR token all by itself, but that would be a very peculiar grammar!


                                            symbol = 0;
                                        }
                                    }

                                    // once we have pushed the special ERROR token value,
                                    // we REMAIN in this inner, "slow parse loop" until
                                    // the entire error recovery phase has completed.
                                    //
                                    // ### Note About Edge Case ###
                                    //
                                    // Userland action code MAY already have 'reset' the
                                    // error recovery phase marker `recovering` to ZERO(0)
                                    // while the error symbol hasn't been shifted onto
                                    // the stack yet. Hence we only exit this "slow parse loop"
                                    // when *both* conditions are met!
                                    ASSERT(preErrorSymbol === 0, "line 1194");
                                    if (recovering === 0) {
                                        break;
                                    }
                                    continue;

                                // reduce:
                                case 2:
                                    this_production = this.productions_[newState - 1]; // `this.productions_[]` is zero-based indexed while states start from 1 upwards...
                                    yyrulelen = this_production[1];

                                    r = this.performAction.call(yyval, yyloc, newState, sp - 1, vstack, lstack);

                                    if (typeof r !== 'undefined') {
                                        // signal end of error recovery loop AND end of outer parse loop
                                        action = 3;
                                        sp = -2; // magic number: signal outer "fast parse loop" ACCEPT state that we already have a properly set up `retval` parser return value.
                                        retval = r;
                                        break;
                                    }

                                    // pop off stack
                                    sp -= yyrulelen;

                                    // don't overwrite the `symbol` variable: use a local var to speed things up:
                                    var ntsymbol = this_production[0]; // push nonterminal (reduce)
                                    stack[sp] = ntsymbol;
                                    vstack[sp] = yyval.$;
                                    lstack[sp] = yyval._$;
                                    // goto new state = table[STATE][NONTERMINAL]
                                    newState = table[sstack[sp - 1]][ntsymbol];
                                    sstack[sp] = newState;
                                    ++sp;

                                    continue;

                                // accept:
                                case 3:
                                    retval = true;
                                    // Return the `$accept` rule's `$$` result, if available.
                                    //
                                    // Also note that JISON always adds this top-most `$accept` rule (with implicit,
                                    // default, action):
                                    //
                                    //     $accept: <startSymbol> $end
                                    //                  %{ $$ = $1; @$ = @1; %}
                                    //
                                    // which, combined with the parse kernel's `$accept` state behaviour coded below,
                                    // will produce the `$$` value output of the <startSymbol> rule as the parse result,
                                    // IFF that result is *not* `undefined`. (See also the parser kernel code.)
                                    //
                                    // In code:
                                    //
                                    //                  %{
                                    //                      @$ = @1;            // if location tracking support is included
                                    //                      if (typeof $1 !== 'undefined')
                                    //                          return $1;
                                    //                      else
                                    //                          return true;           // the default parse result if the rule actions don't produce anything
                                    //                  %}
                                    sp--;
                                    if (sp >= 0 && typeof vstack[sp] !== 'undefined') {
                                        retval = vstack[sp];
                                    }
                                    sp = -2; // magic number: signal outer "fast parse loop" ACCEPT state that we already have a properly set up `retval` parser return value.
                                    break;
                            }

                            // break out of loop: we accept or fail with error
                            break;
                        }

                        // should we also break out of the regular/outer parse loop,
                        // i.e. did the parser already produce a parse result in here?!
                        // *or* did we hit an unsupported parse state, to be handled
                        // in the `switch/default` code further below?
                        ASSERT(action !== 2, "line 1272");
                        if (action === 0 || action === 1) {
                            continue;
                        }
                    }
                }

                switch (action) {
                    // catch misc. parse failures:
                    default:
                        // this shouldn't happen, unless resolve defaults are off
                        if (action instanceof Array) {
                            p = this.constructParseErrorInfo('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, null, null, false);
                            r = this.parseError(p.errStr, p, this.JisonParserError);
                            if (typeof r !== 'undefined') {
                                retval = r;
                            }
                            break;
                        }
                        // Another case of better safe than sorry: in case state transitions come out of another error recovery process
                        // or a buggy LUT (LookUp Table):
                        p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);
                        r = this.parseError(p.errStr, p, this.JisonParserError);
                        if (typeof r !== 'undefined') {
                            retval = r;
                        }
                        break;

                    // shift:
                    case 1:
                        stack[sp] = symbol;
                        vstack[sp] = lexer.yytext;
                        lstack[sp] = copy_yylloc(lexer.yylloc);
                        sstack[sp] = newState; // push state

                        ++sp;
                        symbol = 0;

                        ASSERT(preErrorSymbol === 0, "line 1352"); // normal execution / no error
                        ASSERT(recovering === 0, "line 1353"); // normal execution / no error

                        // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:


                        yyloc = lexer.yylloc;
                        continue;

                    // reduce:
                    case 2:
                        ASSERT(preErrorSymbol === 0, "line 1364"); // normal execution / no error
                        ASSERT(recovering === 0, "line 1365"); // normal execution / no error

                        this_production = this.productions_[newState - 1]; // `this.productions_[]` is zero-based indexed while states start from 1 upwards...
                        yyrulelen = this_production[1];

                        r = this.performAction.call(yyval, yyloc, newState, sp - 1, vstack, lstack);

                        if (typeof r !== 'undefined') {
                            retval = r;
                            break;
                        }

                        // pop off stack
                        sp -= yyrulelen;

                        // don't overwrite the `symbol` variable: use a local var to speed things up:
                        var ntsymbol = this_production[0]; // push nonterminal (reduce)
                        stack[sp] = ntsymbol;
                        vstack[sp] = yyval.$;
                        lstack[sp] = yyval._$;
                        // goto new state = table[STATE][NONTERMINAL]
                        newState = table[sstack[sp - 1]][ntsymbol];
                        sstack[sp] = newState;
                        ++sp;

                        continue;

                    // accept:
                    case 3:
                        if (sp !== -2) {
                            retval = true;
                            // Return the `$accept` rule's `$$` result, if available.
                            //
                            // Also note that JISON always adds this top-most `$accept` rule (with implicit,
                            // default, action):
                            //
                            //     $accept: <startSymbol> $end
                            //                  %{ $$ = $1; @$ = @1; %}
                            //
                            // which, combined with the parse kernel's `$accept` state behaviour coded below,
                            // will produce the `$$` value output of the <startSymbol> rule as the parse result,
                            // IFF that result is *not* `undefined`. (See also the parser kernel code.)
                            //
                            // In code:
                            //
                            //                  %{
                            //                      @$ = @1;            // if location tracking support is included
                            //                      if (typeof $1 !== 'undefined')
                            //                          return $1;
                            //                      else
                            //                          return true;           // the default parse result if the rule actions don't produce anything
                            //                  %}
                            sp--;
                            if (typeof vstack[sp] !== 'undefined') {
                                retval = vstack[sp];
                            }
                        }
                        break;
                }

                // break out of loop: we accept or fail with error
                break;
            }
        } catch (ex) {
            // report exceptions through the parseError callback too, but keep the exception intact
            // if it is a known parser or lexer error which has been thrown by parseError() already:
            if (ex instanceof this.JisonParserError) {
                throw ex;
            } else if (lexer && typeof lexer.JisonLexerError === 'function' && ex instanceof lexer.JisonLexerError) {
                throw ex;
            } else {
                p = this.constructParseErrorInfo('Parsing aborted due to exception.', ex, null, false);
                retval = false;
                r = this.parseError(p.errStr, p, this.JisonParserError);
                if (typeof r !== 'undefined') {
                    retval = r;
                }
            }
        } finally {
            retval = this.cleanupAfterParse(retval, true, true);
            this.__reentrant_call_depth--;
        } // /finally

        return retval;
    },
    yyError: 1
};
parser$1.originalParseError = parser$1.parseError;
parser$1.originalQuoteName = parser$1.quoteName;
/* lexer generated by jison-lex 0.6.1-210 */

/*
 * Returns a Lexer object of the following structure:
 *
 *  Lexer: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a direct reference!
 *
 *               This "shared context" object was passed to the lexer by way of 
 *               the `lexer.setInput(str, yy)` API before you may use it.
 *
 *               This "shared context" object is passed to the lexer action code in `performAction()`
 *               so userland code in the lexer actions may communicate with the outside world 
 *               and/or other lexer rules' actions in more or less complex ways.
 *
 *  }
 *
 *  Lexer.prototype: {
 *    EOF: 1,
 *    ERROR: 2,
 *
 *    yy:        The overall "shared context" object reference.
 *
 *    JisonLexerError: function(msg, hash),
 *
 *    performAction: function lexer__performAction(yy, yyrulenumber, YY_START),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `lexer` instance. 
 *                               `yy_` is an alias for `this` lexer instance reference used internally.
 *
 *               - `yy`      : a reference to the `yy` "shared state" object which was passed to the lexer
 *                             by way of the `lexer.setInput(str, yy)` API before.
 *
 *                             Note:
 *                             The extra arguments you specified in the `%parse-param` statement in your
 *                             **parser** grammar definition file are passed to the lexer via this object
 *                             reference as member variables.
 *
 *               - `yyrulenumber`   : index of the matched lexer rule (regex), used internally.
 *
 *               - `YY_START`: the current lexer "start condition" state.
 *
 *    parseError: function(str, hash, ExceptionClass),
 *
 *    constructLexErrorInfo: function(error_message, is_recoverable),
 *               Helper function.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this lexer kernel in many places; example usage:
 *
 *                   var infoObj = lexer.constructParseErrorInfo('fail!', true);
 *                   var retVal = lexer.parseError(infoObj.errStr, infoObj, lexer.JisonLexerError);
 *
 *    options: { ... lexer %options ... },
 *
 *    lex: function(),
 *               Produce one token of lexed input, which was passed in earlier via the `lexer.setInput()` API.
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of the **lexer** grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Lexer's additional `args...` parameters (via lexer's `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the **parser** or the jison run-time; 
 *               when such a collision is detected an exception is thrown to prevent the generated run-time 
 *               from silently accepting this confusing and potentially hazardous situation! 
 *
 *    cleanupAfterLex: function(do_not_nuke_errorinfos),
 *               Helper function.
 *
 *               This helper API is invoked when the **parse process** has completed: it is the responsibility
 *               of the **parser** (or the calling userland code) to invoke this method once cleanup is desired. 
 *
 *               This helper may be invoked by user code to ensure the internal lexer gets properly garbage collected.
 *
 *    setInput: function(input, [yy]),
 *
 *
 *    input: function(),
 *
 *
 *    unput: function(str),
 *
 *
 *    more: function(),
 *
 *
 *    reject: function(),
 *
 *
 *    less: function(n),
 *
 *
 *    pastInput: function(n),
 *
 *
 *    upcomingInput: function(n),
 *
 *
 *    showPosition: function(),
 *
 *
 *    test_match: function(regex_match_array, rule_index),
 *
 *
 *    next: function(),
 *
 *
 *    begin: function(condition),
 *
 *
 *    pushState: function(condition),
 *
 *
 *    popState: function(),
 *
 *
 *    topState: function(),
 *
 *
 *    _currentRules: function(),
 *
 *
 *    stateStackSize: function(),
 *
 *
 *    performAction: function(yy, yy_, yyrulenumber, YY_START),
 *
 *
 *    rules: [...],
 *
 *
 *    conditions: {associative list: name ==> set},
 *  }
 *
 *
 *  token location info (`yylloc`): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *  }
 *
 * while `this` will reference the current lexer instance.
 *
 * When `parseError` is invoked by the lexer, the default implementation will
 * attempt to invoke `yy.parser.parseError()`; when this callback is not provided
 * it will try to invoke `yy.parseError()` instead. When that callback is also not
 * provided, a `JisonLexerError` exception will be thrown containing the error
 * message and `hash`, as constructed by the `constructLexErrorInfo()` API.
 *
 * Note that the lexer's `JisonLexerError` error class is passed via the
 * `ExceptionClass` argument, which is invoked to construct the exception
 * instance to be thrown, so technically `parseError` will throw the object
 * produced by the `new ExceptionClass(str, hash)` JavaScript expression.
 *
 * ---
 *
 * You can specify lexer options by setting / modifying the `.options` object of your Lexer instance.
 * These options are available:
 *
 * (Options are permanent.)
 *  
 *  yy: {
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *  }
 *
 *  lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 * WARNING: the next set of options are not meant to be changed. They echo the abilities of
 * the lexer as per when it was compiled!
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this %option has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */

var lexer = function () {
    /**
     * See also:
     * http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
     * but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
     * with userland code which might access the derived class in a 'classic' way.
     *
     * @public
     * @constructor
     * @nocollapse
     */
    function JisonLexerError(msg, hash) {
        Object.defineProperty(this, 'name', {
            enumerable: false,
            writable: false,
            value: 'JisonLexerError'
        });

        if (msg == null) msg = '???';

        Object.defineProperty(this, 'message', {
            enumerable: false,
            writable: true,
            value: msg
        });

        this.hash = hash;
        var stacktrace;

        if (hash && hash.exception instanceof Error) {
            var ex2 = hash.exception;
            this.message = ex2.message || msg;
            stacktrace = ex2.stack;
        }

        if (!stacktrace) {
            if (Error.hasOwnProperty('captureStackTrace')) {
                // V8
                Error.captureStackTrace(this, this.constructor);
            } else {
                stacktrace = new Error(msg).stack;
            }
        }

        if (stacktrace) {
            Object.defineProperty(this, 'stack', {
                enumerable: false,
                writable: false,
                value: stacktrace
            });
        }
    }

    if (typeof Object.setPrototypeOf === 'function') {
        Object.setPrototypeOf(JisonLexerError.prototype, Error.prototype);
    } else {
        JisonLexerError.prototype = Object.create(Error.prototype);
    }

    JisonLexerError.prototype.constructor = JisonLexerError;
    JisonLexerError.prototype.name = 'JisonLexerError';

    var lexer = {

        // Code Generator Information Report
        // ---------------------------------
        //
        // Options:
        //
        //   backtracking: .................... false
        //   location.ranges: ................. true
        //   location line+column tracking: ... true
        //
        //
        // Forwarded Parser Analysis flags:
        //
        //   uses yyleng: ..................... false
        //   uses yylineno: ................... false
        //   uses yytext: ..................... false
        //   uses yylloc: ..................... false
        //   uses lexer values: ............... true / true
        //   location tracking: ............... true
        //   location assignment: ............. true
        //
        //
        // Lexer Analysis flags:
        //
        //   uses yyleng: ..................... ???
        //   uses yylineno: ................... ???
        //   uses yytext: ..................... ???
        //   uses yylloc: ..................... ???
        //   uses ParseError API: ............. ???
        //   uses yyerror: .................... ???
        //   uses location tracking & editing:  ???
        //   uses more() API: ................. ???
        //   uses unput() API: ................ ???
        //   uses reject() API: ............... ???
        //   uses less() API: ................. ???
        //   uses display APIs pastInput(), upcomingInput(), showPosition():
        //        ............................. ???
        //   uses describeYYLLOC() API: ....... ???
        //
        // --------- END OF REPORT -----------

        EOF: 1,
        ERROR: 2,

        // JisonLexerError: JisonLexerError,        /// <-- injected by the code generator

        // options: {},                             /// <-- injected by the code generator

        // yy: ...,                                 /// <-- injected by setInput()

        __currentRuleSet__: null, /// INTERNAL USE ONLY: internal rule set cache for the current lexer state  

        __error_infos: [], /// INTERNAL USE ONLY: the set of lexErrorInfo objects created since the last cleanup  
        __decompressed: false, /// INTERNAL USE ONLY: mark whether the lexer instance has been 'unfolded' completely and is now ready for use  
        done: false, /// INTERNAL USE ONLY  
        _backtrack: false, /// INTERNAL USE ONLY  
        _input: '', /// INTERNAL USE ONLY  
        _more: false, /// INTERNAL USE ONLY  
        _signaled_error_token: false, /// INTERNAL USE ONLY  
        conditionStack: [], /// INTERNAL USE ONLY; managed via `pushState()`, `popState()`, `topState()` and `stateStackSize()`  
        match: '', /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction. `match` is identical to `yytext` except that this one still contains the matched input string after `lexer.performAction()` has been invoked, where userland code MAY have changed/replaced the `yytext` value entirely!  
        matched: '', /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks entire input which has been matched so far  
        matches: false, /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks RE match result for last (successful) match attempt  
        yytext: '', /// ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction; this value is transferred to the parser as the 'token value' when the parser consumes the lexer token produced through a call to the `lex()` API.  
        offset: 0, /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks the 'cursor position' in the input string, i.e. the number of characters matched so far  
        yyleng: 0, /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: length of matched input for the token under construction (`yytext`)  
        yylineno: 0, /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: 'line number' at which the token under construction is located  
        yylloc: null, /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks location info (lines + columns) for the token under construction  

        /**
         * INTERNAL USE: construct a suitable error info hash object instance for `parseError`.
         * 
         * @public
         * @this {RegExpLexer}
         */
        constructLexErrorInfo: function lexer_constructLexErrorInfo(msg, recoverable, show_input_position) {
            msg = '' + msg;

            // heuristic to determine if the error message already contains a (partial) source code dump
            // as produced by either `showPosition()` or `prettyPrintRange()`:
            if (show_input_position == undefined) {
                show_input_position = !(msg.indexOf('\n') > 0 && msg.indexOf('^') > 0);
            }

            if (this.yylloc && show_input_position) {
                if (typeof this.prettyPrintRange === 'function') {
                    var pretty_src = this.prettyPrintRange(this.yylloc);

                    if (!/\n\s*$/.test(msg)) {
                        msg += '\n';
                    }

                    msg += '\n  Erroneous area:\n' + this.prettyPrintRange(this.yylloc);
                } else if (typeof this.showPosition === 'function') {
                    var pos_str = this.showPosition();

                    if (pos_str) {
                        if (msg.length && msg[msg.length - 1] !== '\n' && pos_str[0] !== '\n') {
                            msg += '\n' + pos_str;
                        } else {
                            msg += pos_str;
                        }
                    }
                }
            }

            /** @constructor */
            var pei = {
                errStr: msg,
                recoverable: !!recoverable,
                text: this.match, // This one MAY be empty; userland code should use the `upcomingInput` API to obtain more text which follows the 'lexer cursor position'...  
                token: null,
                line: this.yylineno,
                loc: this.yylloc,
                yy: this.yy,
                lexer: this,

                /**
                 * and make sure the error info doesn't stay due to potential
                 * ref cycle via userland code manipulations.
                 * These would otherwise all be memory leak opportunities!
                 * 
                 * Note that only array and object references are nuked as those
                 * constitute the set of elements which can produce a cyclic ref.
                 * The rest of the members is kept intact as they are harmless.
                 * 
                 * @public
                 * @this {LexErrorInfo}
                 */
                destroy: function destructLexErrorInfo() {
                    // remove cyclic references added to error info:
                    // info.yy = null;
                    // info.lexer = null;
                    // ...
                    var rec = !!this.recoverable;

                    for (var key in this) {
                        if (this.hasOwnProperty(key) && (typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {
                            this[key] = undefined;
                        }
                    }

                    this.recoverable = rec;
                }
            };

            // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
            this.__error_infos.push(pei);

            return pei;
        },

        /**
         * handler which is invoked when a lexer error occurs.
         * 
         * @public
         * @this {RegExpLexer}
         */
        parseError: function lexer_parseError(str, hash, ExceptionClass) {
            if (!ExceptionClass) {
                ExceptionClass = this.JisonLexerError;
            }

            if (this.yy) {
                if (this.yy.parser && typeof this.yy.parser.parseError === 'function') {
                    return this.yy.parser.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
                } else if (typeof this.yy.parseError === 'function') {
                    return this.yy.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
                }
            }

            throw new ExceptionClass(str, hash);
        },

        /**
         * method which implements `yyerror(str, ...args)` functionality for use inside lexer actions.
         * 
         * @public
         * @this {RegExpLexer}
         */
        yyerror: function yyError(str /*, ...args */) {
            var lineno_msg = '';

            if (this.yylloc) {
                lineno_msg = ' on line ' + (this.yylineno + 1);
            }

            var p = this.constructLexErrorInfo('Lexical error' + lineno_msg + ': ' + str, this.options.lexerErrorsAreRecoverable);

            // Add any extra args to the hash under the name `extra_error_attributes`:
            var args = Array.prototype.slice.call(arguments, 1);

            if (args.length) {
                p.extra_error_attributes = args;
            }

            return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
        },

        /**
         * final cleanup function for when we have completed lexing the input;
         * make it an API so that external code can use this one once userland
         * code has decided it's time to destroy any lingering lexer error
         * hash object instances and the like: this function helps to clean
         * up these constructs, which *may* carry cyclic references which would
         * otherwise prevent the instances from being properly and timely
         * garbage-collected, i.e. this function helps prevent memory leaks!
         * 
         * @public
         * @this {RegExpLexer}
         */
        cleanupAfterLex: function lexer_cleanupAfterLex(do_not_nuke_errorinfos) {
            // prevent lingering circular references from causing memory leaks:
            this.setInput('', {});

            // nuke the error hash info instances created during this run.
            // Userland code must COPY any data/references
            // in the error hash instance(s) it is more permanently interested in.
            if (!do_not_nuke_errorinfos) {
                for (var i = this.__error_infos.length - 1; i >= 0; i--) {
                    var el = this.__error_infos[i];

                    if (el && typeof el.destroy === 'function') {
                        el.destroy();
                    }
                }

                this.__error_infos.length = 0;
            }

            return this;
        },

        /**
         * clear the lexer token context; intended for internal use only
         * 
         * @public
         * @this {RegExpLexer}
         */
        clear: function lexer_clear() {
            this.yytext = '';
            this.yyleng = 0;
            this.match = '';

            // - DO NOT reset `this.matched`
            this.matches = false;

            this._more = false;
            this._backtrack = false;
            var col = this.yylloc ? this.yylloc.last_column : 0;

            this.yylloc = {
                first_line: this.yylineno + 1,
                first_column: col,
                last_line: this.yylineno + 1,
                last_column: col,
                range: [this.offset, this.offset]
            };
        },

        /**
         * resets the lexer, sets new input
         * 
         * @public
         * @this {RegExpLexer}
         */
        setInput: function lexer_setInput(input, yy) {
            this.yy = yy || this.yy || {};

            // also check if we've fully initialized the lexer instance,
            // including expansion work to be done to go from a loaded
            // lexer to a usable lexer:
            if (!this.__decompressed) {
                // step 1: decompress the regex list:
                var rules = this.rules;

                for (var i = 0, len = rules.length; i < len; i++) {
                    var rule_re = rules[i];

                    // compression: is the RE an xref to another RE slot in the rules[] table?
                    if (typeof rule_re === 'number') {
                        rules[i] = rules[rule_re];
                    }
                }

                // step 2: unfold the conditions[] set to make these ready for use:
                var conditions = this.conditions;

                for (var k in conditions) {
                    var spec = conditions[k];
                    var rule_ids = spec.rules;
                    var len = rule_ids.length;
                    var rule_regexes = new Array(len + 1); // slot 0 is unused; we use a 1-based index approach here to keep the hottest code in `lexer_next()` fast and simple! 
                    var rule_new_ids = new Array(len + 1);

                    for (var i = 0; i < len; i++) {
                        var idx = rule_ids[i];
                        var rule_re = rules[idx];
                        rule_regexes[i + 1] = rule_re;
                        rule_new_ids[i + 1] = idx;
                    }

                    spec.rules = rule_new_ids;
                    spec.__rule_regexes = rule_regexes;
                    spec.__rule_count = len;
                }

                this.__decompressed = true;
            }

            this._input = input || '';
            this.clear();
            this._signaled_error_token = false;
            this.done = false;
            this.yylineno = 0;
            this.matched = '';
            this.conditionStack = ['INITIAL'];
            this.__currentRuleSet__ = null;

            this.yylloc = {
                first_line: 1,
                first_column: 0,
                last_line: 1,
                last_column: 0,
                range: [0, 0]
            };

            this.offset = 0;
            return this;
        },

        /**
         * edit the remaining input via user-specified callback.
         * This can be used to forward-adjust the input-to-parse, 
         * e.g. inserting macro expansions and alike in the
         * input which has yet to be lexed.
         * The behaviour of this API contrasts the `unput()` et al
         * APIs as those act on the *consumed* input, while this
         * one allows one to manipulate the future, without impacting
         * the current `yyloc` cursor location or any history. 
         * 
         * Use this API to help implement C-preprocessor-like
         * `#include` statements, etc.
         * 
         * The provided callback must be synchronous and is
         * expected to return the edited input (string).
         *
         * The `cpsArg` argument value is passed to the callback
         * as-is.
         *
         * `callback` interface: 
         * `function callback(input, cpsArg)`
         * 
         * - `input` will carry the remaining-input-to-lex string
         *   from the lexer.
         * - `cpsArg` is `cpsArg` passed into this API.
         * 
         * The `this` reference for the callback will be set to
         * reference this lexer instance so that userland code
         * in the callback can easily and quickly access any lexer
         * API. 
         *
         * When the callback returns a non-string-type falsey value,
         * we assume the callback did not edit the input and we
         * will using the input as-is.
         *
         * When the callback returns a non-string-type value, it
         * is converted to a string for lexing via the `"" + retval`
         * operation. (See also why: http://2ality.com/2012/03/converting-to-string.html 
         * -- that way any returned object's `toValue()` and `toString()`
         * methods will be invoked in a proper/desirable order.)
         * 
         * @public
         * @this {RegExpLexer}
         */
        editRemainingInput: function lexer_editRemainingInput(callback, cpsArg) {
            var rv = callback.call(this, this._input, cpsArg);

            if (typeof rv !== 'string') {
                if (rv) {
                    this._input = '' + rv;
                }
                // else: keep `this._input` as is.  
            } else {
                this._input = rv;
            }

            return this;
        },

        /**
         * consumes and returns one char from the input
         * 
         * @public
         * @this {RegExpLexer}
         */
        input: function lexer_input() {
            if (!this._input) {
                //this.done = true;    -- don't set `done` as we want the lex()/next() API to be able to produce one custom EOF token match after this anyhow. (lexer can match special <<EOF>> tokens and perform user action code for a <<EOF>> match, but only does so *once*)
                return null;
            }

            var ch = this._input[0];
            this.yytext += ch;
            this.yyleng++;
            this.offset++;
            this.match += ch;
            this.matched += ch;

            // Count the linenumber up when we hit the LF (or a stand-alone CR).
            // On CRLF, the linenumber is incremented when you fetch the CR or the CRLF combo
            // and we advance immediately past the LF as well, returning both together as if
            // it was all a single 'character' only.
            var slice_len = 1;

            var lines = false;

            if (ch === '\n') {
                lines = true;
            } else if (ch === '\r') {
                lines = true;
                var ch2 = this._input[1];

                if (ch2 === '\n') {
                    slice_len++;
                    ch += ch2;
                    this.yytext += ch2;
                    this.yyleng++;
                    this.offset++;
                    this.match += ch2;
                    this.matched += ch2;
                    this.yylloc.range[1]++;
                }
            }

            if (lines) {
                this.yylineno++;
                this.yylloc.last_line++;
                this.yylloc.last_column = 0;
            } else {
                this.yylloc.last_column++;
            }

            this.yylloc.range[1]++;
            this._input = this._input.slice(slice_len);
            return ch;
        },

        /**
         * unshifts one char (or an entire string) into the input
         * 
         * @public
         * @this {RegExpLexer}
         */
        unput: function lexer_unput(ch) {
            var len = ch.length;
            var lines = ch.split(/(?:\r\n?|\n)/g);
            this._input = ch + this._input;
            this.yytext = this.yytext.substr(0, this.yytext.length - len);
            this.yyleng = this.yytext.length;
            this.offset -= len;
            this.match = this.match.substr(0, this.match.length - len);
            this.matched = this.matched.substr(0, this.matched.length - len);

            if (lines.length > 1) {
                this.yylineno -= lines.length - 1;
                this.yylloc.last_line = this.yylineno + 1;

                // Get last entirely matched line into the `pre_lines[]` array's
                // last index slot; we don't mind when other previously 
                // matched lines end up in the array too. 
                var pre = this.match;

                var pre_lines = pre.split(/(?:\r\n?|\n)/g);

                if (pre_lines.length === 1) {
                    pre = this.matched;
                    pre_lines = pre.split(/(?:\r\n?|\n)/g);
                }

                this.yylloc.last_column = pre_lines[pre_lines.length - 1].length;
            } else {
                this.yylloc.last_column -= len;
            }

            this.yylloc.range[1] = this.yylloc.range[0] + this.yyleng;
            this.done = false;
            return this;
        },

        /**
         * cache matched text and append it on next action
         * 
         * @public
         * @this {RegExpLexer}
         */
        more: function lexer_more() {
            this._more = true;
            return this;
        },

        /**
         * signal the lexer that this rule fails to match the input, so the
         * next matching rule (regex) should be tested instead.
         * 
         * @public
         * @this {RegExpLexer}
         */
        reject: function lexer_reject() {
            if (this.options.backtrack_lexer) {
                this._backtrack = true;
            } else {
                // when the `parseError()` call returns, we MUST ensure that the error is registered.
                // We accomplish this by signaling an 'error' token to be produced for the current
                // `.lex()` run.
                var lineno_msg = '';

                if (this.yylloc) {
                    lineno_msg = ' on line ' + (this.yylineno + 1);
                }

                var p = this.constructLexErrorInfo('Lexical error' + lineno_msg + ': You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).', false);

                this._signaled_error_token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
            }

            return this;
        },

        /**
         * retain first n characters of the match
         * 
         * @public
         * @this {RegExpLexer}
         */
        less: function lexer_less(n) {
            return this.unput(this.match.slice(n));
        },

        /**
         * return (part of the) already matched input, i.e. for error
         * messages.
         * 
         * Limit the returned string length to `maxSize` (default: 20).
         * 
         * Limit the returned string to the `maxLines` number of lines of
         * input (default: 1).
         * 
         * Negative limit values equal *unlimited*.
         * 
         * @public
         * @this {RegExpLexer}
         */
        pastInput: function lexer_pastInput(maxSize, maxLines) {
            var past = this.matched.substring(0, this.matched.length - this.match.length);

            if (maxSize < 0) maxSize = past.length;else if (!maxSize) maxSize = 20;

            if (maxLines < 0) maxLines = past.length; // can't ever have more input lines than this! 
            else if (!maxLines) maxLines = 1;

            // `substr` anticipation: treat \r\n as a single character and take a little
            // more than necessary so that we can still properly check against maxSize
            // after we've transformed and limited the newLines in here:
            past = past.substr(-maxSize * 2 - 2);

            // now that we have a significantly reduced string to process, transform the newlines
            // and chop them, then limit them:
            var a = past.replace(/\r\n|\r/g, '\n').split('\n');

            a = a.slice(-maxLines);
            past = a.join('\n');

            // When, after limiting to maxLines, we still have too much to return,
            // do add an ellipsis prefix...
            if (past.length > maxSize) {
                past = '...' + past.substr(-maxSize);
            }

            return past;
        },

        /**
         * return (part of the) upcoming input, i.e. for error messages.
         * 
         * Limit the returned string length to `maxSize` (default: 20).
         * 
         * Limit the returned string to the `maxLines` number of lines of input (default: 1).
         * 
         * Negative limit values equal *unlimited*.
         *
         * > ### NOTE ###
         * >
         * > *"upcoming input"* is defined as the whole of the both
         * > the *currently lexed* input, together with any remaining input
         * > following that. *"currently lexed"* input is the input 
         * > already recognized by the lexer but not yet returned with
         * > the lexer token. This happens when you are invoking this API
         * > from inside any lexer rule action code block. 
         * >
         * 
         * @public
         * @this {RegExpLexer}
         */
        upcomingInput: function lexer_upcomingInput(maxSize, maxLines) {
            var next = this.match;

            if (maxSize < 0) maxSize = next.length + this._input.length;else if (!maxSize) maxSize = 20;

            if (maxLines < 0) maxLines = maxSize; // can't ever have more input lines than this! 
            else if (!maxLines) maxLines = 1;

            // `substring` anticipation: treat \r\n as a single character and take a little
            // more than necessary so that we can still properly check against maxSize
            // after we've transformed and limited the newLines in here:
            if (next.length < maxSize * 2 + 2) {
                next += this._input.substring(0, maxSize * 2 + 2); // substring is faster on Chrome/V8 
            }

            // now that we have a significantly reduced string to process, transform the newlines
            // and chop them, then limit them:
            var a = next.replace(/\r\n|\r/g, '\n').split('\n');

            a = a.slice(0, maxLines);
            next = a.join('\n');

            // When, after limiting to maxLines, we still have too much to return,
            // do add an ellipsis postfix...
            if (next.length > maxSize) {
                next = next.substring(0, maxSize) + '...';
            }

            return next;
        },

        /**
         * return a string which displays the character position where the
         * lexing error occurred, i.e. for error messages
         * 
         * @public
         * @this {RegExpLexer}
         */
        showPosition: function lexer_showPosition(maxPrefix, maxPostfix) {
            var pre = this.pastInput(maxPrefix).replace(/\s/g, ' ');
            var c = new Array(pre.length + 1).join('-');
            return pre + this.upcomingInput(maxPostfix).replace(/\s/g, ' ') + '\n' + c + '^';
        },

        /**
         * return an YYLLOC info object derived off the given context (actual, preceding, following, current).
         * Use this method when the given `actual` location is not guaranteed to exist (i.e. when
         * it MAY be NULL) and you MUST have a valid location info object anyway:
         * then we take the given context of the `preceding` and `following` locations, IFF those are available,
         * and reconstruct the `actual` location info from those.
         * If this fails, the heuristic is to take the `current` location, IFF available.
         * If this fails as well, we assume the sought location is at/around the current lexer position
         * and then produce that one as a response. DO NOTE that these heuristic/derived location info
         * values MAY be inaccurate!
         *
         * NOTE: `deriveLocationInfo()` ALWAYS produces a location info object *copy* of `actual`, not just
         * a *reference* hence all input location objects can be assumed to be 'constant' (function has no side-effects).
         * 
         * @public
         * @this {RegExpLexer}
         */
        deriveLocationInfo: function lexer_deriveYYLLOC(actual, preceding, following, current) {
            var loc = {
                first_line: 1,
                first_column: 0,
                last_line: 1,
                last_column: 0,
                range: [0, 0]
            };

            if (actual) {
                loc.first_line = actual.first_line | 0;
                loc.last_line = actual.last_line | 0;
                loc.first_column = actual.first_column | 0;
                loc.last_column = actual.last_column | 0;

                if (actual.range) {
                    loc.range[0] = actual.range[0] | 0;
                    loc.range[1] = actual.range[1] | 0;
                }
            }

            if (loc.first_line <= 0 || loc.last_line < loc.first_line) {
                // plan B: heuristic using preceding and following:
                if (loc.first_line <= 0 && preceding) {
                    loc.first_line = preceding.last_line | 0;
                    loc.first_column = preceding.last_column | 0;

                    if (preceding.range) {
                        loc.range[0] = actual.range[1] | 0;
                    }
                }

                if ((loc.last_line <= 0 || loc.last_line < loc.first_line) && following) {
                    loc.last_line = following.first_line | 0;
                    loc.last_column = following.first_column | 0;

                    if (following.range) {
                        loc.range[1] = actual.range[0] | 0;
                    }
                }

                // plan C?: see if the 'current' location is useful/sane too:
                if (loc.first_line <= 0 && current && (loc.last_line <= 0 || current.last_line <= loc.last_line)) {
                    loc.first_line = current.first_line | 0;
                    loc.first_column = current.first_column | 0;

                    if (current.range) {
                        loc.range[0] = current.range[0] | 0;
                    }
                }

                if (loc.last_line <= 0 && current && (loc.first_line <= 0 || current.first_line >= loc.first_line)) {
                    loc.last_line = current.last_line | 0;
                    loc.last_column = current.last_column | 0;

                    if (current.range) {
                        loc.range[1] = current.range[1] | 0;
                    }
                }
            }

            // sanitize: fix last_line BEFORE we fix first_line as we use the 'raw' value of the latter
            // or plan D heuristics to produce a 'sensible' last_line value:
            if (loc.last_line <= 0) {
                if (loc.first_line <= 0) {
                    loc.first_line = this.yylloc.first_line;
                    loc.last_line = this.yylloc.last_line;
                    loc.first_column = this.yylloc.first_column;
                    loc.last_column = this.yylloc.last_column;
                    loc.range[0] = this.yylloc.range[0];
                    loc.range[1] = this.yylloc.range[1];
                } else {
                    loc.last_line = this.yylloc.last_line;
                    loc.last_column = this.yylloc.last_column;
                    loc.range[1] = this.yylloc.range[1];
                }
            }

            if (loc.first_line <= 0) {
                loc.first_line = loc.last_line;
                loc.first_column = 0; // loc.last_column; 
                loc.range[1] = loc.range[0];
            }

            if (loc.first_column < 0) {
                loc.first_column = 0;
            }

            if (loc.last_column < 0) {
                loc.last_column = loc.first_column > 0 ? loc.first_column : 80;
            }

            return loc;
        },

        /**
         * return a string which displays the lines & columns of input which are referenced 
         * by the given location info range, plus a few lines of context.
         * 
         * This function pretty-prints the indicated section of the input, with line numbers 
         * and everything!
         * 
         * This function is very useful to provide highly readable error reports, while
         * the location range may be specified in various flexible ways:
         * 
         * - `loc` is the location info object which references the area which should be
         *   displayed and 'marked up': these lines & columns of text are marked up by `^`
         *   characters below each character in the entire input range.
         * 
         * - `context_loc` is the *optional* location info object which instructs this
         *   pretty-printer how much *leading* context should be displayed alongside
         *   the area referenced by `loc`. This can help provide context for the displayed
         *   error, etc.
         * 
         *   When this location info is not provided, a default context of 3 lines is
         *   used.
         * 
         * - `context_loc2` is another *optional* location info object, which serves
         *   a similar purpose to `context_loc`: it specifies the amount of *trailing*
         *   context lines to display in the pretty-print output.
         * 
         *   When this location info is not provided, a default context of 1 line only is
         *   used.
         * 
         * Special Notes:
         * 
         * - when the `loc`-indicated range is very large (about 5 lines or more), then
         *   only the first and last few lines of this block are printed while a
         *   `...continued...` message will be printed between them.
         * 
         *   This serves the purpose of not printing a huge amount of text when the `loc`
         *   range happens to be huge: this way a manageable & readable output results
         *   for arbitrary large ranges.
         * 
         * - this function can display lines of input which whave not yet been lexed.
         *   `prettyPrintRange()` can access the entire input!
         * 
         * @public
         * @this {RegExpLexer}
         */
        prettyPrintRange: function lexer_prettyPrintRange(loc, context_loc, context_loc2) {
            loc = this.deriveLocationInfo(loc, context_loc, context_loc2);
            var CONTEXT = 3;
            var CONTEXT_TAIL = 1;
            var MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT = 2;
            var input = this.matched + this._input;
            var lines = input.split('\n');
            var l0 = Math.max(1, context_loc ? context_loc.first_line : loc.first_line - CONTEXT);
            var l1 = Math.max(1, context_loc2 ? context_loc2.last_line : loc.last_line + CONTEXT_TAIL);
            var lineno_display_width = 1 + Math.log10(l1 | 1) | 0;
            var ws_prefix = new Array(lineno_display_width).join(' ');
            var nonempty_line_indexes = [];

            var rv = lines.slice(l0 - 1, l1 + 1).map(function injectLineNumber(line, index) {
                var lno = index + l0;
                var lno_pfx = (ws_prefix + lno).substr(-lineno_display_width);
                var rv = lno_pfx + ': ' + line;
                var errpfx = new Array(lineno_display_width + 1).join('^');
                var offset = 2 + 1;
                var len = 0;

                if (lno === loc.first_line) {
                    offset += loc.first_column;

                    len = Math.max(2, (lno === loc.last_line ? loc.last_column : line.length) - loc.first_column + 1);
                } else if (lno === loc.last_line) {
                    len = Math.max(2, loc.last_column + 1);
                } else if (lno > loc.first_line && lno < loc.last_line) {
                    len = Math.max(2, line.length + 1);
                }

                if (len) {
                    var lead = new Array(offset).join('.');
                    var mark = new Array(len).join('^');
                    rv += '\n' + errpfx + lead + mark;

                    if (line.trim().length > 0) {
                        nonempty_line_indexes.push(index);
                    }
                }

                rv = rv.replace(/\t/g, ' ');
                return rv;
            });

            // now make sure we don't print an overly large amount of error area: limit it 
            // to the top and bottom line count:
            if (nonempty_line_indexes.length > 2 * MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT) {
                var clip_start = nonempty_line_indexes[MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT - 1] + 1;
                var clip_end = nonempty_line_indexes[nonempty_line_indexes.length - MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT] - 1;
                var intermediate_line = new Array(lineno_display_width + 1).join(' ') + '  (...continued...)';
                intermediate_line += '\n' + new Array(lineno_display_width + 1).join('-') + '  (---------------)';
                rv.splice(clip_start, clip_end - clip_start + 1, intermediate_line);
            }

            return rv.join('\n');
        },

        /**
         * helper function, used to produce a human readable description as a string, given
         * the input `yylloc` location object.
         * 
         * Set `display_range_too` to TRUE to include the string character index position(s)
         * in the description if the `yylloc.range` is available.
         * 
         * @public
         * @this {RegExpLexer}
         */
        describeYYLLOC: function lexer_describe_yylloc(yylloc, display_range_too) {
            var l1 = yylloc.first_line;
            var l2 = yylloc.last_line;
            var c1 = yylloc.first_column;
            var c2 = yylloc.last_column;
            var dl = l2 - l1;
            var dc = c2 - c1;
            var rv;

            if (dl === 0) {
                rv = 'line ' + l1 + ', ';

                if (dc <= 1) {
                    rv += 'column ' + c1;
                } else {
                    rv += 'columns ' + c1 + ' .. ' + c2;
                }
            } else {
                rv = 'lines ' + l1 + '(column ' + c1 + ') .. ' + l2 + '(column ' + c2 + ')';
            }

            if (yylloc.range && display_range_too) {
                var r1 = yylloc.range[0];
                var r2 = yylloc.range[1] - 1;

                if (r2 <= r1) {
                    rv += ' {String Offset: ' + r1 + '}';
                } else {
                    rv += ' {String Offset range: ' + r1 + ' .. ' + r2 + '}';
                }
            }

            return rv;
        },

        /**
         * test the lexed token: return FALSE when not a match, otherwise return token.
         * 
         * `match` is supposed to be an array coming out of a regex match, i.e. `match[0]`
         * contains the actually matched text string.
         * 
         * Also move the input cursor forward and update the match collectors:
         * 
         * - `yytext`
         * - `yyleng`
         * - `match`
         * - `matches`
         * - `yylloc`
         * - `offset`
         * 
         * @public
         * @this {RegExpLexer}
         */
        test_match: function lexer_test_match(match, indexed_rule) {
            var token, lines, backup, match_str, match_str_len;

            if (this.options.backtrack_lexer) {
                // save context
                backup = {
                    yylineno: this.yylineno,

                    yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.yylloc.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                        range: this.yylloc.range.slice(0)
                    },

                    yytext: this.yytext,
                    match: this.match,
                    matches: this.matches,
                    matched: this.matched,
                    yyleng: this.yyleng,
                    offset: this.offset,
                    _more: this._more,
                    _input: this._input,

                    //_signaled_error_token: this._signaled_error_token,
                    yy: this.yy,

                    conditionStack: this.conditionStack.slice(0),
                    done: this.done
                };
            }

            match_str = match[0];
            match_str_len = match_str.length;

            // if (match_str.indexOf('\n') !== -1 || match_str.indexOf('\r') !== -1) {
            lines = match_str.split(/(?:\r\n?|\n)/g);

            if (lines.length > 1) {
                this.yylineno += lines.length - 1;
                this.yylloc.last_line = this.yylineno + 1;
                this.yylloc.last_column = lines[lines.length - 1].length;
            } else {
                this.yylloc.last_column += match_str_len;
            }

            // }
            this.yytext += match_str;

            this.match += match_str;
            this.matched += match_str;
            this.matches = match;
            this.yyleng = this.yytext.length;
            this.yylloc.range[1] += match_str_len;

            // previous lex rules MAY have invoked the `more()` API rather than producing a token:
            // those rules will already have moved this `offset` forward matching their match lengths,
            // hence we must only add our own match length now:
            this.offset += match_str_len;

            this._more = false;
            this._backtrack = false;
            this._input = this._input.slice(match_str_len);

            // calling this method:
            //
            //   function lexer__performAction(yy, yyrulenumber, YY_START) {...}
            token = this.performAction.call(this, this.yy, indexed_rule, this.conditionStack[this.conditionStack.length - 1] /* = YY_START */
            );

            // otherwise, when the action codes are all simple return token statements:
            //token = this.simpleCaseActionClusters[indexed_rule];

            if (this.done && this._input) {
                this.done = false;
            }

            if (token) {
                return token;
            } else if (this._backtrack) {
                // recover context
                for (var k in backup) {
                    this[k] = backup[k];
                }

                this.__currentRuleSet__ = null;
                return false; // rule action called reject() implying the next rule should be tested instead. 
            } else if (this._signaled_error_token) {
                // produce one 'error' token as `.parseError()` in `reject()`
                // did not guarantee a failure signal by throwing an exception!
                token = this._signaled_error_token;

                this._signaled_error_token = false;
                return token;
            }

            return false;
        },

        /**
         * return next match in input
         * 
         * @public
         * @this {RegExpLexer}
         */
        next: function lexer_next() {
            if (this.done) {
                this.clear();
                return this.EOF;
            }

            if (!this._input) {
                this.done = true;
            }

            var token, match, tempMatch, index;

            if (!this._more) {
                this.clear();
            }

            var spec = this.__currentRuleSet__;

            if (!spec) {
                // Update the ruleset cache as we apparently encountered a state change or just started lexing.
                // The cache is set up for fast lookup -- we assume a lexer will switch states much less often than it will
                // invoke the `lex()` token-producing API and related APIs, hence caching the set for direct access helps
                // speed up those activities a tiny bit.
                spec = this.__currentRuleSet__ = this._currentRules();

                // Check whether a *sane* condition has been pushed before: this makes the lexer robust against
                // user-programmer bugs such as https://github.com/zaach/jison-lex/issues/19
                if (!spec || !spec.rules) {
                    var lineno_msg = '';

                    if (this.options.trackPosition) {
                        lineno_msg = ' on line ' + (this.yylineno + 1);
                    }

                    var p = this.constructLexErrorInfo('Internal lexer engine error' + lineno_msg + ': The lex grammar programmer pushed a non-existing condition name "' + this.topState() + '"; this is a fatal error and should be reported to the application programmer team!', false);

                    // produce one 'error' token until this situation has been resolved, most probably by parse termination!
                    return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
                }
            }

            var rule_ids = spec.rules;
            var regexes = spec.__rule_regexes;
            var len = spec.__rule_count;

            // Note: the arrays are 1-based, while `len` itself is a valid index,
            // hence the non-standard less-or-equal check in the next loop condition!
            for (var i = 1; i <= len; i++) {
                tempMatch = this._input.match(regexes[i]);

                if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                    match = tempMatch;
                    index = i;

                    if (this.options.backtrack_lexer) {
                        token = this.test_match(tempMatch, rule_ids[i]);

                        if (token !== false) {
                            return token;
                        } else if (this._backtrack) {
                            match = undefined;
                            continue; // rule action called reject() implying a rule MISmatch. 
                        } else {
                            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                            return false;
                        }
                    } else if (!this.options.flex) {
                        break;
                    }
                }
            }

            if (match) {
                token = this.test_match(match, rule_ids[index]);

                if (token !== false) {
                    return token;
                }

                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                return false;
            }

            if (!this._input) {
                this.done = true;
                this.clear();
                return this.EOF;
            } else {
                var lineno_msg = '';

                if (this.options.trackPosition) {
                    lineno_msg = ' on line ' + (this.yylineno + 1);
                }

                var p = this.constructLexErrorInfo('Lexical error' + lineno_msg + ': Unrecognized text.', this.options.lexerErrorsAreRecoverable);

                var pendingInput = this._input;
                var activeCondition = this.topState();
                var conditionStackDepth = this.conditionStack.length;
                token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;

                if (token === this.ERROR) {
                    // we can try to recover from a lexer error that `parseError()` did not 'recover' for us
                    // by moving forward at least one character at a time IFF the (user-specified?) `parseError()`
                    // has not consumed/modified any pending input or changed state in the error handler:
                    if (!this.matches && // and make sure the input has been modified/consumed ...
                    pendingInput === this._input && // ...or the lexer state has been modified significantly enough
                    // to merit a non-consuming error handling action right now.
                    activeCondition === this.topState() && conditionStackDepth === this.conditionStack.length) {
                        this.input();
                    }
                }

                return token;
            }
        },

        /**
         * return next match that has a token
         * 
         * @public
         * @this {RegExpLexer}
         */
        lex: function lexer_lex() {
            var r;

            // allow the PRE/POST handlers set/modify the return token for maximum flexibility of the generated lexer:
            if (typeof this.pre_lex === 'function') {
                r = this.pre_lex.call(this, 0);
            }

            if (typeof this.options.pre_lex === 'function') {
                // (also account for a userdef function which does not return any value: keep the token as is)
                r = this.options.pre_lex.call(this, r) || r;
            }

            if (this.yy && typeof this.yy.pre_lex === 'function') {
                // (also account for a userdef function which does not return any value: keep the token as is)
                r = this.yy.pre_lex.call(this, r) || r;
            }

            while (!r) {
                r = this.next();
            }

            if (this.yy && typeof this.yy.post_lex === 'function') {
                // (also account for a userdef function which does not return any value: keep the token as is)
                r = this.yy.post_lex.call(this, r) || r;
            }

            if (typeof this.options.post_lex === 'function') {
                // (also account for a userdef function which does not return any value: keep the token as is)
                r = this.options.post_lex.call(this, r) || r;
            }

            if (typeof this.post_lex === 'function') {
                // (also account for a userdef function which does not return any value: keep the token as is)
                r = this.post_lex.call(this, r) || r;
            }

            return r;
        },

        /**
         * return next match that has a token. Identical to the `lex()` API but does not invoke any of the 
         * `pre_lex()` nor any of the `post_lex()` callbacks.
         * 
         * @public
         * @this {RegExpLexer}
         */
        fastLex: function lexer_fastLex() {
            var r;

            while (!r) {
                r = this.next();
            }

            return r;
        },

        /**
         * return info about the lexer state that can help a parser or other lexer API user to use the
         * most efficient means available. This API is provided to aid run-time performance for larger
         * systems which employ this lexer.
         * 
         * @public
         * @this {RegExpLexer}
         */
        canIUse: function lexer_canIUse() {
            var rv = {
                fastLex: !(typeof this.pre_lex === 'function' || typeof this.options.pre_lex === 'function' || this.yy && typeof this.yy.pre_lex === 'function' || this.yy && typeof this.yy.post_lex === 'function' || typeof this.options.post_lex === 'function' || typeof this.post_lex === 'function') && typeof this.fastLex === 'function'
            };

            return rv;
        },

        /**
         * backwards compatible alias for `pushState()`;
         * the latter is symmetrical with `popState()` and we advise to use
         * those APIs in any modern lexer code, rather than `begin()`.
         * 
         * @public
         * @this {RegExpLexer}
         */
        begin: function lexer_begin(condition) {
            return this.pushState(condition);
        },

        /**
         * activates a new lexer condition state (pushes the new lexer
         * condition state onto the condition stack)
         * 
         * @public
         * @this {RegExpLexer}
         */
        pushState: function lexer_pushState(condition) {
            this.conditionStack.push(condition);
            this.__currentRuleSet__ = null;
            return this;
        },

        /**
         * pop the previously active lexer condition state off the condition
         * stack
         * 
         * @public
         * @this {RegExpLexer}
         */
        popState: function lexer_popState() {
            var n = this.conditionStack.length - 1;

            if (n > 0) {
                this.__currentRuleSet__ = null;
                return this.conditionStack.pop();
            } else {
                return this.conditionStack[0];
            }
        },

        /**
         * return the currently active lexer condition state; when an index
         * argument is provided it produces the N-th previous condition state,
         * if available
         * 
         * @public
         * @this {RegExpLexer}
         */
        topState: function lexer_topState(n) {
            n = this.conditionStack.length - 1 - Math.abs(n || 0);

            if (n >= 0) {
                return this.conditionStack[n];
            } else {
                return 'INITIAL';
            }
        },

        /**
         * (internal) determine the lexer rule set which is active for the
         * currently active lexer condition state
         * 
         * @public
         * @this {RegExpLexer}
         */
        _currentRules: function lexer__currentRules() {
            if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
                return this.conditions[this.conditionStack[this.conditionStack.length - 1]];
            } else {
                return this.conditions['INITIAL'];
            }
        },

        /**
         * return the number of states currently on the stack
         * 
         * @public
         * @this {RegExpLexer}
         */
        stateStackSize: function lexer_stateStackSize() {
            return this.conditionStack.length;
        },

        options: {
            xregexp: true,
            ranges: true,
            trackPosition: true,
            parseActionsUseYYMERGELOCATIONINFO: true,
            easy_keyword_rules: true
        },

        JisonLexerError: JisonLexerError,

        performAction: function lexer__performAction(yy, yyrulenumber, YY_START) {
            var yy_ = this;
            switch (yyrulenumber) {
                case 0:
                    /*! Conditions:: rules macro named_chunk INITIAL */
                    /*! Rule::       %\{ */
                    yy.depth = 0;

                    yy.include_command_allowed = false;
                    this.pushState('action');
                    this.unput(yy_.yytext);
                    yy_.yytext = '';
                    return 28;
                    break;

                case 1:
                    /*! Conditions:: action */
                    /*! Rule::       %\{([^]*?)%\} */
                    yy_.yytext = this.matches[1].replace(/%\\\}/g, '%}'); // unescape any literal '%\}' that exists within the action code block 

                    yy.include_command_allowed = true;
                    return 32;
                    break;

                case 2:
                    /*! Conditions:: action */
                    /*! Rule::       %include\b */
                    if (yy.include_command_allowed) {
                        // This is an include instruction in place of an action:
                        //
                        // - one %include per action chunk
                        // - one %include replaces an entire action chunk
                        this.pushState('path');

                        return 51;
                    } else {
                        // TODO
                        yy_.yyerror(rmCommonWS(_templateObject27) + this.prettyPrintRange(yy_.yylloc));

                        return 37;
                    }

                    break;

                case 3:
                    /*! Conditions:: action */
                    /*! Rule::       {WS}*\/\*[^]*?\*\/ */
                    //yy.include_command_allowed = false; -- doesn't impact include-allowed state
                    return 34;

                    break;

                case 4:
                    /*! Conditions:: action */
                    /*! Rule::       {WS}*\/\/.* */
                    yy.include_command_allowed = false;

                    return 35;
                    break;

                case 6:
                    /*! Conditions:: action */
                    /*! Rule::       \| */
                    if (yy.include_command_allowed) {
                        this.popState();
                        this.unput(yy_.yytext);
                        yy_.yytext = '';
                        return 31;
                    } else {
                        return 33;
                    }

                    break;

                case 7:
                    /*! Conditions:: action */
                    /*! Rule::       %% */
                    if (yy.include_command_allowed) {
                        this.popState();
                        this.unput(yy_.yytext);
                        yy_.yytext = '';
                        return 31;
                    } else {
                        return 33;
                    }

                    break;

                case 9:
                    /*! Conditions:: action */
                    /*! Rule::       \/[^\s/]*?(?:['"`{}][^\s/]*?)*\/ */
                    yy.include_command_allowed = false;

                    return 33;
                    break;

                case 10:
                    /*! Conditions:: action */
                    /*! Rule::       \/[^}{BR}]* */
                    yy.include_command_allowed = false;

                    return 33;
                    break;

                case 11:
                    /*! Conditions:: action */
                    /*! Rule::       "{DOUBLEQUOTED_STRING_CONTENT}" */
                    yy.include_command_allowed = false;

                    return 33;
                    break;

                case 12:
                    /*! Conditions:: action */
                    /*! Rule::       '{QUOTED_STRING_CONTENT}' */
                    yy.include_command_allowed = false;

                    return 33;
                    break;

                case 13:
                    /*! Conditions:: action */
                    /*! Rule::       `{ES2017_STRING_CONTENT}` */
                    yy.include_command_allowed = false;

                    return 33;
                    break;

                case 14:
                    /*! Conditions:: action */
                    /*! Rule::       [^{}/"'`|%\{\}{BR}{WS}]+ */
                    yy.include_command_allowed = false;

                    return 33;
                    break;

                case 15:
                    /*! Conditions:: action */
                    /*! Rule::       \{ */
                    yy.depth++;

                    yy.include_command_allowed = false;
                    return 33;
                    break;

                case 16:
                    /*! Conditions:: action */
                    /*! Rule::       \} */
                    yy.include_command_allowed = false;

                    if (yy.depth <= 0) {
                        yy_.yyerror(rmCommonWS(_templateObject28) + this.prettyPrintRange(yy_.yylloc));

                        return 30;
                    } else {
                        yy.depth--;
                    }

                    return 33;
                    break;

                case 17:
                    /*! Conditions:: action */
                    /*! Rule::       (?:{BR}{WS}+)+(?=[^{WS}{BR}|]) */
                    yy.include_command_allowed = true;

                    return 36; // keep empty lines as-is inside action code blocks.  
                    break;

                case 18:
                    /*! Conditions:: action */
                    /*! Rule::       {BR} */
                    if (yy.depth > 0) {
                        yy.include_command_allowed = true;
                        return 36; // keep empty lines as-is inside action code blocks. 
                    } else {
                        // end of action code chunk
                        this.popState();

                        this.unput(yy_.yytext);
                        yy_.yytext = '';
                        return 31;
                    }

                    break;

                case 19:
                    /*! Conditions:: action */
                    /*! Rule::       $ */
                    yy.include_command_allowed = false;

                    if (yy.depth !== 0) {
                        yy_.yyerror(rmCommonWS(_templateObject29, yy.depth) + this.prettyPrintRange(yy_.yylloc));

                        yy_.yytext = '';
                        return 29;
                    }

                    this.popState();
                    yy_.yytext = '';
                    return 31;
                    break;

                case 21:
                    /*! Conditions:: conditions */
                    /*! Rule::       > */
                    this.popState();

                    return 6;
                    break;

                case 24:
                    /*! Conditions:: INITIAL start_condition macro path options */
                    /*! Rule::       {WS}*\/\/[^\r\n]* */
                    /* skip single-line comment */
                    break;

                case 25:
                    /*! Conditions:: INITIAL start_condition macro path options */
                    /*! Rule::       {WS}*\/\*[^]*?\*\/ */
                    /* skip multi-line comment */
                    break;

                case 26:
                    /*! Conditions:: rules */
                    /*! Rule::       {BR}+ */
                    /* empty */
                    break;

                case 27:
                    /*! Conditions:: rules */
                    /*! Rule::       {WS}+{BR}+ */
                    /* empty */
                    break;

                case 28:
                    /*! Conditions:: rules */
                    /*! Rule::       \/\/[^\r\n]* */
                    /* skip single-line comment */
                    break;

                case 29:
                    /*! Conditions:: rules */
                    /*! Rule::       \/\*[^]*?\*\/ */
                    /* skip multi-line comment */
                    break;

                case 30:
                    /*! Conditions:: rules */
                    /*! Rule::       {WS}+(?=[^{WS}{BR}|%]) */
                    yy.depth = 0;

                    yy.include_command_allowed = true;
                    this.pushState('action');
                    return 28;
                    break;

                case 31:
                    /*! Conditions:: rules */
                    /*! Rule::       %% */
                    this.popState();

                    this.pushState('code');
                    return 19;
                    break;

                case 32:
                    /*! Conditions:: rules */
                    /*! Rule::       {ANY_LITERAL_CHAR}+ */
                    // accept any non-regex, non-lex, non-string-delim,
                    // non-escape-starter, non-space character as-is
                    return 46;

                    break;

                case 35:
                    /*! Conditions:: options */
                    /*! Rule::       "{DOUBLEQUOTED_STRING_CONTENT}" */
                    yy_.yytext = unescQuote(this.matches[1], /\\"/g);

                    return 49; // value is always a string type  
                    break;

                case 36:
                    /*! Conditions:: options */
                    /*! Rule::       '{QUOTED_STRING_CONTENT}' */
                    yy_.yytext = unescQuote(this.matches[1], /\\'/g);

                    return 49; // value is always a string type  
                    break;

                case 37:
                    /*! Conditions:: options */
                    /*! Rule::       `{ES2017_STRING_CONTENT}` */
                    yy_.yytext = unescQuote(this.matches[1], /\\`/g);

                    return 49; // value is always a string type  
                    break;

                case 39:
                    /*! Conditions:: options */
                    /*! Rule::       {BR}{WS}+(?=\S) */
                    /* skip leading whitespace on the next line of input, when followed by more options */
                    break;

                case 40:
                    /*! Conditions:: options */
                    /*! Rule::       {BR} */
                    this.popState();

                    return 48;
                    break;

                case 41:
                    /*! Conditions:: options */
                    /*! Rule::       {WS}+ */
                    /* skip whitespace */
                    break;

                case 43:
                    /*! Conditions:: start_condition */
                    /*! Rule::       {BR}+ */
                    this.popState();

                    break;

                case 44:
                    /*! Conditions:: start_condition */
                    /*! Rule::       {WS}+ */
                    /* empty */
                    break;

                case 46:
                    /*! Conditions:: INITIAL */
                    /*! Rule::       {ID} */
                    this.pushState('macro');

                    return 20;
                    break;

                case 47:
                    /*! Conditions:: macro named_chunk */
                    /*! Rule::       {BR}+ */
                    this.popState();

                    break;

                case 48:
                    /*! Conditions:: macro */
                    /*! Rule::       {ANY_LITERAL_CHAR}+ */
                    // accept any non-regex, non-lex, non-string-delim,
                    // non-escape-starter, non-space character as-is
                    return 46;

                    break;

                case 49:
                    /*! Conditions:: rules macro named_chunk INITIAL */
                    /*! Rule::       {BR}+ */
                    /* empty */
                    break;

                case 50:
                    /*! Conditions:: rules macro named_chunk INITIAL */
                    /*! Rule::       \s+ */
                    /* empty */
                    break;

                case 51:
                    /*! Conditions:: rules macro named_chunk INITIAL */
                    /*! Rule::       "{DOUBLEQUOTED_STRING_CONTENT}" */
                    yy_.yytext = unescQuote(this.matches[1], /\\"/g);

                    return 26;
                    break;

                case 52:
                    /*! Conditions:: rules macro named_chunk INITIAL */
                    /*! Rule::       '{QUOTED_STRING_CONTENT}' */
                    yy_.yytext = unescQuote(this.matches[1], /\\'/g);

                    return 26;
                    break;

                case 53:
                    /*! Conditions:: rules macro named_chunk INITIAL */
                    /*! Rule::       \[ */
                    this.pushState('set');

                    return 41;
                    break;

                case 66:
                    /*! Conditions:: rules macro named_chunk INITIAL */
                    /*! Rule::       < */
                    this.pushState('conditions');

                    return 5;
                    break;

                case 67:
                    /*! Conditions:: rules macro named_chunk INITIAL */
                    /*! Rule::       \/! */
                    return 39; // treated as `(?!atom)`  

                    break;

                case 68:
                    /*! Conditions:: rules macro named_chunk INITIAL */
                    /*! Rule::       \/ */
                    return 14; // treated as `(?=atom)`  

                    break;

                case 70:
                    /*! Conditions:: rules macro named_chunk INITIAL */
                    /*! Rule::       \\. */
                    yy_.yytext = yy_.yytext.replace(/^\\/g, '');

                    return 44;
                    break;

                case 73:
                    /*! Conditions:: rules macro named_chunk INITIAL */
                    /*! Rule::       %option[s]? */
                    this.pushState('options');

                    return 47;
                    break;

                case 74:
                    /*! Conditions:: rules macro named_chunk INITIAL */
                    /*! Rule::       %s\b */
                    this.pushState('start_condition');

                    return 21;
                    break;

                case 75:
                    /*! Conditions:: rules macro named_chunk INITIAL */
                    /*! Rule::       %x\b */
                    this.pushState('start_condition');

                    return 22;
                    break;

                case 76:
                    /*! Conditions:: rules macro named_chunk INITIAL */
                    /*! Rule::       %code\b */
                    this.pushState('named_chunk');

                    return 25;
                    break;

                case 77:
                    /*! Conditions:: rules macro named_chunk INITIAL */
                    /*! Rule::       %import\b */
                    this.pushState('named_chunk');

                    return 24;
                    break;

                case 78:
                    /*! Conditions:: rules macro named_chunk INITIAL */
                    /*! Rule::       %include\b */
                    yy.depth = 0;

                    yy.include_command_allowed = true;
                    this.pushState('action');
                    this.unput(yy_.yytext);
                    yy_.yytext = '';
                    return 28;
                    break;

                case 79:
                    /*! Conditions:: code */
                    /*! Rule::       %include\b */
                    this.pushState('path');

                    return 51;
                    break;

                case 80:
                    /*! Conditions:: INITIAL rules code */
                    /*! Rule::       %{NAME}([^\r\n]*) */
                    /* ignore unrecognized decl */
                    this.warn(rmCommonWS(_templateObject30, dquote(yy_.yytext), dquote(this.topState())) + this.prettyPrintRange(yy_.yylloc));

                    yy_.yytext = {
                        name: this.matches[1], // {NAME}  
                        value: this.matches[2].trim() // optional value/parameters 
                    };

                    return 23;
                    break;

                case 81:
                    /*! Conditions:: rules macro named_chunk INITIAL */
                    /*! Rule::       %% */
                    this.pushState('rules');

                    return 19;
                    break;

                case 89:
                    /*! Conditions:: set */
                    /*! Rule::       \] */
                    this.popState();

                    return 42;
                    break;

                case 91:
                    /*! Conditions:: code */
                    /*! Rule::       [^\r\n]+ */
                    return 53; // the bit of CODE just before EOF...  

                    break;

                case 92:
                    /*! Conditions:: path */
                    /*! Rule::       {BR} */
                    this.popState();

                    this.unput(yy_.yytext);
                    break;

                case 93:
                    /*! Conditions:: path */
                    /*! Rule::       "{DOUBLEQUOTED_STRING_CONTENT}" */
                    yy_.yytext = unescQuote(this.matches[1]);

                    this.popState();
                    return 52;
                    break;

                case 94:
                    /*! Conditions:: path */
                    /*! Rule::       '{QUOTED_STRING_CONTENT}' */
                    yy_.yytext = unescQuote(this.matches[1]);

                    this.popState();
                    return 52;
                    break;

                case 95:
                    /*! Conditions:: path */
                    /*! Rule::       {WS}+ */
                    // skip whitespace in the line 
                    break;

                case 96:
                    /*! Conditions:: path */
                    /*! Rule::       [^\s\r\n]+ */
                    this.popState();

                    return 52;
                    break;

                case 97:
                    /*! Conditions:: action */
                    /*! Rule::       " */
                    yy_.yyerror(rmCommonWS(_templateObject31) + this.prettyPrintRange(yy_.yylloc));

                    return 2;
                    break;

                case 98:
                    /*! Conditions:: action */
                    /*! Rule::       ' */
                    yy_.yyerror(rmCommonWS(_templateObject31) + this.prettyPrintRange(yy_.yylloc));

                    return 2;
                    break;

                case 99:
                    /*! Conditions:: action */
                    /*! Rule::       ` */
                    yy_.yyerror(rmCommonWS(_templateObject31) + this.prettyPrintRange(yy_.yylloc));

                    return 2;
                    break;

                case 100:
                    /*! Conditions:: options */
                    /*! Rule::       " */
                    yy_.yyerror(rmCommonWS(_templateObject32) + this.prettyPrintRange(yy_.yylloc));

                    return 2;
                    break;

                case 101:
                    /*! Conditions:: options */
                    /*! Rule::       ' */
                    yy_.yyerror(rmCommonWS(_templateObject32) + this.prettyPrintRange(yy_.yylloc));

                    return 2;
                    break;

                case 102:
                    /*! Conditions:: options */
                    /*! Rule::       ` */
                    yy_.yyerror(rmCommonWS(_templateObject32) + this.prettyPrintRange(yy_.yylloc));

                    return 2;
                    break;

                case 103:
                    /*! Conditions:: * */
                    /*! Rule::       " */
                    var rules = this.topState() === 'macro' ? 'macro\'s' : this.topState();

                    yy_.yyerror(rmCommonWS(_templateObject33, rules) + this.prettyPrintRange(yy_.yylloc));

                    return 2;
                    break;

                case 104:
                    /*! Conditions:: * */
                    /*! Rule::       ' */
                    var rules = this.topState() === 'macro' ? 'macro\'s' : this.topState();

                    yy_.yyerror(rmCommonWS(_templateObject33, rules) + this.prettyPrintRange(yy_.yylloc));

                    return 2;
                    break;

                case 105:
                    /*! Conditions:: * */
                    /*! Rule::       ` */
                    var rules = this.topState() === 'macro' ? 'macro\'s' : this.topState();

                    yy_.yyerror(rmCommonWS(_templateObject33, rules) + this.prettyPrintRange(yy_.yylloc));

                    return 2;
                    break;

                case 106:
                    /*! Conditions:: macro rules */
                    /*! Rule::       . */
                    /* b0rk on bad characters */
                    var rules = this.topState() === 'macro' ? 'macro\'s' : this.topState();

                    yy_.yyerror(rmCommonWS(_templateObject34, rules, rules) + this.prettyPrintRange(yy_.yylloc));

                    break;

                case 107:
                    /*! Conditions:: * */
                    /*! Rule::       . */
                    yy_.yyerror(rmCommonWS(_templateObject35, dquote(yy_.yytext), dquote(this.topState())) + this.prettyPrintRange(yy_.yylloc));

                    break;

                default:
                    return this.simpleCaseActionClusters[yyrulenumber];
            }
        },

        simpleCaseActionClusters: {
            /*! Conditions:: action */
            /*! Rule::       {WS}+ */
            5: 36,

            /*! Conditions:: action */
            /*! Rule::       % */
            8: 33,

            /*! Conditions:: conditions */
            /*! Rule::       {NAME} */
            20: 20,

            /*! Conditions:: conditions */
            /*! Rule::       , */
            22: 8,

            /*! Conditions:: conditions */
            /*! Rule::       \* */
            23: 7,

            /*! Conditions:: options */
            /*! Rule::       {NAME} */
            33: 20,

            /*! Conditions:: options */
            /*! Rule::       = */
            34: 18,

            /*! Conditions:: options */
            /*! Rule::       [^\s\r\n]+ */
            38: 50,

            /*! Conditions:: start_condition */
            /*! Rule::       {ID} */
            42: 27,

            /*! Conditions:: named_chunk */
            /*! Rule::       {ID} */
            45: 20,

            /*! Conditions:: rules macro named_chunk INITIAL */
            /*! Rule::       \| */
            54: 9,

            /*! Conditions:: rules macro named_chunk INITIAL */
            /*! Rule::       \(\?: */
            55: 38,

            /*! Conditions:: rules macro named_chunk INITIAL */
            /*! Rule::       \(\?= */
            56: 38,

            /*! Conditions:: rules macro named_chunk INITIAL */
            /*! Rule::       \(\?! */
            57: 38,

            /*! Conditions:: rules macro named_chunk INITIAL */
            /*! Rule::       \( */
            58: 10,

            /*! Conditions:: rules macro named_chunk INITIAL */
            /*! Rule::       \) */
            59: 11,

            /*! Conditions:: rules macro named_chunk INITIAL */
            /*! Rule::       \+ */
            60: 12,

            /*! Conditions:: rules macro named_chunk INITIAL */
            /*! Rule::       \* */
            61: 7,

            /*! Conditions:: rules macro named_chunk INITIAL */
            /*! Rule::       \? */
            62: 13,

            /*! Conditions:: rules macro named_chunk INITIAL */
            /*! Rule::       \^ */
            63: 16,

            /*! Conditions:: rules macro named_chunk INITIAL */
            /*! Rule::       , */
            64: 8,

            /*! Conditions:: rules macro named_chunk INITIAL */
            /*! Rule::       <<EOF>> */
            65: 17,

            /*! Conditions:: rules macro named_chunk INITIAL */
            /*! Rule::       \\([0-7]{1,3}|[rfntvsSbBwWdD\\*+()${}|[\]\/.^?]|c[A-Z]|x[0-9A-F]{2}|u[a-fA-F0-9]{4}) */
            69: 44,

            /*! Conditions:: rules macro named_chunk INITIAL */
            /*! Rule::       \$ */
            71: 17,

            /*! Conditions:: rules macro named_chunk INITIAL */
            /*! Rule::       \. */
            72: 15,

            /*! Conditions:: rules macro named_chunk INITIAL */
            /*! Rule::       \{\d+(,\s*\d+|,)?\} */
            82: 45,

            /*! Conditions:: rules macro named_chunk INITIAL */
            /*! Rule::       \{{ID}\} */
            83: 40,

            /*! Conditions:: set options */
            /*! Rule::       \{{ID}\} */
            84: 40,

            /*! Conditions:: rules macro named_chunk INITIAL */
            /*! Rule::       \{ */
            85: 3,

            /*! Conditions:: rules macro named_chunk INITIAL */
            /*! Rule::       \} */
            86: 4,

            /*! Conditions:: set */
            /*! Rule::       (?:\\\\|\\\]|[^\]{])+ */
            87: 43,

            /*! Conditions:: set */
            /*! Rule::       \{ */
            88: 43,

            /*! Conditions:: code */
            /*! Rule::       [^\r\n]*(\r|\n)+ */
            90: 53,

            /*! Conditions:: * */
            /*! Rule::       $ */
            108: 1
        },

        rules: [
        /*   0: *//^(?:%\{)/,
        /*   1: */new XRegExp('^(?:%\\{([^]*?)%\\})', ''),
        /*   2: *//^(?:%include\b)/,
        /*   3: */new XRegExp('^(?:([^\\S\\n\\r])*\\/\\*[^]*?\\*\\/)', ''),
        /*   4: *//^(?:([^\S\n\r])*\/\/.*)/,
        /*   5: *//^(?:([^\S\n\r])+)/,
        /*   6: *//^(?:\|)/,
        /*   7: *//^(?:%%)/,
        /*   8: *//^(?:%)/,
        /*   9: *//^(?:\/[^\s\/]*?(?:['"`{}][^\s\/]*?)*\/)/,
        /*  10: *//^(?:\/[^\n\r}]*)/,
        /*  11: *//^(?:"((?:\\"|\\[^"]|[^\n\r"\\])*)")/,
        /*  12: *//^(?:'((?:\\'|\\[^']|[^\n\r'\\])*)')/,
        /*  13: *//^(?:`((?:\\`|\\[^`]|[^\\`])*)`)/,
        /*  14: *//^(?:[^\s"%'\/`{-}]+)/,
        /*  15: *//^(?:\{)/,
        /*  16: *//^(?:\})/,
        /*  17: *//^(?:(?:(\r\n|\n|\r)([^\S\n\r])+)+(?=[^\s|]))/,
        /*  18: *//^(?:(\r\n|\n|\r))/,
        /*  19: *//^(?:$)/,
        /*  20: */new XRegExp('^(?:([\\p{Alphabetic}_](?:[\\p{Alphabetic}\\p{Number}\\-_]*(?:[\\p{Alphabetic}\\p{Number}_]))?))', ''),
        /*  21: *//^(?:>)/,
        /*  22: *//^(?:,)/,
        /*  23: *//^(?:\*)/,
        /*  24: *//^(?:([^\S\n\r])*\/\/[^\n\r]*)/,
        /*  25: */new XRegExp('^(?:([^\\S\\n\\r])*\\/\\*[^]*?\\*\\/)', ''),
        /*  26: *//^(?:(\r\n|\n|\r)+)/,
        /*  27: *//^(?:([^\S\n\r])+(\r\n|\n|\r)+)/,
        /*  28: *//^(?:\/\/[^\r\n]*)/,
        /*  29: */new XRegExp('^(?:\\/\\*[^]*?\\*\\/)', ''),
        /*  30: *//^(?:([^\S\n\r])+(?=[^\s%|]))/,
        /*  31: *//^(?:%%)/,
        /*  32: *//^(?:([^\s!"$%'-,.\/:-?\[-\^{-}])+)/,
        /*  33: */new XRegExp('^(?:([\\p{Alphabetic}_](?:[\\p{Alphabetic}\\p{Number}\\-_]*(?:[\\p{Alphabetic}\\p{Number}_]))?))', ''),
        /*  34: *//^(?:=)/,
        /*  35: *//^(?:"((?:\\"|\\[^"]|[^\n\r"\\])*)")/,
        /*  36: *//^(?:'((?:\\'|\\[^']|[^\n\r'\\])*)')/,
        /*  37: *//^(?:`((?:\\`|\\[^`]|[^\\`])*)`)/,
        /*  38: *//^(?:\S+)/,
        /*  39: *//^(?:(\r\n|\n|\r)([^\S\n\r])+(?=\S))/,
        /*  40: *//^(?:(\r\n|\n|\r))/,
        /*  41: *//^(?:([^\S\n\r])+)/,
        /*  42: */new XRegExp('^(?:([\\p{Alphabetic}_](?:[\\p{Alphabetic}\\p{Number}_])*))', ''),
        /*  43: *//^(?:(\r\n|\n|\r)+)/,
        /*  44: *//^(?:([^\S\n\r])+)/,
        /*  45: */new XRegExp('^(?:([\\p{Alphabetic}_](?:[\\p{Alphabetic}\\p{Number}_])*))', ''),
        /*  46: */new XRegExp('^(?:([\\p{Alphabetic}_](?:[\\p{Alphabetic}\\p{Number}_])*))', ''),
        /*  47: *//^(?:(\r\n|\n|\r)+)/,
        /*  48: *//^(?:([^\s!"$%'-,.\/:-?\[-\^{-}])+)/,
        /*  49: *//^(?:(\r\n|\n|\r)+)/,
        /*  50: *//^(?:\s+)/,
        /*  51: *//^(?:"((?:\\"|\\[^"]|[^\n\r"\\])*)")/,
        /*  52: *//^(?:'((?:\\'|\\[^']|[^\n\r'\\])*)')/,
        /*  53: *//^(?:\[)/,
        /*  54: *//^(?:\|)/,
        /*  55: *//^(?:\(\?:)/,
        /*  56: *//^(?:\(\?=)/,
        /*  57: *//^(?:\(\?!)/,
        /*  58: *//^(?:\()/,
        /*  59: *//^(?:\))/,
        /*  60: *//^(?:\+)/,
        /*  61: *//^(?:\*)/,
        /*  62: *//^(?:\?)/,
        /*  63: *//^(?:\^)/,
        /*  64: *//^(?:,)/,
        /*  65: *//^(?:<<EOF>>)/,
        /*  66: *//^(?:<)/,
        /*  67: *//^(?:\/!)/,
        /*  68: *//^(?:\/)/,
        /*  69: *//^(?:\\([0-7]{1,3}|[$(-+.\/?BDSW\[-\^bdfnr-tvw{-}]|c[A-Z]|x[\dA-F]{2}|u[\dA-Fa-f]{4}))/,
        /*  70: *//^(?:\\.)/,
        /*  71: *//^(?:\$)/,
        /*  72: *//^(?:\.)/,
        /*  73: *//^(?:%option[s]?)/,
        /*  74: *//^(?:%s\b)/,
        /*  75: *//^(?:%x\b)/,
        /*  76: *//^(?:%code\b)/,
        /*  77: *//^(?:%import\b)/,
        /*  78: *//^(?:%include\b)/,
        /*  79: *//^(?:%include\b)/,
        /*  80: */new XRegExp('^(?:%([\\p{Alphabetic}_](?:[\\p{Alphabetic}\\p{Number}\\-_]*(?:[\\p{Alphabetic}\\p{Number}_]))?)([^\\n\\r]*))', ''),
        /*  81: *//^(?:%%)/,
        /*  82: *//^(?:\{\d+(,\s*\d+|,)?\})/,
        /*  83: */new XRegExp('^(?:\\{([\\p{Alphabetic}_](?:[\\p{Alphabetic}\\p{Number}_])*)\\})', ''),
        /*  84: */new XRegExp('^(?:\\{([\\p{Alphabetic}_](?:[\\p{Alphabetic}\\p{Number}_])*)\\})', ''),
        /*  85: *//^(?:\{)/,
        /*  86: *//^(?:\})/,
        /*  87: *//^(?:(?:\\\\|\\\]|[^\]{])+)/,
        /*  88: *//^(?:\{)/,
        /*  89: *//^(?:\])/,
        /*  90: *//^(?:[^\r\n]*(\r|\n)+)/,
        /*  91: *//^(?:[^\r\n]+)/,
        /*  92: *//^(?:(\r\n|\n|\r))/,
        /*  93: *//^(?:"((?:\\"|\\[^"]|[^\n\r"\\])*)")/,
        /*  94: *//^(?:'((?:\\'|\\[^']|[^\n\r'\\])*)')/,
        /*  95: *//^(?:([^\S\n\r])+)/,
        /*  96: *//^(?:\S+)/,
        /*  97: *//^(?:")/,
        /*  98: *//^(?:')/,
        /*  99: *//^(?:`)/,
        /* 100: *//^(?:")/,
        /* 101: *//^(?:')/,
        /* 102: *//^(?:`)/,
        /* 103: *//^(?:")/,
        /* 104: *//^(?:')/,
        /* 105: *//^(?:`)/,
        /* 106: *//^(?:.)/,
        /* 107: *//^(?:.)/,
        /* 108: *//^(?:$)/],

        conditions: {
            'rules': {
                rules: [0, 26, 27, 28, 29, 30, 31, 32, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 80, 81, 82, 83, 85, 86, 103, 104, 105, 106, 107, 108],

                inclusive: true
            },

            'macro': {
                rules: [0, 24, 25, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 81, 82, 83, 85, 86, 103, 104, 105, 106, 107, 108],

                inclusive: true
            },

            'named_chunk': {
                rules: [0, 45, 47, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 81, 82, 83, 85, 86, 103, 104, 105, 107, 108],

                inclusive: true
            },

            'code': {
                rules: [79, 80, 90, 91, 103, 104, 105, 107, 108],
                inclusive: false
            },

            'start_condition': {
                rules: [24, 25, 42, 43, 44, 103, 104, 105, 107, 108],
                inclusive: false
            },

            'options': {
                rules: [24, 25, 33, 34, 35, 36, 37, 38, 39, 40, 41, 84, 100, 101, 102, 103, 104, 105, 107, 108],

                inclusive: false
            },

            'conditions': {
                rules: [20, 21, 22, 23, 103, 104, 105, 107, 108],
                inclusive: false
            },

            'action': {
                rules: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 97, 98, 99, 103, 104, 105, 107, 108],

                inclusive: false
            },

            'path': {
                rules: [24, 25, 92, 93, 94, 95, 96, 103, 104, 105, 107, 108],
                inclusive: false
            },

            'set': {
                rules: [84, 87, 88, 89, 103, 104, 105, 107, 108],
                inclusive: false
            },

            'INITIAL': {
                rules: [0, 24, 25, 46, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 80, 81, 82, 83, 85, 86, 103, 104, 105, 107, 108],

                inclusive: true
            }
        }
    };

    var rmCommonWS = helpers.rmCommonWS;
    var dquote = helpers.dquote;

    function unescQuote(str) {
        str = '' + str;
        var a = str.split('\\\\');

        a = a.map(function (s) {
            return s.replace(/\\'/g, '\'').replace(/\\"/g, '"');
        });

        str = a.join('\\\\');
        return str;
    }

    lexer.warn = function l_warn() {
        if (this.yy && this.yy.parser && typeof this.yy.parser.warn === 'function') {
            return this.yy.parser.warn.apply(this, arguments);
        } else {
            console.warn.apply(console, arguments);
        }
    };

    lexer.log = function l_log() {
        if (this.yy && this.yy.parser && typeof this.yy.parser.log === 'function') {
            return this.yy.parser.log.apply(this, arguments);
        } else {
            console.log.apply(console, arguments);
        }
    };

    return lexer;
}();
parser$1.lexer = lexer;

var rmCommonWS$2 = helpers.rmCommonWS;
var checkActionBlock = helpers.checkActionBlock;

function encodeRE(s) {
    return s.replace(/([.*+?^${}()|\[\]\/\\])/g, '\\$1').replace(/\\\\u([a-fA-F0-9]{4})/g, '\\u$1');
}

function prepareString(s) {
    // unescape slashes
    s = s.replace(/\\\\/g, "\\");
    s = encodeRE(s);
    return s;
}

// convert string value to number or boolean value, when possible
// (and when this is more or less obviously the intent)
// otherwise produce the string itself as value.
function parseValue(v) {
    if (v === 'false') {
        return false;
    }
    if (v === 'true') {
        return true;
    }
    // http://stackoverflow.com/questions/175739/is-there-a-built-in-way-in-javascript-to-check-if-a-string-is-a-valid-number
    // Note that the `v` check ensures that we do not convert `undefined`, `null` and `''` (empty string!)
    if (v && !isNaN(v)) {
        var rv = +v;
        if (isFinite(rv)) {
            return rv;
        }
    }
    return v;
}

parser$1.warn = function p_warn() {
    console.warn.apply(console, arguments);
};

parser$1.log = function p_log() {
    console.log.apply(console, arguments);
};

parser$1.pre_parse = function p_lex() {
    if (parser$1.yydebug) parser$1.log('pre_parse:', arguments);
};

parser$1.yy.pre_parse = function p_lex() {
    if (parser$1.yydebug) parser$1.log('pre_parse YY:', arguments);
};

parser$1.yy.post_lex = function p_lex() {
    if (parser$1.yydebug) parser$1.log('post_lex:', arguments);
};

function Parser$1() {
    this.yy = {};
}
Parser$1.prototype = parser$1;
parser$1.Parser = Parser$1;

function yyparse() {
    return parser$1.parse.apply(parser$1, arguments);
}

var jisonlex = {
    parser: parser$1,
    Parser: Parser$1,
    parse: yyparse

};

//
// Helper library for set definitions
//
// MIT Licensed
//
//
// This code is intended to help parse regex set expressions and mix them
// together, i.e. to answer questions like this:
// 
// what is the resulting regex set expression when we mix the regex set
// `[a-z]` with the regex set `[^\s]` where with 'mix' we mean that any
// input which matches either input regex should match the resulting
// regex set. (a.k.a. Full Outer Join, see also http://www.diffen.com/difference/Inner_Join_vs_Outer_Join)
// 

var XREGEXP_UNICODE_ESCAPE_RE$1 = /^\{[A-Za-z0-9 \-\._]+\}/; // Matches the XRegExp Unicode escape braced part, e.g. `{Number}`
var CHR_RE$1 = /^(?:[^\\]|\\[^cxu0-9]|\\[0-9]{1,3}|\\c[A-Z]|\\x[0-9a-fA-F]{2}|\\u[0-9a-fA-F]{4}|\\u\{[0-9a-fA-F]+\})/;
var SET_PART_RE$1 = /^(?:[^\\\]]|\\[^cxu0-9]|\\[0-9]{1,3}|\\c[A-Z]|\\x[0-9a-fA-F]{2}|\\u[0-9a-fA-F]{4}|\\u\{[0-9a-fA-F]+\})+/;
var NOTHING_SPECIAL_RE$1 = /^(?:[^\\\[\]\(\)\|^\{\}]|\\[^cxu0-9]|\\[0-9]{1,3}|\\c[A-Z]|\\x[0-9a-fA-F]{2}|\\u[0-9a-fA-F]{4}|\\u\{[0-9a-fA-F]+\})+/;
var SET_IS_SINGLE_PCODE_RE = /^\\[dDwWsS]$|^\\p\{[A-Za-z0-9 \-\._]+\}$/;

var UNICODE_BASE_PLANE_MAX_CP$1 = 65535;

// The expanded regex sets which are equivalent to the given `\\{c}` escapes:
//
// `/\s/`:
var WHITESPACE_SETSTR$1 = ' \f\n\r\t\x0B\xA0\u1680\u180E\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF';
// `/\d/`:
var DIGIT_SETSTR$1 = '0-9';
// `/\w/`:
var WORDCHAR_SETSTR$1 = 'A-Za-z0-9_';

// Helper for `bitarray2set()`: convert character code to a representation string suitable for use in a regex
function i2c(i) {
    var c, x;

    switch (i) {
        case 10:
            return '\\n';

        case 13:
            return '\\r';

        case 9:
            return '\\t';

        case 8:
            return '\\b';

        case 12:
            return '\\f';

        case 11:
            return '\\v';

        case 45:
            // ASCII/Unicode for '-' dash
            return '\\-';

        case 91:
            // '['
            return '\\[';

        case 92:
            // '\\'
            return '\\\\';

        case 93:
            // ']'
            return '\\]';

        case 94:
            // ']'
            return '\\^';
    }
    if (i < 32 || i > 0xFFF0 /* Unicode Specials, also in UTF16 */
    || i >= 0xD800 && i <= 0xDFFF /* Unicode Supplementary Planes; we're TOAST in JavaScript as we're NOT UTF-16 but UCS-2! */
    || String.fromCharCode(i).match(/[\u2028\u2029]/) /* Code compilation via `new Function()` does not like to see these, or rather: treats them as just another form of CRLF, which breaks your generated regex code! */
    ) {
            // Detail about a detail:
            // U+2028 and U+2029 are part of the `\s` regex escape code (`\s` and `[\s]` match either of these) and when placed in a JavaScript
            // source file verbatim (without escaping it as a `\uNNNN` item) then JavaScript will interpret it as such and consequently report
            // a b0rked generated parser, as the generated code would include this regex right here.
            // Hence we MUST escape these buggers everywhere we go...
            x = i.toString(16);
            if (x.length >= 1 && i <= 0xFFFF) {
                c = '0000' + x;
                return '\\u' + c.substr(c.length - 4);
            } else {
                return '\\u{' + x + '}';
            }
        }
    return String.fromCharCode(i);
}

// Helper collection for `bitarray2set()`: we have expanded all these cached `\\p{NAME}` regex sets when creating
// this bitarray and now we should look at these expansions again to see if `bitarray2set()` can produce a
// `\\p{NAME}` shorthand to represent [part of] the bitarray:
var Pcodes_bitarray_cache = {};
var Pcodes_bitarray_cache_test_order = [];

// Helper collection for `bitarray2set()` for minifying special cases of result sets which can be represented by 
// a single regex 'escape', e.g. `\d` for digits 0-9.
var EscCode_bitarray_output_refs;

// now initialize the EscCodes_... table above:
init_EscCode_lookup_table();

function init_EscCode_lookup_table() {
    var s,
        bitarr,
        set2esc = {},
        esc2bitarr = {};

    // patch global lookup tables for the time being, while we calculate their *real* content in this function:
    EscCode_bitarray_output_refs = {
        esc2bitarr: {},
        set2esc: {}
    };
    Pcodes_bitarray_cache_test_order = [];

    // `/\S':
    bitarr = [];
    set2bitarray(bitarr, '^' + WHITESPACE_SETSTR$1);
    s = bitarray2set(bitarr);
    esc2bitarr['S'] = bitarr;
    set2esc[s] = 'S';
    // set2esc['^' + s] = 's';
    Pcodes_bitarray_cache['\\S'] = bitarr;

    // `/\s':
    bitarr = [];
    set2bitarray(bitarr, WHITESPACE_SETSTR$1);
    s = bitarray2set(bitarr);
    esc2bitarr['s'] = bitarr;
    set2esc[s] = 's';
    // set2esc['^' + s] = 'S';
    Pcodes_bitarray_cache['\\s'] = bitarr;

    // `/\D':
    bitarr = [];
    set2bitarray(bitarr, '^' + DIGIT_SETSTR$1);
    s = bitarray2set(bitarr);
    esc2bitarr['D'] = bitarr;
    set2esc[s] = 'D';
    // set2esc['^' + s] = 'd';
    Pcodes_bitarray_cache['\\D'] = bitarr;

    // `/\d':
    bitarr = [];
    set2bitarray(bitarr, DIGIT_SETSTR$1);
    s = bitarray2set(bitarr);
    esc2bitarr['d'] = bitarr;
    set2esc[s] = 'd';
    // set2esc['^' + s] = 'D';
    Pcodes_bitarray_cache['\\d'] = bitarr;

    // `/\W':
    bitarr = [];
    set2bitarray(bitarr, '^' + WORDCHAR_SETSTR$1);
    s = bitarray2set(bitarr);
    esc2bitarr['W'] = bitarr;
    set2esc[s] = 'W';
    // set2esc['^' + s] = 'w';
    Pcodes_bitarray_cache['\\W'] = bitarr;

    // `/\w':
    bitarr = [];
    set2bitarray(bitarr, WORDCHAR_SETSTR$1);
    s = bitarray2set(bitarr);
    esc2bitarr['w'] = bitarr;
    set2esc[s] = 'w';
    // set2esc['^' + s] = 'W';
    Pcodes_bitarray_cache['\\w'] = bitarr;

    EscCode_bitarray_output_refs = {
        esc2bitarr: esc2bitarr,
        set2esc: set2esc
    };

    updatePcodesBitarrayCacheTestOrder();
}

function updatePcodesBitarrayCacheTestOrder(opts) {
    var t = new Array(UNICODE_BASE_PLANE_MAX_CP$1 + 1);
    var l = {};
    var user_has_xregexp = opts && opts.options && opts.options.xregexp;
    var i, j, k, ba;

    // mark every character with which regex pcodes they are part of:
    for (k in Pcodes_bitarray_cache) {
        ba = Pcodes_bitarray_cache[k];

        if (!user_has_xregexp && k.indexOf('\\p{') >= 0) {
            continue;
        }

        var cnt = 0;
        for (i = 0; i <= UNICODE_BASE_PLANE_MAX_CP$1; i++) {
            if (ba[i]) {
                cnt++;
                if (!t[i]) {
                    t[i] = [k];
                } else {
                    t[i].push(k);
                }
            }
        }
        l[k] = cnt;
    }

    // now dig out the unique ones: only need one per pcode.
    // 
    // We ASSUME every \\p{NAME} 'pcode' has at least ONE character
    // in it that is ONLY matched by that particular pcode. 
    // If this assumption fails, nothing is lost, but our 'regex set
    // optimized representation' will be sub-optimal as than this pcode
    // won't be tested during optimization. 
    // 
    // Now that would be a pity, so the assumption better holds...
    // Turns out the assumption doesn't hold already for /\S/ + /\D/
    // as the second one (\D) is a pure subset of \S. So we have to
    // look for markers which match multiple escapes/pcodes for those
    // ones where a unique item isn't available...
    var lut = [];
    var done = {};
    var keys = Object.keys(Pcodes_bitarray_cache);

    for (i = 0; i <= UNICODE_BASE_PLANE_MAX_CP$1; i++) {
        k = t[i][0];
        if (t[i].length === 1 && !done[k]) {
            assert(l[k] > 0);
            lut.push([i, k]);
            done[k] = true;
        }
    }

    for (j = 0; keys[j]; j++) {
        k = keys[j];

        if (!user_has_xregexp && k.indexOf('\\p{') >= 0) {
            continue;
        }

        if (!done[k]) {
            assert(l[k] > 0);
            // find a minimum span character to mark this one:
            var w = Infinity;
            var rv;
            ba = Pcodes_bitarray_cache[k];
            for (i = 0; i <= UNICODE_BASE_PLANE_MAX_CP$1; i++) {
                if (ba[i]) {
                    var tl = t[i].length;
                    if (tl > 1 && tl < w) {
                        assert(l[k] > 0);
                        rv = [i, k];
                        w = tl;
                    }
                }
            }
            if (rv) {
                done[k] = true;
                lut.push(rv);
            }
        }
    }

    // order from large set to small set so that small sets don't gobble
    // characters also represented by overlapping larger set pcodes.
    // 
    // Again we assume something: that finding the large regex pcode sets
    // before the smaller, more specialized ones, will produce a more
    // optimal minification of the regex set expression. 
    // 
    // This is a guestimate/heuristic only!
    lut.sort(function (a, b) {
        var k1 = a[1];
        var k2 = b[1];
        var ld = l[k2] - l[k1];
        if (ld) {
            return ld;
        }
        // and for same-size sets, order from high to low unique identifier.
        return b[0] - a[0];
    });

    Pcodes_bitarray_cache_test_order = lut;
}

// 'Join' a regex set `[...]` into a Unicode range spanning logic array, flagging every character in the given set.
function set2bitarray(bitarr, s, opts) {
    var orig = s;
    var set_is_inverted = false;
    var bitarr_orig;

    function mark(d1, d2) {
        if (d2 == null) d2 = d1;
        for (var i = d1; i <= d2; i++) {
            bitarr[i] = true;
        }
    }

    function add2bitarray(dst, src) {
        for (var i = 0; i <= UNICODE_BASE_PLANE_MAX_CP$1; i++) {
            if (src[i]) {
                dst[i] = true;
            }
        }
    }

    function eval_escaped_code(s) {
        var c;
        // decode escaped code? If none, just take the character as-is
        if (s.indexOf('\\') === 0) {
            var l = s.substr(0, 2);
            switch (l) {
                case '\\c':
                    c = s.charCodeAt(2) - 'A'.charCodeAt(0) + 1;
                    return String.fromCharCode(c);

                case '\\x':
                    s = s.substr(2);
                    c = parseInt(s, 16);
                    return String.fromCharCode(c);

                case '\\u':
                    s = s.substr(2);
                    if (s[0] === '{') {
                        s = s.substr(1, s.length - 2);
                    }
                    c = parseInt(s, 16);
                    if (c >= 0x10000) {
                        return new Error('We do NOT support Extended Plane Unicode Codepoints (i.e. CodePoints beyond U:FFFF) in regex set expressions, e.g. \\u{' + s + '}');
                    }
                    return String.fromCharCode(c);

                case '\\0':
                case '\\1':
                case '\\2':
                case '\\3':
                case '\\4':
                case '\\5':
                case '\\6':
                case '\\7':
                    s = s.substr(1);
                    c = parseInt(s, 8);
                    return String.fromCharCode(c);

                case '\\r':
                    return '\r';

                case '\\n':
                    return '\n';

                case '\\v':
                    return '\v';

                case '\\f':
                    return '\f';

                case '\\t':
                    return '\t';

                case '\\b':
                    return '\b';

                default:
                    // just the character itself:
                    return s.substr(1);
            }
        } else {
            return s;
        }
    }

    if (s && s.length) {
        var c1, c2;

        // inverted set?
        if (s[0] === '^') {
            set_is_inverted = true;
            s = s.substr(1);
            bitarr_orig = bitarr;
            bitarr = new Array(UNICODE_BASE_PLANE_MAX_CP$1 + 1);
        }

        // BITARR collects flags for characters set. Inversion means the complement set of character is st instead.
        // This results in an OR operations when sets are joined/chained.

        while (s.length) {
            c1 = s.match(CHR_RE$1);
            if (!c1) {
                // hit an illegal escape sequence? cope anyway!
                c1 = s[0];
            } else {
                c1 = c1[0];
                // Quick hack for XRegExp escapes inside a regex `[...]` set definition: we *could* try to keep those
                // intact but it's easier to unfold them here; this is not nice for when the grammar specifies explicit
                // XRegExp support, but alas, we'll get there when we get there... ;-)
                switch (c1) {
                    case '\\p':
                        s = s.substr(c1.length);
                        c2 = s.match(XREGEXP_UNICODE_ESCAPE_RE$1);
                        if (c2) {
                            c2 = c2[0];
                            s = s.substr(c2.length);
                            // do we have this one cached already?
                            var pex = c1 + c2;
                            var ba4p = Pcodes_bitarray_cache[pex];
                            if (!ba4p) {
                                // expand escape:
                                var xr = new XRegExp('[' + pex + ']'); // TODO: case-insensitive grammar???
                                // rewrite to a standard `[...]` regex set: XRegExp will do this for us via `XRegExp.toString()`:
                                var xs = '' + xr;
                                // remove the wrapping `/.../` to get at the (possibly *combined* series of) `[...]` sets inside:
                                xs = xs.substr(1, xs.length - 2);

                                ba4p = reduceRegexToSetBitArray(xs, pex, opts);

                                Pcodes_bitarray_cache[pex] = ba4p;
                                updatePcodesBitarrayCacheTestOrder(opts);
                            }
                            // merge bitarrays:
                            add2bitarray(bitarr, ba4p);
                            continue;
                        }
                        break;

                    case '\\S':
                    case '\\s':
                    case '\\W':
                    case '\\w':
                    case '\\d':
                    case '\\D':
                        // these can't participate in a range, but need to be treated special:
                        s = s.substr(c1.length);
                        // check for \S, \s, \D, \d, \W, \w and expand them:
                        var ba4e = EscCode_bitarray_output_refs.esc2bitarr[c1[1]];
                        assert(ba4e);
                        add2bitarray(bitarr, ba4e);
                        continue;

                    case '\\b':
                        // matches a backspace: https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions#special-backspace
                        c1 = '\b';
                        break;
                }
            }
            var v1 = eval_escaped_code(c1);
            // propagate deferred exceptions = error reports.
            if (v1 instanceof Error) {
                return v1;
            }
            v1 = v1.charCodeAt(0);
            s = s.substr(c1.length);

            if (s[0] === '-' && s.length >= 2) {
                // we can expect a range like 'a-z':
                s = s.substr(1);
                c2 = s.match(CHR_RE$1);
                if (!c2) {
                    // hit an illegal escape sequence? cope anyway!
                    c2 = s[0];
                } else {
                    c2 = c2[0];
                }
                var v2 = eval_escaped_code(c2);
                // propagate deferred exceptions = error reports.
                if (v2 instanceof Error) {
                    return v1;
                }
                v2 = v2.charCodeAt(0);
                s = s.substr(c2.length);

                // legal ranges go UP, not /DOWN!
                if (v1 <= v2) {
                    mark(v1, v2);
                } else {
                    console.warn('INVALID CHARACTER RANGE found in regex: ', { re: orig, start: c1, start_n: v1, end: c2, end_n: v2 });
                    mark(v1);
                    mark('-'.charCodeAt(0));
                    mark(v2);
                }
                continue;
            }
            mark(v1);
        }

        // When we have marked all slots, '^' NEGATES the set, hence we flip all slots.
        // 
        // Since a regex like `[^]` should match everything(?really?), we don't need to check if the MARK
        // phase actually marked anything at all: the `^` negation will correctly flip=mark the entire
        // range then.
        if (set_is_inverted) {
            for (var i = 0; i <= UNICODE_BASE_PLANE_MAX_CP$1; i++) {
                if (!bitarr[i]) {
                    bitarr_orig[i] = true;
                }
            }
        }
    }
    return false;
}

// convert a simple bitarray back into a regex set `[...]` content:
function bitarray2set(l, output_inverted_variant, output_minimized) {
    // construct the inverse(?) set from the mark-set:
    //
    // Before we do that, we inject a sentinel so that our inner loops
    // below can be simple and fast:
    l[UNICODE_BASE_PLANE_MAX_CP$1 + 1] = 1;
    // now reconstruct the regex set:
    var rv = [];
    var i, j, cnt, lut, tn, tspec, match, pcode, ba4pcode, l2;
    var bitarr_is_cloned = false;
    var l_orig = l;

    if (output_inverted_variant) {
        // generate the inverted set, hence all unmarked slots are part of the output range:
        cnt = 0;
        for (i = 0; i <= UNICODE_BASE_PLANE_MAX_CP$1; i++) {
            if (!l[i]) {
                cnt++;
            }
        }
        if (cnt === UNICODE_BASE_PLANE_MAX_CP$1 + 1) {
            // When there's nothing in the output we output a special 'match-nothing' regex: `[^\S\s]`.
            // BUT... since we output the INVERTED set, we output the match-all set instead:
            return '\\S\\s';
        } else if (cnt === 0) {
            // When we find the entire Unicode range is in the output match set, we replace this with
            // a shorthand regex: `[\S\s]`
            // BUT... since we output the INVERTED set, we output the match-nothing set instead:
            return '^\\S\\s';
        }

        // Now see if we can replace several bits by an escape / pcode:
        if (output_minimized) {
            lut = Pcodes_bitarray_cache_test_order;
            for (tn = 0; lut[tn]; tn++) {
                tspec = lut[tn];
                // check if the uniquely identifying char is in the inverted set:
                if (!l[tspec[0]]) {
                    // check if the pcode is covered by the inverted set:
                    pcode = tspec[1];
                    ba4pcode = Pcodes_bitarray_cache[pcode];
                    match = 0;
                    for (j = 0; j <= UNICODE_BASE_PLANE_MAX_CP$1; j++) {
                        if (ba4pcode[j]) {
                            if (!l[j]) {
                                // match in current inverted bitset, i.e. there's at
                                // least one 'new' bit covered by this pcode/escape:
                                match++;
                            } else if (l_orig[j]) {
                                // mismatch!
                                match = false;
                                break;
                            }
                        }
                    }

                    // We're only interested in matches which actually cover some 
                    // yet uncovered bits: `match !== 0 && match !== false`.
                    // 
                    // Apply the heuristic that the pcode/escape is only going to be used
                    // when it covers *more* characters than its own identifier's length:
                    if (match && match > pcode.length) {
                        rv.push(pcode);

                        // and nuke the bits in the array which match the given pcode:
                        // make sure these edits are visible outside this function as
                        // `l` is an INPUT parameter (~ not modified)!
                        if (!bitarr_is_cloned) {
                            l2 = new Array(UNICODE_BASE_PLANE_MAX_CP$1 + 1);
                            for (j = 0; j <= UNICODE_BASE_PLANE_MAX_CP$1; j++) {
                                l2[j] = l[j] || ba4pcode[j]; // `!(!l[j] && !ba4pcode[j])`
                            }
                            // recreate sentinel
                            l2[UNICODE_BASE_PLANE_MAX_CP$1 + 1] = 1;
                            l = l2;
                            bitarr_is_cloned = true;
                        } else {
                            for (j = 0; j <= UNICODE_BASE_PLANE_MAX_CP$1; j++) {
                                l[j] = l[j] || ba4pcode[j];
                            }
                        }
                    }
                }
            }
        }

        i = 0;
        while (i <= UNICODE_BASE_PLANE_MAX_CP$1) {
            // find first character not in original set:
            while (l[i]) {
                i++;
            }
            if (i >= UNICODE_BASE_PLANE_MAX_CP$1 + 1) {
                break;
            }
            // find next character not in original set:
            for (j = i + 1; !l[j]; j++) {} /* empty loop */
            // generate subset:
            rv.push(i2c(i));
            if (j - 1 > i) {
                rv.push((j - 2 > i ? '-' : '') + i2c(j - 1));
            }
            i = j;
        }
    } else {
        // generate the non-inverted set, hence all logic checks are inverted here...
        cnt = 0;
        for (i = 0; i <= UNICODE_BASE_PLANE_MAX_CP$1; i++) {
            if (l[i]) {
                cnt++;
            }
        }
        if (cnt === UNICODE_BASE_PLANE_MAX_CP$1 + 1) {
            // When we find the entire Unicode range is in the output match set, we replace this with
            // a shorthand regex: `[\S\s]`
            return '\\S\\s';
        } else if (cnt === 0) {
            // When there's nothing in the output we output a special 'match-nothing' regex: `[^\S\s]`.
            return '^\\S\\s';
        }

        // Now see if we can replace several bits by an escape / pcode:
        if (output_minimized) {
            lut = Pcodes_bitarray_cache_test_order;
            for (tn = 0; lut[tn]; tn++) {
                tspec = lut[tn];
                // check if the uniquely identifying char is in the set:
                if (l[tspec[0]]) {
                    // check if the pcode is covered by the set:
                    pcode = tspec[1];
                    ba4pcode = Pcodes_bitarray_cache[pcode];
                    match = 0;
                    for (j = 0; j <= UNICODE_BASE_PLANE_MAX_CP$1; j++) {
                        if (ba4pcode[j]) {
                            if (l[j]) {
                                // match in current bitset, i.e. there's at
                                // least one 'new' bit covered by this pcode/escape:
                                match++;
                            } else if (!l_orig[j]) {
                                // mismatch!
                                match = false;
                                break;
                            }
                        }
                    }

                    // We're only interested in matches which actually cover some 
                    // yet uncovered bits: `match !== 0 && match !== false`.
                    // 
                    // Apply the heuristic that the pcode/escape is only going to be used
                    // when it covers *more* characters than its own identifier's length:
                    if (match && match > pcode.length) {
                        rv.push(pcode);

                        // and nuke the bits in the array which match the given pcode:
                        // make sure these edits are visible outside this function as
                        // `l` is an INPUT parameter (~ not modified)!
                        if (!bitarr_is_cloned) {
                            l2 = new Array(UNICODE_BASE_PLANE_MAX_CP$1 + 1);
                            for (j = 0; j <= UNICODE_BASE_PLANE_MAX_CP$1; j++) {
                                l2[j] = l[j] && !ba4pcode[j];
                            }
                            // recreate sentinel
                            l2[UNICODE_BASE_PLANE_MAX_CP$1 + 1] = 1;
                            l = l2;
                            bitarr_is_cloned = true;
                        } else {
                            for (j = 0; j <= UNICODE_BASE_PLANE_MAX_CP$1; j++) {
                                l[j] = l[j] && !ba4pcode[j];
                            }
                        }
                    }
                }
            }
        }

        i = 0;
        while (i <= UNICODE_BASE_PLANE_MAX_CP$1) {
            // find first character not in original set:
            while (!l[i]) {
                i++;
            }
            if (i >= UNICODE_BASE_PLANE_MAX_CP$1 + 1) {
                break;
            }
            // find next character not in original set:
            for (j = i + 1; l[j]; j++) {} /* empty loop */
            if (j > UNICODE_BASE_PLANE_MAX_CP$1 + 1) {
                j = UNICODE_BASE_PLANE_MAX_CP$1 + 1;
            }
            // generate subset:
            rv.push(i2c(i));
            if (j - 1 > i) {
                rv.push((j - 2 > i ? '-' : '') + i2c(j - 1));
            }
            i = j;
        }
    }

    assert(rv.length);
    var s = rv.join('');
    assert(s);

    // Check if the set is better represented by one of the regex escapes:
    var esc4s = EscCode_bitarray_output_refs.set2esc[s];
    if (esc4s) {
        // When we hit a special case like this, it is always the shortest notation, hence wins on the spot!
        return '\\' + esc4s;
    }
    return s;
}

// Pretty brutal conversion of 'regex' `s` back to raw regex set content: strip outer [...] when they're there;
// ditto for inner combos of sets, i.e. `]|[` as in `[0-9]|[a-z]`.
function reduceRegexToSetBitArray(s, name, opts) {
    var orig = s;

    // propagate deferred exceptions = error reports.
    if (s instanceof Error) {
        return s;
    }

    var l = new Array(UNICODE_BASE_PLANE_MAX_CP$1 + 1);
    var internal_state = 0;
    var derr;

    while (s.length) {
        var c1 = s.match(CHR_RE$1);
        if (!c1) {
            // cope with illegal escape sequences too!
            return new Error('illegal escape sequence at start of regex part: "' + s + '" of regex "' + orig + '"');
        } else {
            c1 = c1[0];
        }
        s = s.substr(c1.length);

        switch (c1) {
            case '[':
                // this is starting a set within the regex: scan until end of set!
                var set_content = [];
                while (s.length) {
                    var inner = s.match(SET_PART_RE$1);
                    if (!inner) {
                        inner = s.match(CHR_RE$1);
                        if (!inner) {
                            // cope with illegal escape sequences too!
                            return new Error('illegal escape sequence at start of regex part: ' + s + '" of regex "' + orig + '"');
                        } else {
                            inner = inner[0];
                        }
                        if (inner === ']') break;
                    } else {
                        inner = inner[0];
                    }
                    set_content.push(inner);
                    s = s.substr(inner.length);
                }

                // ensure that we hit the terminating ']':
                var c2 = s.match(CHR_RE$1);
                if (!c2) {
                    // cope with illegal escape sequences too!
                    return new Error('regex set expression is broken in regex: "' + orig + '" --> "' + s + '"');
                } else {
                    c2 = c2[0];
                }
                if (c2 !== ']') {
                    return new Error('regex set expression is broken in regex: ' + orig);
                }
                s = s.substr(c2.length);

                var se = set_content.join('');
                if (!internal_state) {
                    derr = set2bitarray(l, se, opts);
                    // propagate deferred exceptions = error reports.
                    if (derr instanceof Error) {
                        return derr;
                    }

                    // a set is to use like a single character in a longer literal phrase, hence input `[abc]word[def]` would thus produce output `[abc]`:
                    internal_state = 1;
                }
                break;

            // Strip unescaped pipes to catch constructs like `\\r|\\n` and turn them into
            // something ready for use inside a regex set, e.g. `\\r\\n`.
            //
            // > Of course, we realize that converting more complex piped constructs this way
            // > will produce something you might not expect, e.g. `A|WORD2` which
            // > would end up as the set `[AW]` which is something else than the input
            // > entirely.
            // >
            // > However, we can only depend on the user (grammar writer) to realize this and
            // > prevent this from happening by not creating such oddities in the input grammar.
            case '|':
                // a|b --> [ab]
                internal_state = 0;
                break;

            case '(':
                // (a) --> a
                //
                // TODO - right now we treat this as 'too complex':

                // Strip off some possible outer wrappers which we know how to remove.
                // We don't worry about 'damaging' the regex as any too-complex regex will be caught
                // in the validation check at the end; our 'strippers' here would not damage useful
                // regexes anyway and them damaging the unacceptable ones is fine.
                s = s.replace(/^\((?:\?:)?(.*?)\)$/, '$1'); // (?:...) -> ...  and  (...) -> ...
                s = s.replace(/^\^?(.*?)\$?$/, '$1'); // ^...$ --> ...  (catch these both inside and outside the outer grouping, hence do the ungrouping twice: one before, once after this)
                s = s.replace(/^\((?:\?:)?(.*?)\)$/, '$1'); // (?:...) -> ...  and  (...) -> ...

                return new Error('[macro [' + name + '] is unsuitable for use inside regex set expressions: "[' + orig + ']"]');

            case '.':
            case '*':
            case '+':
            case '?':
                // wildcard
                //
                // TODO - right now we treat this as 'too complex':
                return new Error('[macro [' + name + '] is unsuitable for use inside regex set expressions: "[' + orig + ']"]');

            case '{':
                // range, e.g. `x{1,3}`, or macro?
                // TODO - right now we treat this as 'too complex':
                return new Error('[macro [' + name + '] is unsuitable for use inside regex set expressions: "[' + orig + ']"]');

            default:
                // literal character or word: take the first character only and ignore the rest, so that
                // the constructed set for `word|noun` would be `[wb]`:
                if (!internal_state) {
                    derr = set2bitarray(l, c1, opts);
                    // propagate deferred exceptions = error reports.
                    if (derr instanceof Error) {
                        return derr;
                    }

                    internal_state = 2;
                }
                break;
        }
    }

    s = bitarray2set(l);

    // When this result is suitable for use in a set, than we should be able to compile
    // it in a regex; that way we can easily validate whether macro X is fit to be used
    // inside a regex set:
    try {
        var re;
        assert(s);
        assert(!(s instanceof Error));
        re = new XRegExp('[' + s + ']');
        re.test(s[0]);

        // One thing is apparently *not* caught by the RegExp compile action above: `[a[b]c]`
        // so we check for lingering UNESCAPED brackets in here as those cannot be:
        if (/[^\\][\[\]]/.exec(s)) {
            throw new Error('unescaped brackets in set data');
        }
    } catch (ex) {
        // make sure we produce a set range expression which will fail badly when it is used
        // in actual code:
        s = new Error('[macro [' + name + '] is unsuitable for use inside regex set expressions: "[' + s + ']"]: ' + ex.message);
    }

    assert(s);
    // propagate deferred exceptions = error reports.
    if (s instanceof Error) {
        return s;
    }
    return l;
}

// Convert bitarray representing, for example, `'0-9'` to regex string `[0-9]` 
// -- or in this example it can be further optimized to only `\d`!
function produceOptimizedRegex4Set(bitarr) {
    // First try to produce a minimum regex from the bitarray directly:
    var s1 = bitarray2set(bitarr, false, true);

    // and when the regex set turns out to match a single pcode/escape, then
    // use that one as-is:
    if (s1.match(SET_IS_SINGLE_PCODE_RE)) {
        // When we hit a special case like this, it is always the shortest notation, hence wins on the spot!
        return s1;
    } else {
        s1 = '[' + s1 + ']';
    }

    // Now try to produce a minimum regex from the *inverted* bitarray via negation:
    // Because we look at a negated bitset, there's no use looking for matches with
    // special cases here.
    var s2 = bitarray2set(bitarr, true, true);

    if (s2[0] === '^') {
        s2 = s2.substr(1);
        if (s2.match(SET_IS_SINGLE_PCODE_RE)) {
            // When we hit a special case like this, it is always the shortest notation, hence wins on the spot!
            return s2;
        }
    } else {
        s2 = '^' + s2;
    }
    s2 = '[' + s2 + ']';

    // Then, as some pcode/escapes still happen to deliver a LARGER regex string in the end,
    // we also check against the plain, unadulterated regex set expressions:
    // 
    // First try to produce a minimum regex from the bitarray directly:
    var s3 = bitarray2set(bitarr, false, false);

    // and when the regex set turns out to match a single pcode/escape, then
    // use that one as-is:
    if (s3.match(SET_IS_SINGLE_PCODE_RE)) {
        // When we hit a special case like this, it is always the shortest notation, hence wins on the spot!
        return s3;
    } else {
        s3 = '[' + s3 + ']';
    }

    // Now try to produce a minimum regex from the *inverted* bitarray via negation:
    // Because we look at a negated bitset, there's no use looking for matches with
    // special cases here.
    var s4 = bitarray2set(bitarr, true, false);

    if (s4[0] === '^') {
        s4 = s4.substr(1);
        if (s4.match(SET_IS_SINGLE_PCODE_RE)) {
            // When we hit a special case like this, it is always the shortest notation, hence wins on the spot!
            return s4;
        }
    } else {
        s4 = '^' + s4;
    }
    s4 = '[' + s4 + ']';

    if (s2.length < s1.length) {
        s1 = s2;
    }
    if (s3.length < s1.length) {
        s1 = s3;
    }
    if (s4.length < s1.length) {
        s1 = s4;
    }

    return s1;
}

var setmgmt = {
    XREGEXP_UNICODE_ESCAPE_RE: XREGEXP_UNICODE_ESCAPE_RE$1,
    CHR_RE: CHR_RE$1,
    SET_PART_RE: SET_PART_RE$1,
    NOTHING_SPECIAL_RE: NOTHING_SPECIAL_RE$1,
    SET_IS_SINGLE_PCODE_RE: SET_IS_SINGLE_PCODE_RE,

    UNICODE_BASE_PLANE_MAX_CP: UNICODE_BASE_PLANE_MAX_CP$1,

    WHITESPACE_SETSTR: WHITESPACE_SETSTR$1,
    DIGIT_SETSTR: DIGIT_SETSTR$1,
    WORDCHAR_SETSTR: WORDCHAR_SETSTR$1,

    set2bitarray: set2bitarray,
    bitarray2set: bitarray2set,
    produceOptimizedRegex4Set: produceOptimizedRegex4Set,
    reduceRegexToSetBitArray: reduceRegexToSetBitArray
};

// Basic Lexer implemented using JavaScript regular expressions
// Zachary Carter <zach@carter.name>
// MIT Licensed

var rmCommonWS$1 = helpers.rmCommonWS;
var camelCase$1 = helpers.camelCase;
var code_exec$1 = helpers.exec;
// import recast from '@gerhobbelt/recast';
// import astUtils from '@gerhobbelt/ast-util';
var version$1 = '0.6.1-210'; // require('./package.json').version;


var XREGEXP_UNICODE_ESCAPE_RE = setmgmt.XREGEXP_UNICODE_ESCAPE_RE; // Matches the XRegExp Unicode escape braced part, e.g. `{Number}`
var CHR_RE = setmgmt.CHR_RE;
var SET_PART_RE = setmgmt.SET_PART_RE;
var NOTHING_SPECIAL_RE = setmgmt.NOTHING_SPECIAL_RE;
var UNICODE_BASE_PLANE_MAX_CP = setmgmt.UNICODE_BASE_PLANE_MAX_CP;

// WARNING: this regex MUST match the regex for `ID` in ebnf-parser::bnf.l jison language lexer spec! (`ID = [{ALPHA}]{ALNUM}*`)
//
// This is the base XRegExp ID regex used in many places; this should match the ID macro definition in the EBNF/BNF parser et al as well!
var ID_REGEX_BASE$1 = '[\\p{Alphabetic}_][\\p{Alphabetic}_\\p{Number}]*';

// see also ./lib/cli.js
/**
@public
@nocollapse
*/
var defaultJisonLexOptions = {
    moduleType: 'commonjs',
    debug: false,
    enableDebugLogs: false,
    json: false,
    main: false, // CLI: not:(--main option)
    dumpSourceCodeOnFailure: true,
    throwErrorOnCompileFailure: true,

    moduleName: undefined,
    defaultModuleName: 'lexer',
    file: undefined,
    outfile: undefined,
    inputPath: undefined,
    inputFilename: undefined,
    warn_cb: undefined, // function(msg) | true (= use Jison.Print) | false (= throw Exception)

    xregexp: false,
    lexerErrorsAreRecoverable: false,
    flex: false,
    backtrack_lexer: false,
    ranges: false, // track position range, i.e. start+end indexes in the input string
    trackPosition: true, // track line+column position in the input string
    caseInsensitive: false,
    showSource: false,
    exportSourceCode: false,
    exportAST: false,
    prettyCfg: true,
    pre_lex: undefined,
    post_lex: undefined
};

// Merge sets of options.
//
// Convert alternative jison option names to their base option.
//
// The *last* option set which overrides the default wins, where 'override' is
// defined as specifying a not-undefined value which is not equal to the
// default value.
//
// When the FIRST argument is STRING "NODEFAULT", then we MUST NOT mix the 
// default values avialable in Jison.defaultJisonOptions.
//
// Return a fresh set of options.
/** @public */
function mkStdOptions$1() /*...args*/{
    var h = Object.prototype.hasOwnProperty;

    var opts = {};
    var args = [].concat.apply([], arguments);
    // clone defaults, so we do not modify those constants?
    if (args[0] !== "NODEFAULT") {
        args.unshift(defaultJisonLexOptions);
    } else {
        args.shift();
    }

    for (var i = 0, len = args.length; i < len; i++) {
        var o = args[i];
        if (!o) continue;

        // clone input (while camel-casing the options), so we do not modify those either.
        var o2 = {};

        for (var p in o) {
            if (typeof o[p] !== 'undefined' && h.call(o, p)) {
                o2[camelCase$1(p)] = o[p];
            }
        }

        // now clean them options up:
        if (typeof o2.main !== 'undefined') {
            o2.noMain = !o2.main;
        }

        delete o2.main;

        // special check for `moduleName` to ensure we detect the 'default' moduleName entering from the CLI
        // NOT overriding the moduleName set in the grammar definition file via an `%options` entry:
        if (o2.moduleName === o2.defaultModuleName) {
            delete o2.moduleName;
        }

        // now see if we have an overriding option here:
        for (var p in o2) {
            if (h.call(o2, p)) {
                if (typeof o2[p] !== 'undefined') {
                    opts[p] = o2[p];
                }
            }
        }
    }

    return opts;
}

// set up export/output attributes of the `options` object instance
function prepExportStructures$1(options) {
    // set up the 'option' `exportSourceCode` as a hash object for returning
    // all generated source code chunks to the caller
    var exportSourceCode = options.exportSourceCode;
    if (!exportSourceCode || (typeof exportSourceCode === 'undefined' ? 'undefined' : _typeof(exportSourceCode)) !== 'object') {
        exportSourceCode = {
            enabled: !!exportSourceCode
        };
    } else if (typeof exportSourceCode.enabled !== 'boolean') {
        exportSourceCode.enabled = true;
    }
    options.exportSourceCode = exportSourceCode;
}

// Autodetect if the input lexer spec is in JSON or JISON
// format when the `options.json` flag is `true`.
//
// Produce the JSON lexer spec result when these are JSON formatted already as that
// would save us the trouble of doing this again, anywhere else in the JISON
// compiler/generator.
//
// Otherwise return the *parsed* lexer spec as it has
// been processed through LexParser.
function autodetectAndConvertToJSONformat$1(lexerSpec, options) {
    var chk_l = null;
    var ex1, err;

    if (typeof lexerSpec === 'string') {
        if (options.json) {
            try {
                chk_l = json5.parse(lexerSpec);

                // When JSON5-based parsing of the lexer spec succeeds, this implies the lexer spec is specified in `JSON mode`
                // *OR* there's a JSON/JSON5 format error in the input:
            } catch (e) {
                ex1 = e;
            }
        }
        if (!chk_l) {
            // // WARNING: the lexer may receive options specified in the **grammar spec file**,
            // //          hence we should mix the options to ensure the lexParser always
            // //          receives the full set!
            // //
            // // make sure all options are 'standardized' before we go and mix them together:
            // options = mkStdOptions(grammar.options, options);
            try {
                chk_l = jisonlex.parse(lexerSpec, options);
            } catch (e) {
                if (options.json) {
                    err = new Error('Could not parse lexer spec in JSON AUTODETECT mode\nError: ' + ex1.message + ' (' + e.message + ')');
                    err.secondary_exception = e;
                    err.stack = ex1.stack;
                } else {
                    err = new Error('Could not parse lexer spec\nError: ' + e.message);
                    err.stack = e.stack;
                }
                throw err;
            }
        }
    } else {
        chk_l = lexerSpec;
    }

    // Save time! Don't reparse the entire lexer spec *again* inside the code generators when that's not necessary:

    return chk_l;
}

// expand macros and convert matchers to RegExp's
function prepareRules(dict, actions, caseHelper, tokens, startConditions, opts) {
    var m, i, k, rule, action, conditions;
    var active_conditions;
    assert(Array.isArray(dict.rules));
    var rules = dict.rules.slice(0); // shallow copy of the rules array as we MAY modify it in here!        
    var newRules = [];
    var macros = {};
    var regular_rule_count = 0;
    var simple_rule_count = 0;

    // Assure all options are camelCased:
    assert(typeof opts.options['case-insensitive'] === 'undefined');

    if (!tokens) {
        tokens = {};
    }

    if (opts.options.flex && rules.length > 0) {
        rules.push(['.', 'console.log("", yytext); /* `flex` lexing mode: the last resort rule! */']);
    }

    // Depending on the location within the regex we need different expansions of the macros:
    // one expansion for when a macro is *inside* a `[...]` and another expansion when a macro
    // is anywhere else in a regex:
    if (dict.macros) {
        macros = prepareMacros(dict.macros, opts);
    }

    function tokenNumberReplacement(str, token) {
        return 'return ' + (tokens[token] || '\'' + token.replace(/'/g, '\\\'') + '\'');
    }

    // Make sure a comment does not contain any embedded '*/' end-of-comment marker
    // as that would break the generated code
    function postprocessComment(str) {
        if (Array.isArray(str)) {
            str = str.join(' ');
        }
        str = str.replace(/\*\//g, '*\\/'); // destroy any inner `*/` comment terminator sequence.
        return str;
    }

    var routingCode = ['switch(yyrulenumber) {'];

    for (i = 0; i < rules.length; i++) {
        rule = rules[i].slice(0); // shallow copy: do not modify input rules
        m = rule[0];

        active_conditions = [];
        if (!Array.isArray(m)) {
            // implicit add to all inclusive start conditions
            for (k in startConditions) {
                if (startConditions[k].inclusive) {
                    active_conditions.push(k);
                    startConditions[k].rules.push(i);
                }
            }
        } else if (m[0] === '*') {
            // Add to ALL start conditions
            active_conditions.push('*');
            for (k in startConditions) {
                startConditions[k].rules.push(i);
            }
            rule.shift();
            m = rule[0];
        } else {
            // Add to explicit start conditions
            conditions = rule.shift();
            m = rule[0];
            for (k = 0; k < conditions.length; k++) {
                if (!startConditions.hasOwnProperty(conditions[k])) {
                    startConditions[conditions[k]] = {
                        rules: [],
                        inclusive: false
                    };
                    console.warn('Lexer Warning:', '"' + conditions[k] + '" start condition should be defined as %s or %x; assuming %x now.');
                }
                active_conditions.push(conditions[k]);
                startConditions[conditions[k]].rules.push(i);
            }
        }

        if (typeof m === 'string') {
            m = expandMacros(m, macros, opts);
            m = new XRegExp('^(?:' + m + ')', opts.options.caseInsensitive ? 'i' : '');
        }
        newRules.push(m);
        action = rule[1];
        if (typeof action === 'function') {
            // TODO: also cope with Arrow Functions (and inline those as well?) -- see also https://github.com/zaach/jison-lex/issues/23
            action = String(action).replace(/^\s*function\s*\(\)\s?\{/, '').replace(/\}\s*$/, '');
        }
        action = action.replace(/return\s*'((?:\\'|[^']+)+)'/g, tokenNumberReplacement);
        action = action.replace(/return\s*"((?:\\"|[^"]+)+)"/g, tokenNumberReplacement);

        var code = ['\n/*! Conditions::'];
        code.push(postprocessComment(active_conditions));
        code.push('*/', '\n/*! Rule::      ');
        code.push(postprocessComment(rule[0]));
        code.push('*/', '\n');

        // When the action is *only* a simple `return TOKEN` statement, then add it to the caseHelpers;
        // otherwise add the additional `break;` at the end.
        //
        // Note: we do NOT analyze the action block any more to see if the *last* line is a simple
        // `return NNN;` statement as there are too many shoddy idioms, e.g.
        //
        // ```
        // %{ if (cond)
        //      return TOKEN;
        // %}
        // ```
        //
        // which would then cause havoc when our action code analysis (using regexes or otherwise) was 'too simple'
        // to catch these culprits; hence we resort and stick with the most fundamental approach here:
        // always append `break;` even when it would be obvious to a human that such would be 'unreachable code'.
        var match_nr = /^return[\s\r\n]+((?:'(?:\\'|[^']+)+')|(?:"(?:\\"|[^"]+)+")|\d+)[\s\r\n]*;?$/.exec(action.trim());
        if (match_nr) {
            simple_rule_count++;
            caseHelper.push([].concat(code, i, ':', match_nr[1]).join(' ').replace(/[\n]/g, '\n  '));
        } else {
            regular_rule_count++;
            routingCode.push([].concat('case', i, ':', code, action, '\nbreak;').join(' '));
        }
    }
    if (simple_rule_count) {
        routingCode.push('default:');
        routingCode.push('  return this.simpleCaseActionClusters[yyrulenumber];');
    }
    routingCode.push('}');

    // only inject the big switch/case chunk when there's any `switch` or `default` branch to switch to:
    if (simple_rule_count + regular_rule_count > 0) {
        actions.push.apply(actions, routingCode);
    } else {
        actions.push('/* no rules ==> no rule SWITCH! */');
    }

    return {
        rules: newRules,
        macros: macros,

        regular_rule_count: regular_rule_count,
        simple_rule_count: simple_rule_count
    };
}

// expand all macros (with maybe one exception) in the given regex: the macros may exist inside `[...]` regex sets or
// elsewhere, which requires two different treatments to expand these macros.
function reduceRegex(s, name, opts, expandAllMacrosInSet_cb, expandAllMacrosElsewhere_cb) {
    var orig = s;

    function errinfo() {
        if (name) {
            return 'macro [[' + name + ']]';
        } else {
            return 'regex [[' + orig + ']]';
        }
    }

    // propagate deferred exceptions = error reports.
    if (s instanceof Error) {
        return s;
    }

    var c1, c2;
    var rv = [];
    var derr;
    var se;

    while (s.length) {
        c1 = s.match(CHR_RE);
        if (!c1) {
            // cope with illegal escape sequences too!
            return new Error(errinfo() + ': illegal escape sequence at start of regex part: ' + s);
        } else {
            c1 = c1[0];
        }
        s = s.substr(c1.length);

        switch (c1) {
            case '[':
                // this is starting a set within the regex: scan until end of set!
                var set_content = [];
                var l = new Array(UNICODE_BASE_PLANE_MAX_CP + 1);

                while (s.length) {
                    var inner = s.match(SET_PART_RE);
                    if (!inner) {
                        inner = s.match(CHR_RE);
                        if (!inner) {
                            // cope with illegal escape sequences too!
                            return new Error(errinfo() + ': illegal escape sequence at start of regex part: ' + s);
                        } else {
                            inner = inner[0];
                        }
                        if (inner === ']') break;
                    } else {
                        inner = inner[0];
                    }
                    set_content.push(inner);
                    s = s.substr(inner.length);
                }

                // ensure that we hit the terminating ']':
                c2 = s.match(CHR_RE);
                if (!c2) {
                    // cope with illegal escape sequences too!
                    return new Error(errinfo() + ': regex set expression is broken: "' + s + '"');
                } else {
                    c2 = c2[0];
                }
                if (c2 !== ']') {
                    return new Error(errinfo() + ': regex set expression is broken: apparently unterminated');
                }
                s = s.substr(c2.length);

                se = set_content.join('');

                // expand any macros in here:
                if (expandAllMacrosInSet_cb) {
                    se = expandAllMacrosInSet_cb(se);
                    assert(se);
                    if (se instanceof Error) {
                        return new Error(errinfo() + ': ' + se.message);
                    }
                }

                derr = setmgmt.set2bitarray(l, se, opts);
                if (derr instanceof Error) {
                    return new Error(errinfo() + ': ' + derr.message);
                }

                // find out which set expression is optimal in size:
                var s1 = setmgmt.produceOptimizedRegex4Set(l);

                // check if the source regex set potentially has any expansions (guestimate!)
                //
                // The indexOf('{') picks both XRegExp Unicode escapes and JISON lexer macros, which is perfect for us here.
                var has_expansions = se.indexOf('{') >= 0;

                se = '[' + se + ']';

                if (!has_expansions && se.length < s1.length) {
                    s1 = se;
                }
                rv.push(s1);
                break;

            // XRegExp Unicode escape, e.g. `\\p{Number}`:
            case '\\p':
                c2 = s.match(XREGEXP_UNICODE_ESCAPE_RE);
                if (c2) {
                    c2 = c2[0];
                    s = s.substr(c2.length);

                    // nothing to expand.
                    rv.push(c1 + c2);
                } else {
                    // nothing to stretch this match, hence nothing to expand.
                    rv.push(c1);
                }
                break;

            // Either a range expression or the start of a macro reference: `.{1,3}` or `{NAME}`.
            // Treat it as a macro reference and see if it will expand to anything:
            case '{':
                c2 = s.match(NOTHING_SPECIAL_RE);
                if (c2) {
                    c2 = c2[0];
                    s = s.substr(c2.length);

                    var c3 = s[0];
                    s = s.substr(c3.length);
                    if (c3 === '}') {
                        // possibly a macro name in there... Expand if possible:
                        c2 = c1 + c2 + c3;
                        if (expandAllMacrosElsewhere_cb) {
                            c2 = expandAllMacrosElsewhere_cb(c2);
                            assert(c2);
                            if (c2 instanceof Error) {
                                return new Error(errinfo() + ': ' + c2.message);
                            }
                        }
                    } else {
                        // not a well-terminated macro reference or something completely different:
                        // we do not even attempt to expand this as there's guaranteed nothing to expand
                        // in this bit.
                        c2 = c1 + c2 + c3;
                    }
                    rv.push(c2);
                } else {
                    // nothing to stretch this match, hence nothing to expand.
                    rv.push(c1);
                }
                break;

            // Recognize some other regex elements, but there's no need to understand them all.
            //
            // We are merely interested in any chunks now which do *not* include yet another regex set `[...]`
            // nor any `{MACRO}` reference:
            default:
                // non-set character or word: see how much of this there is for us and then see if there
                // are any macros still lurking inside there:
                c2 = s.match(NOTHING_SPECIAL_RE);
                if (c2) {
                    c2 = c2[0];
                    s = s.substr(c2.length);

                    // nothing to expand.
                    rv.push(c1 + c2);
                } else {
                    // nothing to stretch this match, hence nothing to expand.
                    rv.push(c1);
                }
                break;
        }
    }

    s = rv.join('');

    // When this result is suitable for use in a set, than we should be able to compile
    // it in a regex; that way we can easily validate whether macro X is fit to be used
    // inside a regex set:
    try {
        var re;
        re = new XRegExp(s);
        re.test(s[0]);
    } catch (ex) {
        // make sure we produce a regex expression which will fail badly when it is used
        // in actual code:
        return new Error(errinfo() + ': expands to an invalid regex: /' + s + '/');
    }

    assert(s);
    return s;
}

// expand macros within macros and cache the result
function prepareMacros(dict_macros, opts) {
    var macros = {};

    // expand a `{NAME}` macro which exists inside a `[...]` set:
    function expandMacroInSet(i) {
        var k, a, m;
        if (!macros[i]) {
            m = dict_macros[i];

            if (m.indexOf('{') >= 0) {
                // set up our own record so we can detect definition loops:
                macros[i] = {
                    in_set: false,
                    elsewhere: null,
                    raw: dict_macros[i]
                };

                for (k in dict_macros) {
                    if (dict_macros.hasOwnProperty(k) && i !== k) {
                        // it doesn't matter if the lexer recognized that the inner macro(s)
                        // were sitting inside a `[...]` set or not: the fact that they are used
                        // here in macro `i` which itself sits in a set, makes them *all* live in
                        // a set so all of them get the same treatment: set expansion style.
                        //
                        // Note: make sure we don't try to expand any XRegExp `\p{...}` or `\P{...}`
                        // macros here:
                        if (XRegExp._getUnicodeProperty(k)) {
                            // Work-around so that you can use `\p{ascii}` for a XRegExp slug, a.k.a.
                            // Unicode 'General Category' Property cf. http://unicode.org/reports/tr18/#Categories,
                            // while using `\p{ASCII}` as a *macro expansion* of the `ASCII`
                            // macro:
                            if (k.toUpperCase() !== k) {
                                m = new Error('Cannot use name "' + k + '" as a macro name as it clashes with the same XRegExp "\\p{..}" Unicode \'General Category\' Property name. Use all-uppercase macro names, e.g. name your macro "' + k.toUpperCase() + '" to work around this issue or give your offending macro a different name.');
                                break;
                            }
                        }

                        a = m.split('{' + k + '}');
                        if (a.length > 1) {
                            var x = expandMacroInSet(k);
                            assert(x);
                            if (x instanceof Error) {
                                m = x;
                                break;
                            }
                            m = a.join(x);
                        }
                    }
                }
            }

            var mba = setmgmt.reduceRegexToSetBitArray(m, i, opts);

            var s1;

            // propagate deferred exceptions = error reports.
            if (mba instanceof Error) {
                s1 = mba;
            } else {
                s1 = setmgmt.bitarray2set(mba, false);

                m = s1;
            }

            macros[i] = {
                in_set: s1,
                elsewhere: null,
                raw: dict_macros[i]
            };
        } else {
            m = macros[i].in_set;

            if (m instanceof Error) {
                // this turns out to be an macro with 'issues' and it is used, so the 'issues' do matter: bombs away!
                return new Error(m.message);
            }

            // detect definition loop:
            if (m === false) {
                return new Error('Macro name "' + i + '" has an illegal, looping, definition, i.e. it\'s definition references itself, either directly or indirectly, via other macros.');
            }
        }

        return m;
    }

    function expandMacroElsewhere(i) {
        var k, a, m;

        if (macros[i].elsewhere == null) {
            m = dict_macros[i];

            // set up our own record so we can detect definition loops:
            macros[i].elsewhere = false;

            // the macro MAY contain other macros which MAY be inside a `[...]` set in this
            // macro or elsewhere, hence we must parse the regex:
            m = reduceRegex(m, i, opts, expandAllMacrosInSet, expandAllMacrosElsewhere);
            // propagate deferred exceptions = error reports.
            if (m instanceof Error) {
                return m;
            }

            macros[i].elsewhere = m;
        } else {
            m = macros[i].elsewhere;

            if (m instanceof Error) {
                // this turns out to be an macro with 'issues' and it is used, so the 'issues' do matter: bombs away!
                return m;
            }

            // detect definition loop:
            if (m === false) {
                return new Error('Macro name "' + i + '" has an illegal, looping, definition, i.e. it\'s definition references itself, either directly or indirectly, via other macros.');
            }
        }

        return m;
    }

    function expandAllMacrosInSet(s) {
        var i, x;

        // process *all* the macros inside [...] set:
        if (s.indexOf('{') >= 0) {
            for (i in macros) {
                if (macros.hasOwnProperty(i)) {
                    var a = s.split('{' + i + '}');
                    if (a.length > 1) {
                        x = expandMacroInSet(i);
                        assert(x);
                        if (x instanceof Error) {
                            return new Error('failure to expand the macro [' + i + '] in set [' + s + ']: ' + x.message);
                        }
                        s = a.join(x);
                    }

                    // stop the brute-force expansion attempt when we done 'em all:
                    if (s.indexOf('{') === -1) {
                        break;
                    }
                }
            }
        }

        return s;
    }

    function expandAllMacrosElsewhere(s) {
        var i, x;

        // When we process the remaining macro occurrences in the regex
        // every macro used in a lexer rule will become its own capture group.
        //
        // Meanwhile the cached expansion will expand any submacros into
        // *NON*-capturing groups so that the backreference indexes remain as you'ld
        // expect and using macros doesn't require you to know exactly what your
        // used macro will expand into, i.e. which and how many submacros it has.
        //
        // This is a BREAKING CHANGE from vanilla jison 0.4.15!
        if (s.indexOf('{') >= 0) {
            for (i in macros) {
                if (macros.hasOwnProperty(i)) {
                    // These are all submacro expansions, hence non-capturing grouping is applied:
                    var a = s.split('{' + i + '}');
                    if (a.length > 1) {
                        x = expandMacroElsewhere(i);
                        assert(x);
                        if (x instanceof Error) {
                            return new Error('failure to expand the macro [' + i + '] in regex /' + s + '/: ' + x.message);
                        }
                        s = a.join('(?:' + x + ')');
                    }

                    // stop the brute-force expansion attempt when we done 'em all:
                    if (s.indexOf('{') === -1) {
                        break;
                    }
                }
            }
        }

        return s;
    }

    var m, i;

    if (opts.debug) console.log('\n############## RAW macros: ', dict_macros);

    // first we create the part of the dictionary which is targeting the use of macros
    // *inside* `[...]` sets; once we have completed that half of the expansions work,
    // we then go and expand the macros for when they are used elsewhere in a regex:
    // iff we encounter submacros then which are used *inside* a set, we can use that
    // first half dictionary to speed things up a bit as we can use those expansions
    // straight away!
    for (i in dict_macros) {
        if (dict_macros.hasOwnProperty(i)) {
            expandMacroInSet(i);
        }
    }

    for (i in dict_macros) {
        if (dict_macros.hasOwnProperty(i)) {
            expandMacroElsewhere(i);
        }
    }

    if (opts.debug) console.log('\n############### expanded macros: ', macros);

    return macros;
}

// expand macros in a regex; expands them recursively
function expandMacros(src, macros, opts) {
    var expansion_count = 0;

    // By the time we call this function `expandMacros` we MUST have expanded and cached all macros already!
    // Hence things should be easy in there:

    function expandAllMacrosInSet(s) {
        var i, m, x;

        // process *all* the macros inside [...] set:
        if (s.indexOf('{') >= 0) {
            for (i in macros) {
                if (macros.hasOwnProperty(i)) {
                    m = macros[i];

                    var a = s.split('{' + i + '}');
                    if (a.length > 1) {
                        x = m.in_set;

                        assert(x);
                        if (x instanceof Error) {
                            // this turns out to be an macro with 'issues' and it is used, so the 'issues' do matter: bombs away!
                            throw x;
                        }

                        // detect definition loop:
                        if (x === false) {
                            return new Error('Macro name "' + i + '" has an illegal, looping, definition, i.e. it\'s definition references itself, either directly or indirectly, via other macros.');
                        }

                        s = a.join(x);
                        expansion_count++;
                    }

                    // stop the brute-force expansion attempt when we done 'em all:
                    if (s.indexOf('{') === -1) {
                        break;
                    }
                }
            }
        }

        return s;
    }

    function expandAllMacrosElsewhere(s) {
        var i, m, x;

        // When we process the main macro occurrences in the regex
        // every macro used in a lexer rule will become its own capture group.
        //
        // Meanwhile the cached expansion will expand any submacros into
        // *NON*-capturing groups so that the backreference indexes remain as you'ld
        // expect and using macros doesn't require you to know exactly what your
        // used macro will expand into, i.e. which and how many submacros it has.
        //
        // This is a BREAKING CHANGE from vanilla jison 0.4.15!
        if (s.indexOf('{') >= 0) {
            for (i in macros) {
                if (macros.hasOwnProperty(i)) {
                    m = macros[i];

                    var a = s.split('{' + i + '}');
                    if (a.length > 1) {
                        // These are all main macro expansions, hence CAPTURING grouping is applied:
                        x = m.elsewhere;
                        assert(x);

                        // detect definition loop:
                        if (x === false) {
                            return new Error('Macro name "' + i + '" has an illegal, looping, definition, i.e. it\'s definition references itself, either directly or indirectly, via other macros.');
                        }

                        s = a.join('(' + x + ')');
                        expansion_count++;
                    }

                    // stop the brute-force expansion attempt when we done 'em all:
                    if (s.indexOf('{') === -1) {
                        break;
                    }
                }
            }
        }

        return s;
    }

    // When we process the macro occurrences in the regex
    // every macro used in a lexer rule will become its own capture group.
    //
    // Meanwhile the cached expansion will have expanded any submacros into
    // *NON*-capturing groups so that the backreference indexes remain as you'ld
    // expect and using macros doesn't require you to know exactly what your
    // used macro will expand into, i.e. which and how many submacros it has.
    //
    // This is a BREAKING CHANGE from vanilla jison 0.4.15!
    var s2 = reduceRegex(src, null, opts, expandAllMacrosInSet, expandAllMacrosElsewhere);
    // propagate deferred exceptions = error reports.
    if (s2 instanceof Error) {
        throw s2;
    }

    // only when we did expand some actual macros do we take the re-interpreted/optimized/regenerated regex from reduceRegex()
    // in order to keep our test cases simple and rules recognizable. This assumes the user can code good regexes on his own,
    // as long as no macros are involved...
    //
    // Also pick the reduced regex when there (potentially) are XRegExp extensions in the original, e.g. `\\p{Number}`,
    // unless the `xregexp` output option has been enabled.
    if (expansion_count > 0 || src.indexOf('\\p{') >= 0 && !opts.options.xregexp) {
        src = s2;
    } else {
        // Check if the reduced regex is smaller in size; when it is, we still go with the new one!
        if (s2.length < src.length) {
            src = s2;
        }
    }

    return src;
}

function prepareStartConditions(conditions) {
    var sc;
    var hash = {};

    for (sc in conditions) {
        if (conditions.hasOwnProperty(sc)) {
            hash[sc] = {
                rules: [],
                inclusive: !conditions[sc]
            };
        }
    }
    return hash;
}

function buildActions(dict, tokens, opts) {
    var actions = [dict.actionInclude || '', 'var YYSTATE = YY_START;'];
    var tok;
    var toks = {};
    var caseHelper = [];

    // tokens: map/array of token numbers to token names
    for (tok in tokens) {
        var idx = parseInt(tok);
        if (idx && idx > 0) {
            toks[tokens[tok]] = idx;
        }
    }

    var gen = prepareRules(dict, actions, caseHelper, tokens && toks, opts.conditions, opts);

    var code = actions.join('\n');
    'yytext yyleng yylineno yylloc yyerror'.split(' ').forEach(function (yy) {
        code = code.replace(new RegExp('\\b(' + yy + ')\\b', 'g'), 'yy_.$1');
    });

    return {
        caseHelperInclude: '{\n' + caseHelper.join(',') + '\n}',

        actions: 'function lexer__performAction(yy, yyrulenumber, YY_START) {\n            var yy_ = this;\n\n            ' + code + '\n        }',

        rules: gen.rules,
        macros: gen.macros, // propagate these for debugging/diagnostic purposes

        regular_rule_count: gen.regular_rule_count,
        simple_rule_count: gen.simple_rule_count
    };
}

//
// NOTE: this is *almost* a copy of the JisonParserError producing code in
//       jison/lib/jison.js @ line 2304:lrGeneratorMixin.generateErrorClass
//
function generateErrorClass() {
    // --- START lexer error class ---

    var prelude = '/**\n * See also:\n * http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508\n * but we keep the prototype.constructor and prototype.name assignment lines too for compatibility\n * with userland code which might access the derived class in a \'classic\' way.\n *\n * @public\n * @constructor\n * @nocollapse\n */\nfunction JisonLexerError(msg, hash) {\n    Object.defineProperty(this, \'name\', {\n        enumerable: false,\n        writable: false,\n        value: \'JisonLexerError\'\n    });\n\n    if (msg == null) msg = \'???\';\n\n    Object.defineProperty(this, \'message\', {\n        enumerable: false,\n        writable: true,\n        value: msg\n    });\n\n    this.hash = hash;\n\n    var stacktrace;\n    if (hash && hash.exception instanceof Error) {\n        var ex2 = hash.exception;\n        this.message = ex2.message || msg;\n        stacktrace = ex2.stack;\n    }\n    if (!stacktrace) {\n        if (Error.hasOwnProperty(\'captureStackTrace\')) { // V8\n            Error.captureStackTrace(this, this.constructor);\n        } else {\n            stacktrace = (new Error(msg)).stack;\n        }\n    }\n    if (stacktrace) {\n        Object.defineProperty(this, \'stack\', {\n            enumerable: false,\n            writable: false,\n            value: stacktrace\n        });\n    }\n}\n\nif (typeof Object.setPrototypeOf === \'function\') {\n    Object.setPrototypeOf(JisonLexerError.prototype, Error.prototype);\n} else {\n    JisonLexerError.prototype = Object.create(Error.prototype);\n}\nJisonLexerError.prototype.constructor = JisonLexerError;\nJisonLexerError.prototype.name = \'JisonLexerError\';';

    // --- END lexer error class ---

    return prelude;
}

var jisonLexerErrorDefinition = generateErrorClass();

function generateFakeXRegExpClassSrcCode() {
    return rmCommonWS$1(_templateObject36);
}

/** @constructor */
function RegExpLexer(dict, input, tokens, build_options) {
    var opts;
    var dump = false;

    function test_me(tweak_cb, description, src_exception, ex_callback) {
        opts = processGrammar(dict, tokens, build_options);
        opts.__in_rules_failure_analysis_mode__ = false;
        prepExportStructures$1(opts);
        assert(opts.options);
        if (tweak_cb) {
            tweak_cb();
        }
        var source = generateModuleBody(opts);
        try {
            // The generated code will always have the `lexer` variable declared at local scope
            // as `eval()` will use the local scope.
            //
            // The compiled code will look something like this:
            //
            // ```
            // var lexer;
            // bla bla...
            // ```
            //
            // or
            //
            // ```
            // var lexer = { bla... };
            // ```
            var testcode = ['// provide a local version for test purposes:', jisonLexerErrorDefinition, '', generateFakeXRegExpClassSrcCode(), '', source, '', 'return lexer;'].join('\n');
            var lexer = code_exec$1(testcode, function generated_code_exec_wrapper_regexp_lexer(sourcecode) {
                //console.log("===============================LEXER TEST CODE\n", sourcecode, "\n=====================END====================\n");
                var lexer_f = new Function('', sourcecode);
                return lexer_f();
            }, opts.options, "lexer");

            if (!lexer) {
                throw new Error('no lexer defined *at all*?!');
            }
            if (_typeof(lexer.options) !== 'object' || lexer.options == null) {
                throw new Error('your lexer class MUST have an .options member object or it won\'t fly!');
            }
            if (typeof lexer.setInput !== 'function') {
                throw new Error('your lexer class MUST have a .setInput function member or it won\'t fly!');
            }
            if (lexer.EOF !== 1 && lexer.ERROR !== 2) {
                throw new Error('your lexer class MUST have these constants defined: lexer.EOF = 1 and lexer.ERROR = 2 or it won\'t fly!');
            }

            // When we do NOT crash, we found/killed the problem area just before this call!
            if (src_exception && description) {
                var msg = description;
                if (typeof description === 'function') {
                    msg = description();
                }
                src_exception.message += '\n        (' + msg + ')';
            }

            // patch the pre and post handlers in there, now that we have some live code to work with:
            if (opts.options) {
                var pre = opts.options.pre_lex;
                var post = opts.options.post_lex;
                // since JSON cannot encode functions, we'll have to do it manually now:
                if (typeof pre === 'function') {
                    lexer.options.pre_lex = pre;
                }
                if (typeof post === 'function') {
                    lexer.options.post_lex = post;
                }
            }

            if (opts.options.showSource) {
                if (typeof opts.options.showSource === 'function') {
                    opts.options.showSource(lexer, source, opts);
                } else {
                    console.log("\nGenerated lexer sourcecode:\n----------------------------------------\n", source, "\n----------------------------------------\n");
                }
            }
            return lexer;
        } catch (ex) {
            // if (src_exception) {
            //     src_exception.message += '\n        (' + description + ': ' + ex.message + ')';
            // }

            if (ex_callback) {
                ex_callback(ex);
            } else if (dump) {
                console.log('source code:\n', source);
            }
            return false;
        }
    }

    /** @constructor */
    var lexer = test_me(null, null, null, function (ex) {
        // When we get an exception here, it means some part of the user-specified lexer is botched.
        //
        // Now we go and try to narrow down the problem area/category:
        assert(opts.options);
        assert(opts.options.xregexp !== undefined);
        var orig_xregexp_opt = !!opts.options.xregexp;
        if (!test_me(function () {
            assert(opts.options.xregexp !== undefined);
            opts.options.xregexp = false;
            opts.showSource = false;
        }, 'When you have specified %option xregexp, you must also properly IMPORT the XRegExp library in the generated lexer.', ex, null)) {
            if (!test_me(function () {
                // restore xregexp option setting: the trouble wasn't caused by the xregexp flag i.c.w. incorrect XRegExp library importing!
                opts.options.xregexp = orig_xregexp_opt;

                opts.conditions = [];
                opts.showSource = false;
            }, function () {
                assert(Array.isArray(opts.rules));
                return opts.rules.length > 0 ? 'One or more of your lexer state names are possibly botched?' : 'Your custom lexer is somehow botched.';
            }, ex, null)) {
                var rulesSpecSize;
                if (!test_me(function () {
                    // store the parsed rule set size so we can use that info in case
                    // this attempt also fails:
                    assert(Array.isArray(opts.rules));
                    rulesSpecSize = opts.rules.length;

                    // opts.conditions = [];
                    opts.rules = [];
                    opts.showSource = false;
                    opts.__in_rules_failure_analysis_mode__ = true;
                }, 'One or more of your lexer rules are possibly botched?', ex, null)) {
                    // kill each rule action block, one at a time and test again after each 'edit':
                    var rv = false;
                    for (var i = 0, len = rulesSpecSize; i < len; i++) {
                        var lastEditedRuleSpec;
                        rv = test_me(function () {
                            assert(Array.isArray(opts.rules));
                            assert(opts.rules.length === rulesSpecSize);

                            // opts.conditions = [];
                            // opts.rules = [];
                            // opts.__in_rules_failure_analysis_mode__ = true;

                            // nuke all rules' actions up to and including rule numero `i`:
                            for (var j = 0; j <= i; j++) {
                                // rules, when parsed, have 2 or 3 elements: [conditions, handle, action];
                                // now we want to edit the *action* part:
                                var rule = opts.rules[j];
                                assert(Array.isArray(rule));
                                assert(rule.length === 2 || rule.length === 3);
                                rule.pop();
                                rule.push('{ /* nada */ }');
                                lastEditedRuleSpec = rule;
                            }
                        }, function () {
                            return 'Your lexer rule "' + lastEditedRuleSpec[0] + '" action code block is botched?';
                        }, ex, null);
                        if (rv) {
                            break;
                        }
                    }
                    if (!rv) {
                        test_me(function () {
                            opts.conditions = [];
                            opts.rules = [];
                            opts.performAction = 'null';
                            // opts.options = {};
                            // opts.caseHelperInclude = '{}';
                            opts.showSource = false;
                            opts.__in_rules_failure_analysis_mode__ = true;

                            dump = false;
                        }, 'One or more of your lexer rule action code block(s) are possibly botched?', ex, null);
                    }
                }
            }
        }
        throw ex;
    });

    lexer.setInput(input);

    /** @public */
    lexer.generate = function () {
        return generateFromOpts(opts);
    };
    /** @public */
    lexer.generateModule = function () {
        return generateModule(opts);
    };
    /** @public */
    lexer.generateCommonJSModule = function () {
        return generateCommonJSModule(opts);
    };
    /** @public */
    lexer.generateESModule = function () {
        return generateESModule(opts);
    };
    /** @public */
    lexer.generateAMDModule = function () {
        return generateAMDModule(opts);
    };

    // internal APIs to aid testing:
    /** @public */
    lexer.getExpandedMacros = function () {
        return opts.macros;
    };

    return lexer;
}

// code stripping performance test for very simple grammar:
//
// - removing backtracking parser code branches:                    730K -> 750K rounds
// - removing all location info tracking: yylineno, yylloc, etc.:   750K -> 900K rounds
// - no `yyleng`:                                                   900K -> 905K rounds
// - no `this.done` as we cannot have a NULL `_input` anymore:      905K -> 930K rounds
// - `simpleCaseActionClusters` as array instead of hash object:    930K -> 940K rounds
// - lexers which have only return stmts, i.e. only a
//   `simpleCaseActionClusters` lookup table to produce
//   lexer tokens: *inline* the `performAction` call:               940K -> 950K rounds
// - given all the above, you can *inline* what's left of
//   `lexer_next()`:                                                950K -> 955K rounds (? this stuff becomes hard to measure; inaccuracy abounds!)
//
// Total gain when we forget about very minor (and tough to nail) *inlining* `lexer_next()` gains:
//
//     730 -> 950  ~ 30% performance gain.
//

// As a function can be reproduced in source-code form by any JavaScript engine, we're going to wrap this chunk
// of code in a function so that we can easily get it including it comments, etc.:
/**
@public
@nocollapse
*/
function getRegExpLexerPrototype() {
    // --- START lexer kernel ---
    return '{\n    EOF: 1,\n    ERROR: 2,\n\n    // JisonLexerError: JisonLexerError,        /// <-- injected by the code generator\n\n    // options: {},                             /// <-- injected by the code generator\n\n    // yy: ...,                                 /// <-- injected by setInput()\n\n    __currentRuleSet__: null,                   /// INTERNAL USE ONLY: internal rule set cache for the current lexer state\n\n    __error_infos: [],                          /// INTERNAL USE ONLY: the set of lexErrorInfo objects created since the last cleanup\n\n    __decompressed: false,                      /// INTERNAL USE ONLY: mark whether the lexer instance has been \'unfolded\' completely and is now ready for use\n\n    done: false,                                /// INTERNAL USE ONLY\n    _backtrack: false,                          /// INTERNAL USE ONLY\n    _input: \'\',                                 /// INTERNAL USE ONLY\n    _more: false,                               /// INTERNAL USE ONLY\n    _signaled_error_token: false,               /// INTERNAL USE ONLY\n\n    conditionStack: [],                         /// INTERNAL USE ONLY; managed via `pushState()`, `popState()`, `topState()` and `stateStackSize()`\n\n    match: \'\',                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction. `match` is identical to `yytext` except that this one still contains the matched input string after `lexer.performAction()` has been invoked, where userland code MAY have changed/replaced the `yytext` value entirely!\n    matched: \'\',                                /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks entire input which has been matched so far\n    matches: false,                             /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks RE match result for last (successful) match attempt\n    yytext: \'\',                                 /// ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction; this value is transferred to the parser as the \'token value\' when the parser consumes the lexer token produced through a call to the `lex()` API.\n    offset: 0,                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks the \'cursor position\' in the input string, i.e. the number of characters matched so far\n    yyleng: 0,                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: length of matched input for the token under construction (`yytext`)\n    yylineno: 0,                                /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: \'line number\' at which the token under construction is located\n    yylloc: null,                               /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks location info (lines + columns) for the token under construction\n\n    /**\n     * INTERNAL USE: construct a suitable error info hash object instance for `parseError`.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    constructLexErrorInfo: function lexer_constructLexErrorInfo(msg, recoverable, show_input_position) {\n        msg = \'\' + msg;\n\n        // heuristic to determine if the error message already contains a (partial) source code dump\n        // as produced by either `showPosition()` or `prettyPrintRange()`:\n        if (show_input_position == undefined) {\n            show_input_position = !(msg.indexOf(\'\\n\') > 0 && msg.indexOf(\'^\') > 0);\n        }\n        if (this.yylloc && show_input_position) {\n            if (typeof this.prettyPrintRange === \'function\') {\n                var pretty_src = this.prettyPrintRange(this.yylloc);\n\n                if (!/\\n\\s*$/.test(msg)) {\n                    msg += \'\\n\';\n                }\n                msg += \'\\n  Erroneous area:\\n\' + this.prettyPrintRange(this.yylloc);          \n            } else if (typeof this.showPosition === \'function\') {\n                var pos_str = this.showPosition();\n                if (pos_str) {\n                    if (msg.length && msg[msg.length - 1] !== \'\\n\' && pos_str[0] !== \'\\n\') {\n                        msg += \'\\n\' + pos_str;\n                    } else {\n                        msg += pos_str;\n                    }\n                }\n            }\n        }\n        /** @constructor */\n        var pei = {\n            errStr: msg,\n            recoverable: !!recoverable,\n            text: this.match,           // This one MAY be empty; userland code should use the `upcomingInput` API to obtain more text which follows the \'lexer cursor position\'...\n            token: null,\n            line: this.yylineno,\n            loc: this.yylloc,\n            yy: this.yy,\n            lexer: this,\n\n            /**\n             * and make sure the error info doesn\'t stay due to potential\n             * ref cycle via userland code manipulations.\n             * These would otherwise all be memory leak opportunities!\n             * \n             * Note that only array and object references are nuked as those\n             * constitute the set of elements which can produce a cyclic ref.\n             * The rest of the members is kept intact as they are harmless.\n             * \n             * @public\n             * @this {LexErrorInfo}\n             */\n            destroy: function destructLexErrorInfo() {\n                // remove cyclic references added to error info:\n                // info.yy = null;\n                // info.lexer = null;\n                // ...\n                var rec = !!this.recoverable;\n                for (var key in this) {\n                    if (this.hasOwnProperty(key) && typeof key === \'object\') {\n                        this[key] = undefined;\n                    }\n                }\n                this.recoverable = rec;\n            }\n        };\n        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!\n        this.__error_infos.push(pei);\n        return pei;\n    },\n\n    /**\n     * handler which is invoked when a lexer error occurs.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    parseError: function lexer_parseError(str, hash, ExceptionClass) {\n        if (!ExceptionClass) {\n            ExceptionClass = this.JisonLexerError;\n        }\n        if (this.yy) {\n            if (this.yy.parser && typeof this.yy.parser.parseError === \'function\') {\n                return this.yy.parser.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;\n            } else if (typeof this.yy.parseError === \'function\') {\n                return this.yy.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;\n            } \n        }\n        throw new ExceptionClass(str, hash);\n    },\n\n    /**\n     * method which implements `yyerror(str, ...args)` functionality for use inside lexer actions.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    yyerror: function yyError(str /*, ...args */) {\n        var lineno_msg = \'\';\n        if (this.yylloc) {\n            lineno_msg = \' on line \' + (this.yylineno + 1);\n        }\n        var p = this.constructLexErrorInfo(\'Lexical error\' + lineno_msg + \': \' + str, this.options.lexerErrorsAreRecoverable);\n\n        // Add any extra args to the hash under the name `extra_error_attributes`:\n        var args = Array.prototype.slice.call(arguments, 1);\n        if (args.length) {\n            p.extra_error_attributes = args;\n        }\n\n        return (this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR);\n    },\n\n    /**\n     * final cleanup function for when we have completed lexing the input;\n     * make it an API so that external code can use this one once userland\n     * code has decided it\'s time to destroy any lingering lexer error\n     * hash object instances and the like: this function helps to clean\n     * up these constructs, which *may* carry cyclic references which would\n     * otherwise prevent the instances from being properly and timely\n     * garbage-collected, i.e. this function helps prevent memory leaks!\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    cleanupAfterLex: function lexer_cleanupAfterLex(do_not_nuke_errorinfos) {\n        // prevent lingering circular references from causing memory leaks:\n        this.setInput(\'\', {});\n\n        // nuke the error hash info instances created during this run.\n        // Userland code must COPY any data/references\n        // in the error hash instance(s) it is more permanently interested in.\n        if (!do_not_nuke_errorinfos) {\n            for (var i = this.__error_infos.length - 1; i >= 0; i--) {\n                var el = this.__error_infos[i];\n                if (el && typeof el.destroy === \'function\') {\n                    el.destroy();\n                }\n            }\n            this.__error_infos.length = 0;\n        }\n\n        return this;\n    },\n\n    /**\n     * clear the lexer token context; intended for internal use only\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    clear: function lexer_clear() {\n        this.yytext = \'\';\n        this.yyleng = 0;\n        this.match = \'\';\n        // - DO NOT reset `this.matched`\n        this.matches = false;\n        this._more = false;\n        this._backtrack = false;\n\n        var col = (this.yylloc ? this.yylloc.last_column : 0);\n        this.yylloc = {\n            first_line: this.yylineno + 1,\n            first_column: col,\n            last_line: this.yylineno + 1,\n            last_column: col,\n\n            range: [this.offset, this.offset]\n        };\n    },\n\n    /**\n     * resets the lexer, sets new input\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    setInput: function lexer_setInput(input, yy) {\n        this.yy = yy || this.yy || {};\n\n        // also check if we\'ve fully initialized the lexer instance,\n        // including expansion work to be done to go from a loaded\n        // lexer to a usable lexer:\n        if (!this.__decompressed) {\n          // step 1: decompress the regex list:\n          var rules = this.rules;\n          for (var i = 0, len = rules.length; i < len; i++) {\n            var rule_re = rules[i];\n\n            // compression: is the RE an xref to another RE slot in the rules[] table?\n            if (typeof rule_re === \'number\') {\n              rules[i] = rules[rule_re];\n            }\n          }\n\n          // step 2: unfold the conditions[] set to make these ready for use:\n          var conditions = this.conditions;\n          for (var k in conditions) {\n            var spec = conditions[k];\n\n            var rule_ids = spec.rules;\n\n            var len = rule_ids.length;\n            var rule_regexes = new Array(len + 1);            // slot 0 is unused; we use a 1-based index approach here to keep the hottest code in `lexer_next()` fast and simple!\n            var rule_new_ids = new Array(len + 1);\n\n            for (var i = 0; i < len; i++) {\n              var idx = rule_ids[i];\n              var rule_re = rules[idx];\n              rule_regexes[i + 1] = rule_re;\n              rule_new_ids[i + 1] = idx;\n            }\n\n            spec.rules = rule_new_ids;\n            spec.__rule_regexes = rule_regexes;\n            spec.__rule_count = len;\n          }\n\n          this.__decompressed = true;\n        }\n\n        this._input = input || \'\';\n        this.clear();\n        this._signaled_error_token = false;\n        this.done = false;\n        this.yylineno = 0;\n        this.matched = \'\';\n        this.conditionStack = [\'INITIAL\'];\n        this.__currentRuleSet__ = null;\n        this.yylloc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0,\n\n            range: [0, 0]\n        };\n        this.offset = 0;\n        return this;\n    },\n\n    /**\n     * edit the remaining input via user-specified callback.\n     * This can be used to forward-adjust the input-to-parse, \n     * e.g. inserting macro expansions and alike in the\n     * input which has yet to be lexed.\n     * The behaviour of this API contrasts the `unput()` et al\n     * APIs as those act on the *consumed* input, while this\n     * one allows one to manipulate the future, without impacting\n     * the current `yyloc` cursor location or any history. \n     * \n     * Use this API to help implement C-preprocessor-like\n     * `#include` statements, etc.\n     * \n     * The provided callback must be synchronous and is\n     * expected to return the edited input (string).\n     *\n     * The `cpsArg` argument value is passed to the callback\n     * as-is.\n     *\n     * `callback` interface: \n     * `function callback(input, cpsArg)`\n     * \n     * - `input` will carry the remaining-input-to-lex string\n     *   from the lexer.\n     * - `cpsArg` is `cpsArg` passed into this API.\n     * \n     * The `this` reference for the callback will be set to\n     * reference this lexer instance so that userland code\n     * in the callback can easily and quickly access any lexer\n     * API. \n     *\n     * When the callback returns a non-string-type falsey value,\n     * we assume the callback did not edit the input and we\n     * will using the input as-is.\n     *\n     * When the callback returns a non-string-type value, it\n     * is converted to a string for lexing via the `"" + retval`\n     * operation. (See also why: http://2ality.com/2012/03/converting-to-string.html \n     * -- that way any returned object\'s `toValue()` and `toString()`\n     * methods will be invoked in a proper/desirable order.)\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    editRemainingInput: function lexer_editRemainingInput(callback, cpsArg) {\n        var rv = callback.call(this, this._input, cpsArg);\n        if (typeof rv !== \'string\') {\n            if (rv) {\n                this._input = \'\' + rv; \n            }\n            // else: keep `this._input` as is. \n        } else {\n            this._input = rv; \n        }\n        return this;\n    },\n\n    /**\n     * consumes and returns one char from the input\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    input: function lexer_input() {\n        if (!this._input) {\n            //this.done = true;    -- don\'t set `done` as we want the lex()/next() API to be able to produce one custom EOF token match after this anyhow. (lexer can match special <<EOF>> tokens and perform user action code for a <<EOF>> match, but only does so *once*)\n            return null;\n        }\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        // Count the linenumber up when we hit the LF (or a stand-alone CR).\n        // On CRLF, the linenumber is incremented when you fetch the CR or the CRLF combo\n        // and we advance immediately past the LF as well, returning both together as if\n        // it was all a single \'character\' only.\n        var slice_len = 1;\n        var lines = false;\n        if (ch === \'\\n\') {\n            lines = true;\n        } else if (ch === \'\\r\') {\n            lines = true;\n            var ch2 = this._input[1];\n            if (ch2 === \'\\n\') {\n                slice_len++;\n                ch += ch2;\n                this.yytext += ch2;\n                this.yyleng++;\n                this.offset++;\n                this.match += ch2;\n                this.matched += ch2;\n                this.yylloc.range[1]++;\n            }\n        }\n        if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n            this.yylloc.last_column = 0;\n        } else {\n            this.yylloc.last_column++;\n        }\n        this.yylloc.range[1]++;\n\n        this._input = this._input.slice(slice_len);\n        return ch;\n    },\n\n    /**\n     * unshifts one char (or an entire string) into the input\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    unput: function lexer_unput(ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len);\n        this.yyleng = this.yytext.length;\n        this.offset -= len;\n        this.match = this.match.substr(0, this.match.length - len);\n        this.matched = this.matched.substr(0, this.matched.length - len);\n\n        if (lines.length > 1) {\n            this.yylineno -= lines.length - 1;\n\n            this.yylloc.last_line = this.yylineno + 1;\n\n            // Get last entirely matched line into the `pre_lines[]` array\'s\n            // last index slot; we don\'t mind when other previously \n            // matched lines end up in the array too. \n            var pre = this.match;\n            var pre_lines = pre.split(/(?:\\r\\n?|\\n)/g);\n            if (pre_lines.length === 1) {\n                pre = this.matched;\n                pre_lines = pre.split(/(?:\\r\\n?|\\n)/g);\n            }\n            this.yylloc.last_column = pre_lines[pre_lines.length - 1].length;\n        } else {\n            this.yylloc.last_column -= len;\n        }\n\n        this.yylloc.range[1] = this.yylloc.range[0] + this.yyleng;\n\n        this.done = false;\n        return this;\n    },\n\n    /**\n     * cache matched text and append it on next action\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    more: function lexer_more() {\n        this._more = true;\n        return this;\n    },\n\n    /**\n     * signal the lexer that this rule fails to match the input, so the\n     * next matching rule (regex) should be tested instead.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    reject: function lexer_reject() {\n        if (this.options.backtrack_lexer) {\n            this._backtrack = true;\n        } else {\n            // when the `parseError()` call returns, we MUST ensure that the error is registered.\n            // We accomplish this by signaling an \'error\' token to be produced for the current\n            // `.lex()` run.\n            var lineno_msg = \'\';\n            if (this.yylloc) {\n                lineno_msg = \' on line \' + (this.yylineno + 1);\n            }\n            var p = this.constructLexErrorInfo(\'Lexical error\' + lineno_msg + \': You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\', false);\n            this._signaled_error_token = (this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR);\n        }\n        return this;\n    },\n\n    /**\n     * retain first n characters of the match\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    less: function lexer_less(n) {\n        return this.unput(this.match.slice(n));\n    },\n\n    /**\n     * return (part of the) already matched input, i.e. for error\n     * messages.\n     * \n     * Limit the returned string length to `maxSize` (default: 20).\n     * \n     * Limit the returned string to the `maxLines` number of lines of\n     * input (default: 1).\n     * \n     * Negative limit values equal *unlimited*.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    pastInput: function lexer_pastInput(maxSize, maxLines) {\n        var past = this.matched.substring(0, this.matched.length - this.match.length);\n        if (maxSize < 0)\n            maxSize = past.length;\n        else if (!maxSize)\n            maxSize = 20;\n        if (maxLines < 0)\n            maxLines = past.length;         // can\'t ever have more input lines than this!\n        else if (!maxLines)\n            maxLines = 1;\n        // `substr` anticipation: treat \\r\\n as a single character and take a little\n        // more than necessary so that we can still properly check against maxSize\n        // after we\'ve transformed and limited the newLines in here:\n        past = past.substr(-maxSize * 2 - 2);\n        // now that we have a significantly reduced string to process, transform the newlines\n        // and chop them, then limit them:\n        var a = past.replace(/\\r\\n|\\r/g, \'\\n\').split(\'\\n\');\n        a = a.slice(-maxLines);\n        past = a.join(\'\\n\');\n        // When, after limiting to maxLines, we still have too much to return,\n        // do add an ellipsis prefix...\n        if (past.length > maxSize) {\n            past = \'...\' + past.substr(-maxSize);\n        }\n        return past;\n    },\n\n    /**\n     * return (part of the) upcoming input, i.e. for error messages.\n     * \n     * Limit the returned string length to `maxSize` (default: 20).\n     * \n     * Limit the returned string to the `maxLines` number of lines of input (default: 1).\n     * \n     * Negative limit values equal *unlimited*.\n     *\n     * > ### NOTE ###\n     * >\n     * > *"upcoming input"* is defined as the whole of the both\n     * > the *currently lexed* input, together with any remaining input\n     * > following that. *"currently lexed"* input is the input \n     * > already recognized by the lexer but not yet returned with\n     * > the lexer token. This happens when you are invoking this API\n     * > from inside any lexer rule action code block. \n     * >\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    upcomingInput: function lexer_upcomingInput(maxSize, maxLines) {\n        var next = this.match;\n        if (maxSize < 0)\n            maxSize = next.length + this._input.length;\n        else if (!maxSize)\n            maxSize = 20;\n        if (maxLines < 0)\n            maxLines = maxSize;         // can\'t ever have more input lines than this!\n        else if (!maxLines)\n            maxLines = 1;\n        // `substring` anticipation: treat \\r\\n as a single character and take a little\n        // more than necessary so that we can still properly check against maxSize\n        // after we\'ve transformed and limited the newLines in here:\n        if (next.length < maxSize * 2 + 2) {\n            next += this._input.substring(0, maxSize * 2 + 2);  // substring is faster on Chrome/V8\n        }\n        // now that we have a significantly reduced string to process, transform the newlines\n        // and chop them, then limit them:\n        var a = next.replace(/\\r\\n|\\r/g, \'\\n\').split(\'\\n\');\n        a = a.slice(0, maxLines);\n        next = a.join(\'\\n\');\n        // When, after limiting to maxLines, we still have too much to return,\n        // do add an ellipsis postfix...\n        if (next.length > maxSize) {\n            next = next.substring(0, maxSize) + \'...\';\n        }\n        return next;\n    },\n\n    /**\n     * return a string which displays the character position where the\n     * lexing error occurred, i.e. for error messages\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    showPosition: function lexer_showPosition(maxPrefix, maxPostfix) {\n        var pre = this.pastInput(maxPrefix).replace(/\\s/g, \' \');\n        var c = new Array(pre.length + 1).join(\'-\');\n        return pre + this.upcomingInput(maxPostfix).replace(/\\s/g, \' \') + \'\\n\' + c + \'^\';\n    },\n\n    /**\n     * return an YYLLOC info object derived off the given context (actual, preceding, following, current).\n     * Use this method when the given `actual` location is not guaranteed to exist (i.e. when\n     * it MAY be NULL) and you MUST have a valid location info object anyway:\n     * then we take the given context of the `preceding` and `following` locations, IFF those are available,\n     * and reconstruct the `actual` location info from those.\n     * If this fails, the heuristic is to take the `current` location, IFF available.\n     * If this fails as well, we assume the sought location is at/around the current lexer position\n     * and then produce that one as a response. DO NOTE that these heuristic/derived location info\n     * values MAY be inaccurate!\n     *\n     * NOTE: `deriveLocationInfo()` ALWAYS produces a location info object *copy* of `actual`, not just\n     * a *reference* hence all input location objects can be assumed to be \'constant\' (function has no side-effects).\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    deriveLocationInfo: function lexer_deriveYYLLOC(actual, preceding, following, current) {\n        var loc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0,\n\n            range: [0, 0]\n        };\n        if (actual) {\n            loc.first_line = actual.first_line | 0;\n            loc.last_line = actual.last_line | 0;\n            loc.first_column = actual.first_column | 0;\n            loc.last_column = actual.last_column | 0;\n\n            if (actual.range) {\n                loc.range[0] = actual.range[0] | 0; \n                loc.range[1] = actual.range[1] | 0;\n            } \n        }\n        if (loc.first_line <= 0 || loc.last_line < loc.first_line) {\n            // plan B: heuristic using preceding and following:\n            if (loc.first_line <= 0 && preceding) {\n                loc.first_line = preceding.last_line | 0;\n                loc.first_column = preceding.last_column | 0;\n\n                if (preceding.range) {\n                    loc.range[0] = actual.range[1] | 0; \n                } \n            }\n\n            if ((loc.last_line <= 0 || loc.last_line < loc.first_line) && following) {\n                loc.last_line = following.first_line | 0;\n                loc.last_column = following.first_column | 0;\n\n                if (following.range) {\n                    loc.range[1] = actual.range[0] | 0; \n                } \n            }\n\n            // plan C?: see if the \'current\' location is useful/sane too:\n            if (loc.first_line <= 0 && current && (loc.last_line <= 0 || current.last_line <= loc.last_line)) {\n                loc.first_line = current.first_line | 0;\n                loc.first_column = current.first_column | 0;\n\n                if (current.range) {\n                    loc.range[0] = current.range[0] | 0; \n                } \n            }\n\n            if (loc.last_line <= 0 && current && (loc.first_line <= 0 || current.first_line >= loc.first_line)) {\n                loc.last_line = current.last_line | 0;\n                loc.last_column = current.last_column | 0;\n\n                if (current.range) {\n                    loc.range[1] = current.range[1] | 0; \n                } \n            }\n        }\n        // sanitize: fix last_line BEFORE we fix first_line as we use the \'raw\' value of the latter\n        // or plan D heuristics to produce a \'sensible\' last_line value:\n        if (loc.last_line <= 0) {\n            if (loc.first_line <= 0) {\n                loc.first_line = this.yylloc.first_line;\n                loc.last_line = this.yylloc.last_line;\n                loc.first_column = this.yylloc.first_column;\n                loc.last_column = this.yylloc.last_column;\n\n                loc.range[0] = this.yylloc.range[0];\n                loc.range[1] = this.yylloc.range[1];\n            } else {\n                loc.last_line = this.yylloc.last_line;\n                loc.last_column = this.yylloc.last_column;\n\n                loc.range[1] = this.yylloc.range[1];\n            }\n        }\n        if (loc.first_line <= 0) {\n            loc.first_line = loc.last_line;\n            loc.first_column = 0; // loc.last_column;\n\n            loc.range[1] = loc.range[0];\n        }\n        if (loc.first_column < 0) {\n            loc.first_column = 0;\n        }\n        if (loc.last_column < 0) {\n            loc.last_column = (loc.first_column > 0 ? loc.first_column : 80);\n        }\n        return loc;\n    },\n\n    /**\n     * return a string which displays the lines & columns of input which are referenced \n     * by the given location info range, plus a few lines of context.\n     * \n     * This function pretty-prints the indicated section of the input, with line numbers \n     * and everything!\n     * \n     * This function is very useful to provide highly readable error reports, while\n     * the location range may be specified in various flexible ways:\n     * \n     * - `loc` is the location info object which references the area which should be\n     *   displayed and \'marked up\': these lines & columns of text are marked up by `^`\n     *   characters below each character in the entire input range.\n     * \n     * - `context_loc` is the *optional* location info object which instructs this\n     *   pretty-printer how much *leading* context should be displayed alongside\n     *   the area referenced by `loc`. This can help provide context for the displayed\n     *   error, etc.\n     * \n     *   When this location info is not provided, a default context of 3 lines is\n     *   used.\n     * \n     * - `context_loc2` is another *optional* location info object, which serves\n     *   a similar purpose to `context_loc`: it specifies the amount of *trailing*\n     *   context lines to display in the pretty-print output.\n     * \n     *   When this location info is not provided, a default context of 1 line only is\n     *   used.\n     * \n     * Special Notes:\n     * \n     * - when the `loc`-indicated range is very large (about 5 lines or more), then\n     *   only the first and last few lines of this block are printed while a\n     *   `...continued...` message will be printed between them.\n     * \n     *   This serves the purpose of not printing a huge amount of text when the `loc`\n     *   range happens to be huge: this way a manageable & readable output results\n     *   for arbitrary large ranges.\n     * \n     * - this function can display lines of input which whave not yet been lexed.\n     *   `prettyPrintRange()` can access the entire input!\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    prettyPrintRange: function lexer_prettyPrintRange(loc, context_loc, context_loc2) {\n        loc = this.deriveLocationInfo(loc, context_loc, context_loc2);        \n        const CONTEXT = 3;\n        const CONTEXT_TAIL = 1;\n        const MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT = 2;\n        var input = this.matched + this._input;\n        var lines = input.split(\'\\n\');\n        var l0 = Math.max(1, (context_loc ? context_loc.first_line : loc.first_line - CONTEXT));\n        var l1 = Math.max(1, (context_loc2 ? context_loc2.last_line : loc.last_line + CONTEXT_TAIL));\n        var lineno_display_width = (1 + Math.log10(l1 | 1) | 0);\n        var ws_prefix = new Array(lineno_display_width).join(\' \');\n        var nonempty_line_indexes = [];\n        var rv = lines.slice(l0 - 1, l1 + 1).map(function injectLineNumber(line, index) {\n            var lno = index + l0;\n            var lno_pfx = (ws_prefix + lno).substr(-lineno_display_width);\n            var rv = lno_pfx + \': \' + line;\n            var errpfx = (new Array(lineno_display_width + 1)).join(\'^\');\n            var offset = 2 + 1;\n            var len = 0;\n\n            if (lno === loc.first_line) {\n              offset += loc.first_column;\n\n              len = Math.max(\n                2,\n                ((lno === loc.last_line ? loc.last_column : line.length)) - loc.first_column + 1\n              );\n            } else if (lno === loc.last_line) {\n              len = Math.max(2, loc.last_column + 1);\n            } else if (lno > loc.first_line && lno < loc.last_line) {\n              len = Math.max(2, line.length + 1);\n            }\n\n            if (len) {\n              var lead = new Array(offset).join(\'.\');\n              var mark = new Array(len).join(\'^\');\n              rv += \'\\n\' + errpfx + lead + mark;\n\n              if (line.trim().length > 0) {\n                nonempty_line_indexes.push(index);\n              }\n            }\n\n            rv = rv.replace(/\\t/g, \' \');\n            return rv;\n        });\n\n        // now make sure we don\'t print an overly large amount of error area: limit it \n        // to the top and bottom line count:\n        if (nonempty_line_indexes.length > 2 * MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT) {\n            var clip_start = nonempty_line_indexes[MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT - 1] + 1;\n            var clip_end = nonempty_line_indexes[nonempty_line_indexes.length - MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT] - 1;\n\n            var intermediate_line = (new Array(lineno_display_width + 1)).join(\' \') +     \'  (...continued...)\';\n            intermediate_line += \'\\n\' + (new Array(lineno_display_width + 1)).join(\'-\') + \'  (---------------)\';\n            rv.splice(clip_start, clip_end - clip_start + 1, intermediate_line);\n        }\n        return rv.join(\'\\n\');\n    },\n\n    /**\n     * helper function, used to produce a human readable description as a string, given\n     * the input `yylloc` location object.\n     * \n     * Set `display_range_too` to TRUE to include the string character index position(s)\n     * in the description if the `yylloc.range` is available.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    describeYYLLOC: function lexer_describe_yylloc(yylloc, display_range_too) {\n        var l1 = yylloc.first_line;\n        var l2 = yylloc.last_line;\n        var c1 = yylloc.first_column;\n        var c2 = yylloc.last_column;\n        var dl = l2 - l1;\n        var dc = c2 - c1;\n        var rv;\n        if (dl === 0) {\n            rv = \'line \' + l1 + \', \';\n            if (dc <= 1) {\n                rv += \'column \' + c1;\n            } else {\n                rv += \'columns \' + c1 + \' .. \' + c2;\n            }\n        } else {\n            rv = \'lines \' + l1 + \'(column \' + c1 + \') .. \' + l2 + \'(column \' + c2 + \')\';\n        }\n        if (yylloc.range && display_range_too) {\n            var r1 = yylloc.range[0];\n            var r2 = yylloc.range[1] - 1;\n            if (r2 <= r1) {\n                rv += \' {String Offset: \' + r1 + \'}\';\n            } else {\n                rv += \' {String Offset range: \' + r1 + \' .. \' + r2 + \'}\';\n            }\n        }\n        return rv;\n    },\n\n    /**\n     * test the lexed token: return FALSE when not a match, otherwise return token.\n     * \n     * `match` is supposed to be an array coming out of a regex match, i.e. `match[0]`\n     * contains the actually matched text string.\n     * \n     * Also move the input cursor forward and update the match collectors:\n     * \n     * - `yytext`\n     * - `yyleng`\n     * - `match`\n     * - `matches`\n     * - `yylloc`\n     * - `offset`\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    test_match: function lexer_test_match(match, indexed_rule) {\n        var token,\n            lines,\n            backup,\n            match_str,\n            match_str_len;\n\n        if (this.options.backtrack_lexer) {\n            // save context\n            backup = {\n                yylineno: this.yylineno,\n                yylloc: {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.yylloc.last_line,\n                    first_column: this.yylloc.first_column,\n                    last_column: this.yylloc.last_column,\n\n                    range: this.yylloc.range.slice(0)\n                },\n                yytext: this.yytext,\n                match: this.match,\n                matches: this.matches,\n                matched: this.matched,\n                yyleng: this.yyleng,\n                offset: this.offset,\n                _more: this._more,\n                _input: this._input,\n                //_signaled_error_token: this._signaled_error_token,\n                yy: this.yy,\n                conditionStack: this.conditionStack.slice(0),\n                done: this.done\n            };\n        }\n\n        match_str = match[0];\n        match_str_len = match_str.length;\n        // if (match_str.indexOf(\'\\n\') !== -1 || match_str.indexOf(\'\\r\') !== -1) {\n            lines = match_str.split(/(?:\\r\\n?|\\n)/g);\n            if (lines.length > 1) {\n                this.yylineno += lines.length - 1;\n\n                this.yylloc.last_line = this.yylineno + 1;\n                this.yylloc.last_column = lines[lines.length - 1].length;\n            } else {\n                this.yylloc.last_column += match_str_len;\n            }\n        // }\n        this.yytext += match_str;\n        this.match += match_str;\n        this.matched += match_str;\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        this.yylloc.range[1] += match_str_len;\n\n        // previous lex rules MAY have invoked the `more()` API rather than producing a token:\n        // those rules will already have moved this `offset` forward matching their match lengths,\n        // hence we must only add our own match length now:\n        this.offset += match_str_len;\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match_str_len);\n\n        // calling this method:\n        //\n        //   function lexer__performAction(yy, yyrulenumber, YY_START) {...}\n        token = this.performAction.call(this, this.yy, indexed_rule, this.conditionStack[this.conditionStack.length - 1] /* = YY_START */);\n        // otherwise, when the action codes are all simple return token statements:\n        //token = this.simpleCaseActionClusters[indexed_rule];\n\n        if (this.done && this._input) {\n            this.done = false;\n        }\n        if (token) {\n            return token;\n        } else if (this._backtrack) {\n            // recover context\n            for (var k in backup) {\n                this[k] = backup[k];\n            }\n            this.__currentRuleSet__ = null;\n            return false; // rule action called reject() implying the next rule should be tested instead.\n        } else if (this._signaled_error_token) {\n            // produce one \'error\' token as `.parseError()` in `reject()`\n            // did not guarantee a failure signal by throwing an exception!\n            token = this._signaled_error_token;\n            this._signaled_error_token = false;\n            return token;\n        }\n        return false;\n    },\n\n    /**\n     * return next match in input\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    next: function lexer_next() {\n        if (this.done) {\n            this.clear();\n            return this.EOF;\n        }\n        if (!this._input) {\n            this.done = true;\n        }\n\n        var token,\n            match,\n            tempMatch,\n            index;\n        if (!this._more) {\n            this.clear();\n        }\n        var spec = this.__currentRuleSet__;\n        if (!spec) {\n            // Update the ruleset cache as we apparently encountered a state change or just started lexing.\n            // The cache is set up for fast lookup -- we assume a lexer will switch states much less often than it will\n            // invoke the `lex()` token-producing API and related APIs, hence caching the set for direct access helps\n            // speed up those activities a tiny bit.\n            spec = this.__currentRuleSet__ = this._currentRules();\n            // Check whether a *sane* condition has been pushed before: this makes the lexer robust against\n            // user-programmer bugs such as https://github.com/zaach/jison-lex/issues/19\n            if (!spec || !spec.rules) {\n                var lineno_msg = \'\';\n                if (this.options.trackPosition) {\n                    lineno_msg = \' on line \' + (this.yylineno + 1);\n                }\n                var p = this.constructLexErrorInfo(\'Internal lexer engine error\' + lineno_msg + \': The lex grammar programmer pushed a non-existing condition name "\' + this.topState() + \'"; this is a fatal error and should be reported to the application programmer team!\', false);\n                // produce one \'error\' token until this situation has been resolved, most probably by parse termination!\n                return (this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR);\n            }\n        }\n\n        var rule_ids = spec.rules;\n        var regexes = spec.__rule_regexes;\n        var len = spec.__rule_count;\n\n        // Note: the arrays are 1-based, while `len` itself is a valid index,\n        // hence the non-standard less-or-equal check in the next loop condition!\n        for (var i = 1; i <= len; i++) {\n            tempMatch = this._input.match(regexes[i]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (this.options.backtrack_lexer) {\n                    token = this.test_match(tempMatch, rule_ids[i]);\n                    if (token !== false) {\n                        return token;\n                    } else if (this._backtrack) {\n                        match = undefined;\n                        continue; // rule action called reject() implying a rule MISmatch.\n                    } else {\n                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                        return false;\n                    }\n                } else if (!this.options.flex) {\n                    break;\n                }\n            }\n        }\n        if (match) {\n            token = this.test_match(match, rule_ids[index]);\n            if (token !== false) {\n                return token;\n            }\n            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n            return false;\n        }\n        if (!this._input) {\n            this.done = true;\n            this.clear();\n            return this.EOF;\n        } else {\n            var lineno_msg = \'\';\n            if (this.options.trackPosition) {\n                lineno_msg = \' on line \' + (this.yylineno + 1);\n            }\n            var p = this.constructLexErrorInfo(\'Lexical error\' + lineno_msg + \': Unrecognized text.\', this.options.lexerErrorsAreRecoverable);\n\n            var pendingInput = this._input;\n            var activeCondition = this.topState();\n            var conditionStackDepth = this.conditionStack.length;\n\n            token = (this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR);\n            if (token === this.ERROR) {\n                // we can try to recover from a lexer error that `parseError()` did not \'recover\' for us\n                // by moving forward at least one character at a time IFF the (user-specified?) `parseError()`\n                // has not consumed/modified any pending input or changed state in the error handler:\n                if (!this.matches && \n                    // and make sure the input has been modified/consumed ...\n                    pendingInput === this._input &&\n                    // ...or the lexer state has been modified significantly enough\n                    // to merit a non-consuming error handling action right now.\n                    activeCondition === this.topState() && \n                    conditionStackDepth === this.conditionStack.length\n                ) {\n                    this.input();\n                }\n            }\n            return token;\n        }\n    },\n\n    /**\n     * return next match that has a token\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    lex: function lexer_lex() {\n        var r;\n        // allow the PRE/POST handlers set/modify the return token for maximum flexibility of the generated lexer:\n        if (typeof this.pre_lex === \'function\') {\n            r = this.pre_lex.call(this, 0);\n        }\n        if (typeof this.options.pre_lex === \'function\') {\n            // (also account for a userdef function which does not return any value: keep the token as is)\n            r = this.options.pre_lex.call(this, r) || r;\n        }\n        if (this.yy && typeof this.yy.pre_lex === \'function\') {\n            // (also account for a userdef function which does not return any value: keep the token as is)\n            r = this.yy.pre_lex.call(this, r) || r;\n        }\n\n        while (!r) {\n            r = this.next();\n        }\n\n        if (this.yy && typeof this.yy.post_lex === \'function\') {\n            // (also account for a userdef function which does not return any value: keep the token as is)\n            r = this.yy.post_lex.call(this, r) || r;\n        }\n        if (typeof this.options.post_lex === \'function\') {\n            // (also account for a userdef function which does not return any value: keep the token as is)\n            r = this.options.post_lex.call(this, r) || r;\n        }\n        if (typeof this.post_lex === \'function\') {\n            // (also account for a userdef function which does not return any value: keep the token as is)\n            r = this.post_lex.call(this, r) || r;\n        }\n        return r;\n    },\n\n    /**\n     * return next match that has a token. Identical to the `lex()` API but does not invoke any of the \n     * `pre_lex()` nor any of the `post_lex()` callbacks.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    fastLex: function lexer_fastLex() {\n        var r;\n\n        while (!r) {\n            r = this.next();\n        }\n\n        return r;\n    },\n\n    /**\n     * return info about the lexer state that can help a parser or other lexer API user to use the\n     * most efficient means available. This API is provided to aid run-time performance for larger\n     * systems which employ this lexer.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    canIUse: function lexer_canIUse() {\n        var rv = {\n            fastLex: !(\n                typeof this.pre_lex === \'function\' ||\n                typeof this.options.pre_lex === \'function\' ||\n                (this.yy && typeof this.yy.pre_lex === \'function\') ||\n                (this.yy && typeof this.yy.post_lex === \'function\') ||\n                typeof this.options.post_lex === \'function\' ||\n                typeof this.post_lex === \'function\'\n            ) && typeof this.fastLex === \'function\',\n        };\n        return rv;\n    },\n\n\n    /**\n     * backwards compatible alias for `pushState()`;\n     * the latter is symmetrical with `popState()` and we advise to use\n     * those APIs in any modern lexer code, rather than `begin()`.\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    begin: function lexer_begin(condition) {\n        return this.pushState(condition);\n    },\n\n    /**\n     * activates a new lexer condition state (pushes the new lexer\n     * condition state onto the condition stack)\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    pushState: function lexer_pushState(condition) {\n        this.conditionStack.push(condition);\n        this.__currentRuleSet__ = null;\n        return this;\n    },\n\n    /**\n     * pop the previously active lexer condition state off the condition\n     * stack\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    popState: function lexer_popState() {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n            this.__currentRuleSet__ = null; \n            return this.conditionStack.pop();\n        } else {\n            return this.conditionStack[0];\n        }\n    },\n\n    /**\n     * return the currently active lexer condition state; when an index\n     * argument is provided it produces the N-th previous condition state,\n     * if available\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    topState: function lexer_topState(n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n            return this.conditionStack[n];\n        } else {\n            return \'INITIAL\';\n        }\n    },\n\n    /**\n     * (internal) determine the lexer rule set which is active for the\n     * currently active lexer condition state\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    _currentRules: function lexer__currentRules() {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n            return this.conditions[this.conditionStack[this.conditionStack.length - 1]];\n        } else {\n            return this.conditions[\'INITIAL\'];\n        }\n    },\n\n    /**\n     * return the number of states currently on the stack\n     * \n     * @public\n     * @this {RegExpLexer}\n     */\n    stateStackSize: function lexer_stateStackSize() {\n        return this.conditionStack.length;\n    }\n}';
    // --- END lexer kernel ---
}

RegExpLexer.prototype = new Function(rmCommonWS$1(_templateObject37, getRegExpLexerPrototype()))();

// The lexer code stripper, driven by optimization analysis settings and
// lexer options, which cannot be changed at run-time.
function stripUnusedLexerCode(src, opt) {
    //   uses yyleng: ..................... ${opt.lexerActionsUseYYLENG}
    //   uses yylineno: ................... ${opt.lexerActionsUseYYLINENO}
    //   uses yytext: ..................... ${opt.lexerActionsUseYYTEXT}
    //   uses yylloc: ..................... ${opt.lexerActionsUseYYLOC}
    //   uses ParseError API: ............. ${opt.lexerActionsUseParseError}
    //   uses location tracking & editing:  ${opt.lexerActionsUseLocationTracking}
    //   uses more() API: ................. ${opt.lexerActionsUseMore}
    //   uses unput() API: ................ ${opt.lexerActionsUseUnput}
    //   uses reject() API: ............... ${opt.lexerActionsUseReject}
    //   uses less() API: ................. ${opt.lexerActionsUseLess}
    //   uses display APIs pastInput(), upcomingInput(), showPosition():
    //        ............................. ${opt.lexerActionsUseDisplayAPIs}
    //   uses describeYYLLOC() API: ....... ${opt.lexerActionsUseDescribeYYLOC}

    var ast = helpers.parseCodeChunkToAST(src, opt);
    var new_src = helpers.prettyPrintAST(ast, opt);

    new_src = new_src.replace(/\/\*\s*JISON-LEX-ANALYTICS-REPORT\s*\*\//g, rmCommonWS$1(_templateObject38, opt.options.backtrack_lexer, opt.options.ranges, opt.options.trackPosition, opt.parseActionsUseYYLENG, opt.parseActionsUseYYLINENO, opt.parseActionsUseYYTEXT, opt.parseActionsUseYYLOC, opt.parseActionsUseValueTracking, opt.parseActionsUseValueAssignment, opt.parseActionsUseLocationTracking, opt.parseActionsUseLocationAssignment, opt.lexerActionsUseYYLENG, opt.lexerActionsUseYYLINENO, opt.lexerActionsUseYYTEXT, opt.lexerActionsUseYYLOC, opt.lexerActionsUseParseError, opt.lexerActionsUseYYERROR, opt.lexerActionsUseLocationTracking, opt.lexerActionsUseMore, opt.lexerActionsUseUnput, opt.lexerActionsUseReject, opt.lexerActionsUseLess, opt.lexerActionsUseDisplayAPIs, opt.lexerActionsUseDescribeYYLOC));

    return new_src;
}

// generate lexer source from a grammar
/**  @public */
function generate(dict, tokens, build_options) {
    var opt = processGrammar(dict, tokens, build_options);

    return generateFromOpts(opt);
}

// process the grammar and build final data structures and functions
/**  @public */
function processGrammar(dict, tokens, build_options) {
    build_options = build_options || {};
    var opts = {
        // include the knowledge passed through `build_options` about which lexer
        // features will actually be *used* by the environment (which in 99.9%
        // of cases is a jison *parser*):
        //
        // (this stuff comes straight from the jison Optimization Analysis.)
        //
        parseActionsUseYYLENG: build_options.parseActionsUseYYLENG,
        parseActionsUseYYLINENO: build_options.parseActionsUseYYLINENO,
        parseActionsUseYYTEXT: build_options.parseActionsUseYYTEXT,
        parseActionsUseYYLOC: build_options.parseActionsUseYYLOC,
        parseActionsUseParseError: build_options.parseActionsUseParseError,
        parseActionsUseYYERROR: build_options.parseActionsUseYYERROR,
        parseActionsUseYYERROK: build_options.parseActionsUseYYERROK,
        parseActionsUseYYRECOVERING: build_options.parseActionsUseYYRECOVERING,
        parseActionsUseYYCLEARIN: build_options.parseActionsUseYYCLEARIN,
        parseActionsUseValueTracking: build_options.parseActionsUseValueTracking,
        parseActionsUseValueAssignment: build_options.parseActionsUseValueAssignment,
        parseActionsUseLocationTracking: build_options.parseActionsUseLocationTracking,
        parseActionsUseLocationAssignment: build_options.parseActionsUseLocationAssignment,
        parseActionsUseYYSTACK: build_options.parseActionsUseYYSTACK,
        parseActionsUseYYSSTACK: build_options.parseActionsUseYYSSTACK,
        parseActionsUseYYSTACKPOINTER: build_options.parseActionsUseYYSTACKPOINTER,
        parseActionsUseYYRULELENGTH: build_options.parseActionsUseYYRULELENGTH,
        parserHasErrorRecovery: build_options.parserHasErrorRecovery,
        parserHasErrorReporting: build_options.parserHasErrorReporting,

        lexerActionsUseYYLENG: '???',
        lexerActionsUseYYLINENO: '???',
        lexerActionsUseYYTEXT: '???',
        lexerActionsUseYYLOC: '???',
        lexerActionsUseParseError: '???',
        lexerActionsUseYYERROR: '???',
        lexerActionsUseLocationTracking: '???',
        lexerActionsUseMore: '???',
        lexerActionsUseUnput: '???',
        lexerActionsUseReject: '???',
        lexerActionsUseLess: '???',
        lexerActionsUseDisplayAPIs: '???',
        lexerActionsUseDescribeYYLOC: '???'
    };

    dict = autodetectAndConvertToJSONformat$1(dict, build_options) || {};

    // Feed the possibly reprocessed 'dictionary' above back to the caller
    // (for use by our error diagnostic assistance code)
    opts.lex_rule_dictionary = dict;

    // Always provide the lexer with an options object, even if it's empty!
    // Make sure to camelCase all options:
    opts.options = mkStdOptions$1(build_options, dict.options);

    opts.moduleType = opts.options.moduleType;
    opts.moduleName = opts.options.moduleName;

    opts.conditions = prepareStartConditions(dict.startConditions);
    opts.conditions.INITIAL = {
        rules: [],
        inclusive: true
    };

    // only produce rule action code blocks when there are any rules at all;
    // a "custom lexer" has ZERO rules and must be defined entirely in 
    // other code blocks: 
    var code = dict.rules ? buildActions(dict, tokens, opts) : {};
    opts.performAction = code.actions;
    opts.caseHelperInclude = code.caseHelperInclude;
    opts.rules = code.rules || [];
    opts.macros = code.macros;

    opts.regular_rule_count = code.regular_rule_count;
    opts.simple_rule_count = code.simple_rule_count;

    opts.conditionStack = ['INITIAL'];

    opts.actionInclude = dict.actionInclude || '';
    opts.moduleInclude = (opts.moduleInclude || '') + (dict.moduleInclude || '').trim();

    return opts;
}

// Assemble the final source from the processed grammar
/**  @public */
function generateFromOpts(opt) {
    var code = '';

    switch (opt.moduleType) {
        case 'js':
            code = generateModule(opt);
            break;
        case 'amd':
            code = generateAMDModule(opt);
            break;
        case 'es':
            code = generateESModule(opt);
            break;
        case 'commonjs':
        default:
            code = generateCommonJSModule(opt);
            break;
    }

    return code;
}

function generateRegexesInitTableCode(opt) {
    var a = opt.rules;
    var print_xregexp = opt.options && opt.options.xregexp;
    var id_display_width = 1 + Math.log10(a.length | 1) | 0;
    var ws_prefix = new Array(id_display_width).join(' ');
    var b = a.map(function generateXRegExpInitCode(re, idx) {
        var idx_str = (ws_prefix + idx).substr(-id_display_width);

        if (re instanceof XRegExp) {
            // When we don't need the special XRegExp sauce at run-time, we do with the original
            // JavaScript RegExp instance a.k.a. 'native regex':
            if (re.xregexp.isNative || !print_xregexp) {
                return '/* ' + idx_str + ': */  ' + re;
            }
            // And make sure to escape the regex to make it suitable for placement inside a *string*
            // as it is passed as a string argument to the XRegExp constructor here.
            var re_src = re.xregexp.source.replace(/[\\"]/g, '\\$&');
            return '/* ' + idx_str + ': */  new XRegExp("' + re_src + '", "' + re.xregexp.flags + '")';
        } else {
            return '/* ' + idx_str + ': */  ' + re;
        }
    });
    return b.join(',\n');
}

function generateModuleBody(opt) {
    // make the JSON output look more like JavaScript:
    function cleanupJSON(str) {
        str = str.replace(/  "rules": \[/g, '  rules: [');
        str = str.replace(/  "inclusive": /g, '  inclusive: ');
        return str;
    }

    function produceOptions(opts) {
        var obj = {};
        var do_not_pass = {
            debug: !opts.debug, // do not include this item when it is FALSE as there's no debug tracing built into the generated grammar anyway!
            enableDebugLogs: 1,
            json: 1,
            _: 1,
            noMain: 1,
            dumpSourceCodeOnFailure: 1,
            throwErrorOnCompileFailure: 1,
            reportStats: 1,
            file: 1,
            outfile: 1,
            inputPath: 1,
            inputFilename: 1,
            defaultModuleName: 1,
            moduleName: 1,
            moduleType: 1,
            lexerErrorsAreRecoverable: 0,
            flex: 0,
            backtrack_lexer: 0,
            caseInsensitive: 0,
            showSource: 1,
            exportAST: 1,
            exportAllTables: 1,
            exportSourceCode: 1,
            prettyCfg: 1,
            parseActionsUseYYLENG: 1,
            parseActionsUseYYLINENO: 1,
            parseActionsUseYYTEXT: 1,
            parseActionsUseYYLOC: 1,
            parseActionsUseParseError: 1,
            parseActionsUseYYERROR: 1,
            parseActionsUseYYRECOVERING: 1,
            parseActionsUseYYERROK: 1,
            parseActionsUseYYCLEARIN: 1,
            parseActionsUseValueTracking: 1,
            parseActionsUseValueAssignment: 1,
            parseActionsUseLocationTracking: 1,
            parseActionsUseLocationAssignment: 1,
            parseActionsUseYYSTACK: 1,
            parseActionsUseYYSSTACK: 1,
            parseActionsUseYYSTACKPOINTER: 1,
            parseActionsUseYYRULELENGTH: 1,
            parserHasErrorRecovery: 1,
            parserHasErrorReporting: 1,
            lexerActionsUseYYLENG: 1,
            lexerActionsUseYYLINENO: 1,
            lexerActionsUseYYTEXT: 1,
            lexerActionsUseYYLOC: 1,
            lexerActionsUseParseError: 1,
            lexerActionsUseYYERROR: 1,
            lexerActionsUseLocationTracking: 1,
            lexerActionsUseMore: 1,
            lexerActionsUseUnput: 1,
            lexerActionsUseReject: 1,
            lexerActionsUseLess: 1,
            lexerActionsUseDisplayAPIs: 1,
            lexerActionsUseDescribeYYLOC: 1
        };
        for (var k in opts) {
            if (!do_not_pass[k] && opts[k] != null && opts[k] !== false) {
                // make sure numeric values are encoded as numeric, the rest as boolean/string.
                if (typeof opts[k] === 'string') {
                    var f = parseFloat(opts[k]);
                    if (f == opts[k]) {
                        obj[k] = f;
                        continue;
                    }
                }
                obj[k] = opts[k];
            }
        }

        // And now some options which should receive some special processing:
        var pre = obj.pre_lex;
        var post = obj.post_lex;
        // since JSON cannot encode functions, we'll have to do it manually at run-time, i.e. later on:
        if (pre) {
            obj.pre_lex = true;
        }
        if (post) {
            obj.post_lex = true;
        }

        var js = JSON.stringify(obj, null, 2);

        js = js.replace(new XRegExp('  "(' + ID_REGEX_BASE$1 + ')": ', 'g'), '  $1: ');
        js = js.replace(/^( +)pre_lex: true(,)?$/gm, function (m, ls, tc) {
            return ls + 'pre_lex: ' + String(pre) + (tc || '');
        });
        js = js.replace(/^( +)post_lex: true(,)?$/gm, function (m, ls, tc) {
            return ls + 'post_lex: ' + String(post) + (tc || '');
        });
        return js;
    }

    var out;
    if (opt.rules.length > 0 || opt.__in_rules_failure_analysis_mode__) {
        // we don't mind that the `test_me()` code above will have this `lexer` variable re-defined:
        // JavaScript is fine with that.
        var code = [rmCommonWS$1(_templateObject39), '/*JISON-LEX-ANALYTICS-REPORT*/' /* slot #1: placeholder for analysis report further below */
        ];

        // get the RegExpLexer.prototype in source code form:
        var protosrc = getRegExpLexerPrototype();
        // and strip off the surrounding bits we don't want:
        protosrc = protosrc.replace(/^[\s\r\n]*\{/, '').replace(/\s*\}[\s\r\n]*$/, '').trim();
        code.push(protosrc + ',\n');

        assert(opt.options);
        // Assure all options are camelCased:
        assert(typeof opt.options['case-insensitive'] === 'undefined');

        code.push('    options: ' + produceOptions(opt.options));

        /*
                function isEmpty(code) {
                    switch (typeof code) {
                    case 'undefined':
                    case 'null':
                        return true;
        
                    case 'string':
        
                    } 
                }
        */

        var performActionCode = String(opt.performAction);
        var simpleCaseActionClustersCode = String(opt.caseHelperInclude);
        var rulesCode = generateRegexesInitTableCode(opt);
        var conditionsCode = cleanupJSON(JSON.stringify(opt.conditions, null, 2));
        code.push(rmCommonWS$1(_templateObject40, performActionCode, simpleCaseActionClustersCode, rulesCode, conditionsCode));

        opt.is_custom_lexer = false;

        out = code.join('');
    } else {
        // We're clearly looking at a custom lexer here as there's no lexer rules at all.
        //
        // We are re-purposing the `%{...%}` `actionInclude` code block here as it serves no purpose otherwise.
        //
        // Meanwhile we make sure we have the `lexer` variable declared in *local scope* no matter
        // what crazy stuff (or lack thereof) the userland code is pulling in the `actionInclude` chunk.
        out = 'var lexer;\n';

        assert(opt.regular_rule_count === 0);
        assert(opt.simple_rule_count === 0);
        opt.is_custom_lexer = true;

        if (opt.actionInclude) {
            out += opt.actionInclude + (!opt.actionInclude.match(/;[\s\r\n]*$/) ? ';' : '') + '\n';
        }
    }

    // The output of this function is guaranteed to read something like this:
    //
    // ```
    // var lexer;
    //
    // bla bla bla bla ... lotsa bla bla;
    // ```
    //
    // and that should work nicely as an `eval()`-able piece of source code.
    return out;
}

function generateGenericHeaderComment() {
    var out = rmCommonWS$1(_templateObject41, version$1);

    return out;
}

function prepareOptions(opt) {
    opt = opt || {};

    // check for illegal identifier
    if (!opt.moduleName || !opt.moduleName.match(/^[a-zA-Z_$][a-zA-Z0-9_$\.]*$/)) {
        if (opt.moduleName) {
            var msg = 'WARNING: The specified moduleName "' + opt.moduleName + '" is illegal (only characters [a-zA-Z0-9_$] and "." dot are accepted); using the default moduleName "lexer" instead.';
            if (typeof opt.warn_cb === 'function') {
                opt.warn_cb(msg);
            } else {
                // do not treat as warning; barf hairball instead so that this oddity gets noticed right away!
                throw new Error(msg);
            }
        }
        opt.moduleName = 'lexer';
    }

    prepExportStructures$1(opt);

    return opt;
}

function generateModule(opt) {
    opt = prepareOptions(opt);

    var out = [generateGenericHeaderComment(), '', 'var ' + opt.moduleName + ' = (function () {', jisonLexerErrorDefinition, '', generateModuleBody(opt), '', opt.moduleInclude ? opt.moduleInclude + ';' : '', '', 'return lexer;', '})();'];

    var src = out.join('\n') + '\n';
    src = stripUnusedLexerCode(src, opt);
    opt.exportSourceCode.all = src;
    return src;
}

function generateAMDModule(opt) {
    opt = prepareOptions(opt);

    var out = [generateGenericHeaderComment(), '', 'define([], function () {', jisonLexerErrorDefinition, '', generateModuleBody(opt), '', opt.moduleInclude ? opt.moduleInclude + ';' : '', '', 'return lexer;', '});'];

    var src = out.join('\n') + '\n';
    src = stripUnusedLexerCode(src, opt);
    opt.exportSourceCode.all = src;
    return src;
}

function generateESModule(opt) {
    opt = prepareOptions(opt);

    var out = [generateGenericHeaderComment(), '', 'var lexer = (function () {', jisonLexerErrorDefinition, '', generateModuleBody(opt), '', opt.moduleInclude ? opt.moduleInclude + ';' : '', '', 'return lexer;', '})();', '', 'function yylex() {', '    return lexer.lex.apply(lexer, arguments);', '}', rmCommonWS$1(_templateObject42)];

    var src = out.join('\n') + '\n';
    src = stripUnusedLexerCode(src, opt);
    opt.exportSourceCode.all = src;
    return src;
}

function generateCommonJSModule(opt) {
    opt = prepareOptions(opt);

    var out = [generateGenericHeaderComment(), '', 'var ' + opt.moduleName + ' = (function () {', jisonLexerErrorDefinition, '', generateModuleBody(opt), '', opt.moduleInclude ? opt.moduleInclude + ';' : '', '', 'return lexer;', '})();', '', 'if (typeof require !== \'undefined\' && typeof exports !== \'undefined\') {', '  exports.lexer = ' + opt.moduleName + ';', '  exports.lex = function () {', '    return ' + opt.moduleName + '.lex.apply(lexer, arguments);', '  };', '}'];

    var src = out.join('\n') + '\n';
    src = stripUnusedLexerCode(src, opt);
    opt.exportSourceCode.all = src;
    return src;
}

RegExpLexer.generate = generate;

RegExpLexer.version = version$1;
RegExpLexer.defaultJisonLexOptions = defaultJisonLexOptions;
RegExpLexer.mkStdOptions = mkStdOptions$1;
RegExpLexer.camelCase = camelCase$1;
RegExpLexer.autodetectAndConvertToJSONformat = autodetectAndConvertToJSONformat$1;

/* parser generated by jison 0.6.1-210 */

/*
 * Returns a Parser object of the following structure:
 *
 *  Parser: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a derivative/copy of this one,
 *               not a direct reference!
 *  }
 *
 *  Parser.prototype: {
 *    yy: {},
 *    EOF: 1,
 *    TERROR: 2,
 *
 *    trace: function(errorMessage, ...),
 *
 *    JisonParserError: function(msg, hash),
 *
 *    quoteName: function(name),
 *               Helper function which can be overridden by user code later on: put suitable
 *               quotes around literal IDs in a description string.
 *
 *    originalQuoteName: function(name),
 *               The basic quoteName handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function
 *               at the end of the `parse()`.
 *
 *    describeSymbol: function(symbol),
 *               Return a more-or-less human-readable description of the given symbol, when
 *               available, or the symbol itself, serving as its own 'description' for lack
 *               of something better to serve up.
 *
 *               Return NULL when the symbol is unknown to the parser.
 *
 *    symbols_: {associative list: name ==> number},
 *    terminals_: {associative list: number ==> name},
 *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},
 *    terminal_descriptions_: (if there are any) {associative list: number ==> description},
 *    productions_: [...],
 *
 *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)
 *                             to store/reference the rule value `$$` and location info `@$`.
 *
 *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets
 *                 to see the same object via the `this` reference, i.e. if you wish to carry custom
 *                 data from one reduce action through to the next within a single parse run, then you
 *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.
 *
 *                 `this.yy` is a direct reference to the `yy` shared state object.
 *
 *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`
 *                 object at `parse()` start and are therefore available to the action code via the
 *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from
 *                 the %parse-param` list.
 *
 *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used
 *                             to match this rule. This is *not* the look-ahead token, but the last token
 *                             that's actually part of this rule.
 *
 *                 Formulated another way, `yytext` is the value of the token immediately preceeding
 *                 the current look-ahead token.
 *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.
 *
 *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.
 *
 *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.
 *
 *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.
 *
 *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead
 *                               of an empty object when no suitable location info can be provided.
 *
 *               - `yystate` : the current parser state number, used internally for dispatching and
 *                               executing the action code chunk matching the rule currently being reduced.
 *
 *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *                 Also note that you can access this and other stack index values using the new double-hash
 *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things
 *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.
 *                 This is made available to write very advanced grammar action rules, e.g. when you want
 *                 to investigate the parse state stack in your action code, which would, for example,
 *                 be relevant when you wish to implement error diagnostics and reporting schemes similar
 *                 to the work described here:
 *
 *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.
 *                   In Journes Francophones des Languages Applicatifs.
 *
 *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.
 *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631640.
 *
 *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.
 *                             constructs.
 *
 *               - `yylstack`: reference to the parser token location stack. Also accessed via
 *                             the `@1` etc. constructs.
 *
 *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are
 *                             UNDEFINED rather than an empty (location) object, when the lexer/parser
 *                             action code did not provide a suitable location info object when such a
 *                             slot was filled!
 *
 *               - `yystack` : reference to the parser token id stack. Also accessed via the
 *                             `#1` etc. constructs.
 *
 *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to
 *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might
 *                 want access this array for your own purposes, such as error analysis as mentioned above!
 *
 *                 Note that this stack stores the current stack of *tokens*, that is the sequence of
 *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*
 *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and
 *                 *reduced*.
 *
 *               - `yysstack`: reference to the parser state stack. This one carries the internal parser
 *                             *states* such as the one in `yystate`, which are used to represent
 *                             the parser state machine in the *parse table*. *Very* *internal* stuff,
 *                             what can I say? If you access this one, you're clearly doing wicked things
 *
 *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your
 *                             grammar definition file.
 *
 *    table: [...],
 *               State transition table
 *               ----------------------
 *
 *               index levels are:
 *               - `state`  --> hash table
 *               - `symbol` --> action (number or array)
 *
 *                 If the `action` is an array, these are the elements' meaning:
 *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept
 *                 - index [1]: GOTO `state`
 *
 *                 If the `action` is a number, it is the GOTO `state`
 *
 *    defaultActions: {...},
 *
 *    parseError: function(str, hash, ExceptionClass),
 *    yyError: function(str, ...),
 *    yyRecovering: function(),
 *    yyErrOk: function(),
 *    yyClearIn: function(),
 *
 *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this parser kernel in many places; example usage:
 *
 *                   var infoObj = parser.constructParseErrorInfo('fail!', null,
 *                                     parser.collect_expected_token_set(state), true);
 *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);
 *
 *    originalParseError: function(str, hash, ExceptionClass),
 *               The basic `parseError` handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function
 *               at the end of the `parse()`.
 *
 *    options: { ... parser %options ... },
 *
 *    parse: function(input[, args...]),
 *               Parse the given `input` and return the parsed value (or `true` when none was provided by
 *               the root action, in which case the parser is acting as a *matcher*).
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the jison run-time;
 *               when such a collision is detected an exception is thrown to prevent the generated run-time
 *               from silently accepting this confusing and potentially hazardous situation!
 *
 *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in
 *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state
 *               object and any collision with those will be reported by the lexer via a thrown exception.
 *
 *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown
 *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY
 *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and
 *               the internal parser gets properly garbage collected under these particular circumstances.
 *
 *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API can be invoked to calculate a spanning `yylloc` location info object.
 *
 *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case
 *               this function will attempt to obtain a suitable location marker by inspecting the location stack
 *               backwards.
 *
 *               For more info see the documentation comment further below, immediately above this function's
 *               implementation.
 *
 *    lexer: {
 *        yy: {...},           A reference to the so-called "shared state" `yy` once
 *                             received via a call to the `.setInput(input, yy)` lexer API.
 *        EOF: 1,
 *        ERROR: 2,
 *        JisonLexerError: function(msg, hash),
 *        parseError: function(str, hash, ExceptionClass),
 *        setInput: function(input, [yy]),
 *        input: function(),
 *        unput: function(str),
 *        more: function(),
 *        reject: function(),
 *        less: function(n),
 *        pastInput: function(n),
 *        upcomingInput: function(n),
 *        showPosition: function(),
 *        test_match: function(regex_match_array, rule_index, ...),
 *        next: function(...),
 *        lex: function(...),
 *        begin: function(condition),
 *        pushState: function(condition),
 *        popState: function(),
 *        topState: function(),
 *        _currentRules: function(),
 *        stateStackSize: function(),
 *        cleanupAfterLex: function()
 *
 *        options: { ... lexer %options ... },
 *
 *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),
 *        rules: [...],
 *        conditions: {associative list: name ==> set},
 *    }
 *  }
 *
 *
 *  token location info (@$, _$, etc.): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer and
 * parser errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *  }
 *
 * parser (grammar) errors will also provide these additional members:
 *
 *  {
 *    expected:    (array describing the set of expected tokens;
 *                  may be UNDEFINED when we cannot easily produce such a set)
 *    state:       (integer (or array when the table includes grammar collisions);
 *                  represents the current internal state of the parser kernel.
 *                  can, for example, be used to pass to the `collect_expected_token_set()`
 *                  API to obtain the expected token set)
 *    action:      (integer; represents the current internal action which will be executed)
 *    new_state:   (integer; represents the next/planned internal state, once the current
 *                  action has executed)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *    parser:      (reference to the current parser instance)
 *  }
 *
 * while `this` will reference the current parser instance.
 *
 * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    lexer:       (reference to the current lexer instance which reported the error)
 *  }
 *
 * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired
 * from either the parser or lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    exception:   (reference to the exception thrown)
 *  }
 *
 * Please do note that in the latter situation, the `expected` field will be omitted as
 * this type of failure is assumed not to be due to *parse errors* but rather due to user
 * action code in either parser or lexer failing unexpectedly.
 *
 * ---
 *
 * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.
 * These options are available:
 *
 * ### options which are global for all parser instances
 *
 *  Parser.pre_parse: function(yy)
 *                 optional: you can specify a pre_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`.
 *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: you can specify a post_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`. When it does not return any value,
 *                 the parser will return the original `retval`.
 *
 * ### options which can be set up per parser instance
 *
 *  yy: {
 *      pre_parse:  function(yy)
 *                 optional: is invoked before the parse cycle starts (and before the first
 *                 invocation of `lex()`) but immediately after the invocation of
 *                 `parser.pre_parse()`).
 *      post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: is invoked when the parse terminates due to success ('accept')
 *                 or failure (even when exceptions are thrown).
 *                 `retval` contains the return value to be produced by `Parser.parse()`;
 *                 this function can override the return value by returning another.
 *                 When it does not return any value, the parser will return the original
 *                 `retval`.
 *                 This function is invoked immediately before `parser.post_parse()`.
 *
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *      quoteName: function(name),
 *                 optional: overrides the default `quoteName` function.
 *  }
 *
 *  parser.lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */

// See also:
// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
// with userland code which might access the derived class in a 'classic' way.
function JisonParserError$2(msg, hash) {
    Object.defineProperty(this, 'name', {
        enumerable: false,
        writable: false,
        value: 'JisonParserError'
    });

    if (msg == null) msg = '???';

    Object.defineProperty(this, 'message', {
        enumerable: false,
        writable: true,
        value: msg
    });

    this.hash = hash;

    var stacktrace;
    if (hash && hash.exception instanceof Error) {
        var ex2 = hash.exception;
        this.message = ex2.message || msg;
        stacktrace = ex2.stack;
    }
    if (!stacktrace) {
        if (Error.hasOwnProperty('captureStackTrace')) {
            // V8/Chrome engine
            Error.captureStackTrace(this, this.constructor);
        } else {
            stacktrace = new Error(msg).stack;
        }
    }
    if (stacktrace) {
        Object.defineProperty(this, 'stack', {
            enumerable: false,
            writable: false,
            value: stacktrace
        });
    }
}

if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonParserError$2.prototype, Error.prototype);
} else {
    JisonParserError$2.prototype = Object.create(Error.prototype);
}
JisonParserError$2.prototype.constructor = JisonParserError$2;
JisonParserError$2.prototype.name = 'JisonParserError';

// helper: reconstruct the productions[] table
function bp$2(s) {
    var rv = [];
    var p = s.pop;
    var r = s.rule;
    for (var i = 0, l = p.length; i < l; i++) {
        rv.push([p[i], r[i]]);
    }
    return rv;
}

// helper: reconstruct the 'goto' table
function bt$2(s) {
    var rv = [];
    var d = s.len;
    var y = s.symbol;
    var t = s.type;
    var a = s.state;
    var m = s.mode;
    var g = s.goto;
    for (var i = 0, l = d.length; i < l; i++) {
        var n = d[i];
        var q = {};
        for (var j = 0; j < n; j++) {
            var z = y.shift();
            switch (t.shift()) {
                case 2:
                    q[z] = [m.shift(), g.shift()];
                    break;

                case 0:
                    q[z] = a.shift();
                    break;

                default:
                    // type === 1: accept
                    q[z] = [3];
            }
        }
        rv.push(q);
    }
    return rv;
}

// helper: runlength encoding with increment step: code, length: step (default step = 0)
// `this` references an array
function s$2(c, l, a) {
    a = a || 0;
    for (var i = 0; i < l; i++) {
        this.push(c);
        c += a;
    }
}

// helper: duplicate sequence from *relative* offset and length.
// `this` references an array
function c$2(i, l) {
    i = this.length - i;
    for (l += i; i < l; i++) {
        this.push(this[i]);
    }
}

// helper: unpack an array using helpers and data, all passed in an array argument 'a'.
function u$2(a) {
    var rv = [];
    for (var i = 0, l = a.length; i < l; i++) {
        var e = a[i];
        // Is this entry a helper function?
        if (typeof e === 'function') {
            i++;
            e.apply(rv, a[i]);
        } else {
            rv.push(e);
        }
    }
    return rv;
}

var parser$3 = {
    // Code Generator Information Report
    // ---------------------------------
    //
    // Options:
    //
    //   default action mode: ............. classic,merge
    //   try..catch: ...................... true
    //   default resolve on conflict: ..... true
    //   on-demand look-ahead: ............ false
    //   error recovery token skip maximum: 3
    //   yyerror in parse actions is: ..... NOT recoverable,
    //   yyerror in lexer actions and other non-fatal lexer are:
    //   .................................. NOT recoverable,
    //   debug grammar/output: ............ false
    //   has partial LR conflict upgrade:   true
    //   rudimentary token-stack support:   false
    //   parser table compression mode: ... 2
    //   export debug tables: ............. false
    //   export *all* tables: ............. false
    //   module type: ..................... es
    //   parser engine type: .............. lalr
    //   output main() in the module: ..... true
    //   has user-specified main(): ....... false
    //   has user-specified require()/import modules for main():
    //   .................................. false
    //   number of expected conflicts: .... 0
    //
    //
    // Parser Analysis flags:
    //
    //   no significant actions (parser is a language matcher only):
    //   .................................. false
    //   uses yyleng: ..................... false
    //   uses yylineno: ................... false
    //   uses yytext: ..................... false
    //   uses yylloc: ..................... false
    //   uses ParseError API: ............. false
    //   uses YYERROR: .................... false
    //   uses YYRECOVERING: ............... false
    //   uses YYERROK: .................... false
    //   uses YYCLEARIN: .................. false
    //   tracks rule values: .............. true
    //   assigns rule values: ............. true
    //   uses location tracking: .......... false
    //   assigns location: ................ false
    //   uses yystack: .................... false
    //   uses yysstack: ................... false
    //   uses yysp: ....................... true
    //   uses yyrulelength: ............... false
    //   uses yyMergeLocationInfo API: .... false
    //   has error recovery: .............. false
    //   has error reporting: ............. false
    //
    // --------- END OF REPORT -----------

    trace: function no_op_trace() {},
    JisonParserError: JisonParserError$2,
    yy: {},
    options: {
        type: "lalr",
        hasPartialLrUpgradeOnConflict: true,
        errorRecoveryTokenDiscardCount: 3
    },
    symbols_: {
        "$accept": 0,
        "$end": 1,
        "(": 4,
        ")": 5,
        "*": 6,
        "+": 8,
        "?": 7,
        "ALIAS": 9,
        "EOF": 1,
        "SYMBOL": 10,
        "error": 2,
        "expression": 16,
        "handle": 13,
        "handle_list": 12,
        "production": 11,
        "rule": 14,
        "suffix": 17,
        "suffixed_expression": 15,
        "|": 3
    },
    terminals_: {
        1: "EOF",
        2: "error",
        3: "|",
        4: "(",
        5: ")",
        6: "*",
        7: "?",
        8: "+",
        9: "ALIAS",
        10: "SYMBOL"
    },
    TERROR: 2,
    EOF: 1,

    // internals: defined here so the object *structure* doesn't get modified by parse() et al,
    // thus helping JIT compilers like Chrome V8.
    originalQuoteName: null,
    originalParseError: null,
    cleanupAfterParse: null,
    constructParseErrorInfo: null,
    yyMergeLocationInfo: null,

    __reentrant_call_depth: 0, // INTERNAL USE ONLY
    __error_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup
    __error_recovery_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup

    // APIs which will be set up depending on user action code analysis:
    //yyRecovering: 0,
    //yyErrOk: 0,
    //yyClearIn: 0,

    // Helper APIs
    // -----------

    // Helper function which can be overridden by user code later on: put suitable quotes around
    // literal IDs in a description string.
    quoteName: function parser_quoteName(id_str) {
        return '"' + id_str + '"';
    },

    // Return the name of the given symbol (terminal or non-terminal) as a string, when available.
    //
    // Return NULL when the symbol is unknown to the parser.
    getSymbolName: function parser_getSymbolName(symbol) {
        if (this.terminals_[symbol]) {
            return this.terminals_[symbol];
        }

        // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.
        //
        // An example of this may be where a rule's action code contains a call like this:
        //
        //      parser.getSymbolName(#$)
        //
        // to obtain a human-readable name of the current grammar rule.
        var s = this.symbols_;
        for (var key in s) {
            if (s[key] === symbol) {
                return key;
            }
        }
        return null;
    },

    // Return a more-or-less human-readable description of the given symbol, when available,
    // or the symbol itself, serving as its own 'description' for lack of something better to serve up.
    //
    // Return NULL when the symbol is unknown to the parser.
    describeSymbol: function parser_describeSymbol(symbol) {
        if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {
            return this.terminal_descriptions_[symbol];
        } else if (symbol === this.EOF) {
            return 'end of input';
        }
        var id = this.getSymbolName(symbol);
        if (id) {
            return this.quoteName(id);
        }
        return null;
    },

    // Produce a (more or less) human-readable list of expected tokens at the point of failure.
    //
    // The produced list may contain token or token set descriptions instead of the tokens
    // themselves to help turning this output into something that easier to read by humans
    // unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,
    // expected terminals and nonterminals is produced.
    //
    // The returned list (array) will not contain any duplicate entries.
    collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {
        var TERROR = this.TERROR;
        var tokenset = [];
        var check = {};
        // Has this (error?) state been outfitted with a custom expectations description text for human consumption?
        // If so, use that one instead of the less palatable token set.
        if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {
            return [this.state_descriptions_[state]];
        }
        for (var p in this.table[state]) {
            p = +p;
            if (p !== TERROR) {
                var d = do_not_describe ? p : this.describeSymbol(p);
                if (d && !check[d]) {
                    tokenset.push(d);
                    check[d] = true; // Mark this token description as already mentioned to prevent outputting duplicate entries.
                }
            }
        }
        return tokenset;
    },
    productions_: bp$2({
        pop: u$2([11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, s$2, [17, 4]]),
        rule: u$2([2, 1, 3, 0, 1, 1, 2, 3, c$2, [8, 6], 1])
    }),
    performAction: function parser__PerformAction(yystate /* action[1] */, yysp, yyvstack) {

        /* this == yyval */

        // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!
        var yy = this.yy;
        var yyparser = yy.parser;
        var yylexer = yy.lexer;

        switch (yystate) {
            case 0:
                /*! Production::    $accept : production $end */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,-,-,-,-):
                this.$ = yyvstack[yysp - 1];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,-,-,-,-)
                break;

            case 1:
                /*! Production::    production : handle EOF */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,-,-,-,-):
                this.$ = yyvstack[yysp - 1];
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,-,-,-,-)


                return yyvstack[yysp - 1];
                break;

            case 2:
            /*! Production::    handle_list : handle */
            case 6:
                /*! Production::    rule : suffixed_expression */

                this.$ = [yyvstack[yysp]];
                break;

            case 3:
                /*! Production::    handle_list : handle_list "|" handle */

                yyvstack[yysp - 2].push(yyvstack[yysp]);
                this.$ = yyvstack[yysp - 2];
                break;

            case 4:
                /*! Production::    handle : %epsilon */

                this.$ = [];
                break;

            case 5:
            /*! Production::    handle : rule */
            case 13:
            /*! Production::    suffix : "*" */
            case 14:
            /*! Production::    suffix : "?" */
            case 15:
                /*! Production::    suffix : "+" */

                this.$ = yyvstack[yysp];
                break;

            case 7:
                /*! Production::    rule : rule suffixed_expression */

                yyvstack[yysp - 1].push(yyvstack[yysp]);
                this.$ = yyvstack[yysp - 1];
                break;

            case 8:
                /*! Production::    suffixed_expression : expression suffix ALIAS */

                this.$ = ['xalias', yyvstack[yysp - 1], yyvstack[yysp - 2], yyvstack[yysp]];
                break;

            case 9:
                /*! Production::    suffixed_expression : expression suffix */

                if (yyvstack[yysp]) {
                    this.$ = [yyvstack[yysp], yyvstack[yysp - 1]];
                } else {
                    this.$ = yyvstack[yysp - 1];
                }
                break;

            case 10:
                /*! Production::    expression : SYMBOL */

                this.$ = ['symbol', yyvstack[yysp]];
                break;

            case 11:
                /*! Production::    expression : "(" handle_list ")" */

                this.$ = ['()', yyvstack[yysp - 1]];
                break;

            case 12:
                /*! Production::    suffix : %epsilon */

                this.$ = undefined;
                break;

        }
    },
    table: bt$2({
        len: u$2([8, 1, 1, 7, 0, 10, 0, 9, 0, 0, 6, s$2, [0, 3], 2, s$2, [0, 3], 8, 0]),
        symbol: u$2([1, 4, 10, 11, s$2, [13, 4, 1], s$2, [1, 3], 3, 4, 5, 10, c$2, [9, 3], s$2, [3, 8, 1], 17, c$2, [16, 4], s$2, [12, 5, 1], c$2, [19, 4], 9, 10, 3, 5, c$2, [17, 4], c$2, [16, 4]]),
        type: u$2([s$2, [2, 3], s$2, [0, 5], 1, s$2, [2, 6], 0, 0, s$2, [2, 9], c$2, [10, 5], s$2, [0, 5], s$2, [2, 12], s$2, [0, 4]]),
        state: u$2([s$2, [1, 5, 1], 9, 5, 10, 14, 15, c$2, [8, 3], 19, c$2, [4, 3]]),
        mode: u$2([2, s$2, [1, 3], 2, 2, 1, 2, c$2, [5, 3], c$2, [7, 3], c$2, [12, 4], c$2, [13, 9], c$2, [15, 3], c$2, [5, 4]]),
        goto: u$2([4, 7, 6, 8, 5, 5, 7, 5, 6, s$2, [12, 4], 11, 12, 13, 12, 12, 4, 7, 4, 6, s$2, [9, 4], 16, 9, 18, 17, c$2, [12, 4]])
    }),
    defaultActions: {
        4: 6,
        6: 10,
        8: 1,
        9: 7,
        11: 13,
        12: 14,
        13: 15,
        15: 2,
        16: 8,
        17: 11,
        19: 3
    },
    parseError: function parseError(str, hash, ExceptionClass) {
        if (hash.recoverable) {
            if (typeof this.trace === 'function') {
                this.trace(str);
            }
            hash.destroy(); // destroy... well, *almost*!
        } else {
            if (typeof this.trace === 'function') {
                this.trace(str);
            }
            if (!ExceptionClass) {
                ExceptionClass = this.JisonParserError;
            }
            throw new ExceptionClass(str, hash);
        }
    },
    parse: function parse(input) {
        var self = this;
        var stack = new Array(128); // token stack: stores token which leads to state at the same index (column storage)
        var sstack = new Array(128); // state stack: stores states (column storage)

        var vstack = new Array(128); // semantic value stack

        var table = this.table;
        var sp = 0; // 'stack pointer': index into the stacks


        var symbol = 0;

        var TERROR = this.TERROR;
        var EOF = this.EOF;
        var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = this.options.errorRecoveryTokenDiscardCount | 0 || 3;
        var NO_ACTION = [0, 20 /* === table.length :: ensures that anyone using this new state will fail dramatically! */];

        var lexer;
        if (this.__lexer__) {
            lexer = this.__lexer__;
        } else {
            lexer = this.__lexer__ = Object.create(this.lexer);
        }

        var sharedState_yy = {
            parseError: undefined,
            quoteName: undefined,
            lexer: undefined,
            parser: undefined,
            pre_parse: undefined,
            post_parse: undefined,
            pre_lex: undefined,
            post_lex: undefined // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!
        };

        this.yyGetSharedState = function yyGetSharedState() {
            return sharedState_yy;
        };

        function shallow_copy_noclobber(dst, src) {
            for (var k in src) {
                if (typeof dst[k] === 'undefined' && Object.prototype.hasOwnProperty.call(src, k)) {
                    dst[k] = src[k];
                }
            }
        }

        // copy state
        shallow_copy_noclobber(sharedState_yy, this.yy);

        sharedState_yy.lexer = lexer;
        sharedState_yy.parser = this;

        // Does the shared state override the default `parseError` that already comes with this instance?
        if (typeof sharedState_yy.parseError === 'function') {
            this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {
                if (!ExceptionClass) {
                    ExceptionClass = this.JisonParserError;
                }
                return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);
            };
        } else {
            this.parseError = this.originalParseError;
        }

        // Does the shared state override the default `quoteName` that already comes with this instance?
        if (typeof sharedState_yy.quoteName === 'function') {
            this.quoteName = function quoteNameAlt(id_str) {
                return sharedState_yy.quoteName.call(this, id_str);
            };
        } else {
            this.quoteName = this.originalQuoteName;
        }

        // set up the cleanup function; make it an API so that external code can re-use this one in case of
        // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which
        // case this parse() API method doesn't come with a `finally { ... }` block any more!
        //
        // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
        //       or else your `sharedState`, etc. references will be *wrong*!
        this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {
            var rv;

            if (invoke_post_methods) {
                var hash;

                if (sharedState_yy.post_parse || this.post_parse) {
                    // create an error hash info instance: we re-use this API in a **non-error situation**
                    // as this one delivers all parser internals ready for access by userland code.
                    hash = this.constructParseErrorInfo(null /* no error! */, null /* no exception! */, null, false);
                }

                if (sharedState_yy.post_parse) {
                    rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);
                    if (typeof rv !== 'undefined') resultValue = rv;
                }
                if (this.post_parse) {
                    rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);
                    if (typeof rv !== 'undefined') resultValue = rv;
                }

                // cleanup:
                if (hash && hash.destroy) {
                    hash.destroy();
                }
            }

            if (this.__reentrant_call_depth > 1) return resultValue; // do not (yet) kill the sharedState when this is a reentrant run.

            // clean up the lingering lexer structures as well:
            if (lexer.cleanupAfterLex) {
                lexer.cleanupAfterLex(do_not_nuke_errorinfos);
            }

            // prevent lingering circular references from causing memory leaks:
            if (sharedState_yy) {
                sharedState_yy.lexer = undefined;
                sharedState_yy.parser = undefined;
                if (lexer.yy === sharedState_yy) {
                    lexer.yy = undefined;
                }
            }
            sharedState_yy = undefined;
            this.parseError = this.originalParseError;
            this.quoteName = this.originalQuoteName;

            // nuke the vstack[] array at least as that one will still reference obsoleted user values.
            // To be safe, we nuke the other internal stack columns as well...
            stack.length = 0; // fastest way to nuke an array without overly bothering the GC
            sstack.length = 0;

            vstack.length = 0;
            sp = 0;

            // nuke the error hash info instances created during this run.
            // Userland code must COPY any data/references
            // in the error hash instance(s) it is more permanently interested in.
            if (!do_not_nuke_errorinfos) {
                for (var i = this.__error_infos.length - 1; i >= 0; i--) {
                    var el = this.__error_infos[i];
                    if (el && typeof el.destroy === 'function') {
                        el.destroy();
                    }
                }
                this.__error_infos.length = 0;
            }

            return resultValue;
        };

        // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
        //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!
        this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {
            var pei = {
                errStr: msg,
                exception: ex,
                text: lexer.match,
                value: lexer.yytext,
                token: this.describeSymbol(symbol) || symbol,
                token_id: symbol,
                line: lexer.yylineno,

                expected: expected,
                recoverable: recoverable,
                state: state,
                action: action,
                new_state: newState,
                symbol_stack: stack,
                state_stack: sstack,
                value_stack: vstack,

                stack_pointer: sp,
                yy: sharedState_yy,
                lexer: lexer,
                parser: this,

                // and make sure the error info doesn't stay due to potential
                // ref cycle via userland code manipulations.
                // These would otherwise all be memory leak opportunities!
                //
                // Note that only array and object references are nuked as those
                // constitute the set of elements which can produce a cyclic ref.
                // The rest of the members is kept intact as they are harmless.
                destroy: function destructParseErrorInfo() {
                    // remove cyclic references added to error info:
                    // info.yy = null;
                    // info.lexer = null;
                    // info.value = null;
                    // info.value_stack = null;
                    // ...
                    var rec = !!this.recoverable;
                    for (var key in this) {
                        if (this.hasOwnProperty(key) && (typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {
                            this[key] = undefined;
                        }
                    }
                    this.recoverable = rec;
                }
            };
            // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
            this.__error_infos.push(pei);
            return pei;
        };

        function stdLex() {
            var token = lexer.lex();
            // if token isn't its numeric value, convert
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }

            return token || EOF;
        }

        function fastLex() {
            var token = lexer.fastLex();
            // if token isn't its numeric value, convert
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }

            return token || EOF;
        }

        var lex = stdLex;

        var state, action, r, t;
        var yyval = {
            $: true,
            _$: undefined,
            yy: sharedState_yy
        };
        var p;
        var yyrulelen;
        var this_production;
        var newState;
        var retval = false;

        try {
            this.__reentrant_call_depth++;

            lexer.setInput(input, sharedState_yy);

            // NOTE: we *assume* no lexer pre/post handlers are set up *after* 
            // this initial `setInput()` call: hence we can now check and decide
            // whether we'll go with the standard, slower, lex() API or the
            // `fast_lex()` one:
            if (typeof lexer.canIUse === 'function') {
                var lexerInfo = lexer.canIUse();
                if (lexerInfo.fastLex && typeof fastLex === 'function') {
                    lex = fastLex;
                }
            }

            vstack[sp] = null;
            sstack[sp] = 0;
            stack[sp] = 0;
            ++sp;

            if (this.pre_parse) {
                this.pre_parse.call(this, sharedState_yy);
            }
            if (sharedState_yy.pre_parse) {
                sharedState_yy.pre_parse.call(this, sharedState_yy);
            }

            newState = sstack[sp - 1];
            for (;;) {
                // retrieve state number from top of stack
                state = newState; // sstack[sp - 1];

                // use default actions if available
                if (this.defaultActions[state]) {
                    action = 2;
                    newState = this.defaultActions[state];
                } else {
                    // The single `==` condition below covers both these `===` comparisons in a single
                    // operation:
                    //
                    //     if (symbol === null || typeof symbol === 'undefined') ...
                    if (!symbol) {
                        symbol = lex();
                    }
                    // read action for current state and first input
                    t = table[state] && table[state][symbol] || NO_ACTION;
                    newState = t[1];
                    action = t[0];

                    // handle parse error
                    if (!action) {
                        var errStr;
                        var errSymbolDescr = this.describeSymbol(symbol) || symbol;
                        var expected = this.collect_expected_token_set(state);

                        // Report error
                        if (typeof lexer.yylineno === 'number') {
                            errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';
                        } else {
                            errStr = 'Parse error: ';
                        }
                        if (typeof lexer.showPosition === 'function') {
                            errStr += '\n' + lexer.showPosition(79 - 10, 10) + '\n';
                        }
                        if (expected.length) {
                            errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;
                        } else {
                            errStr += 'Unexpected ' + errSymbolDescr;
                        }
                        // we cannot recover from the error!
                        p = this.constructParseErrorInfo(errStr, null, expected, false);
                        r = this.parseError(p.errStr, p, this.JisonParserError);
                        if (typeof r !== 'undefined') {
                            retval = r;
                        }
                        break;
                    }
                }

                switch (action) {
                    // catch misc. parse failures:
                    default:
                        // this shouldn't happen, unless resolve defaults are off
                        if (action instanceof Array) {
                            p = this.constructParseErrorInfo('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, null, null, false);
                            r = this.parseError(p.errStr, p, this.JisonParserError);
                            if (typeof r !== 'undefined') {
                                retval = r;
                            }
                            break;
                        }
                        // Another case of better safe than sorry: in case state transitions come out of another error recovery process
                        // or a buggy LUT (LookUp Table):
                        p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);
                        r = this.parseError(p.errStr, p, this.JisonParserError);
                        if (typeof r !== 'undefined') {
                            retval = r;
                        }
                        break;

                    // shift:
                    case 1:
                        stack[sp] = symbol;
                        vstack[sp] = lexer.yytext;

                        sstack[sp] = newState; // push state

                        ++sp;
                        symbol = 0;

                        // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:


                        continue;

                    // reduce:
                    case 2:

                        this_production = this.productions_[newState - 1]; // `this.productions_[]` is zero-based indexed while states start from 1 upwards...
                        yyrulelen = this_production[1];

                        r = this.performAction.call(yyval, newState, sp - 1, vstack);

                        if (typeof r !== 'undefined') {
                            retval = r;
                            break;
                        }

                        // pop off stack
                        sp -= yyrulelen;

                        // don't overwrite the `symbol` variable: use a local var to speed things up:
                        var ntsymbol = this_production[0]; // push nonterminal (reduce)
                        stack[sp] = ntsymbol;
                        vstack[sp] = yyval.$;

                        // goto new state = table[STATE][NONTERMINAL]
                        newState = table[sstack[sp - 1]][ntsymbol];
                        sstack[sp] = newState;
                        ++sp;

                        continue;

                    // accept:
                    case 3:
                        if (sp !== -2) {
                            retval = true;
                            // Return the `$accept` rule's `$$` result, if available.
                            //
                            // Also note that JISON always adds this top-most `$accept` rule (with implicit,
                            // default, action):
                            //
                            //     $accept: <startSymbol> $end
                            //                  %{ $$ = $1; @$ = @1; %}
                            //
                            // which, combined with the parse kernel's `$accept` state behaviour coded below,
                            // will produce the `$$` value output of the <startSymbol> rule as the parse result,
                            // IFF that result is *not* `undefined`. (See also the parser kernel code.)
                            //
                            // In code:
                            //
                            //                  %{
                            //                      @$ = @1;            // if location tracking support is included
                            //                      if (typeof $1 !== 'undefined')
                            //                          return $1;
                            //                      else
                            //                          return true;           // the default parse result if the rule actions don't produce anything
                            //                  %}
                            sp--;
                            if (typeof vstack[sp] !== 'undefined') {
                                retval = vstack[sp];
                            }
                        }
                        break;
                }

                // break out of loop: we accept or fail with error
                break;
            }
        } catch (ex) {
            // report exceptions through the parseError callback too, but keep the exception intact
            // if it is a known parser or lexer error which has been thrown by parseError() already:
            if (ex instanceof this.JisonParserError) {
                throw ex;
            } else if (lexer && typeof lexer.JisonLexerError === 'function' && ex instanceof lexer.JisonLexerError) {
                throw ex;
            } else {
                p = this.constructParseErrorInfo('Parsing aborted due to exception.', ex, null, false);
                retval = false;
                r = this.parseError(p.errStr, p, this.JisonParserError);
                if (typeof r !== 'undefined') {
                    retval = r;
                }
            }
        } finally {
            retval = this.cleanupAfterParse(retval, true, true);
            this.__reentrant_call_depth--;
        } // /finally

        return retval;
    }
};
parser$3.originalParseError = parser$3.parseError;
parser$3.originalQuoteName = parser$3.quoteName;
/* lexer generated by jison-lex 0.6.1-210 */

/*
 * Returns a Lexer object of the following structure:
 *
 *  Lexer: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a direct reference!
 *
 *               This "shared context" object was passed to the lexer by way of 
 *               the `lexer.setInput(str, yy)` API before you may use it.
 *
 *               This "shared context" object is passed to the lexer action code in `performAction()`
 *               so userland code in the lexer actions may communicate with the outside world 
 *               and/or other lexer rules' actions in more or less complex ways.
 *
 *  }
 *
 *  Lexer.prototype: {
 *    EOF: 1,
 *    ERROR: 2,
 *
 *    yy:        The overall "shared context" object reference.
 *
 *    JisonLexerError: function(msg, hash),
 *
 *    performAction: function lexer__performAction(yy, yyrulenumber, YY_START),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `lexer` instance. 
 *                               `yy_` is an alias for `this` lexer instance reference used internally.
 *
 *               - `yy`      : a reference to the `yy` "shared state" object which was passed to the lexer
 *                             by way of the `lexer.setInput(str, yy)` API before.
 *
 *                             Note:
 *                             The extra arguments you specified in the `%parse-param` statement in your
 *                             **parser** grammar definition file are passed to the lexer via this object
 *                             reference as member variables.
 *
 *               - `yyrulenumber`   : index of the matched lexer rule (regex), used internally.
 *
 *               - `YY_START`: the current lexer "start condition" state.
 *
 *    parseError: function(str, hash, ExceptionClass),
 *
 *    constructLexErrorInfo: function(error_message, is_recoverable),
 *               Helper function.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this lexer kernel in many places; example usage:
 *
 *                   var infoObj = lexer.constructParseErrorInfo('fail!', true);
 *                   var retVal = lexer.parseError(infoObj.errStr, infoObj, lexer.JisonLexerError);
 *
 *    options: { ... lexer %options ... },
 *
 *    lex: function(),
 *               Produce one token of lexed input, which was passed in earlier via the `lexer.setInput()` API.
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of the **lexer** grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Lexer's additional `args...` parameters (via lexer's `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the **parser** or the jison run-time; 
 *               when such a collision is detected an exception is thrown to prevent the generated run-time 
 *               from silently accepting this confusing and potentially hazardous situation! 
 *
 *    cleanupAfterLex: function(do_not_nuke_errorinfos),
 *               Helper function.
 *
 *               This helper API is invoked when the **parse process** has completed: it is the responsibility
 *               of the **parser** (or the calling userland code) to invoke this method once cleanup is desired. 
 *
 *               This helper may be invoked by user code to ensure the internal lexer gets properly garbage collected.
 *
 *    setInput: function(input, [yy]),
 *
 *
 *    input: function(),
 *
 *
 *    unput: function(str),
 *
 *
 *    more: function(),
 *
 *
 *    reject: function(),
 *
 *
 *    less: function(n),
 *
 *
 *    pastInput: function(n),
 *
 *
 *    upcomingInput: function(n),
 *
 *
 *    showPosition: function(),
 *
 *
 *    test_match: function(regex_match_array, rule_index),
 *
 *
 *    next: function(),
 *
 *
 *    begin: function(condition),
 *
 *
 *    pushState: function(condition),
 *
 *
 *    popState: function(),
 *
 *
 *    topState: function(),
 *
 *
 *    _currentRules: function(),
 *
 *
 *    stateStackSize: function(),
 *
 *
 *    performAction: function(yy, yy_, yyrulenumber, YY_START),
 *
 *
 *    rules: [...],
 *
 *
 *    conditions: {associative list: name ==> set},
 *  }
 *
 *
 *  token location info (`yylloc`): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *  }
 *
 * while `this` will reference the current lexer instance.
 *
 * When `parseError` is invoked by the lexer, the default implementation will
 * attempt to invoke `yy.parser.parseError()`; when this callback is not provided
 * it will try to invoke `yy.parseError()` instead. When that callback is also not
 * provided, a `JisonLexerError` exception will be thrown containing the error
 * message and `hash`, as constructed by the `constructLexErrorInfo()` API.
 *
 * Note that the lexer's `JisonLexerError` error class is passed via the
 * `ExceptionClass` argument, which is invoked to construct the exception
 * instance to be thrown, so technically `parseError` will throw the object
 * produced by the `new ExceptionClass(str, hash)` JavaScript expression.
 *
 * ---
 *
 * You can specify lexer options by setting / modifying the `.options` object of your Lexer instance.
 * These options are available:
 *
 * (Options are permanent.)
 *  
 *  yy: {
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *  }
 *
 *  lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 * WARNING: the next set of options are not meant to be changed. They echo the abilities of
 * the lexer as per when it was compiled!
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this %option has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */

var lexer$2 = function () {
    /**
     * See also:
     * http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
     * but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
     * with userland code which might access the derived class in a 'classic' way.
     *
     * @public
     * @constructor
     * @nocollapse
     */
    function JisonLexerError(msg, hash) {
        Object.defineProperty(this, 'name', {
            enumerable: false,
            writable: false,
            value: 'JisonLexerError'
        });

        if (msg == null) msg = '???';

        Object.defineProperty(this, 'message', {
            enumerable: false,
            writable: true,
            value: msg
        });

        this.hash = hash;
        var stacktrace;

        if (hash && hash.exception instanceof Error) {
            var ex2 = hash.exception;
            this.message = ex2.message || msg;
            stacktrace = ex2.stack;
        }

        if (!stacktrace) {
            if (Error.hasOwnProperty('captureStackTrace')) {
                // V8
                Error.captureStackTrace(this, this.constructor);
            } else {
                stacktrace = new Error(msg).stack;
            }
        }

        if (stacktrace) {
            Object.defineProperty(this, 'stack', {
                enumerable: false,
                writable: false,
                value: stacktrace
            });
        }
    }

    if (typeof Object.setPrototypeOf === 'function') {
        Object.setPrototypeOf(JisonLexerError.prototype, Error.prototype);
    } else {
        JisonLexerError.prototype = Object.create(Error.prototype);
    }

    JisonLexerError.prototype.constructor = JisonLexerError;
    JisonLexerError.prototype.name = 'JisonLexerError';

    var lexer = {

        // Code Generator Information Report
        // ---------------------------------
        //
        // Options:
        //
        //   backtracking: .................... false
        //   location.ranges: ................. true
        //   location line+column tracking: ... true
        //
        //
        // Forwarded Parser Analysis flags:
        //
        //   uses yyleng: ..................... false
        //   uses yylineno: ................... false
        //   uses yytext: ..................... false
        //   uses yylloc: ..................... false
        //   uses lexer values: ............... true / true
        //   location tracking: ............... false
        //   location assignment: ............. false
        //
        //
        // Lexer Analysis flags:
        //
        //   uses yyleng: ..................... ???
        //   uses yylineno: ................... ???
        //   uses yytext: ..................... ???
        //   uses yylloc: ..................... ???
        //   uses ParseError API: ............. ???
        //   uses yyerror: .................... ???
        //   uses location tracking & editing:  ???
        //   uses more() API: ................. ???
        //   uses unput() API: ................ ???
        //   uses reject() API: ............... ???
        //   uses less() API: ................. ???
        //   uses display APIs pastInput(), upcomingInput(), showPosition():
        //        ............................. ???
        //   uses describeYYLLOC() API: ....... ???
        //
        // --------- END OF REPORT -----------

        EOF: 1,
        ERROR: 2,

        // JisonLexerError: JisonLexerError,        /// <-- injected by the code generator

        // options: {},                             /// <-- injected by the code generator

        // yy: ...,                                 /// <-- injected by setInput()

        __currentRuleSet__: null, /// INTERNAL USE ONLY: internal rule set cache for the current lexer state  

        __error_infos: [], /// INTERNAL USE ONLY: the set of lexErrorInfo objects created since the last cleanup  
        __decompressed: false, /// INTERNAL USE ONLY: mark whether the lexer instance has been 'unfolded' completely and is now ready for use  
        done: false, /// INTERNAL USE ONLY  
        _backtrack: false, /// INTERNAL USE ONLY  
        _input: '', /// INTERNAL USE ONLY  
        _more: false, /// INTERNAL USE ONLY  
        _signaled_error_token: false, /// INTERNAL USE ONLY  
        conditionStack: [], /// INTERNAL USE ONLY; managed via `pushState()`, `popState()`, `topState()` and `stateStackSize()`  
        match: '', /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction. `match` is identical to `yytext` except that this one still contains the matched input string after `lexer.performAction()` has been invoked, where userland code MAY have changed/replaced the `yytext` value entirely!  
        matched: '', /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks entire input which has been matched so far  
        matches: false, /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks RE match result for last (successful) match attempt  
        yytext: '', /// ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction; this value is transferred to the parser as the 'token value' when the parser consumes the lexer token produced through a call to the `lex()` API.  
        offset: 0, /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks the 'cursor position' in the input string, i.e. the number of characters matched so far  
        yyleng: 0, /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: length of matched input for the token under construction (`yytext`)  
        yylineno: 0, /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: 'line number' at which the token under construction is located  
        yylloc: null, /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks location info (lines + columns) for the token under construction  

        /**
         * INTERNAL USE: construct a suitable error info hash object instance for `parseError`.
         * 
         * @public
         * @this {RegExpLexer}
         */
        constructLexErrorInfo: function lexer_constructLexErrorInfo(msg, recoverable, show_input_position) {
            msg = '' + msg;

            // heuristic to determine if the error message already contains a (partial) source code dump
            // as produced by either `showPosition()` or `prettyPrintRange()`:
            if (show_input_position == undefined) {
                show_input_position = !(msg.indexOf('\n') > 0 && msg.indexOf('^') > 0);
            }

            if (this.yylloc && show_input_position) {
                if (typeof this.prettyPrintRange === 'function') {
                    var pretty_src = this.prettyPrintRange(this.yylloc);

                    if (!/\n\s*$/.test(msg)) {
                        msg += '\n';
                    }

                    msg += '\n  Erroneous area:\n' + this.prettyPrintRange(this.yylloc);
                } else if (typeof this.showPosition === 'function') {
                    var pos_str = this.showPosition();

                    if (pos_str) {
                        if (msg.length && msg[msg.length - 1] !== '\n' && pos_str[0] !== '\n') {
                            msg += '\n' + pos_str;
                        } else {
                            msg += pos_str;
                        }
                    }
                }
            }

            /** @constructor */
            var pei = {
                errStr: msg,
                recoverable: !!recoverable,
                text: this.match, // This one MAY be empty; userland code should use the `upcomingInput` API to obtain more text which follows the 'lexer cursor position'...  
                token: null,
                line: this.yylineno,
                loc: this.yylloc,
                yy: this.yy,
                lexer: this,

                /**
                 * and make sure the error info doesn't stay due to potential
                 * ref cycle via userland code manipulations.
                 * These would otherwise all be memory leak opportunities!
                 * 
                 * Note that only array and object references are nuked as those
                 * constitute the set of elements which can produce a cyclic ref.
                 * The rest of the members is kept intact as they are harmless.
                 * 
                 * @public
                 * @this {LexErrorInfo}
                 */
                destroy: function destructLexErrorInfo() {
                    // remove cyclic references added to error info:
                    // info.yy = null;
                    // info.lexer = null;
                    // ...
                    var rec = !!this.recoverable;

                    for (var key in this) {
                        if (this.hasOwnProperty(key) && (typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {
                            this[key] = undefined;
                        }
                    }

                    this.recoverable = rec;
                }
            };

            // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
            this.__error_infos.push(pei);

            return pei;
        },

        /**
         * handler which is invoked when a lexer error occurs.
         * 
         * @public
         * @this {RegExpLexer}
         */
        parseError: function lexer_parseError(str, hash, ExceptionClass) {
            if (!ExceptionClass) {
                ExceptionClass = this.JisonLexerError;
            }

            if (this.yy) {
                if (this.yy.parser && typeof this.yy.parser.parseError === 'function') {
                    return this.yy.parser.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
                } else if (typeof this.yy.parseError === 'function') {
                    return this.yy.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
                }
            }

            throw new ExceptionClass(str, hash);
        },

        /**
         * method which implements `yyerror(str, ...args)` functionality for use inside lexer actions.
         * 
         * @public
         * @this {RegExpLexer}
         */
        yyerror: function yyError(str /*, ...args */) {
            var lineno_msg = '';

            if (this.yylloc) {
                lineno_msg = ' on line ' + (this.yylineno + 1);
            }

            var p = this.constructLexErrorInfo('Lexical error' + lineno_msg + ': ' + str, this.options.lexerErrorsAreRecoverable);

            // Add any extra args to the hash under the name `extra_error_attributes`:
            var args = Array.prototype.slice.call(arguments, 1);

            if (args.length) {
                p.extra_error_attributes = args;
            }

            return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
        },

        /**
         * final cleanup function for when we have completed lexing the input;
         * make it an API so that external code can use this one once userland
         * code has decided it's time to destroy any lingering lexer error
         * hash object instances and the like: this function helps to clean
         * up these constructs, which *may* carry cyclic references which would
         * otherwise prevent the instances from being properly and timely
         * garbage-collected, i.e. this function helps prevent memory leaks!
         * 
         * @public
         * @this {RegExpLexer}
         */
        cleanupAfterLex: function lexer_cleanupAfterLex(do_not_nuke_errorinfos) {
            // prevent lingering circular references from causing memory leaks:
            this.setInput('', {});

            // nuke the error hash info instances created during this run.
            // Userland code must COPY any data/references
            // in the error hash instance(s) it is more permanently interested in.
            if (!do_not_nuke_errorinfos) {
                for (var i = this.__error_infos.length - 1; i >= 0; i--) {
                    var el = this.__error_infos[i];

                    if (el && typeof el.destroy === 'function') {
                        el.destroy();
                    }
                }

                this.__error_infos.length = 0;
            }

            return this;
        },

        /**
         * clear the lexer token context; intended for internal use only
         * 
         * @public
         * @this {RegExpLexer}
         */
        clear: function lexer_clear() {
            this.yytext = '';
            this.yyleng = 0;
            this.match = '';

            // - DO NOT reset `this.matched`
            this.matches = false;

            this._more = false;
            this._backtrack = false;
            var col = this.yylloc ? this.yylloc.last_column : 0;

            this.yylloc = {
                first_line: this.yylineno + 1,
                first_column: col,
                last_line: this.yylineno + 1,
                last_column: col,
                range: [this.offset, this.offset]
            };
        },

        /**
         * resets the lexer, sets new input
         * 
         * @public
         * @this {RegExpLexer}
         */
        setInput: function lexer_setInput(input, yy) {
            this.yy = yy || this.yy || {};

            // also check if we've fully initialized the lexer instance,
            // including expansion work to be done to go from a loaded
            // lexer to a usable lexer:
            if (!this.__decompressed) {
                // step 1: decompress the regex list:
                var rules = this.rules;

                for (var i = 0, len = rules.length; i < len; i++) {
                    var rule_re = rules[i];

                    // compression: is the RE an xref to another RE slot in the rules[] table?
                    if (typeof rule_re === 'number') {
                        rules[i] = rules[rule_re];
                    }
                }

                // step 2: unfold the conditions[] set to make these ready for use:
                var conditions = this.conditions;

                for (var k in conditions) {
                    var spec = conditions[k];
                    var rule_ids = spec.rules;
                    var len = rule_ids.length;
                    var rule_regexes = new Array(len + 1); // slot 0 is unused; we use a 1-based index approach here to keep the hottest code in `lexer_next()` fast and simple! 
                    var rule_new_ids = new Array(len + 1);

                    for (var i = 0; i < len; i++) {
                        var idx = rule_ids[i];
                        var rule_re = rules[idx];
                        rule_regexes[i + 1] = rule_re;
                        rule_new_ids[i + 1] = idx;
                    }

                    spec.rules = rule_new_ids;
                    spec.__rule_regexes = rule_regexes;
                    spec.__rule_count = len;
                }

                this.__decompressed = true;
            }

            this._input = input || '';
            this.clear();
            this._signaled_error_token = false;
            this.done = false;
            this.yylineno = 0;
            this.matched = '';
            this.conditionStack = ['INITIAL'];
            this.__currentRuleSet__ = null;

            this.yylloc = {
                first_line: 1,
                first_column: 0,
                last_line: 1,
                last_column: 0,
                range: [0, 0]
            };

            this.offset = 0;
            return this;
        },

        /**
         * edit the remaining input via user-specified callback.
         * This can be used to forward-adjust the input-to-parse, 
         * e.g. inserting macro expansions and alike in the
         * input which has yet to be lexed.
         * The behaviour of this API contrasts the `unput()` et al
         * APIs as those act on the *consumed* input, while this
         * one allows one to manipulate the future, without impacting
         * the current `yyloc` cursor location or any history. 
         * 
         * Use this API to help implement C-preprocessor-like
         * `#include` statements, etc.
         * 
         * The provided callback must be synchronous and is
         * expected to return the edited input (string).
         *
         * The `cpsArg` argument value is passed to the callback
         * as-is.
         *
         * `callback` interface: 
         * `function callback(input, cpsArg)`
         * 
         * - `input` will carry the remaining-input-to-lex string
         *   from the lexer.
         * - `cpsArg` is `cpsArg` passed into this API.
         * 
         * The `this` reference for the callback will be set to
         * reference this lexer instance so that userland code
         * in the callback can easily and quickly access any lexer
         * API. 
         *
         * When the callback returns a non-string-type falsey value,
         * we assume the callback did not edit the input and we
         * will using the input as-is.
         *
         * When the callback returns a non-string-type value, it
         * is converted to a string for lexing via the `"" + retval`
         * operation. (See also why: http://2ality.com/2012/03/converting-to-string.html 
         * -- that way any returned object's `toValue()` and `toString()`
         * methods will be invoked in a proper/desirable order.)
         * 
         * @public
         * @this {RegExpLexer}
         */
        editRemainingInput: function lexer_editRemainingInput(callback, cpsArg) {
            var rv = callback.call(this, this._input, cpsArg);

            if (typeof rv !== 'string') {
                if (rv) {
                    this._input = '' + rv;
                }
                // else: keep `this._input` as is.  
            } else {
                this._input = rv;
            }

            return this;
        },

        /**
         * consumes and returns one char from the input
         * 
         * @public
         * @this {RegExpLexer}
         */
        input: function lexer_input() {
            if (!this._input) {
                //this.done = true;    -- don't set `done` as we want the lex()/next() API to be able to produce one custom EOF token match after this anyhow. (lexer can match special <<EOF>> tokens and perform user action code for a <<EOF>> match, but only does so *once*)
                return null;
            }

            var ch = this._input[0];
            this.yytext += ch;
            this.yyleng++;
            this.offset++;
            this.match += ch;
            this.matched += ch;

            // Count the linenumber up when we hit the LF (or a stand-alone CR).
            // On CRLF, the linenumber is incremented when you fetch the CR or the CRLF combo
            // and we advance immediately past the LF as well, returning both together as if
            // it was all a single 'character' only.
            var slice_len = 1;

            var lines = false;

            if (ch === '\n') {
                lines = true;
            } else if (ch === '\r') {
                lines = true;
                var ch2 = this._input[1];

                if (ch2 === '\n') {
                    slice_len++;
                    ch += ch2;
                    this.yytext += ch2;
                    this.yyleng++;
                    this.offset++;
                    this.match += ch2;
                    this.matched += ch2;
                    this.yylloc.range[1]++;
                }
            }

            if (lines) {
                this.yylineno++;
                this.yylloc.last_line++;
                this.yylloc.last_column = 0;
            } else {
                this.yylloc.last_column++;
            }

            this.yylloc.range[1]++;
            this._input = this._input.slice(slice_len);
            return ch;
        },

        /**
         * unshifts one char (or an entire string) into the input
         * 
         * @public
         * @this {RegExpLexer}
         */
        unput: function lexer_unput(ch) {
            var len = ch.length;
            var lines = ch.split(/(?:\r\n?|\n)/g);
            this._input = ch + this._input;
            this.yytext = this.yytext.substr(0, this.yytext.length - len);
            this.yyleng = this.yytext.length;
            this.offset -= len;
            this.match = this.match.substr(0, this.match.length - len);
            this.matched = this.matched.substr(0, this.matched.length - len);

            if (lines.length > 1) {
                this.yylineno -= lines.length - 1;
                this.yylloc.last_line = this.yylineno + 1;

                // Get last entirely matched line into the `pre_lines[]` array's
                // last index slot; we don't mind when other previously 
                // matched lines end up in the array too. 
                var pre = this.match;

                var pre_lines = pre.split(/(?:\r\n?|\n)/g);

                if (pre_lines.length === 1) {
                    pre = this.matched;
                    pre_lines = pre.split(/(?:\r\n?|\n)/g);
                }

                this.yylloc.last_column = pre_lines[pre_lines.length - 1].length;
            } else {
                this.yylloc.last_column -= len;
            }

            this.yylloc.range[1] = this.yylloc.range[0] + this.yyleng;
            this.done = false;
            return this;
        },

        /**
         * cache matched text and append it on next action
         * 
         * @public
         * @this {RegExpLexer}
         */
        more: function lexer_more() {
            this._more = true;
            return this;
        },

        /**
         * signal the lexer that this rule fails to match the input, so the
         * next matching rule (regex) should be tested instead.
         * 
         * @public
         * @this {RegExpLexer}
         */
        reject: function lexer_reject() {
            if (this.options.backtrack_lexer) {
                this._backtrack = true;
            } else {
                // when the `parseError()` call returns, we MUST ensure that the error is registered.
                // We accomplish this by signaling an 'error' token to be produced for the current
                // `.lex()` run.
                var lineno_msg = '';

                if (this.yylloc) {
                    lineno_msg = ' on line ' + (this.yylineno + 1);
                }

                var p = this.constructLexErrorInfo('Lexical error' + lineno_msg + ': You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).', false);

                this._signaled_error_token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
            }

            return this;
        },

        /**
         * retain first n characters of the match
         * 
         * @public
         * @this {RegExpLexer}
         */
        less: function lexer_less(n) {
            return this.unput(this.match.slice(n));
        },

        /**
         * return (part of the) already matched input, i.e. for error
         * messages.
         * 
         * Limit the returned string length to `maxSize` (default: 20).
         * 
         * Limit the returned string to the `maxLines` number of lines of
         * input (default: 1).
         * 
         * Negative limit values equal *unlimited*.
         * 
         * @public
         * @this {RegExpLexer}
         */
        pastInput: function lexer_pastInput(maxSize, maxLines) {
            var past = this.matched.substring(0, this.matched.length - this.match.length);

            if (maxSize < 0) maxSize = past.length;else if (!maxSize) maxSize = 20;

            if (maxLines < 0) maxLines = past.length; // can't ever have more input lines than this! 
            else if (!maxLines) maxLines = 1;

            // `substr` anticipation: treat \r\n as a single character and take a little
            // more than necessary so that we can still properly check against maxSize
            // after we've transformed and limited the newLines in here:
            past = past.substr(-maxSize * 2 - 2);

            // now that we have a significantly reduced string to process, transform the newlines
            // and chop them, then limit them:
            var a = past.replace(/\r\n|\r/g, '\n').split('\n');

            a = a.slice(-maxLines);
            past = a.join('\n');

            // When, after limiting to maxLines, we still have too much to return,
            // do add an ellipsis prefix...
            if (past.length > maxSize) {
                past = '...' + past.substr(-maxSize);
            }

            return past;
        },

        /**
         * return (part of the) upcoming input, i.e. for error messages.
         * 
         * Limit the returned string length to `maxSize` (default: 20).
         * 
         * Limit the returned string to the `maxLines` number of lines of input (default: 1).
         * 
         * Negative limit values equal *unlimited*.
         *
         * > ### NOTE ###
         * >
         * > *"upcoming input"* is defined as the whole of the both
         * > the *currently lexed* input, together with any remaining input
         * > following that. *"currently lexed"* input is the input 
         * > already recognized by the lexer but not yet returned with
         * > the lexer token. This happens when you are invoking this API
         * > from inside any lexer rule action code block. 
         * >
         * 
         * @public
         * @this {RegExpLexer}
         */
        upcomingInput: function lexer_upcomingInput(maxSize, maxLines) {
            var next = this.match;

            if (maxSize < 0) maxSize = next.length + this._input.length;else if (!maxSize) maxSize = 20;

            if (maxLines < 0) maxLines = maxSize; // can't ever have more input lines than this! 
            else if (!maxLines) maxLines = 1;

            // `substring` anticipation: treat \r\n as a single character and take a little
            // more than necessary so that we can still properly check against maxSize
            // after we've transformed and limited the newLines in here:
            if (next.length < maxSize * 2 + 2) {
                next += this._input.substring(0, maxSize * 2 + 2); // substring is faster on Chrome/V8 
            }

            // now that we have a significantly reduced string to process, transform the newlines
            // and chop them, then limit them:
            var a = next.replace(/\r\n|\r/g, '\n').split('\n');

            a = a.slice(0, maxLines);
            next = a.join('\n');

            // When, after limiting to maxLines, we still have too much to return,
            // do add an ellipsis postfix...
            if (next.length > maxSize) {
                next = next.substring(0, maxSize) + '...';
            }

            return next;
        },

        /**
         * return a string which displays the character position where the
         * lexing error occurred, i.e. for error messages
         * 
         * @public
         * @this {RegExpLexer}
         */
        showPosition: function lexer_showPosition(maxPrefix, maxPostfix) {
            var pre = this.pastInput(maxPrefix).replace(/\s/g, ' ');
            var c = new Array(pre.length + 1).join('-');
            return pre + this.upcomingInput(maxPostfix).replace(/\s/g, ' ') + '\n' + c + '^';
        },

        /**
         * return an YYLLOC info object derived off the given context (actual, preceding, following, current).
         * Use this method when the given `actual` location is not guaranteed to exist (i.e. when
         * it MAY be NULL) and you MUST have a valid location info object anyway:
         * then we take the given context of the `preceding` and `following` locations, IFF those are available,
         * and reconstruct the `actual` location info from those.
         * If this fails, the heuristic is to take the `current` location, IFF available.
         * If this fails as well, we assume the sought location is at/around the current lexer position
         * and then produce that one as a response. DO NOTE that these heuristic/derived location info
         * values MAY be inaccurate!
         *
         * NOTE: `deriveLocationInfo()` ALWAYS produces a location info object *copy* of `actual`, not just
         * a *reference* hence all input location objects can be assumed to be 'constant' (function has no side-effects).
         * 
         * @public
         * @this {RegExpLexer}
         */
        deriveLocationInfo: function lexer_deriveYYLLOC(actual, preceding, following, current) {
            var loc = {
                first_line: 1,
                first_column: 0,
                last_line: 1,
                last_column: 0,
                range: [0, 0]
            };

            if (actual) {
                loc.first_line = actual.first_line | 0;
                loc.last_line = actual.last_line | 0;
                loc.first_column = actual.first_column | 0;
                loc.last_column = actual.last_column | 0;

                if (actual.range) {
                    loc.range[0] = actual.range[0] | 0;
                    loc.range[1] = actual.range[1] | 0;
                }
            }

            if (loc.first_line <= 0 || loc.last_line < loc.first_line) {
                // plan B: heuristic using preceding and following:
                if (loc.first_line <= 0 && preceding) {
                    loc.first_line = preceding.last_line | 0;
                    loc.first_column = preceding.last_column | 0;

                    if (preceding.range) {
                        loc.range[0] = actual.range[1] | 0;
                    }
                }

                if ((loc.last_line <= 0 || loc.last_line < loc.first_line) && following) {
                    loc.last_line = following.first_line | 0;
                    loc.last_column = following.first_column | 0;

                    if (following.range) {
                        loc.range[1] = actual.range[0] | 0;
                    }
                }

                // plan C?: see if the 'current' location is useful/sane too:
                if (loc.first_line <= 0 && current && (loc.last_line <= 0 || current.last_line <= loc.last_line)) {
                    loc.first_line = current.first_line | 0;
                    loc.first_column = current.first_column | 0;

                    if (current.range) {
                        loc.range[0] = current.range[0] | 0;
                    }
                }

                if (loc.last_line <= 0 && current && (loc.first_line <= 0 || current.first_line >= loc.first_line)) {
                    loc.last_line = current.last_line | 0;
                    loc.last_column = current.last_column | 0;

                    if (current.range) {
                        loc.range[1] = current.range[1] | 0;
                    }
                }
            }

            // sanitize: fix last_line BEFORE we fix first_line as we use the 'raw' value of the latter
            // or plan D heuristics to produce a 'sensible' last_line value:
            if (loc.last_line <= 0) {
                if (loc.first_line <= 0) {
                    loc.first_line = this.yylloc.first_line;
                    loc.last_line = this.yylloc.last_line;
                    loc.first_column = this.yylloc.first_column;
                    loc.last_column = this.yylloc.last_column;
                    loc.range[0] = this.yylloc.range[0];
                    loc.range[1] = this.yylloc.range[1];
                } else {
                    loc.last_line = this.yylloc.last_line;
                    loc.last_column = this.yylloc.last_column;
                    loc.range[1] = this.yylloc.range[1];
                }
            }

            if (loc.first_line <= 0) {
                loc.first_line = loc.last_line;
                loc.first_column = 0; // loc.last_column; 
                loc.range[1] = loc.range[0];
            }

            if (loc.first_column < 0) {
                loc.first_column = 0;
            }

            if (loc.last_column < 0) {
                loc.last_column = loc.first_column > 0 ? loc.first_column : 80;
            }

            return loc;
        },

        /**
         * return a string which displays the lines & columns of input which are referenced 
         * by the given location info range, plus a few lines of context.
         * 
         * This function pretty-prints the indicated section of the input, with line numbers 
         * and everything!
         * 
         * This function is very useful to provide highly readable error reports, while
         * the location range may be specified in various flexible ways:
         * 
         * - `loc` is the location info object which references the area which should be
         *   displayed and 'marked up': these lines & columns of text are marked up by `^`
         *   characters below each character in the entire input range.
         * 
         * - `context_loc` is the *optional* location info object which instructs this
         *   pretty-printer how much *leading* context should be displayed alongside
         *   the area referenced by `loc`. This can help provide context for the displayed
         *   error, etc.
         * 
         *   When this location info is not provided, a default context of 3 lines is
         *   used.
         * 
         * - `context_loc2` is another *optional* location info object, which serves
         *   a similar purpose to `context_loc`: it specifies the amount of *trailing*
         *   context lines to display in the pretty-print output.
         * 
         *   When this location info is not provided, a default context of 1 line only is
         *   used.
         * 
         * Special Notes:
         * 
         * - when the `loc`-indicated range is very large (about 5 lines or more), then
         *   only the first and last few lines of this block are printed while a
         *   `...continued...` message will be printed between them.
         * 
         *   This serves the purpose of not printing a huge amount of text when the `loc`
         *   range happens to be huge: this way a manageable & readable output results
         *   for arbitrary large ranges.
         * 
         * - this function can display lines of input which whave not yet been lexed.
         *   `prettyPrintRange()` can access the entire input!
         * 
         * @public
         * @this {RegExpLexer}
         */
        prettyPrintRange: function lexer_prettyPrintRange(loc, context_loc, context_loc2) {
            loc = this.deriveLocationInfo(loc, context_loc, context_loc2);
            var CONTEXT = 3;
            var CONTEXT_TAIL = 1;
            var MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT = 2;
            var input = this.matched + this._input;
            var lines = input.split('\n');
            var l0 = Math.max(1, context_loc ? context_loc.first_line : loc.first_line - CONTEXT);
            var l1 = Math.max(1, context_loc2 ? context_loc2.last_line : loc.last_line + CONTEXT_TAIL);
            var lineno_display_width = 1 + Math.log10(l1 | 1) | 0;
            var ws_prefix = new Array(lineno_display_width).join(' ');
            var nonempty_line_indexes = [];

            var rv = lines.slice(l0 - 1, l1 + 1).map(function injectLineNumber(line, index) {
                var lno = index + l0;
                var lno_pfx = (ws_prefix + lno).substr(-lineno_display_width);
                var rv = lno_pfx + ': ' + line;
                var errpfx = new Array(lineno_display_width + 1).join('^');
                var offset = 2 + 1;
                var len = 0;

                if (lno === loc.first_line) {
                    offset += loc.first_column;

                    len = Math.max(2, (lno === loc.last_line ? loc.last_column : line.length) - loc.first_column + 1);
                } else if (lno === loc.last_line) {
                    len = Math.max(2, loc.last_column + 1);
                } else if (lno > loc.first_line && lno < loc.last_line) {
                    len = Math.max(2, line.length + 1);
                }

                if (len) {
                    var lead = new Array(offset).join('.');
                    var mark = new Array(len).join('^');
                    rv += '\n' + errpfx + lead + mark;

                    if (line.trim().length > 0) {
                        nonempty_line_indexes.push(index);
                    }
                }

                rv = rv.replace(/\t/g, ' ');
                return rv;
            });

            // now make sure we don't print an overly large amount of error area: limit it 
            // to the top and bottom line count:
            if (nonempty_line_indexes.length > 2 * MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT) {
                var clip_start = nonempty_line_indexes[MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT - 1] + 1;
                var clip_end = nonempty_line_indexes[nonempty_line_indexes.length - MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT] - 1;
                var intermediate_line = new Array(lineno_display_width + 1).join(' ') + '  (...continued...)';
                intermediate_line += '\n' + new Array(lineno_display_width + 1).join('-') + '  (---------------)';
                rv.splice(clip_start, clip_end - clip_start + 1, intermediate_line);
            }

            return rv.join('\n');
        },

        /**
         * helper function, used to produce a human readable description as a string, given
         * the input `yylloc` location object.
         * 
         * Set `display_range_too` to TRUE to include the string character index position(s)
         * in the description if the `yylloc.range` is available.
         * 
         * @public
         * @this {RegExpLexer}
         */
        describeYYLLOC: function lexer_describe_yylloc(yylloc, display_range_too) {
            var l1 = yylloc.first_line;
            var l2 = yylloc.last_line;
            var c1 = yylloc.first_column;
            var c2 = yylloc.last_column;
            var dl = l2 - l1;
            var dc = c2 - c1;
            var rv;

            if (dl === 0) {
                rv = 'line ' + l1 + ', ';

                if (dc <= 1) {
                    rv += 'column ' + c1;
                } else {
                    rv += 'columns ' + c1 + ' .. ' + c2;
                }
            } else {
                rv = 'lines ' + l1 + '(column ' + c1 + ') .. ' + l2 + '(column ' + c2 + ')';
            }

            if (yylloc.range && display_range_too) {
                var r1 = yylloc.range[0];
                var r2 = yylloc.range[1] - 1;

                if (r2 <= r1) {
                    rv += ' {String Offset: ' + r1 + '}';
                } else {
                    rv += ' {String Offset range: ' + r1 + ' .. ' + r2 + '}';
                }
            }

            return rv;
        },

        /**
         * test the lexed token: return FALSE when not a match, otherwise return token.
         * 
         * `match` is supposed to be an array coming out of a regex match, i.e. `match[0]`
         * contains the actually matched text string.
         * 
         * Also move the input cursor forward and update the match collectors:
         * 
         * - `yytext`
         * - `yyleng`
         * - `match`
         * - `matches`
         * - `yylloc`
         * - `offset`
         * 
         * @public
         * @this {RegExpLexer}
         */
        test_match: function lexer_test_match(match, indexed_rule) {
            var token, lines, backup, match_str, match_str_len;

            if (this.options.backtrack_lexer) {
                // save context
                backup = {
                    yylineno: this.yylineno,

                    yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.yylloc.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                        range: this.yylloc.range.slice(0)
                    },

                    yytext: this.yytext,
                    match: this.match,
                    matches: this.matches,
                    matched: this.matched,
                    yyleng: this.yyleng,
                    offset: this.offset,
                    _more: this._more,
                    _input: this._input,

                    //_signaled_error_token: this._signaled_error_token,
                    yy: this.yy,

                    conditionStack: this.conditionStack.slice(0),
                    done: this.done
                };
            }

            match_str = match[0];
            match_str_len = match_str.length;

            // if (match_str.indexOf('\n') !== -1 || match_str.indexOf('\r') !== -1) {
            lines = match_str.split(/(?:\r\n?|\n)/g);

            if (lines.length > 1) {
                this.yylineno += lines.length - 1;
                this.yylloc.last_line = this.yylineno + 1;
                this.yylloc.last_column = lines[lines.length - 1].length;
            } else {
                this.yylloc.last_column += match_str_len;
            }

            // }
            this.yytext += match_str;

            this.match += match_str;
            this.matched += match_str;
            this.matches = match;
            this.yyleng = this.yytext.length;
            this.yylloc.range[1] += match_str_len;

            // previous lex rules MAY have invoked the `more()` API rather than producing a token:
            // those rules will already have moved this `offset` forward matching their match lengths,
            // hence we must only add our own match length now:
            this.offset += match_str_len;

            this._more = false;
            this._backtrack = false;
            this._input = this._input.slice(match_str_len);

            // calling this method:
            //
            //   function lexer__performAction(yy, yyrulenumber, YY_START) {...}
            token = this.performAction.call(this, this.yy, indexed_rule, this.conditionStack[this.conditionStack.length - 1] /* = YY_START */
            );

            // otherwise, when the action codes are all simple return token statements:
            //token = this.simpleCaseActionClusters[indexed_rule];

            if (this.done && this._input) {
                this.done = false;
            }

            if (token) {
                return token;
            } else if (this._backtrack) {
                // recover context
                for (var k in backup) {
                    this[k] = backup[k];
                }

                this.__currentRuleSet__ = null;
                return false; // rule action called reject() implying the next rule should be tested instead. 
            } else if (this._signaled_error_token) {
                // produce one 'error' token as `.parseError()` in `reject()`
                // did not guarantee a failure signal by throwing an exception!
                token = this._signaled_error_token;

                this._signaled_error_token = false;
                return token;
            }

            return false;
        },

        /**
         * return next match in input
         * 
         * @public
         * @this {RegExpLexer}
         */
        next: function lexer_next() {
            if (this.done) {
                this.clear();
                return this.EOF;
            }

            if (!this._input) {
                this.done = true;
            }

            var token, match, tempMatch, index;

            if (!this._more) {
                this.clear();
            }

            var spec = this.__currentRuleSet__;

            if (!spec) {
                // Update the ruleset cache as we apparently encountered a state change or just started lexing.
                // The cache is set up for fast lookup -- we assume a lexer will switch states much less often than it will
                // invoke the `lex()` token-producing API and related APIs, hence caching the set for direct access helps
                // speed up those activities a tiny bit.
                spec = this.__currentRuleSet__ = this._currentRules();

                // Check whether a *sane* condition has been pushed before: this makes the lexer robust against
                // user-programmer bugs such as https://github.com/zaach/jison-lex/issues/19
                if (!spec || !spec.rules) {
                    var lineno_msg = '';

                    if (this.options.trackPosition) {
                        lineno_msg = ' on line ' + (this.yylineno + 1);
                    }

                    var p = this.constructLexErrorInfo('Internal lexer engine error' + lineno_msg + ': The lex grammar programmer pushed a non-existing condition name "' + this.topState() + '"; this is a fatal error and should be reported to the application programmer team!', false);

                    // produce one 'error' token until this situation has been resolved, most probably by parse termination!
                    return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
                }
            }

            var rule_ids = spec.rules;
            var regexes = spec.__rule_regexes;
            var len = spec.__rule_count;

            // Note: the arrays are 1-based, while `len` itself is a valid index,
            // hence the non-standard less-or-equal check in the next loop condition!
            for (var i = 1; i <= len; i++) {
                tempMatch = this._input.match(regexes[i]);

                if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                    match = tempMatch;
                    index = i;

                    if (this.options.backtrack_lexer) {
                        token = this.test_match(tempMatch, rule_ids[i]);

                        if (token !== false) {
                            return token;
                        } else if (this._backtrack) {
                            match = undefined;
                            continue; // rule action called reject() implying a rule MISmatch. 
                        } else {
                            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                            return false;
                        }
                    } else if (!this.options.flex) {
                        break;
                    }
                }
            }

            if (match) {
                token = this.test_match(match, rule_ids[index]);

                if (token !== false) {
                    return token;
                }

                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                return false;
            }

            if (!this._input) {
                this.done = true;
                this.clear();
                return this.EOF;
            } else {
                var lineno_msg = '';

                if (this.options.trackPosition) {
                    lineno_msg = ' on line ' + (this.yylineno + 1);
                }

                var p = this.constructLexErrorInfo('Lexical error' + lineno_msg + ': Unrecognized text.', this.options.lexerErrorsAreRecoverable);

                var pendingInput = this._input;
                var activeCondition = this.topState();
                var conditionStackDepth = this.conditionStack.length;
                token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;

                if (token === this.ERROR) {
                    // we can try to recover from a lexer error that `parseError()` did not 'recover' for us
                    // by moving forward at least one character at a time IFF the (user-specified?) `parseError()`
                    // has not consumed/modified any pending input or changed state in the error handler:
                    if (!this.matches && // and make sure the input has been modified/consumed ...
                    pendingInput === this._input && // ...or the lexer state has been modified significantly enough
                    // to merit a non-consuming error handling action right now.
                    activeCondition === this.topState() && conditionStackDepth === this.conditionStack.length) {
                        this.input();
                    }
                }

                return token;
            }
        },

        /**
         * return next match that has a token
         * 
         * @public
         * @this {RegExpLexer}
         */
        lex: function lexer_lex() {
            var r;

            // allow the PRE/POST handlers set/modify the return token for maximum flexibility of the generated lexer:
            if (typeof this.pre_lex === 'function') {
                r = this.pre_lex.call(this, 0);
            }

            if (typeof this.options.pre_lex === 'function') {
                // (also account for a userdef function which does not return any value: keep the token as is)
                r = this.options.pre_lex.call(this, r) || r;
            }

            if (this.yy && typeof this.yy.pre_lex === 'function') {
                // (also account for a userdef function which does not return any value: keep the token as is)
                r = this.yy.pre_lex.call(this, r) || r;
            }

            while (!r) {
                r = this.next();
            }

            if (this.yy && typeof this.yy.post_lex === 'function') {
                // (also account for a userdef function which does not return any value: keep the token as is)
                r = this.yy.post_lex.call(this, r) || r;
            }

            if (typeof this.options.post_lex === 'function') {
                // (also account for a userdef function which does not return any value: keep the token as is)
                r = this.options.post_lex.call(this, r) || r;
            }

            if (typeof this.post_lex === 'function') {
                // (also account for a userdef function which does not return any value: keep the token as is)
                r = this.post_lex.call(this, r) || r;
            }

            return r;
        },

        /**
         * return next match that has a token. Identical to the `lex()` API but does not invoke any of the 
         * `pre_lex()` nor any of the `post_lex()` callbacks.
         * 
         * @public
         * @this {RegExpLexer}
         */
        fastLex: function lexer_fastLex() {
            var r;

            while (!r) {
                r = this.next();
            }

            return r;
        },

        /**
         * return info about the lexer state that can help a parser or other lexer API user to use the
         * most efficient means available. This API is provided to aid run-time performance for larger
         * systems which employ this lexer.
         * 
         * @public
         * @this {RegExpLexer}
         */
        canIUse: function lexer_canIUse() {
            var rv = {
                fastLex: !(typeof this.pre_lex === 'function' || typeof this.options.pre_lex === 'function' || this.yy && typeof this.yy.pre_lex === 'function' || this.yy && typeof this.yy.post_lex === 'function' || typeof this.options.post_lex === 'function' || typeof this.post_lex === 'function') && typeof this.fastLex === 'function'
            };

            return rv;
        },

        /**
         * backwards compatible alias for `pushState()`;
         * the latter is symmetrical with `popState()` and we advise to use
         * those APIs in any modern lexer code, rather than `begin()`.
         * 
         * @public
         * @this {RegExpLexer}
         */
        begin: function lexer_begin(condition) {
            return this.pushState(condition);
        },

        /**
         * activates a new lexer condition state (pushes the new lexer
         * condition state onto the condition stack)
         * 
         * @public
         * @this {RegExpLexer}
         */
        pushState: function lexer_pushState(condition) {
            this.conditionStack.push(condition);
            this.__currentRuleSet__ = null;
            return this;
        },

        /**
         * pop the previously active lexer condition state off the condition
         * stack
         * 
         * @public
         * @this {RegExpLexer}
         */
        popState: function lexer_popState() {
            var n = this.conditionStack.length - 1;

            if (n > 0) {
                this.__currentRuleSet__ = null;
                return this.conditionStack.pop();
            } else {
                return this.conditionStack[0];
            }
        },

        /**
         * return the currently active lexer condition state; when an index
         * argument is provided it produces the N-th previous condition state,
         * if available
         * 
         * @public
         * @this {RegExpLexer}
         */
        topState: function lexer_topState(n) {
            n = this.conditionStack.length - 1 - Math.abs(n || 0);

            if (n >= 0) {
                return this.conditionStack[n];
            } else {
                return 'INITIAL';
            }
        },

        /**
         * (internal) determine the lexer rule set which is active for the
         * currently active lexer condition state
         * 
         * @public
         * @this {RegExpLexer}
         */
        _currentRules: function lexer__currentRules() {
            if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
                return this.conditions[this.conditionStack[this.conditionStack.length - 1]];
            } else {
                return this.conditions['INITIAL'];
            }
        },

        /**
         * return the number of states currently on the stack
         * 
         * @public
         * @this {RegExpLexer}
         */
        stateStackSize: function lexer_stateStackSize() {
            return this.conditionStack.length;
        },

        options: {
            xregexp: true,
            ranges: true,
            trackPosition: true,
            easy_keyword_rules: true
        },

        JisonLexerError: JisonLexerError,

        performAction: function lexer__performAction(yy, yyrulenumber, YY_START) {
            var yy_ = this;
            switch (yyrulenumber) {
                case 0:
                    /*! Conditions:: INITIAL */
                    /*! Rule::       \s+ */
                    /* skip whitespace */
                    break;

                case 3:
                    /*! Conditions:: INITIAL */
                    /*! Rule::       \[{ID}\] */
                    yy_.yytext = this.matches[1];

                    return 9;
                    break;

                default:
                    return this.simpleCaseActionClusters[yyrulenumber];
            }
        },

        simpleCaseActionClusters: {
            /*! Conditions:: INITIAL */
            /*! Rule::       {ID} */
            1: 10,

            /*! Conditions:: INITIAL */
            /*! Rule::       \$end\b */
            2: 10,

            /*! Conditions:: INITIAL */
            /*! Rule::       '{QUOTED_STRING_CONTENT}' */
            4: 10,

            /*! Conditions:: INITIAL */
            /*! Rule::       "{DOUBLEQUOTED_STRING_CONTENT}" */
            5: 10,

            /*! Conditions:: INITIAL */
            /*! Rule::       \. */
            6: 10,

            /*! Conditions:: INITIAL */
            /*! Rule::       \( */
            7: 4,

            /*! Conditions:: INITIAL */
            /*! Rule::       \) */
            8: 5,

            /*! Conditions:: INITIAL */
            /*! Rule::       \* */
            9: 6,

            /*! Conditions:: INITIAL */
            /*! Rule::       \? */
            10: 7,

            /*! Conditions:: INITIAL */
            /*! Rule::       \| */
            11: 3,

            /*! Conditions:: INITIAL */
            /*! Rule::       \+ */
            12: 8,

            /*! Conditions:: INITIAL */
            /*! Rule::       $ */
            13: 1
        },

        rules: [
        /*  0: *//^(?:\s+)/,
        /*  1: */new XRegExp('^(?:([\\p{Alphabetic}_](?:[\\p{Alphabetic}\\p{Number}_])*))', ''),
        /*  2: *//^(?:\$end\b)/,
        /*  3: */new XRegExp('^(?:\\[([\\p{Alphabetic}_](?:[\\p{Alphabetic}\\p{Number}_])*)\\])', ''),
        /*  4: *//^(?:'((?:\\'|\\[^']|[^'\\])*)')/,
        /*  5: *//^(?:"((?:\\"|\\[^"]|[^"\\])*)")/,
        /*  6: *//^(?:\.)/,
        /*  7: *//^(?:\()/,
        /*  8: *//^(?:\))/,
        /*  9: *//^(?:\*)/,
        /* 10: *//^(?:\?)/,
        /* 11: *//^(?:\|)/,
        /* 12: *//^(?:\+)/,
        /* 13: *//^(?:$)/],

        conditions: {
            'INITIAL': {
                rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
                inclusive: true
            }
        }
    };

    return lexer;
}();
parser$3.lexer = lexer$2;

function Parser$3() {
    this.yy = {};
}
Parser$3.prototype = parser$3;
parser$3.Parser = Parser$3;

function yyparse$2() {
    return parser$3.parse.apply(parser$3, arguments);
}

var parser$4 = {
    parser: parser$3,
    Parser: Parser$3,
    parse: yyparse$2

};

//import assert from 'assert';

var devDebug$1 = 0;

// WARNING: this regex MUST match the regex for `ID` in ebnf-parser::bnf.l jison language lexer spec! (`ID = [{ALPHA}]{ALNUM}*`)
//
// This is the base XRegExp ID regex used in many places; this should match the ID macro definition in the EBNF/BNF parser et al as well!
var ID_REGEX_BASE$2 = '[\\p{Alphabetic}_][\\p{Alphabetic}_\\p{Number}]*';

// produce a unique production symbol.
// Use this to produce rule productions from transformed EBNF which are
// guaranteed not to collide with previously generated / already existing
// rules (~ symbols).
function generateUniqueSymbol(id, postfix, opts) {
    var sym = id + postfix;
    if (opts.grammar[sym]) {
        var i = 2; // the first occurrence won't have a number, this is already a collision, so start numbering at *2*.
        do {
            sym = id + postfix + i;
            i++;
        } while (opts.grammar[sym]);
    }
    return sym;
}

function generatePushAction(handle, offset) {
    var terms = handle.terms;
    var rv = [];

    for (var i = 0, len = terms.length; i < len; i++) {
        rv.push('$' + (i + offset));
    }
    rv = rv.join(', ');
    // and make sure we contain a term series unambiguously, i.e. anything more complex than
    // a single term inside an EBNF check is produced as an array so we can differentiate
    // between */+/? EBNF operator results and groups of tokens per individual match.
    if (len > 1) {
        rv = '[' + rv + ']';
    }
    return rv;
}

function transformExpression(e, opts, emit) {
    var type = e[0],
        value = e[1],
        name = false,
        has_transformed = 0;
    var list, n;

    if (type === 'xalias') {
        type = e[1];
        value = e[2];
        name = e[3];
        if (type) {
            e = e.slice(1);
        } else {
            e = value;
            type = e[0];
            value = e[1];
        }
        if (devDebug$1 > 3) console.log('xalias: ', e, type, value, name);
    }

    if (type === 'symbol') {
        n = e[1];
        if (devDebug$1 > 2) console.log('symbol EMIT: ', n + (name ? '[' + name + ']' : ''));
        emit(n + (name ? '[' + name + ']' : ''));
    } else if (type === '+') {
        if (!name) {
            name = generateUniqueSymbol(opts.production, '_repetition_plus', opts);
        }
        if (devDebug$1 > 2) console.log('+ EMIT name: ', name);
        emit(name);

        has_transformed = 1;

        opts = optsForProduction(name, opts.grammar);
        list = transformExpressionList([value], opts);
        opts.grammar[name] = [[list.fragment, '$$ = [' + generatePushAction(list, 1) + '];'], [name + ' ' + list.fragment, '$1.push(' + generatePushAction(list, 2) + ');\n$$ = $1;']];
    } else if (type === '*') {
        if (!name) {
            name = generateUniqueSymbol(opts.production, '_repetition', opts);
        }
        if (devDebug$1 > 2) console.log('* EMIT name: ', name);
        emit(name);

        has_transformed = 1;

        opts = optsForProduction(name, opts.grammar);
        list = transformExpressionList([value], opts);
        opts.grammar[name] = [['', '$$ = [];'], [name + ' ' + list.fragment, '$1.push(' + generatePushAction(list, 2) + ');\n$$ = $1;']];
    } else if (type === '?') {
        if (!name) {
            name = generateUniqueSymbol(opts.production, '_option', opts);
        }
        if (devDebug$1 > 2) console.log('? EMIT name: ', name);
        emit(name);

        has_transformed = 1;

        opts = optsForProduction(name, opts.grammar);
        list = transformExpressionList([value], opts);
        // you want to be able to check if 0 or 1 occurrences were recognized: since jison
        // by default *copies* the lexer token value, i.e. `$$ = $1` is the (optional) default action,
        // we will need to set the action up explicitly in case of the 0-count match:
        // `$$ = undefined`.
        //
        // Note that we MUST return an array as the
        // '1 occurrence' match CAN carry multiple terms, e.g. in constructs like
        // `(T T T)?`, which would otherwise be unrecognizable from the `T*` construct.
        opts.grammar[name] = [['', '$$ = undefined;'], [list.fragment, '$$ = ' + generatePushAction(list, 1) + ';']];
    } else if (type === '()') {
        if (value.length === 1 && !name) {
            list = transformExpressionList(value[0], opts);
            if (list.first_transformed_term_index) {
                has_transformed = list.first_transformed_term_index;
            }
            if (devDebug$1 > 2) console.log('group EMIT len=1: ', list);
            emit(list);
        } else {
            if (!name) {
                name = generateUniqueSymbol(opts.production, '_group', opts);
            }
            if (devDebug$1 > 2) console.log('group EMIT name: ', name);
            emit(name);

            has_transformed = 1;

            opts = optsForProduction(name, opts.grammar);
            opts.grammar[name] = value.map(function (handle) {
                var list = transformExpressionList(handle, opts);
                return [list.fragment, '$$ = ' + generatePushAction(list, 1) + ';'];
            });
        }
    }

    return has_transformed;
}

function transformExpressionList(list, opts) {
    var first_transformed_term_index = false;
    var terms = list.reduce(function (tot, e) {
        var ci = tot.length;

        var has_transformed = transformExpression(e, opts, function (name) {
            if (name.terms) {
                tot.push.apply(tot, name.terms);
            } else {
                tot.push(name);
            }
        });

        if (has_transformed) {
            first_transformed_term_index = ci + has_transformed;
        }
        return tot;
    }, []);

    return {
        fragment: terms.join(' '),
        terms: terms,
        first_transformed_term_index: first_transformed_term_index // 1-based index
    };
}

function optsForProduction(id, grammar) {
    return {
        production: id,
        grammar: grammar
    };
}

function transformProduction(id, production, grammar) {
    var transform_opts = optsForProduction(id, grammar);
    return production.map(function (handle) {
        var action = null,
            opts = null;
        var i, len, n;

        if (typeof handle !== 'string') {
            action = handle[1];
            opts = handle[2];
            handle = handle[0];
        }
        var expressions = parser$4.parse(handle);

        if (devDebug$1 > 1) console.log('\n================\nEBNF transform expressions:\n ', handle, opts, JSON.stringify(expressions, null, 2));

        var list = transformExpressionList(expressions, transform_opts);

        var ret = [list.fragment];
        if (action) {
            // make sure the action doesn't address any inner items.
            if (list.first_transformed_term_index) {
                var rhs = list.fragment;
                // seek out all names and aliases; strip out literal tokens first as those cannot serve as $names:
                var alist = list.terms; // rhs.replace(/'[^']+'/g, '~').replace(/"[^"]+"/g, '~').split(' ');
                // we also know at which index the first transformation occurred:
                if (devDebug$1 > 2) console.log('alist ~ rhs rule terms: ', alist, rhs);

                var alias_re = new XRegExp('\\[' + ID_REGEX_BASE$2 + '\\]');
                var term_re = new XRegExp('^' + ID_REGEX_BASE$2 + '$');
                // and collect the PERMITTED aliases: the names of the terms and all the remaining aliases
                var good_aliases = {};
                var alias_cnt = {};
                var donotalias = {};

                // WARNING: this replicates the knowledge/code of jison.js::addName()
                var addName = function addNameEBNF(s, i) {
                    var base = s.replace(/[0-9]+$/, '');
                    var dna = donotalias[base];

                    if (good_aliases[s]) {
                        alias_cnt[s]++;
                        if (!dna) {
                            good_aliases[s + alias_cnt[s]] = i + 1;
                            alias_cnt[s + alias_cnt[s]] = 1;
                        }
                    } else {
                        good_aliases[s] = i + 1;
                        alias_cnt[s] = 1;
                        if (!dna) {
                            good_aliases[s + alias_cnt[s]] = i + 1;
                            alias_cnt[s + alias_cnt[s]] = 1;
                        }
                    }
                };

                // WARNING: this replicates the knowledge/code of jison.js::markBasename()
                var markBasename = function markBasenameEBNF(s) {
                    if (/[0-9]$/.test(s)) {
                        s = s.replace(/[0-9]+$/, '');
                        donotalias[s] = true;
                    }
                };

                // mark both regular and aliased names, e.g., `id[alias1]` and `id1`
                //
                // WARNING: this replicates the knowledge/code of jison.js::markBasename()+addName() usage
                for (i = 0, len = alist.length; i < len; i++) {
                    var term = alist[i];
                    var alias = term.match(alias_re);
                    if (alias) {
                        markBasename(alias[0].substr(1, alias[0].length - 2));
                        term = term.replace(alias_re, '');
                    }
                    if (term.match(term_re)) {
                        markBasename(term);
                    }
                }
                // then check & register both regular and aliased names, e.g., `id[alias1]` and `id1`
                for (i = 0, len = alist.length; i < len; i++) {
                    var term = alist[i];
                    var alias = term.match(alias_re);
                    if (alias) {
                        addName(alias[0].substr(1, alias[0].length - 2), i);
                        term = term.replace(alias_re, '');
                    }
                    if (term.match(term_re)) {
                        addName(term, i);
                    }
                }
                if (devDebug$1 > 2) console.log('good_aliases: ', {
                    donotalias: donotalias,
                    good_aliases: good_aliases,
                    alias_cnt: alias_cnt
                });

                // now scan the action for all named and numeric semantic values ($nonterminal / $1 / @1, ##1, ...)
                //
                // Note that `#name` are straight **static** symbol translations, which are okay as they don't
                // require access to the parse stack: `#n` references can be resolved completely 
                // at grammar compile time.
                //
                var nameref_re = new XRegExp('(?:[$@]|##)' + ID_REGEX_BASE$2, 'g');
                var named_spots = nameref_re.exec(action);
                var numbered_spots = action.match(/(?:[$@]|##)[0-9]+\b/g);
                var max_term_index = list.terms.length;
                if (devDebug$1 > 2) console.log('ACTION named_spots: ', named_spots);
                if (devDebug$1 > 2) console.log('ACTION numbered_spots: ', numbered_spots);

                // loop through the XRegExp alias regex matches in `action`
                while (named_spots) {
                    n = named_spots[0].replace(/^(?:[$@]|##)/, '');
                    if (!good_aliases[n]) {
                        throw new Error('The action block references the named alias "' + n + '" ' + 'which is not available in production "' + handle + '"; ' + 'it probably got removed by the EBNF rule rewrite process.\n' + 'Be reminded that you cannot reference sub-elements within EBNF */+/? groups, ' + 'only the outer-most EBNF group alias will remain available at all times ' + 'due to the EBNF-to-BNF rewrite process.');
                    }

                    if (alias_cnt[n] !== 1) {
                        throw new Error('The action block references the ambiguous named alias or term reference "' + n + '" ' + 'which is mentioned ' + alias_cnt[n] + ' times in production "' + handle + '", implicit and explicit aliases included.\n' + 'You should either provide unambiguous = uniquely named aliases for these terms or use numeric index references (e.g. `$3`) as a stop-gap in your action code.\n' + 'Be reminded that you cannot reference sub-elements within EBNF */+/? groups, ' + 'only the outer-most EBNF group alias will remain available at all times ' + 'due to the EBNF-to-BNF rewrite process.');
                    }
                    //assert(good_aliases[n] <= max_term_index, 'max term index');

                    named_spots = nameref_re.exec(action);
                }
                if (numbered_spots) {
                    for (i = 0, len = numbered_spots.length; i < len; i++) {
                        n = parseInt(numbered_spots[i].replace(/^(?:[$@]|##)/, ''));
                        if (n > max_term_index) {
                            /* @const */var n_suffixes = ['st', 'nd', 'rd', 'th'];
                            throw new Error('The action block references the ' + n + n_suffixes[Math.max(0, Math.min(3, n - 1))] + ' term, ' + 'which is not available in production "' + handle + '"; ' + 'Be reminded that you cannot reference sub-elements within EBNF */+/? groups, ' + 'only the outer-most EBNF group alias will remain available at all times ' + 'due to the EBNF-to-BNF rewrite process.');
                        }
                    }
                }
            }
            ret.push(action);
        }
        if (opts) {
            ret.push(opts);
        }
        if (devDebug$1 > 1) console.log('\n\nEBNF tx result:\n ', JSON.stringify(list, null, 2), JSON.stringify(ret, null, 2));

        if (ret.length === 1) {
            return ret[0];
        } else {
            return ret;
        }
    });
}

var ref_list;
var ref_names;

// create a deep copy of the input, so we will keep the input constant.
function deepClone(from, sub) {
    if (sub == null) {
        ref_list = [];
        ref_names = [];
        sub = 'root';
    }
    if (typeof from === 'function') return from;
    if (from == null || (typeof from === 'undefined' ? 'undefined' : _typeof(from)) !== 'object') return from;
    if (from.constructor !== Object && from.constructor !== Array) {
        return from;
    }

    for (var i = 0, len = ref_list.length; i < len; i++) {
        if (ref_list[i] === from) {
            throw new Error('[Circular/Xref:' + ref_names[i] + ']'); // circular or cross reference
        }
    }
    ref_list.push(from);
    ref_names.push(sub);
    sub += '.';

    var to = new from.constructor();
    for (var name in from) {
        to[name] = deepClone(from[name], sub + name);
    }
    return to;
}

function transformGrammar(grammar) {
    grammar = deepClone(grammar);

    Object.keys(grammar).forEach(function transformGrammarForKey(id) {
        grammar[id] = transformProduction(id, grammar[id], grammar);
    });

    return grammar;
}

function transform(ebnf) {
    if (devDebug$1 > 0) console.log('EBNF:\n ', JSON.stringify(ebnf, null, 2));
    var rv = transformGrammar(ebnf);
    if (devDebug$1 > 0) console.log('\n\nEBNF after transformation:\n ', JSON.stringify(rv, null, 2));

    return rv;
}

// hack:
var assert$2;

/* parser generated by jison 0.6.1-210 */

/*
 * Returns a Parser object of the following structure:
 *
 *  Parser: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a derivative/copy of this one,
 *               not a direct reference!
 *  }
 *
 *  Parser.prototype: {
 *    yy: {},
 *    EOF: 1,
 *    TERROR: 2,
 *
 *    trace: function(errorMessage, ...),
 *
 *    JisonParserError: function(msg, hash),
 *
 *    quoteName: function(name),
 *               Helper function which can be overridden by user code later on: put suitable
 *               quotes around literal IDs in a description string.
 *
 *    originalQuoteName: function(name),
 *               The basic quoteName handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function
 *               at the end of the `parse()`.
 *
 *    describeSymbol: function(symbol),
 *               Return a more-or-less human-readable description of the given symbol, when
 *               available, or the symbol itself, serving as its own 'description' for lack
 *               of something better to serve up.
 *
 *               Return NULL when the symbol is unknown to the parser.
 *
 *    symbols_: {associative list: name ==> number},
 *    terminals_: {associative list: number ==> name},
 *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},
 *    terminal_descriptions_: (if there are any) {associative list: number ==> description},
 *    productions_: [...],
 *
 *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)
 *                             to store/reference the rule value `$$` and location info `@$`.
 *
 *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets
 *                 to see the same object via the `this` reference, i.e. if you wish to carry custom
 *                 data from one reduce action through to the next within a single parse run, then you
 *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.
 *
 *                 `this.yy` is a direct reference to the `yy` shared state object.
 *
 *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`
 *                 object at `parse()` start and are therefore available to the action code via the
 *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from
 *                 the %parse-param` list.
 *
 *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used
 *                             to match this rule. This is *not* the look-ahead token, but the last token
 *                             that's actually part of this rule.
 *
 *                 Formulated another way, `yytext` is the value of the token immediately preceeding
 *                 the current look-ahead token.
 *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.
 *
 *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.
 *
 *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.
 *
 *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.
 *
 *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead
 *                               of an empty object when no suitable location info can be provided.
 *
 *               - `yystate` : the current parser state number, used internally for dispatching and
 *                               executing the action code chunk matching the rule currently being reduced.
 *
 *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *                 Also note that you can access this and other stack index values using the new double-hash
 *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things
 *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.
 *                 This is made available to write very advanced grammar action rules, e.g. when you want
 *                 to investigate the parse state stack in your action code, which would, for example,
 *                 be relevant when you wish to implement error diagnostics and reporting schemes similar
 *                 to the work described here:
 *
 *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.
 *                   In Journes Francophones des Languages Applicatifs.
 *
 *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.
 *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631640.
 *
 *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.
 *                             constructs.
 *
 *               - `yylstack`: reference to the parser token location stack. Also accessed via
 *                             the `@1` etc. constructs.
 *
 *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are
 *                             UNDEFINED rather than an empty (location) object, when the lexer/parser
 *                             action code did not provide a suitable location info object when such a
 *                             slot was filled!
 *
 *               - `yystack` : reference to the parser token id stack. Also accessed via the
 *                             `#1` etc. constructs.
 *
 *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to
 *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might
 *                 want access this array for your own purposes, such as error analysis as mentioned above!
 *
 *                 Note that this stack stores the current stack of *tokens*, that is the sequence of
 *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*
 *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and
 *                 *reduced*.
 *
 *               - `yysstack`: reference to the parser state stack. This one carries the internal parser
 *                             *states* such as the one in `yystate`, which are used to represent
 *                             the parser state machine in the *parse table*. *Very* *internal* stuff,
 *                             what can I say? If you access this one, you're clearly doing wicked things
 *
 *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your
 *                             grammar definition file.
 *
 *    table: [...],
 *               State transition table
 *               ----------------------
 *
 *               index levels are:
 *               - `state`  --> hash table
 *               - `symbol` --> action (number or array)
 *
 *                 If the `action` is an array, these are the elements' meaning:
 *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept
 *                 - index [1]: GOTO `state`
 *
 *                 If the `action` is a number, it is the GOTO `state`
 *
 *    defaultActions: {...},
 *
 *    parseError: function(str, hash, ExceptionClass),
 *    yyError: function(str, ...),
 *    yyRecovering: function(),
 *    yyErrOk: function(),
 *    yyClearIn: function(),
 *
 *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this parser kernel in many places; example usage:
 *
 *                   var infoObj = parser.constructParseErrorInfo('fail!', null,
 *                                     parser.collect_expected_token_set(state), true);
 *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);
 *
 *    originalParseError: function(str, hash, ExceptionClass),
 *               The basic `parseError` handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function
 *               at the end of the `parse()`.
 *
 *    options: { ... parser %options ... },
 *
 *    parse: function(input[, args...]),
 *               Parse the given `input` and return the parsed value (or `true` when none was provided by
 *               the root action, in which case the parser is acting as a *matcher*).
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the jison run-time;
 *               when such a collision is detected an exception is thrown to prevent the generated run-time
 *               from silently accepting this confusing and potentially hazardous situation!
 *
 *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in
 *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state
 *               object and any collision with those will be reported by the lexer via a thrown exception.
 *
 *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown
 *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY
 *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and
 *               the internal parser gets properly garbage collected under these particular circumstances.
 *
 *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API can be invoked to calculate a spanning `yylloc` location info object.
 *
 *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case
 *               this function will attempt to obtain a suitable location marker by inspecting the location stack
 *               backwards.
 *
 *               For more info see the documentation comment further below, immediately above this function's
 *               implementation.
 *
 *    lexer: {
 *        yy: {...},           A reference to the so-called "shared state" `yy` once
 *                             received via a call to the `.setInput(input, yy)` lexer API.
 *        EOF: 1,
 *        ERROR: 2,
 *        JisonLexerError: function(msg, hash),
 *        parseError: function(str, hash, ExceptionClass),
 *        setInput: function(input, [yy]),
 *        input: function(),
 *        unput: function(str),
 *        more: function(),
 *        reject: function(),
 *        less: function(n),
 *        pastInput: function(n),
 *        upcomingInput: function(n),
 *        showPosition: function(),
 *        test_match: function(regex_match_array, rule_index, ...),
 *        next: function(...),
 *        lex: function(...),
 *        begin: function(condition),
 *        pushState: function(condition),
 *        popState: function(),
 *        topState: function(),
 *        _currentRules: function(),
 *        stateStackSize: function(),
 *        cleanupAfterLex: function()
 *
 *        options: { ... lexer %options ... },
 *
 *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),
 *        rules: [...],
 *        conditions: {associative list: name ==> set},
 *    }
 *  }
 *
 *
 *  token location info (@$, _$, etc.): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer and
 * parser errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *  }
 *
 * parser (grammar) errors will also provide these additional members:
 *
 *  {
 *    expected:    (array describing the set of expected tokens;
 *                  may be UNDEFINED when we cannot easily produce such a set)
 *    state:       (integer (or array when the table includes grammar collisions);
 *                  represents the current internal state of the parser kernel.
 *                  can, for example, be used to pass to the `collect_expected_token_set()`
 *                  API to obtain the expected token set)
 *    action:      (integer; represents the current internal action which will be executed)
 *    new_state:   (integer; represents the next/planned internal state, once the current
 *                  action has executed)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *    parser:      (reference to the current parser instance)
 *  }
 *
 * while `this` will reference the current parser instance.
 *
 * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    lexer:       (reference to the current lexer instance which reported the error)
 *  }
 *
 * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired
 * from either the parser or lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    exception:   (reference to the exception thrown)
 *  }
 *
 * Please do note that in the latter situation, the `expected` field will be omitted as
 * this type of failure is assumed not to be due to *parse errors* but rather due to user
 * action code in either parser or lexer failing unexpectedly.
 *
 * ---
 *
 * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.
 * These options are available:
 *
 * ### options which are global for all parser instances
 *
 *  Parser.pre_parse: function(yy)
 *                 optional: you can specify a pre_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`.
 *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: you can specify a post_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`. When it does not return any value,
 *                 the parser will return the original `retval`.
 *
 * ### options which can be set up per parser instance
 *
 *  yy: {
 *      pre_parse:  function(yy)
 *                 optional: is invoked before the parse cycle starts (and before the first
 *                 invocation of `lex()`) but immediately after the invocation of
 *                 `parser.pre_parse()`).
 *      post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: is invoked when the parse terminates due to success ('accept')
 *                 or failure (even when exceptions are thrown).
 *                 `retval` contains the return value to be produced by `Parser.parse()`;
 *                 this function can override the return value by returning another.
 *                 When it does not return any value, the parser will return the original
 *                 `retval`.
 *                 This function is invoked immediately before `parser.post_parse()`.
 *
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *      quoteName: function(name),
 *                 optional: overrides the default `quoteName` function.
 *  }
 *
 *  parser.lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */

// See also:
// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
// with userland code which might access the derived class in a 'classic' way.
function JisonParserError$1(msg, hash) {
    Object.defineProperty(this, 'name', {
        enumerable: false,
        writable: false,
        value: 'JisonParserError'
    });

    if (msg == null) msg = '???';

    Object.defineProperty(this, 'message', {
        enumerable: false,
        writable: true,
        value: msg
    });

    this.hash = hash;

    var stacktrace;
    if (hash && hash.exception instanceof Error) {
        var ex2 = hash.exception;
        this.message = ex2.message || msg;
        stacktrace = ex2.stack;
    }
    if (!stacktrace) {
        if (Error.hasOwnProperty('captureStackTrace')) {
            // V8/Chrome engine
            Error.captureStackTrace(this, this.constructor);
        } else {
            stacktrace = new Error(msg).stack;
        }
    }
    if (stacktrace) {
        Object.defineProperty(this, 'stack', {
            enumerable: false,
            writable: false,
            value: stacktrace
        });
    }
}

if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonParserError$1.prototype, Error.prototype);
} else {
    JisonParserError$1.prototype = Object.create(Error.prototype);
}
JisonParserError$1.prototype.constructor = JisonParserError$1;
JisonParserError$1.prototype.name = 'JisonParserError';

// helper: reconstruct the productions[] table
function bp$1(s) {
    var rv = [];
    var p = s.pop;
    var r = s.rule;
    for (var i = 0, l = p.length; i < l; i++) {
        rv.push([p[i], r[i]]);
    }
    return rv;
}

// helper: reconstruct the defaultActions[] table
function bda$1(s) {
    var rv = {};
    var d = s.idx;
    var g = s.goto;
    for (var i = 0, l = d.length; i < l; i++) {
        var j = d[i];
        rv[j] = g[i];
    }
    return rv;
}

// helper: reconstruct the 'goto' table
function bt$1(s) {
    var rv = [];
    var d = s.len;
    var y = s.symbol;
    var t = s.type;
    var a = s.state;
    var m = s.mode;
    var g = s.goto;
    for (var i = 0, l = d.length; i < l; i++) {
        var n = d[i];
        var q = {};
        for (var j = 0; j < n; j++) {
            var z = y.shift();
            switch (t.shift()) {
                case 2:
                    q[z] = [m.shift(), g.shift()];
                    break;

                case 0:
                    q[z] = a.shift();
                    break;

                default:
                    // type === 1: accept
                    q[z] = [3];
            }
        }
        rv.push(q);
    }
    return rv;
}

// helper: runlength encoding with increment step: code, length: step (default step = 0)
// `this` references an array
function s$1(c, l, a) {
    a = a || 0;
    for (var i = 0; i < l; i++) {
        this.push(c);
        c += a;
    }
}

// helper: duplicate sequence from *relative* offset and length.
// `this` references an array
function c$1(i, l) {
    i = this.length - i;
    for (l += i; i < l; i++) {
        this.push(this[i]);
    }
}

// helper: unpack an array using helpers and data, all passed in an array argument 'a'.
function u$1(a) {
    var rv = [];
    for (var i = 0, l = a.length; i < l; i++) {
        var e = a[i];
        // Is this entry a helper function?
        if (typeof e === 'function') {
            i++;
            e.apply(rv, a[i]);
        } else {
            rv.push(e);
        }
    }
    return rv;
}

var parser$2 = {
    // Code Generator Information Report
    // ---------------------------------
    //
    // Options:
    //
    //   default action mode: ............. classic,merge
    //   try..catch: ...................... true
    //   default resolve on conflict: ..... true
    //   on-demand look-ahead: ............ false
    //   error recovery token skip maximum: 3
    //   yyerror in parse actions is: ..... NOT recoverable,
    //   yyerror in lexer actions and other non-fatal lexer are:
    //   .................................. NOT recoverable,
    //   debug grammar/output: ............ false
    //   has partial LR conflict upgrade:   true
    //   rudimentary token-stack support:   false
    //   parser table compression mode: ... 2
    //   export debug tables: ............. false
    //   export *all* tables: ............. false
    //   module type: ..................... es
    //   parser engine type: .............. lalr
    //   output main() in the module: ..... true
    //   has user-specified main(): ....... false
    //   has user-specified require()/import modules for main():
    //   .................................. false
    //   number of expected conflicts: .... 0
    //
    //
    // Parser Analysis flags:
    //
    //   no significant actions (parser is a language matcher only):
    //   .................................. false
    //   uses yyleng: ..................... false
    //   uses yylineno: ................... false
    //   uses yytext: ..................... false
    //   uses yylloc: ..................... false
    //   uses ParseError API: ............. false
    //   uses YYERROR: .................... true
    //   uses YYRECOVERING: ............... false
    //   uses YYERROK: .................... false
    //   uses YYCLEARIN: .................. false
    //   tracks rule values: .............. true
    //   assigns rule values: ............. true
    //   uses location tracking: .......... true
    //   assigns location: ................ true
    //   uses yystack: .................... false
    //   uses yysstack: ................... false
    //   uses yysp: ....................... true
    //   uses yyrulelength: ............... false
    //   uses yyMergeLocationInfo API: .... true
    //   has error recovery: .............. true
    //   has error reporting: ............. true
    //
    // --------- END OF REPORT -----------

    trace: function no_op_trace() {},
    JisonParserError: JisonParserError$1,
    yy: {},
    options: {
        type: "lalr",
        hasPartialLrUpgradeOnConflict: true,
        errorRecoveryTokenDiscardCount: 3
    },
    symbols_: {
        "$accept": 0,
        "$end": 1,
        "%%": 14,
        "(": 7,
        ")": 8,
        "*": 9,
        "+": 11,
        ":": 5,
        ";": 4,
        "=": 3,
        "?": 10,
        "ACTION": 15,
        "ACTION_BODY": 43,
        "ALIAS": 39,
        "ARROW_ACTION": 42,
        "CODE": 46,
        "DEBUG": 19,
        "EBNF": 20,
        "EOF": 1,
        "EOF_ID": 40,
        "EPSILON": 38,
        "ID": 24,
        "IMPORT": 22,
        "INCLUDE": 44,
        "INIT_CODE": 23,
        "INTEGER": 37,
        "LEFT": 33,
        "LEX_BLOCK": 17,
        "NAME": 25,
        "NONASSOC": 35,
        "OPTIONS": 27,
        "OPTIONS_END": 28,
        "OPTION_STRING_VALUE": 29,
        "OPTION_VALUE": 30,
        "PARSER_TYPE": 32,
        "PARSE_PARAM": 31,
        "PATH": 45,
        "PREC": 41,
        "RIGHT": 34,
        "START": 16,
        "STRING": 26,
        "TOKEN": 18,
        "TOKEN_TYPE": 36,
        "UNKNOWN_DECL": 21,
        "action": 85,
        "action_body": 86,
        "action_comments_body": 87,
        "action_ne": 84,
        "associativity": 61,
        "declaration": 51,
        "declaration_list": 50,
        "error": 2,
        "expression": 79,
        "extra_parser_module_code": 88,
        "full_token_definitions": 63,
        "grammar": 69,
        "handle": 76,
        "handle_action": 75,
        "handle_list": 74,
        "handle_sublist": 77,
        "id": 83,
        "id_list": 68,
        "import_name": 53,
        "import_path": 54,
        "include_macro_code": 89,
        "init_code_name": 52,
        "module_code_chunk": 90,
        "one_full_token": 64,
        "operator": 60,
        "option": 57,
        "option_list": 56,
        "optional_action_header_block": 49,
        "optional_end_block": 48,
        "optional_module_code_chunk": 91,
        "optional_production_description": 73,
        "optional_token_type": 65,
        "options": 55,
        "parse_params": 58,
        "parser_type": 59,
        "prec": 81,
        "production": 71,
        "production_id": 72,
        "production_list": 70,
        "spec": 47,
        "suffix": 80,
        "suffixed_expression": 78,
        "symbol": 82,
        "token_description": 67,
        "token_list": 62,
        "token_value": 66,
        "{": 12,
        "|": 6,
        "}": 13
    },
    terminals_: {
        1: "EOF",
        2: "error",
        3: "=",
        4: ";",
        5: ":",
        6: "|",
        7: "(",
        8: ")",
        9: "*",
        10: "?",
        11: "+",
        12: "{",
        13: "}",
        14: "%%",
        15: "ACTION",
        16: "START",
        17: "LEX_BLOCK",
        18: "TOKEN",
        19: "DEBUG",
        20: "EBNF",
        21: "UNKNOWN_DECL",
        22: "IMPORT",
        23: "INIT_CODE",
        24: "ID",
        25: "NAME",
        26: "STRING",
        27: "OPTIONS",
        28: "OPTIONS_END",
        29: "OPTION_STRING_VALUE",
        30: "OPTION_VALUE",
        31: "PARSE_PARAM",
        32: "PARSER_TYPE",
        33: "LEFT",
        34: "RIGHT",
        35: "NONASSOC",
        36: "TOKEN_TYPE",
        37: "INTEGER",
        38: "EPSILON",
        39: "ALIAS",
        40: "EOF_ID",
        41: "PREC",
        42: "ARROW_ACTION",
        43: "ACTION_BODY",
        44: "INCLUDE",
        45: "PATH",
        46: "CODE"
    },
    TERROR: 2,
    EOF: 1,

    // internals: defined here so the object *structure* doesn't get modified by parse() et al,
    // thus helping JIT compilers like Chrome V8.
    originalQuoteName: null,
    originalParseError: null,
    cleanupAfterParse: null,
    constructParseErrorInfo: null,
    yyMergeLocationInfo: null,

    __reentrant_call_depth: 0, // INTERNAL USE ONLY
    __error_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup
    __error_recovery_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup

    // APIs which will be set up depending on user action code analysis:
    //yyRecovering: 0,
    //yyErrOk: 0,
    //yyClearIn: 0,

    // Helper APIs
    // -----------

    // Helper function which can be overridden by user code later on: put suitable quotes around
    // literal IDs in a description string.
    quoteName: function parser_quoteName(id_str) {
        return '"' + id_str + '"';
    },

    // Return the name of the given symbol (terminal or non-terminal) as a string, when available.
    //
    // Return NULL when the symbol is unknown to the parser.
    getSymbolName: function parser_getSymbolName(symbol) {
        if (this.terminals_[symbol]) {
            return this.terminals_[symbol];
        }

        // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.
        //
        // An example of this may be where a rule's action code contains a call like this:
        //
        //      parser.getSymbolName(#$)
        //
        // to obtain a human-readable name of the current grammar rule.
        var s = this.symbols_;
        for (var key in s) {
            if (s[key] === symbol) {
                return key;
            }
        }
        return null;
    },

    // Return a more-or-less human-readable description of the given symbol, when available,
    // or the symbol itself, serving as its own 'description' for lack of something better to serve up.
    //
    // Return NULL when the symbol is unknown to the parser.
    describeSymbol: function parser_describeSymbol(symbol) {
        if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {
            return this.terminal_descriptions_[symbol];
        } else if (symbol === this.EOF) {
            return 'end of input';
        }
        var id = this.getSymbolName(symbol);
        if (id) {
            return this.quoteName(id);
        }
        return null;
    },

    // Produce a (more or less) human-readable list of expected tokens at the point of failure.
    //
    // The produced list may contain token or token set descriptions instead of the tokens
    // themselves to help turning this output into something that easier to read by humans
    // unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,
    // expected terminals and nonterminals is produced.
    //
    // The returned list (array) will not contain any duplicate entries.
    collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {
        var TERROR = this.TERROR;
        var tokenset = [];
        var check = {};
        // Has this (error?) state been outfitted with a custom expectations description text for human consumption?
        // If so, use that one instead of the less palatable token set.
        if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {
            return [this.state_descriptions_[state]];
        }
        for (var p in this.table[state]) {
            p = +p;
            if (p !== TERROR) {
                var d = do_not_describe ? p : this.describeSymbol(p);
                if (d && !check[d]) {
                    tokenset.push(d);
                    check[d] = true; // Mark this token description as already mentioned to prevent outputting duplicate entries.
                }
            }
        }
        return tokenset;
    },
    productions_: bp$1({
        pop: u$1([s$1, [47, 3], 48, 48, s$1, [49, 3], s$1, [50, 3], s$1, [51, 20], s$1, [52, 3], 53, 53, 54, 54, s$1, [55, 3], 56, 56, s$1, [57, 6], 58, 58, 59, 59, 60, 60, s$1, [61, 3], 62, 62, 63, 63, s$1, [64, 3], 65, s$1, [65, 4, 1], 68, 69, 70, 70, s$1, [71, 3], 72, 72, 73, 73, s$1, [74, 4], s$1, [75, 3], 76, 76, 77, 77, 78, 78, s$1, [79, 5], s$1, [80, 4], s$1, [81, 3], 82, 82, 83, s$1, [84, 4], s$1, [85, 3], s$1, [86, 5], 87, 87, 88, 88, 89, 89, s$1, [90, 3], 91, 91]),
        rule: u$1([5, 5, 3, 0, 2, 0, s$1, [2, 3], c$1, [4, 3], 1, 1, c$1, [3, 3], s$1, [1, 6], s$1, [3, 5], s$1, [2, 3], c$1, [15, 9], c$1, [11, 4], c$1, [20, 7], s$1, [2, 4], s$1, [1, 3], 2, 1, 2, 2, c$1, [15, 3], 0, c$1, [11, 7], c$1, [36, 4], 3, 3, 1, 0, 3, c$1, [39, 4], c$1, [80, 4], c$1, [9, 3], c$1, [39, 4], 3, 3, c$1, [34, 5], c$1, [40, 5], c$1, [32, 3], s$1, [1, 3], 0, 0, 1, 5, 4, 4, c$1, [53, 3], c$1, [85, 4], c$1, [35, 3], 0])
    }),
    performAction: function parser__PerformAction(yyloc, yystate /* action[1] */, yysp, yyvstack, yylstack) {

        /* this == yyval */

        // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!
        var yy = this.yy;
        var yyparser = yy.parser;
        var yylexer = yy.lexer;

        switch (yystate) {
            case 0:
                /*! Production::    $accept : spec $end */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 1];
                this._$ = yylstack[yysp - 1];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,LT,LA,-,-)
                break;

            case 1:
                /*! Production::    spec : declaration_list "%%" grammar optional_end_block EOF */

                // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
                // END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 4];
                if (yyvstack[yysp - 1].trim() !== '') {
                    yy.addDeclaration(this.$, { include: yyvstack[yysp - 1] });
                }
                return extend(this.$, yyvstack[yysp - 2]);
                break;

            case 2:
                /*! Production::    spec : declaration_list "%%" grammar error EOF */

                // default action (generated by JISON mode classic/merge :: 5,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 4];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
                // END of default action (generated by JISON mode classic/merge :: 5,VT,VA,-,-,LT,LA,-,-)


                yyparser.yyError(rmCommonWS$4(_templateObject43, yylexer.prettyPrintRange(yylstack[yysp - 1], yylstack[yysp - 2])));
                break;

            case 3:
                /*! Production::    spec : declaration_list error EOF */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 2];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-)


                yyparser.yyError(rmCommonWS$4(_templateObject44, yylexer.prettyPrintRange(yylstack[yysp - 1], yylstack[yysp - 2])));
                break;

            case 4:
            /*! Production::    optional_end_block : %epsilon */
            case 100:
            /*! Production::    suffix : %epsilon */
            case 116:
            /*! Production::    action : %epsilon */
            case 117:
            /*! Production::    action_body : %epsilon */
            case 132:
                /*! Production::    optional_module_code_chunk : %epsilon */

                // default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(null, null, null, null, true);
                // END of default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-)


                this.$ = '';
                break;

            case 5:
                /*! Production::    optional_end_block : "%%" extra_parser_module_code */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                var rv = checkActionBlock$2(yyvstack[yysp], yylstack[yysp]);
                if (rv) {
                    yyparser.yyError(rmCommonWS$4(_templateObject45, rv, yylexer.prettyPrintRange(yylstack[yysp])));
                }
                this.$ = yyvstack[yysp];
                break;

            case 6:
            /*! Production::    optional_action_header_block : %epsilon */
            case 10:
                /*! Production::    declaration_list : %epsilon */

                // default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(null, null, null, null, true);
                // END of default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-)


                this.$ = {};
                break;

            case 7:
            /*! Production::    optional_action_header_block : optional_action_header_block ACTION */
            case 8:
                /*! Production::    optional_action_header_block : optional_action_header_block include_macro_code */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 1];
                var rv = checkActionBlock$2(yyvstack[yysp], yylstack[yysp]);
                if (rv) {
                    yyparser.yyError(rmCommonWS$4(_templateObject46, rv, yylexer.prettyPrintRange(yylstack[yysp])));
                }
                yy.addDeclaration(this.$, { actionInclude: yyvstack[yysp] });
                break;

            case 9:
                /*! Production::    declaration_list : declaration_list declaration */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 1];yy.addDeclaration(this.$, yyvstack[yysp]);
                break;

            case 11:
                /*! Production::    declaration_list : declaration_list error */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 1];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-)


                // TODO ...
                yyparser.yyError(rmCommonWS$4(_templateObject47, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 1])));
                break;

            case 12:
                /*! Production::    declaration : START id */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = { start: yyvstack[yysp] };
                break;

            case 13:
                /*! Production::    declaration : LEX_BLOCK */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = { lex: { text: yyvstack[yysp], position: yylstack[yysp] } };
                break;

            case 14:
                /*! Production::    declaration : operator */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = { operator: yyvstack[yysp] };
                break;

            case 15:
                /*! Production::    declaration : TOKEN full_token_definitions */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = { token_list: yyvstack[yysp] };
                break;

            case 16:
                /*! Production::    declaration : ACTION */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                var rv = checkActionBlock$2(yyvstack[yysp], yylstack[yysp]);
                if (rv) {
                    yyparser.yyError(rmCommonWS$4(_templateObject48, rv, yylexer.prettyPrintRange(yylstack[yysp])));
                }
                this.$ = { include: yyvstack[yysp] };
                break;

            case 17:
                /*! Production::    declaration : include_macro_code */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                var rv = checkActionBlock$2(yyvstack[yysp], yylstack[yysp]);
                if (rv) {
                    yyparser.yyError(rmCommonWS$4(_templateObject46, rv, yylexer.prettyPrintRange(yylstack[yysp])));
                }
                this.$ = { include: yyvstack[yysp] };
                break;

            case 18:
                /*! Production::    declaration : parse_params */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = { parseParams: yyvstack[yysp] };
                break;

            case 19:
                /*! Production::    declaration : parser_type */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = { parserType: yyvstack[yysp] };
                break;

            case 20:
                /*! Production::    declaration : options */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = { options: yyvstack[yysp] };
                break;

            case 21:
                /*! Production::    declaration : DEBUG */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = { options: [['debug', true]] };
                break;

            case 22:
                /*! Production::    declaration : EBNF */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                ebnf = true;
                this.$ = { options: [['ebnf', true]] };
                break;

            case 23:
                /*! Production::    declaration : UNKNOWN_DECL */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = { unknownDecl: yyvstack[yysp] };
                break;

            case 24:
                /*! Production::    declaration : IMPORT import_name import_path */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)


                this.$ = { imports: { name: yyvstack[yysp - 1], path: yyvstack[yysp] } };
                break;

            case 25:
                /*! Production::    declaration : IMPORT import_name error */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 2];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-)


                yyparser.yyError(rmCommonWS$4(_templateObject49, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 2])));
                break;

            case 26:
                /*! Production::    declaration : IMPORT error import_path */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 2];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-)


                yyparser.yyError(rmCommonWS$4(_templateObject50, yylexer.prettyPrintRange(yylstack[yysp - 1], yylstack[yysp - 2])));
                break;

            case 27:
                /*! Production::    declaration : INIT_CODE init_code_name action_ne */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)


                var rv = checkActionBlock$2(yyvstack[yysp], yylstack[yysp]);
                if (rv) {
                    yyparser.yyError(rmCommonWS$4(_templateObject51, $init_code_name, rv, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 2])));
                }
                this.$ = {
                    initCode: {
                        qualifier: yyvstack[yysp - 1],
                        include: yyvstack[yysp]
                    }
                };
                break;

            case 28:
                /*! Production::    declaration : INIT_CODE error action_ne */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 2];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-)


                yyparser.yyError(rmCommonWS$4(_templateObject52, yylexer.prettyPrintRange(yylstack[yysp - 1], yylstack[yysp - 2], yylstack[yysp])));
                break;

            case 29:
                /*! Production::    declaration : START error */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 1];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-)


                // TODO ...
                yyparser.yyError(rmCommonWS$4(_templateObject53, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 1])));
                break;

            case 30:
                /*! Production::    declaration : TOKEN error */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 1];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-)


                // TODO ...
                yyparser.yyError(rmCommonWS$4(_templateObject54, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 1])));
                break;

            case 31:
                /*! Production::    declaration : IMPORT error */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 1];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-)


                // TODO ...
                yyparser.yyError(rmCommonWS$4(_templateObject55, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 1])));
                break;

            case 32:
            /*! Production::    init_code_name : ID */
            case 33:
            /*! Production::    init_code_name : NAME */
            case 34:
            /*! Production::    init_code_name : STRING */
            case 35:
            /*! Production::    import_name : ID */
            case 36:
            /*! Production::    import_name : STRING */
            case 37:
            /*! Production::    import_path : ID */
            case 38:
            /*! Production::    import_path : STRING */
            case 67:
            /*! Production::    optional_token_type : TOKEN_TYPE */
            case 68:
            /*! Production::    token_value : INTEGER */
            case 69:
            /*! Production::    token_description : STRING */
            case 80:
            /*! Production::    optional_production_description : STRING */
            case 95:
            /*! Production::    expression : ID */
            case 101:
            /*! Production::    suffix : "*" */
            case 102:
            /*! Production::    suffix : "?" */
            case 103:
            /*! Production::    suffix : "+" */
            case 107:
            /*! Production::    symbol : id */
            case 108:
            /*! Production::    symbol : STRING */
            case 109:
            /*! Production::    id : ID */
            case 112:
            /*! Production::    action_ne : ACTION */
            case 113:
            /*! Production::    action_ne : include_macro_code */
            case 114:
            /*! Production::    action : action_ne */
            case 118:
            /*! Production::    action_body : action_comments_body */
            case 122:
            /*! Production::    action_comments_body : ACTION_BODY */
            case 124:
            /*! Production::    extra_parser_module_code : optional_module_code_chunk */
            case 128:
            /*! Production::    module_code_chunk : CODE */
            case 131:
                /*! Production::    optional_module_code_chunk : module_code_chunk */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp];
                break;

            case 39:
            /*! Production::    options : OPTIONS option_list OPTIONS_END */
            case 110:
                /*! Production::    action_ne : "{" action_body "}" */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 1];
                break;

            case 40:
                /*! Production::    options : OPTIONS error OPTIONS_END */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 2];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-)


                // TODO ...
                yyparser.yyError(rmCommonWS$4(_templateObject56, yylexer.prettyPrintRange(yylstack[yysp - 1], yylstack[yysp - 2], yylstack[yysp])));
                break;

            case 41:
                /*! Production::    options : OPTIONS error */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 1];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-)


                // TODO ...
                yyparser.yyError(rmCommonWS$4(_templateObject57, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 1])));
                break;

            case 42:
            /*! Production::    option_list : option_list option */
            case 59:
            /*! Production::    token_list : token_list symbol */
            case 70:
                /*! Production::    id_list : id_list id */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 1];this.$.push(yyvstack[yysp]);
                break;

            case 43:
            /*! Production::    option_list : option */
            case 60:
            /*! Production::    token_list : symbol */
            case 71:
            /*! Production::    id_list : id */
            case 83:
                /*! Production::    handle_list : handle_action */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = [yyvstack[yysp]];
                break;

            case 44:
                /*! Production::    option : NAME */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = [yyvstack[yysp], true];
                break;

            case 45:
                /*! Production::    option : NAME "=" OPTION_STRING_VALUE */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)


                this.$ = [yyvstack[yysp - 2], yyvstack[yysp]];
                break;

            case 46:
            /*! Production::    option : NAME "=" OPTION_VALUE */
            case 47:
                /*! Production::    option : NAME "=" NAME */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)


                this.$ = [yyvstack[yysp - 2], parseValue$1(yyvstack[yysp])];
                break;

            case 48:
                /*! Production::    option : NAME "=" error */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 2];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-)


                // TODO ...
                yyparser.yyError(rmCommonWS$4(_templateObject58, yyvstack[yysp - 2], yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 2])));
                break;

            case 49:
                /*! Production::    option : NAME error */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 1];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-)


                // TODO ...
                yyparser.yyError(rmCommonWS$4(_templateObject59, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 1])));
                break;

            case 50:
            /*! Production::    parse_params : PARSE_PARAM token_list */
            case 52:
                /*! Production::    parser_type : PARSER_TYPE symbol */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp];
                break;

            case 51:
                /*! Production::    parse_params : PARSE_PARAM error */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 1];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-)


                // TODO ...
                yyparser.yyError(rmCommonWS$4(_templateObject60, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 1])));
                break;

            case 53:
                /*! Production::    parser_type : PARSER_TYPE error */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 1];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-)


                // TODO ...
                yyparser.yyError(rmCommonWS$4(_templateObject61, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 1])));
                break;

            case 54:
                /*! Production::    operator : associativity token_list */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = [yyvstack[yysp - 1]];this.$.push.apply(this.$, yyvstack[yysp]);
                break;

            case 55:
                /*! Production::    operator : associativity error */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 1];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-)


                // TODO ...
                yyparser.yyError(rmCommonWS$4(_templateObject62, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 1])));
                break;

            case 56:
                /*! Production::    associativity : LEFT */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = 'left';
                break;

            case 57:
                /*! Production::    associativity : RIGHT */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = 'right';
                break;

            case 58:
                /*! Production::    associativity : NONASSOC */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = 'nonassoc';
                break;

            case 61:
                /*! Production::    full_token_definitions : optional_token_type id_list */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                var rv = [];
                var lst = yyvstack[yysp];
                for (var i = 0, len = lst.length; i < len; i++) {
                    var id = lst[i];
                    var m = { id: id };
                    if (yyvstack[yysp - 1]) {
                        m.type = yyvstack[yysp - 1];
                    }
                    rv.push(m);
                }
                this.$ = rv;
                break;

            case 62:
                /*! Production::    full_token_definitions : optional_token_type one_full_token */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                var m = yyvstack[yysp];
                if (yyvstack[yysp - 1]) {
                    m.type = yyvstack[yysp - 1];
                }
                this.$ = [m];
                break;

            case 63:
                /*! Production::    one_full_token : id token_value token_description */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)


                this.$ = {
                    id: yyvstack[yysp - 2],
                    value: yyvstack[yysp - 1],
                    description: yyvstack[yysp]
                };
                break;

            case 64:
                /*! Production::    one_full_token : id token_description */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = {
                    id: yyvstack[yysp - 1],
                    description: yyvstack[yysp]
                };
                break;

            case 65:
                /*! Production::    one_full_token : id token_value */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = {
                    id: yyvstack[yysp - 1],
                    value: yyvstack[yysp]
                };
                break;

            case 66:
                /*! Production::    optional_token_type : %epsilon */

                // default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(null, null, null, null, true);
                // END of default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-)


                this.$ = false;
                break;

            case 72:
                /*! Production::    grammar : optional_action_header_block production_list */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 1];
                this.$.grammar = yyvstack[yysp];
                break;

            case 73:
                /*! Production::    production_list : production_list production */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 1];
                if (yyvstack[yysp][0] in this.$) {
                    this.$[yyvstack[yysp][0]] = this.$[yyvstack[yysp][0]].concat(yyvstack[yysp][1]);
                } else {
                    this.$[yyvstack[yysp][0]] = yyvstack[yysp][1];
                }
                break;

            case 74:
                /*! Production::    production_list : production */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = {};this.$[yyvstack[yysp][0]] = yyvstack[yysp][1];
                break;

            case 75:
                /*! Production::    production : production_id handle_list ";" */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)


                this.$ = [yyvstack[yysp - 2], yyvstack[yysp - 1]];
                break;

            case 76:
                /*! Production::    production : production_id error ";" */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 2];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-)


                // TODO ...
                yyparser.yyError(rmCommonWS$4(_templateObject63, yylexer.prettyPrintRange(yylstack[yysp - 1], yylstack[yysp - 2])));
                break;

            case 77:
                /*! Production::    production : production_id error */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 1];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-)


                // TODO ...
                yyparser.yyError(rmCommonWS$4(_templateObject64, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 1])));
                break;

            case 78:
                /*! Production::    production_id : id optional_production_description ":" */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 2];

                // TODO: carry rule description support into the parser generator...
                break;

            case 79:
                /*! Production::    production_id : id optional_production_description error */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 2];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-)


                // TODO ...
                yyparser.yyError(rmCommonWS$4(_templateObject65, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 2])));
                break;

            case 81:
                /*! Production::    optional_production_description : %epsilon */

                // default action (generated by JISON mode classic/merge :: 0,VT,VA,-,-,LT,LA,-,-):
                this.$ = undefined;
                this._$ = yyparser.yyMergeLocationInfo(null, null, null, null, true);
                // END of default action (generated by JISON mode classic/merge :: 0,VT,VA,-,-,LT,LA,-,-)
                break;

            case 82:
                /*! Production::    handle_list : handle_list "|" handle_action */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 2];
                this.$.push(yyvstack[yysp]);
                break;

            case 84:
                /*! Production::    handle_list : handle_list "|" error */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 2];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-)


                // TODO ...
                yyparser.yyError(rmCommonWS$4(_templateObject66, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 2])));
                break;

            case 85:
                /*! Production::    handle_list : handle_list ":" error */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 2];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-)


                // TODO ...
                yyparser.yyError(rmCommonWS$4(_templateObject67, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 2])));
                break;

            case 86:
                /*! Production::    handle_action : handle prec action */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)


                this.$ = [yyvstack[yysp - 2].length ? yyvstack[yysp - 2].join(' ') : ''];
                if (yyvstack[yysp]) {
                    var rv = checkActionBlock$2(yyvstack[yysp], yylstack[yysp]);
                    if (rv) {
                        yyparser.yyError(rmCommonWS$4(_templateObject68, rv, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 2])));
                    }
                    this.$.push(yyvstack[yysp]);
                }
                if (yyvstack[yysp - 1]) {
                    if (yyvstack[yysp - 2].length === 0) {
                        yyparser.yyError(rmCommonWS$4(_templateObject69, yylexer.prettyPrintRange(yylstack[yysp - 2], yylstack[yysp - 3], yylstack[yysp] /* @handle is very probably NULL! We need this one for some decent location info! */)));
                    }
                    this.$.push(yyvstack[yysp - 1]);
                }
                if (this.$.length === 1) {
                    this.$ = this.$[0];
                }
                break;

            case 87:
                /*! Production::    handle_action : EPSILON action */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = [''];
                if (yyvstack[yysp]) {
                    var rv = checkActionBlock$2(yyvstack[yysp], yylstack[yysp]);
                    if (rv) {
                        yyparser.yyError(rmCommonWS$4(_templateObject70, rv, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 1])));
                    }
                    this.$.push(yyvstack[yysp]);
                }
                if (this.$.length === 1) {
                    this.$ = this.$[0];
                }
                break;

            case 88:
                /*! Production::    handle_action : EPSILON error */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 1];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-)


                // TODO ...
                yyparser.yyError(rmCommonWS$4(_templateObject71, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 1])));
                break;

            case 89:
                /*! Production::    handle : handle suffixed_expression */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 1];
                this.$.push(yyvstack[yysp]);
                break;

            case 90:
                /*! Production::    handle : %epsilon */

                // default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(null, null, null, null, true);
                // END of default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-)


                this.$ = [];
                break;

            case 91:
                /*! Production::    handle_sublist : handle_sublist "|" handle */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 2];
                this.$.push(yyvstack[yysp].join(' '));
                break;

            case 92:
                /*! Production::    handle_sublist : handle */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = [yyvstack[yysp].join(' ')];
                break;

            case 93:
                /*! Production::    suffixed_expression : expression suffix ALIAS */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 2] + yyvstack[yysp - 1] + "[" + yyvstack[yysp] + "]";
                break;

            case 94:
            /*! Production::    suffixed_expression : expression suffix */
            case 123:
            /*! Production::    action_comments_body : action_comments_body ACTION_BODY */
            case 129:
                /*! Production::    module_code_chunk : module_code_chunk CODE */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 1] + yyvstack[yysp];
                break;

            case 96:
                /*! Production::    expression : EOF_ID */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = '$end';
                break;

            case 97:
                /*! Production::    expression : STRING */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                // Re-encode the string *anyway* as it will
                // be made part of the rule rhs a.k.a. production (type: *string*) again and we want
                // to be able to handle all tokens, including *significant space*
                // encoded as literal tokens in a grammar such as this: `rule: A ' ' B`.
                this.$ = dquote$2(yyvstack[yysp]);
                break;

            case 98:
                /*! Production::    expression : "(" handle_sublist ")" */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)


                this.$ = '(' + yyvstack[yysp - 1].join(' | ') + ')';
                break;

            case 99:
                /*! Production::    expression : "(" handle_sublist error */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 2];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-)


                yyparser.yyError(rmCommonWS$4(_templateObject72, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 2])));
                break;

            case 104:
                /*! Production::    prec : PREC symbol */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                this.$ = { prec: yyvstack[yysp] };
                break;

            case 105:
                /*! Production::    prec : PREC error */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 1];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-)


                // TODO ...
                yyparser.yyError(rmCommonWS$4(_templateObject73, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 1])));
                break;

            case 106:
                /*! Production::    prec : %epsilon */

                // default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(null, null, null, null, true);
                // END of default action (generated by JISON mode classic/merge :: 0,VT,VA,VU,-,LT,LA,-,-)


                this.$ = null;
                break;

            case 111:
                /*! Production::    action_ne : "{" action_body error */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 2];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,-,-,LT,LA,-,-)


                yyparser.yyError(rmCommonWS$4(_templateObject74, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 2])));
                break;

            case 115:
                /*! Production::    action : ARROW_ACTION */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = '$$ = ' + yyvstack[yysp];
                break;

            case 119:
                /*! Production::    action_body : action_body "{" action_body "}" action_comments_body */

                // default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 4, yysp);
                // END of default action (generated by JISON mode classic/merge :: 5,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 4] + yyvstack[yysp - 3] + yyvstack[yysp - 2] + yyvstack[yysp - 1] + yyvstack[yysp];
                break;

            case 120:
                /*! Production::    action_body : action_body "{" action_body "}" */

                // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
                // END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 3] + yyvstack[yysp - 2] + yyvstack[yysp - 1] + yyvstack[yysp];
                break;

            case 121:
                /*! Production::    action_body : action_body "{" action_body error */

                // default action (generated by JISON mode classic/merge :: 4,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 3];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
                // END of default action (generated by JISON mode classic/merge :: 4,VT,VA,-,-,LT,LA,-,-)


                yyparser.yyError(rmCommonWS$4(_templateObject75, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 2])));
                break;

            case 125:
                /*! Production::    extra_parser_module_code : optional_module_code_chunk include_macro_code extra_parser_module_code */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 2] + yyvstack[yysp - 1] + yyvstack[yysp];
                break;

            case 126:
                /*! Production::    include_macro_code : INCLUDE PATH */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                var fileContent = fs.readFileSync(yyvstack[yysp], { encoding: 'utf-8' });
                var rv = checkActionBlock$2(fileContent);
                if (rv) {
                    yyparser.yyError(rmCommonWS$4(_templateObject76, $PATH, rv, yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 1])));
                }
                // And no, we don't support nested '%include':
                this.$ = '\n// Included by Jison: ' + yyvstack[yysp] + ':\n\n' + fileContent + '\n\n// End Of Include by Jison: ' + yyvstack[yysp] + '\n\n';
                break;

            case 127:
                /*! Production::    include_macro_code : INCLUDE error */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 1];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-)


                yyparser.yyError(rmCommonWS$4(_templateObject77) + yylexer.prettyPrintRange(yylstack[yysp], yylstack[yysp - 1]));
                break;

            case 130:
                /*! Production::    module_code_chunk : error */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp];
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,LT,LA,-,-)


                // TODO ...
                yyparser.yyError(rmCommonWS$4(_templateObject78) + yylexer.prettyPrintRange(yylstack[yysp]));
                break;

            case 164:
                // === NO_ACTION[1] :: ensures that anyone (but us) using this new state will fail dramatically!
                // error recovery reduction action (action generated by jison,
                // using the user-specified `%code error_recovery_reduction` %{...%}
                // code chunk below.


                break;

        }
    },
    table: bt$1({
        len: u$1([20, 1, 25, 5, 19, 18, 3, 18, 18, 5, s$1, [18, 8], 4, 5, 6, 2, s$1, [6, 4, -1], 3, 3, 4, 8, 1, 18, 18, 26, c$1, [18, 3], 1, 4, 21, 3, 3, 5, 5, s$1, [3, 3], 22, 18, 20, 25, 25, 24, 24, 22, s$1, [18, 3], 3, 19, 2, 4, 1, 1, 7, 7, c$1, [40, 3], 17, 4, 20, 18, 23, s$1, [18, 6], 6, 21, 21, 18, 20, 18, 2, 18, 4, 2, s$1, [1, 3], s$1, [3, 4], 4, 3, 5, 3, 15, 11, 2, 2, 19, 20, 18, c$1, [104, 3], 4, 4, s$1, [2, 4], 7, 3, 4, 16, 1, 4, 10, 14, c$1, [122, 3], 18, 18, 9, s$1, [3, 4], 14, 14, 18, 21, 21, 6, 4, c$1, [50, 5], 7, 7, s$1, [15, 4], 3, 9, 3, 14, 18, 18, 8, 5, 3, 9, 4]),
        symbol: u$1([2, s$1, [14, 10, 1], 27, s$1, [31, 5, 1], 44, 47, 50, 1, c$1, [21, 18], 51, 55, s$1, [58, 4, 1], 89, 15, 24, 44, 49, 69, c$1, [31, 19], c$1, [18, 19], 24, 83, c$1, [39, 38], 36, 63, 65, c$1, [41, 37], c$1, [18, 108], 24, 26, 53, 2, 24, 25, 26, 52, c$1, [9, 3], 62, 82, 83, 2, 45, c$1, [8, 7], 24, 26, c$1, [5, 3], 25, 56, 57, c$1, [9, 3], c$1, [3, 6], c$1, [266, 3], 48, c$1, [275, 3], 70, 71, 72, 83, 89, c$1, [278, 38], 4, 5, 6, 12, s$1, [14, 11, 1], 26, c$1, [24, 6], 37, 42, c$1, [152, 37], 24, 64, 68, 83, 24, c$1, [119, 3], 54, c$1, [27, 11], c$1, [67, 8], 44, 54, c$1, [147, 6], 12, 15, 44, 84, 89, c$1, [5, 8], c$1, [3, 6], c$1, [46, 20], c$1, [201, 3], c$1, [113, 28], c$1, [40, 9], c$1, [177, 23], c$1, [176, 3], c$1, [25, 24], 1, c$1, [26, 4], c$1, [25, 11], c$1, [73, 7], 46, c$1, [24, 24], c$1, [158, 51], c$1, [18, 25], 25, 28, 57, c$1, [21, 12], 28, c$1, [22, 8], 2, 3, 25, 28, s$1, [1, 3], 2, 44, 46, 88, 90, 91, c$1, [425, 3], 24, c$1, [433, 3], c$1, [440, 3], c$1, [3, 3], c$1, [13, 4], c$1, [153, 4], 7, 12, 15, 24, 26, 38, 40, 41, 42, 44, 74, 75, 76, 2, 5, 26, 73, c$1, [151, 12], c$1, [94, 7], c$1, [307, 38], 37, 44, 66, 67, c$1, [685, 109], 12, 13, 43, 86, 87, c$1, [349, 14], c$1, [445, 11], c$1, [84, 46], c$1, [504, 10], c$1, [348, 19], c$1, [58, 19], 25, 29, 30, c$1, [346, 5], 1, 44, 89, 1, c$1, [483, 3], c$1, [3, 6], c$1, [339, 3], c$1, [121, 3], c$1, [496, 3], c$1, [8, 5], c$1, [349, 8], c$1, [348, 4], 78, 79, 81, c$1, [568, 5], 15, 42, 44, 84, 85, 89, 2, 5, 2, 5, c$1, [359, 19], c$1, [19, 11], c$1, [142, 8], c$1, [337, 30], c$1, [180, 26], c$1, [284, 3], c$1, [287, 4], c$1, [4, 4], 25, 28, 25, 28, c$1, [4, 4], c$1, [517, 8], c$1, [168, 6], c$1, [507, 14], c$1, [506, 3], c$1, [189, 7], c$1, [162, 8], s$1, [4, 5, 1], c$1, [190, 8], c$1, [1024, 6], s$1, [4, 9, 1], c$1, [22, 3], s$1, [39, 4, 1], 44, 80, c$1, [19, 18], c$1, [18, 37], c$1, [16, 3], c$1, [88, 3], 76, 77, c$1, [292, 6], c$1, [3, 6], c$1, [144, 14], c$1, [14, 15], c$1, [480, 39], c$1, [21, 21], c$1, [549, 6], c$1, [6, 3], 1, c$1, [111, 12], c$1, [234, 7], c$1, [7, 7], c$1, [238, 10], c$1, [179, 11], c$1, [15, 40], 6, 8, c$1, [209, 7], 78, 79, c$1, [374, 4], c$1, [313, 14], c$1, [271, 43], c$1, [164, 4], c$1, [169, 4], c$1, [78, 12], 43]),
        type: u$1([s$1, [2, 18], 0, 0, 1, c$1, [21, 20], s$1, [0, 5], c$1, [10, 5], s$1, [2, 39], c$1, [40, 41], c$1, [41, 40], s$1, [2, 108], c$1, [148, 5], c$1, [239, 6], c$1, [159, 6], c$1, [253, 10], c$1, [176, 14], c$1, [36, 7], c$1, [197, 102], c$1, [103, 7], c$1, [108, 21], c$1, [21, 10], c$1, [423, 36], c$1, [373, 149], c$1, [158, 67], c$1, [57, 32], c$1, [322, 8], c$1, [98, 26], c$1, [489, 7], c$1, [721, 173], c$1, [462, 131], c$1, [130, 37], c$1, [375, 11], c$1, [818, 45], c$1, [223, 79], c$1, [124, 24], c$1, [986, 15], c$1, [38, 19], c$1, [57, 20], c$1, [157, 62], c$1, [443, 106], c$1, [106, 103], c$1, [103, 62], c$1, [1248, 16], c$1, [78, 6]]),
        state: u$1([1, 2, 5, 14, 12, 13, 8, 20, 11, 29, 28, 31, 34, 36, 38, 42, 47, 49, 50, 54, 49, 50, 56, 50, 58, 60, 62, 65, 68, 69, 70, 67, 72, 71, 73, 74, 78, 79, 82, 83, 82, 84, 50, 84, 50, 86, 92, 94, 93, 97, 69, 70, 98, 100, 101, 103, 105, 106, 107, 110, 111, 117, 124, 126, 123, 133, 131, 82, 137, 142, 94, 93, 143, 101, 133, 146, 82, 147, 50, 149, 154, 153, 155, 111, 124, 126, 162, 163, 124, 126]),
        mode: u$1([s$1, [2, 18], s$1, [1, 18], c$1, [21, 4], s$1, [2, 36], c$1, [42, 5], c$1, [38, 34], c$1, [77, 38], s$1, [2, 108], s$1, [1, 20], c$1, [30, 15], c$1, [134, 100], c$1, [106, 4], c$1, [335, 26], c$1, [151, 16], c$1, [376, 48], c$1, [347, 120], c$1, [63, 75], c$1, [13, 9], c$1, [23, 4], c$1, [4, 3], c$1, [587, 6], c$1, [427, 12], c$1, [9, 15], c$1, [335, 13], c$1, [389, 39], c$1, [45, 43], c$1, [509, 77], c$1, [762, 121], c$1, [129, 9], c$1, [756, 14], c$1, [334, 14], c$1, [41, 6], c$1, [367, 5], c$1, [784, 37], c$1, [208, 63], c$1, [1142, 20], c$1, [1081, 10], c$1, [487, 14], c$1, [22, 9], c$1, [151, 17], c$1, [221, 10], c$1, [803, 156], c$1, [318, 61], c$1, [216, 50], c$1, [457, 7], c$1, [455, 38], c$1, [123, 34], c$1, [1206, 8], 1]),
        goto: u$1([s$1, [10, 18], 4, 3, 10, 6, 7, 9, s$1, [15, 5, 1], 24, 22, 23, 25, 26, 27, 21, s$1, [6, 3], 30, s$1, [11, 18], s$1, [9, 18], 32, 33, s$1, [13, 18], s$1, [14, 18], 35, 66, 37, s$1, [16, 18], s$1, [17, 18], s$1, [18, 18], s$1, [19, 18], s$1, [20, 18], s$1, [21, 18], s$1, [22, 18], s$1, [23, 18], 39, 40, 41, s$1, [43, 4, 1], 48, 33, 51, 53, 52, 55, 33, 51, 57, 33, 51, 59, 61, s$1, [56, 3], s$1, [57, 3], s$1, [58, 3], 4, 63, 64, 66, 33, 21, 3, s$1, [12, 18], s$1, [29, 18], s$1, [109, 26], s$1, [15, 18], s$1, [30, 18], 33, 67, 75, 76, 77, s$1, [31, 11], c$1, [13, 9], s$1, [35, 3], s$1, [36, 3], 80, 81, 21, c$1, [3, 3], s$1, [32, 3], s$1, [33, 3], s$1, [34, 3], s$1, [54, 11], 33, 51, s$1, [54, 7], s$1, [55, 18], s$1, [60, 20], s$1, [107, 25], s$1, [108, 25], s$1, [126, 24], s$1, [127, 24], s$1, [50, 11], 33, 51, s$1, [50, 7], s$1, [51, 18], s$1, [52, 18], s$1, [53, 18], 61, 85, s$1, [41, 12], 87, s$1, [41, 6], 43, 43, 89, 88, 44, 44, 90, 91, 132, 96, 132, 95, s$1, [72, 3], 33, s$1, [7, 3], s$1, [8, 3], s$1, [74, 4], 99, s$1, [90, 8], 102, s$1, [90, 4], 81, 81, 104, s$1, [61, 11], 33, s$1, [61, 7], s$1, [62, 18], s$1, [71, 12], 109, s$1, [71, 6], 108, 71, s$1, [24, 18], s$1, [25, 18], s$1, [37, 18], s$1, [38, 18], s$1, [26, 18], s$1, [27, 18], s$1, [117, 3], s$1, [112, 22], s$1, [113, 21], s$1, [28, 18], s$1, [59, 20], s$1, [39, 18], 42, 42, s$1, [40, 18], 116, 115, 113, 114, 49, 49, 1, 2, 5, 124, 21, 131, 131, 118, s$1, [128, 3], s$1, [130, 3], s$1, [73, 4], 119, 121, 120, 77, 77, 122, 77, 77, s$1, [83, 3], s$1, [106, 3], 130, 106, 106, 127, 129, 128, 125, 106, 106, 132, s$1, [116, 3], 80, 81, 134, 21, 136, 135, 80, 80, s$1, [70, 19], s$1, [65, 11], 109, s$1, [65, 7], s$1, [64, 18], s$1, [68, 19], s$1, [69, 18], 139, 140, 138, s$1, [118, 3], 141, s$1, [122, 4], 45, 45, 46, 46, 47, 47, 48, 48, c$1, [494, 4], s$1, [129, 3], s$1, [75, 4], 144, c$1, [487, 13], 145, s$1, [76, 4], c$1, [153, 7], s$1, [89, 14], 148, 33, 51, s$1, [100, 6], 150, 151, 152, s$1, [100, 9], s$1, [95, 18], s$1, [96, 18], s$1, [97, 18], s$1, [90, 7], s$1, [87, 3], s$1, [88, 3], s$1, [114, 3], s$1, [115, 3], s$1, [78, 14], s$1, [79, 14], s$1, [63, 18], s$1, [110, 21], s$1, [111, 21], c$1, [526, 4], s$1, [123, 4], 125, s$1, [82, 3], s$1, [84, 3], s$1, [85, 3], s$1, [86, 3], s$1, [104, 7], s$1, [105, 7], s$1, [94, 10], 156, s$1, [94, 4], s$1, [101, 15], s$1, [102, 15], s$1, [103, 15], 158, 159, 157, 92, 92, 130, 92, c$1, [465, 3], 161, 140, 160, s$1, [93, 14], s$1, [98, 18], s$1, [99, 18], s$1, [90, 7], s$1, [120, 3], 112, s$1, [121, 3], 91, 91, 130, 91, c$1, [74, 3], s$1, [119, 3], 141])
    }),
    defaultActions: bda$1({
        idx: u$1([0, 3, 5, 7, 8, s$1, [10, 8, 1], 25, 26, 27, s$1, [30, 6, 1], 37, 40, 41, 44, 45, 46, s$1, [48, 6, 1], 55, 56, 57, 60, 66, 67, 68, 72, s$1, [74, 6, 1], s$1, [81, 7, 1], s$1, [89, 4, 1], 95, 96, 97, 100, 104, 105, 107, 108, 109, s$1, [112, 5, 1], 118, 119, 122, 124, s$1, [127, 13, 1], s$1, [141, 8, 1], 150, 151, 152, s$1, [156, 4, 1], 161]),
        goto: u$1([10, 6, 9, 13, 14, s$1, [16, 8, 1], 56, 57, 58, 3, 12, 29, 109, 15, 30, 67, 35, 36, 32, 33, 34, 55, 60, 107, 108, 126, 127, 51, 52, 53, 43, 7, 8, 74, 62, 24, 25, 37, 38, 26, 27, 112, 113, 28, 59, 39, 42, 40, 49, 1, 2, 5, 128, 130, 73, 83, 80, 70, 64, 68, 69, 122, s$1, [45, 4, 1], 129, 75, 76, 89, 95, 96, 97, 90, 87, 88, 114, 115, 78, 79, 63, 110, 111, 123, 125, 82, 84, 85, 86, 104, 105, 101, 102, 103, 93, 98, 99, 90, 121])
    }),
    parseError: function parseError(str, hash, ExceptionClass) {
        if (hash.recoverable) {
            if (typeof this.trace === 'function') {
                this.trace(str);
            }
            hash.destroy(); // destroy... well, *almost*!
        } else {
            if (typeof this.trace === 'function') {
                this.trace(str);
            }
            if (!ExceptionClass) {
                ExceptionClass = this.JisonParserError;
            }
            throw new ExceptionClass(str, hash);
        }
    },
    parse: function parse(input) {
        var self = this;
        var stack = new Array(128); // token stack: stores token which leads to state at the same index (column storage)
        var sstack = new Array(128); // state stack: stores states (column storage)

        var vstack = new Array(128); // semantic value stack
        var lstack = new Array(128); // location stack
        var table = this.table;
        var sp = 0; // 'stack pointer': index into the stacks
        var yyloc;

        var symbol = 0;
        var preErrorSymbol = 0;
        var lastEofErrorStateDepth = Infinity;
        var recoveringErrorInfo = null;
        var recovering = 0; // (only used when the grammar contains error recovery rules)
        var TERROR = this.TERROR;
        var EOF = this.EOF;
        var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = this.options.errorRecoveryTokenDiscardCount | 0 || 3;
        var NO_ACTION = [0, 164 /* === table.length :: ensures that anyone using this new state will fail dramatically! */];

        var lexer;
        if (this.__lexer__) {
            lexer = this.__lexer__;
        } else {
            lexer = this.__lexer__ = Object.create(this.lexer);
        }

        var sharedState_yy = {
            parseError: undefined,
            quoteName: undefined,
            lexer: undefined,
            parser: undefined,
            pre_parse: undefined,
            post_parse: undefined,
            pre_lex: undefined,
            post_lex: undefined // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!
        };

        var ASSERT;
        if (typeof assert$2 !== 'function') {
            ASSERT = function JisonAssert(cond, msg) {
                if (!cond) {
                    throw new Error('assertion failed: ' + (msg || '***'));
                }
            };
        } else {
            ASSERT = assert$2;
        }

        this.yyGetSharedState = function yyGetSharedState() {
            return sharedState_yy;
        };

        this.yyGetErrorInfoTrack = function yyGetErrorInfoTrack() {
            return recoveringErrorInfo;
        };

        // shallow clone objects, straight copy of simple `src` values
        // e.g. `lexer.yytext` MAY be a complex value object,
        // rather than a simple string/value.
        function shallow_copy(src) {
            if ((typeof src === 'undefined' ? 'undefined' : _typeof(src)) === 'object') {
                var dst = {};
                for (var k in src) {
                    if (Object.prototype.hasOwnProperty.call(src, k)) {
                        dst[k] = src[k];
                    }
                }
                return dst;
            }
            return src;
        }
        function shallow_copy_noclobber(dst, src) {
            for (var k in src) {
                if (typeof dst[k] === 'undefined' && Object.prototype.hasOwnProperty.call(src, k)) {
                    dst[k] = src[k];
                }
            }
        }
        function copy_yylloc(loc) {
            var rv = shallow_copy(loc);
            if (rv && rv.range) {
                rv.range = rv.range.slice(0);
            }
            return rv;
        }

        // copy state
        shallow_copy_noclobber(sharedState_yy, this.yy);

        sharedState_yy.lexer = lexer;
        sharedState_yy.parser = this;

        // *Always* setup `yyError`, `YYRECOVERING`, `yyErrOk` and `yyClearIn` functions as it is paramount
        // to have *their* closure match ours -- if we only set them up once,
        // any subsequent `parse()` runs will fail in very obscure ways when
        // these functions are invoked in the user action code block(s) as
        // their closure will still refer to the `parse()` instance which set
        // them up. Hence we MUST set them up at the start of every `parse()` run!
        if (this.yyError) {
            this.yyError = function yyError(str /*, ...args */) {

                var error_rule_depth = this.options.parserErrorsAreRecoverable ? locateNearestErrorRecoveryRule(state) : -1;
                var expected = this.collect_expected_token_set(state);
                var hash = this.constructParseErrorInfo(str, null, expected, error_rule_depth >= 0);
                // append to the old one?
                if (recoveringErrorInfo) {
                    var esp = recoveringErrorInfo.info_stack_pointer;

                    recoveringErrorInfo.symbol_stack[esp] = symbol;
                    var v = this.shallowCopyErrorInfo(hash);
                    v.yyError = true;
                    v.errorRuleDepth = error_rule_depth;
                    v.recovering = recovering;
                    // v.stackSampleLength = error_rule_depth + EXTRA_STACK_SAMPLE_DEPTH;

                    recoveringErrorInfo.value_stack[esp] = v;
                    recoveringErrorInfo.location_stack[esp] = copy_yylloc(lexer.yylloc);
                    recoveringErrorInfo.state_stack[esp] = newState || NO_ACTION[1];

                    ++esp;
                    recoveringErrorInfo.info_stack_pointer = esp;
                } else {
                    recoveringErrorInfo = this.shallowCopyErrorInfo(hash);
                    recoveringErrorInfo.yyError = true;
                    recoveringErrorInfo.errorRuleDepth = error_rule_depth;
                    recoveringErrorInfo.recovering = recovering;
                }

                // Add any extra args to the hash under the name `extra_error_attributes`:
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length) {
                    hash.extra_error_attributes = args;
                }

                var r = this.parseError(str, hash, this.JisonParserError);
                return r;
            };
        }

        // Does the shared state override the default `parseError` that already comes with this instance?
        if (typeof sharedState_yy.parseError === 'function') {
            this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {
                if (!ExceptionClass) {
                    ExceptionClass = this.JisonParserError;
                }
                return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);
            };
        } else {
            this.parseError = this.originalParseError;
        }

        // Does the shared state override the default `quoteName` that already comes with this instance?
        if (typeof sharedState_yy.quoteName === 'function') {
            this.quoteName = function quoteNameAlt(id_str) {
                return sharedState_yy.quoteName.call(this, id_str);
            };
        } else {
            this.quoteName = this.originalQuoteName;
        }

        // set up the cleanup function; make it an API so that external code can re-use this one in case of
        // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which
        // case this parse() API method doesn't come with a `finally { ... }` block any more!
        //
        // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
        //       or else your `sharedState`, etc. references will be *wrong*!
        this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {
            var rv;

            if (invoke_post_methods) {
                var hash;

                if (sharedState_yy.post_parse || this.post_parse) {
                    // create an error hash info instance: we re-use this API in a **non-error situation**
                    // as this one delivers all parser internals ready for access by userland code.
                    hash = this.constructParseErrorInfo(null /* no error! */, null /* no exception! */, null, false);
                }

                if (sharedState_yy.post_parse) {
                    rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);
                    if (typeof rv !== 'undefined') resultValue = rv;
                }
                if (this.post_parse) {
                    rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);
                    if (typeof rv !== 'undefined') resultValue = rv;
                }

                // cleanup:
                if (hash && hash.destroy) {
                    hash.destroy();
                }
            }

            if (this.__reentrant_call_depth > 1) return resultValue; // do not (yet) kill the sharedState when this is a reentrant run.

            // clean up the lingering lexer structures as well:
            if (lexer.cleanupAfterLex) {
                lexer.cleanupAfterLex(do_not_nuke_errorinfos);
            }

            // prevent lingering circular references from causing memory leaks:
            if (sharedState_yy) {
                sharedState_yy.lexer = undefined;
                sharedState_yy.parser = undefined;
                if (lexer.yy === sharedState_yy) {
                    lexer.yy = undefined;
                }
            }
            sharedState_yy = undefined;
            this.parseError = this.originalParseError;
            this.quoteName = this.originalQuoteName;

            // nuke the vstack[] array at least as that one will still reference obsoleted user values.
            // To be safe, we nuke the other internal stack columns as well...
            stack.length = 0; // fastest way to nuke an array without overly bothering the GC
            sstack.length = 0;
            lstack.length = 0;
            vstack.length = 0;
            sp = 0;

            // nuke the error hash info instances created during this run.
            // Userland code must COPY any data/references
            // in the error hash instance(s) it is more permanently interested in.
            if (!do_not_nuke_errorinfos) {
                for (var i = this.__error_infos.length - 1; i >= 0; i--) {
                    var el = this.__error_infos[i];
                    if (el && typeof el.destroy === 'function') {
                        el.destroy();
                    }
                }
                this.__error_infos.length = 0;

                for (var i = this.__error_recovery_infos.length - 1; i >= 0; i--) {
                    var el = this.__error_recovery_infos[i];
                    if (el && typeof el.destroy === 'function') {
                        el.destroy();
                    }
                }
                this.__error_recovery_infos.length = 0;

                // `recoveringErrorInfo` is also part of the `__error_recovery_infos` array,
                // hence has been destroyed already: no need to do that *twice*.
                if (recoveringErrorInfo) {
                    recoveringErrorInfo = undefined;
                }
            }

            return resultValue;
        };

        // merge yylloc info into a new yylloc instance.
        //
        // `first_index` and `last_index` MAY be UNDEFINED/NULL or these are indexes into the `lstack[]` location stack array.
        //
        // `first_yylloc` and `last_yylloc` MAY be UNDEFINED/NULL or explicit (custom or regular) `yylloc` instances, in which
        // case these override the corresponding first/last indexes.
        //
        // `dont_look_back` is an optional flag (default: FALSE), which instructs this merge operation NOT to search
        // through the parse location stack for a location, which would otherwise be used to construct the new (epsilon!)
        // yylloc info.
        //
        // Note: epsilon rule's yylloc situation is detected by passing both `first_index` and `first_yylloc` as UNDEFINED/NULL.
        this.yyMergeLocationInfo = function parser_yyMergeLocationInfo(first_index, last_index, first_yylloc, last_yylloc, dont_look_back) {
            var i1 = first_index | 0,
                i2 = last_index | 0;
            var l1 = first_yylloc,
                l2 = last_yylloc;
            var rv;

            // rules:
            // - first/last yylloc entries override first/last indexes

            if (!l1) {
                if (first_index != null) {
                    for (var i = i1; i <= i2; i++) {
                        l1 = lstack[i];
                        if (l1) {
                            break;
                        }
                    }
                }
            }

            if (!l2) {
                if (last_index != null) {
                    for (var i = i2; i >= i1; i--) {
                        l2 = lstack[i];
                        if (l2) {
                            break;
                        }
                    }
                }
            }

            // - detect if an epsilon rule is being processed and act accordingly:
            if (!l1 && first_index == null) {
                // epsilon rule span merger. With optional look-ahead in l2.
                if (!dont_look_back) {
                    for (var i = (i1 || sp) - 1; i >= 0; i--) {
                        l1 = lstack[i];
                        if (l1) {
                            break;
                        }
                    }
                }
                if (!l1) {
                    if (!l2) {
                        // when we still don't have any valid yylloc info, we're looking at an epsilon rule
                        // without look-ahead and no preceding terms and/or `dont_look_back` set:
                        // in that case we ca do nothing but return NULL/UNDEFINED:
                        return undefined;
                    } else {
                        // shallow-copy L2: after all, we MAY be looking
                        // at unconventional yylloc info objects...
                        rv = shallow_copy(l2);
                        if (rv.range) {
                            // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
                            rv.range = rv.range.slice(0);
                        }
                        return rv;
                    }
                } else {
                    // shallow-copy L1, then adjust first col/row 1 column past the end.
                    rv = shallow_copy(l1);
                    rv.first_line = rv.last_line;
                    rv.first_column = rv.last_column;
                    if (rv.range) {
                        // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
                        rv.range = rv.range.slice(0);
                        rv.range[0] = rv.range[1];
                    }

                    if (l2) {
                        // shallow-mixin L2, then adjust last col/row accordingly.
                        shallow_copy_noclobber(rv, l2);
                        rv.last_line = l2.last_line;
                        rv.last_column = l2.last_column;
                        if (rv.range && l2.range) {
                            rv.range[1] = l2.range[1];
                        }
                    }
                    return rv;
                }
            }

            if (!l1) {
                l1 = l2;
                l2 = null;
            }
            if (!l1) {
                return undefined;
            }

            // shallow-copy L1|L2, before we try to adjust the yylloc values: after all, we MAY be looking
            // at unconventional yylloc info objects...
            rv = shallow_copy(l1);

            // first_line: ...,
            // first_column: ...,
            // last_line: ...,
            // last_column: ...,
            if (rv.range) {
                // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
                rv.range = rv.range.slice(0);
            }

            if (l2) {
                shallow_copy_noclobber(rv, l2);
                rv.last_line = l2.last_line;
                rv.last_column = l2.last_column;
                if (rv.range && l2.range) {
                    rv.range[1] = l2.range[1];
                }
            }

            return rv;
        };

        // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
        //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!
        this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {
            var pei = {
                errStr: msg,
                exception: ex,
                text: lexer.match,
                value: lexer.yytext,
                token: this.describeSymbol(symbol) || symbol,
                token_id: symbol,
                line: lexer.yylineno,
                loc: copy_yylloc(lexer.yylloc),
                expected: expected,
                recoverable: recoverable,
                state: state,
                action: action,
                new_state: newState,
                symbol_stack: stack,
                state_stack: sstack,
                value_stack: vstack,
                location_stack: lstack,
                stack_pointer: sp,
                yy: sharedState_yy,
                lexer: lexer,
                parser: this,

                // and make sure the error info doesn't stay due to potential
                // ref cycle via userland code manipulations.
                // These would otherwise all be memory leak opportunities!
                //
                // Note that only array and object references are nuked as those
                // constitute the set of elements which can produce a cyclic ref.
                // The rest of the members is kept intact as they are harmless.
                destroy: function destructParseErrorInfo() {
                    // remove cyclic references added to error info:
                    // info.yy = null;
                    // info.lexer = null;
                    // info.value = null;
                    // info.value_stack = null;
                    // ...
                    var rec = !!this.recoverable;
                    for (var key in this) {
                        if (this.hasOwnProperty(key) && (typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {
                            this[key] = undefined;
                        }
                    }
                    this.recoverable = rec;
                }
            };
            // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
            this.__error_infos.push(pei);
            return pei;
        };

        // clone some parts of the (possibly enhanced!) errorInfo object
        // to give them some persistence.
        this.shallowCopyErrorInfo = function parser_shallowCopyErrorInfo(p) {
            var rv = shallow_copy(p);

            // remove the large parts which can only cause cyclic references
            // and are otherwise available from the parser kernel anyway.
            delete rv.sharedState_yy;
            delete rv.parser;
            delete rv.lexer;

            // lexer.yytext MAY be a complex value object, rather than a simple string/value:
            rv.value = shallow_copy(rv.value);

            // yylloc info:
            rv.loc = copy_yylloc(rv.loc);

            // the 'expected' set won't be modified, so no need to clone it:
            //rv.expected = rv.expected.slice(0);

            //symbol stack is a simple array:
            rv.symbol_stack = rv.symbol_stack.slice(0);
            // ditto for state stack:
            rv.state_stack = rv.state_stack.slice(0);
            // clone the yylloc's in the location stack?:
            rv.location_stack = rv.location_stack.map(copy_yylloc);
            // and the value stack may carry both simple and complex values:
            // shallow-copy the latter.
            rv.value_stack = rv.value_stack.map(shallow_copy);

            // and we don't bother with the sharedState_yy reference:
            //delete rv.yy;

            // now we prepare for tracking the COMBINE actions
            // in the error recovery code path:
            //
            // as we want to keep the maximum error info context, we
            // *scan* the state stack to find the first *empty* slot.
            // This position will surely be AT OR ABOVE the current
            // stack pointer, but we want to keep the 'used but discarded'
            // part of the parse stacks *intact* as those slots carry
            // error context that may be useful when you want to produce
            // very detailed error diagnostic reports.
            //
            // ### Purpose of each stack pointer:
            //
            // - stack_pointer: points at the top of the parse stack
            //                  **as it existed at the time of the error
            //                  occurrence, i.e. at the time the stack
            //                  snapshot was taken and copied into the
            //                  errorInfo object.**
            // - base_pointer:  the bottom of the **empty part** of the
            //                  stack, i.e. **the start of the rest of
            //                  the stack space /above/ the existing
            //                  parse stack. This section will be filled
            //                  by the error recovery process as it
            //                  travels the parse state machine to
            //                  arrive at the resolving error recovery rule.**
            // - info_stack_pointer:
            //                  this stack pointer points to the **top of
            //                  the error ecovery tracking stack space**, i.e.
            //                  this stack pointer takes up the role of
            //                  the `stack_pointer` for the error recovery
            //                  process. Any mutations in the **parse stack**
            //                  are **copy-appended** to this part of the
            //                  stack space, keeping the bottom part of the
            //                  stack (the 'snapshot' part where the parse
            //                  state at the time of error occurrence was kept)
            //                  intact.
            // - root_failure_pointer:
            //                  copy of the `stack_pointer`...
            //
            for (var i = rv.stack_pointer; typeof rv.state_stack[i] !== 'undefined'; i++) {
                // empty
            }
            rv.base_pointer = i;
            rv.info_stack_pointer = i;

            rv.root_failure_pointer = rv.stack_pointer;

            // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
            this.__error_recovery_infos.push(rv);

            return rv;
        };

        function stdLex() {
            var token = lexer.lex();
            // if token isn't its numeric value, convert
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }

            return token || EOF;
        }

        function fastLex() {
            var token = lexer.fastLex();
            // if token isn't its numeric value, convert
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }

            return token || EOF;
        }

        var lex = stdLex;

        var state, action, r, t;
        var yyval = {
            $: true,
            _$: undefined,
            yy: sharedState_yy
        };
        var p;
        var yyrulelen;
        var this_production;
        var newState;
        var retval = false;

        // Return the rule stack depth where the nearest error rule can be found.
        // Return -1 when no error recovery rule was found.
        function locateNearestErrorRecoveryRule(state) {
            var stack_probe = sp - 1;
            var depth = 0;

            // try to recover from error
            while (stack_probe >= 0) {
                // check for error recovery rule in this state


                var t = table[state][TERROR] || NO_ACTION;
                if (t[0]) {
                    // We need to make sure we're not cycling forever:
                    // once we hit EOF, even when we `yyerrok()` an error, we must
                    // prevent the core from running forever,
                    // e.g. when parent rules are still expecting certain input to
                    // follow after this, for example when you handle an error inside a set
                    // of braces which are matched by a parent rule in your grammar.
                    //
                    // Hence we require that every error handling/recovery attempt
                    // *after we've hit EOF* has a diminishing state stack: this means
                    // we will ultimately have unwound the state stack entirely and thus
                    // terminate the parse in a controlled fashion even when we have
                    // very complex error/recovery code interplay in the core + user
                    // action code blocks:


                    if (symbol === EOF) {
                        if (lastEofErrorStateDepth > sp - 1 - depth) {
                            lastEofErrorStateDepth = sp - 1 - depth;
                        } else {

                            --stack_probe; // popStack(1): [symbol, action]
                            state = sstack[stack_probe];
                            ++depth;
                            continue;
                        }
                    }
                    return depth;
                }
                if (state === 0 /* $accept rule */ || stack_probe < 1) {

                    return -1; // No suitable error recovery rule available.
                }
                --stack_probe; // popStack(1): [symbol, action]
                state = sstack[stack_probe];
                ++depth;
            }

            return -1; // No suitable error recovery rule available.
        }

        try {
            this.__reentrant_call_depth++;

            lexer.setInput(input, sharedState_yy);

            // NOTE: we *assume* no lexer pre/post handlers are set up *after* 
            // this initial `setInput()` call: hence we can now check and decide
            // whether we'll go with the standard, slower, lex() API or the
            // `fast_lex()` one:
            if (typeof lexer.canIUse === 'function') {
                var lexerInfo = lexer.canIUse();
                if (lexerInfo.fastLex && typeof fastLex === 'function') {
                    lex = fastLex;
                }
            }

            yyloc = lexer.yylloc;
            lstack[sp] = yyloc;
            vstack[sp] = null;
            sstack[sp] = 0;
            stack[sp] = 0;
            ++sp;

            if (this.pre_parse) {
                this.pre_parse.call(this, sharedState_yy);
            }
            if (sharedState_yy.pre_parse) {
                sharedState_yy.pre_parse.call(this, sharedState_yy);
            }

            newState = sstack[sp - 1];
            for (;;) {
                // retrieve state number from top of stack
                state = newState; // sstack[sp - 1];

                // use default actions if available
                if (this.defaultActions[state]) {
                    action = 2;
                    newState = this.defaultActions[state];
                } else {
                    // The single `==` condition below covers both these `===` comparisons in a single
                    // operation:
                    //
                    //     if (symbol === null || typeof symbol === 'undefined') ...
                    if (!symbol) {
                        symbol = lex();
                    }
                    // read action for current state and first input
                    t = table[state] && table[state][symbol] || NO_ACTION;
                    newState = t[1];
                    action = t[0];

                    // handle parse error
                    if (!action) {
                        // first see if there's any chance at hitting an error recovery rule:
                        var error_rule_depth = locateNearestErrorRecoveryRule(state);
                        var errStr = null;
                        var errSymbolDescr = this.describeSymbol(symbol) || symbol;
                        var expected = this.collect_expected_token_set(state);

                        if (!recovering) {
                            // Report error
                            if (typeof lexer.yylineno === 'number') {
                                errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';
                            } else {
                                errStr = 'Parse error: ';
                            }

                            if (typeof lexer.showPosition === 'function') {
                                errStr += '\n' + lexer.showPosition(79 - 10, 10) + '\n';
                            }
                            if (expected.length) {
                                errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;
                            } else {
                                errStr += 'Unexpected ' + errSymbolDescr;
                            }

                            p = this.constructParseErrorInfo(errStr, null, expected, error_rule_depth >= 0);

                            // DO NOT cleanup the old one before we start the new error info track:
                            // the old one will *linger* on the error stack and stay alive until we 
                            // invoke the parser's cleanup API!
                            recoveringErrorInfo = this.shallowCopyErrorInfo(p);

                            r = this.parseError(p.errStr, p, this.JisonParserError);

                            // Protect against overly blunt userland `parseError` code which *sets*
                            // the `recoverable` flag without properly checking first:
                            // we always terminate the parse when there's no recovery rule available anyhow!
                            if (!p.recoverable || error_rule_depth < 0) {
                                if (typeof r !== 'undefined') {
                                    retval = r;
                                }
                                break;
                            } else {
                                // TODO: allow parseError callback to edit symbol and or state at the start of the error recovery process...
                            }
                        }

                        var esp = recoveringErrorInfo.info_stack_pointer;

                        // just recovered from another error
                        if (recovering === ERROR_RECOVERY_TOKEN_DISCARD_COUNT && error_rule_depth >= 0) {
                            // SHIFT current lookahead and grab another
                            recoveringErrorInfo.symbol_stack[esp] = symbol;
                            recoveringErrorInfo.value_stack[esp] = shallow_copy(lexer.yytext);
                            recoveringErrorInfo.location_stack[esp] = copy_yylloc(lexer.yylloc);
                            recoveringErrorInfo.state_stack[esp] = newState; // push state
                            ++esp;

                            // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:


                            yyloc = lexer.yylloc;

                            preErrorSymbol = 0;
                            symbol = lex();
                        }

                        // try to recover from error
                        if (error_rule_depth < 0) {
                            ASSERT(recovering > 0, "line 897");
                            recoveringErrorInfo.info_stack_pointer = esp;

                            // barf a fatal hairball when we're out of look-ahead symbols and none hit a match
                            // while we are still busy recovering from another error:
                            var po = this.__error_infos[this.__error_infos.length - 1];

                            // Report error
                            if (typeof lexer.yylineno === 'number') {
                                errStr = 'Parsing halted on line ' + (lexer.yylineno + 1) + ' while starting to recover from another error';
                            } else {
                                errStr = 'Parsing halted while starting to recover from another error';
                            }

                            if (po) {
                                errStr += ' -- previous error which resulted in this fatal result: ' + po.errStr;
                            } else {
                                errStr += ': ';
                            }

                            if (typeof lexer.showPosition === 'function') {
                                errStr += '\n' + lexer.showPosition(79 - 10, 10) + '\n';
                            }
                            if (expected.length) {
                                errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;
                            } else {
                                errStr += 'Unexpected ' + errSymbolDescr;
                            }

                            p = this.constructParseErrorInfo(errStr, null, expected, false);
                            if (po) {
                                p.extra_error_attributes = po;
                            }

                            r = this.parseError(p.errStr, p, this.JisonParserError);
                            if (typeof r !== 'undefined') {
                                retval = r;
                            }
                            break;
                        }

                        preErrorSymbol = symbol === TERROR ? 0 : symbol; // save the lookahead token
                        symbol = TERROR; // insert generic error symbol as new lookahead

                        var EXTRA_STACK_SAMPLE_DEPTH = 3;

                        // REDUCE/COMBINE the pushed terms/tokens to a new ERROR token:
                        recoveringErrorInfo.symbol_stack[esp] = preErrorSymbol;
                        if (errStr) {
                            recoveringErrorInfo.value_stack[esp] = {
                                yytext: shallow_copy(lexer.yytext),
                                errorRuleDepth: error_rule_depth,
                                errStr: errStr,
                                errorSymbolDescr: errSymbolDescr,
                                expectedStr: expected,
                                stackSampleLength: error_rule_depth + EXTRA_STACK_SAMPLE_DEPTH
                            };
                        } else {
                            recoveringErrorInfo.value_stack[esp] = {
                                yytext: shallow_copy(lexer.yytext),
                                errorRuleDepth: error_rule_depth,
                                stackSampleLength: error_rule_depth + EXTRA_STACK_SAMPLE_DEPTH
                            };
                        }
                        recoveringErrorInfo.location_stack[esp] = copy_yylloc(lexer.yylloc);
                        recoveringErrorInfo.state_stack[esp] = newState || NO_ACTION[1];

                        ++esp;
                        recoveringErrorInfo.info_stack_pointer = esp;

                        yyval.$ = recoveringErrorInfo;
                        yyval._$ = undefined;

                        yyrulelen = error_rule_depth;

                        r = this.performAction.call(yyval, yyloc, NO_ACTION[1], sp - 1, vstack, lstack);

                        if (typeof r !== 'undefined') {
                            retval = r;
                            break;
                        }

                        // pop off stack
                        sp -= yyrulelen;

                        // and move the top entries + discarded part of the parse stacks onto the error info stack:
                        for (var idx = sp - EXTRA_STACK_SAMPLE_DEPTH, top = idx + yyrulelen; idx < top; idx++, esp++) {
                            recoveringErrorInfo.symbol_stack[esp] = stack[idx];
                            recoveringErrorInfo.value_stack[esp] = shallow_copy(vstack[idx]);
                            recoveringErrorInfo.location_stack[esp] = copy_yylloc(lstack[idx]);
                            recoveringErrorInfo.state_stack[esp] = sstack[idx];
                        }

                        recoveringErrorInfo.symbol_stack[esp] = TERROR;
                        recoveringErrorInfo.value_stack[esp] = shallow_copy(yyval.$);
                        recoveringErrorInfo.location_stack[esp] = copy_yylloc(yyval._$);

                        // goto new state = table[STATE][NONTERMINAL]
                        newState = sstack[sp - 1];

                        if (this.defaultActions[newState]) {
                            recoveringErrorInfo.state_stack[esp] = this.defaultActions[newState];
                        } else {
                            t = table[newState] && table[newState][symbol] || NO_ACTION;
                            recoveringErrorInfo.state_stack[esp] = t[1];
                        }

                        ++esp;
                        recoveringErrorInfo.info_stack_pointer = esp;

                        // allow N (default: 3) real symbols to be shifted before reporting a new error
                        recovering = ERROR_RECOVERY_TOKEN_DISCARD_COUNT;

                        // Now duplicate the standard parse machine here, at least its initial
                        // couple of rounds until the TERROR symbol is **pushed onto the parse stack**,
                        // as we wish to push something special then!
                        //
                        // Run the state machine in this copy of the parser state machine
                        // until we *either* consume the error symbol (and its related information)
                        // *or* we run into another error while recovering from this one
                        // *or* we execute a `reduce` action which outputs a final parse
                        // result (yes, that MAY happen!).
                        //
                        // We stay in this secondary parse loop until we have completed
                        // the *error recovery phase* as the main parse loop (further below)
                        // is optimized for regular parse operation and DOES NOT cope with
                        // error recovery *at all*.
                        //
                        // We call the secondary parse loop just below the "slow parse loop",
                        // while the main parse loop, which is an almost-duplicate of this one,
                        // yet optimized for regular parse operation, is called the "fast
                        // parse loop".
                        //
                        // Compare this to `bison` & (vanilla) `jison`, both of which have
                        // only a single parse loop, which handles everything. Our goal is
                        // to eke out every drop of performance in the main parse loop...

                        ASSERT(recoveringErrorInfo, "line 1049");
                        ASSERT(symbol === TERROR, "line 1050");
                        ASSERT(!action, "line 1051");
                        var errorSymbolFromParser = true;
                        for (;;) {
                            // retrieve state number from top of stack
                            state = newState; // sstack[sp - 1];

                            // use default actions if available
                            if (this.defaultActions[state]) {
                                action = 2;
                                newState = this.defaultActions[state];
                            } else {
                                // The single `==` condition below covers both these `===` comparisons in a single
                                // operation:
                                //
                                //     if (symbol === null || typeof symbol === 'undefined') ...
                                if (!symbol) {
                                    symbol = lex();
                                    // **Warning: Edge Case**: the *lexer* may produce
                                    // TERROR tokens of its own volition: *those* TERROR
                                    // tokens should be treated like *regular tokens*
                                    // i.e. tokens which have a lexer-provided `yyvalue`
                                    // and `yylloc`:
                                    errorSymbolFromParser = false;
                                }
                                // read action for current state and first input
                                t = table[state] && table[state][symbol] || NO_ACTION;
                                newState = t[1];
                                action = t[0];

                                // encountered another parse error? If so, break out to main loop
                                // and take it from there!
                                if (!action) {

                                    ASSERT(recoveringErrorInfo, "line 1087");

                                    // Prep state variables so that upon breaking out of
                                    // this "slow parse loop" and hitting the `continue;`
                                    // statement in the outer "fast parse loop" we redo
                                    // the exact same state table lookup as the one above
                                    // so that the outer=main loop will also correctly
                                    // detect the 'parse error' state (`!action`) we have
                                    // just encountered above.
                                    newState = state;
                                    break;
                                }
                            }

                            switch (action) {
                                // catch misc. parse failures:
                                default:
                                    // this shouldn't happen, unless resolve defaults are off
                                    //
                                    // SILENTLY SIGNAL that the outer "fast parse loop" should
                                    // take care of this internal error condition:
                                    // prevent useless code duplication now/here.
                                    break;

                                // shift:
                                case 1:
                                    stack[sp] = symbol;
                                    // ### Note/Warning ###
                                    //
                                    // The *lexer* may also produce TERROR tokens on its own,
                                    // so we specifically test for the TERROR we did set up
                                    // in the error recovery logic further above!
                                    if (symbol === TERROR && errorSymbolFromParser) {
                                        // Push a special value onto the stack when we're
                                        // shifting the `error` symbol that is related to the
                                        // error we're recovering from.
                                        ASSERT(recoveringErrorInfo, "line 1131");
                                        vstack[sp] = recoveringErrorInfo;
                                        lstack[sp] = this.yyMergeLocationInfo(null, null, recoveringErrorInfo.loc, lexer.yylloc, true);
                                    } else {
                                        ASSERT(symbol !== 0, "line 1135");
                                        ASSERT(preErrorSymbol === 0, "line 1136");
                                        vstack[sp] = lexer.yytext;
                                        lstack[sp] = copy_yylloc(lexer.yylloc);
                                    }
                                    sstack[sp] = newState; // push state

                                    ++sp;
                                    symbol = 0;
                                    // **Warning: Edge Case**: the *lexer* may have produced
                                    // TERROR tokens of its own volition: *those* TERROR
                                    // tokens should be treated like *regular tokens*
                                    // i.e. tokens which have a lexer-provided `yyvalue`
                                    // and `yylloc`:
                                    errorSymbolFromParser = false;
                                    if (!preErrorSymbol) {
                                        // normal execution / no error
                                        // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:


                                        yyloc = lexer.yylloc;

                                        if (recovering > 0) {
                                            recovering--;
                                        }
                                    } else {
                                        // error just occurred, resume old lookahead f/ before error, *unless* that drops us straight back into error mode:
                                        ASSERT(recovering > 0, "line 1163");
                                        symbol = preErrorSymbol;
                                        preErrorSymbol = 0;

                                        // read action for current state and first input
                                        t = table[newState] && table[newState][symbol] || NO_ACTION;
                                        if (!t[0] || symbol === TERROR) {
                                            // forget about that symbol and move forward: this wasn't a 'forgot to insert' error type where
                                            // (simple) stuff might have been missing before the token which caused the error we're
                                            // recovering from now...
                                            //
                                            // Also check if the LookAhead symbol isn't the ERROR token we set as part of the error
                                            // recovery, for then this we would we idling (cycling) on the error forever.
                                            // Yes, this does not take into account the possibility that the *lexer* may have
                                            // produced a *new* TERROR token all by itself, but that would be a very peculiar grammar!


                                            symbol = 0;
                                        }
                                    }

                                    // once we have pushed the special ERROR token value,
                                    // we REMAIN in this inner, "slow parse loop" until
                                    // the entire error recovery phase has completed.
                                    //
                                    // ### Note About Edge Case ###
                                    //
                                    // Userland action code MAY already have 'reset' the
                                    // error recovery phase marker `recovering` to ZERO(0)
                                    // while the error symbol hasn't been shifted onto
                                    // the stack yet. Hence we only exit this "slow parse loop"
                                    // when *both* conditions are met!
                                    ASSERT(preErrorSymbol === 0, "line 1194");
                                    if (recovering === 0) {
                                        break;
                                    }
                                    continue;

                                // reduce:
                                case 2:
                                    this_production = this.productions_[newState - 1]; // `this.productions_[]` is zero-based indexed while states start from 1 upwards...
                                    yyrulelen = this_production[1];

                                    r = this.performAction.call(yyval, yyloc, newState, sp - 1, vstack, lstack);

                                    if (typeof r !== 'undefined') {
                                        // signal end of error recovery loop AND end of outer parse loop
                                        action = 3;
                                        sp = -2; // magic number: signal outer "fast parse loop" ACCEPT state that we already have a properly set up `retval` parser return value.
                                        retval = r;
                                        break;
                                    }

                                    // pop off stack
                                    sp -= yyrulelen;

                                    // don't overwrite the `symbol` variable: use a local var to speed things up:
                                    var ntsymbol = this_production[0]; // push nonterminal (reduce)
                                    stack[sp] = ntsymbol;
                                    vstack[sp] = yyval.$;
                                    lstack[sp] = yyval._$;
                                    // goto new state = table[STATE][NONTERMINAL]
                                    newState = table[sstack[sp - 1]][ntsymbol];
                                    sstack[sp] = newState;
                                    ++sp;

                                    continue;

                                // accept:
                                case 3:
                                    retval = true;
                                    // Return the `$accept` rule's `$$` result, if available.
                                    //
                                    // Also note that JISON always adds this top-most `$accept` rule (with implicit,
                                    // default, action):
                                    //
                                    //     $accept: <startSymbol> $end
                                    //                  %{ $$ = $1; @$ = @1; %}
                                    //
                                    // which, combined with the parse kernel's `$accept` state behaviour coded below,
                                    // will produce the `$$` value output of the <startSymbol> rule as the parse result,
                                    // IFF that result is *not* `undefined`. (See also the parser kernel code.)
                                    //
                                    // In code:
                                    //
                                    //                  %{
                                    //                      @$ = @1;            // if location tracking support is included
                                    //                      if (typeof $1 !== 'undefined')
                                    //                          return $1;
                                    //                      else
                                    //                          return true;           // the default parse result if the rule actions don't produce anything
                                    //                  %}
                                    sp--;
                                    if (sp >= 0 && typeof vstack[sp] !== 'undefined') {
                                        retval = vstack[sp];
                                    }
                                    sp = -2; // magic number: signal outer "fast parse loop" ACCEPT state that we already have a properly set up `retval` parser return value.
                                    break;
                            }

                            // break out of loop: we accept or fail with error
                            break;
                        }

                        // should we also break out of the regular/outer parse loop,
                        // i.e. did the parser already produce a parse result in here?!
                        // *or* did we hit an unsupported parse state, to be handled
                        // in the `switch/default` code further below?
                        ASSERT(action !== 2, "line 1272");
                        if (action === 0 || action === 1) {
                            continue;
                        }
                    }
                }

                switch (action) {
                    // catch misc. parse failures:
                    default:
                        // this shouldn't happen, unless resolve defaults are off
                        if (action instanceof Array) {
                            p = this.constructParseErrorInfo('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, null, null, false);
                            r = this.parseError(p.errStr, p, this.JisonParserError);
                            if (typeof r !== 'undefined') {
                                retval = r;
                            }
                            break;
                        }
                        // Another case of better safe than sorry: in case state transitions come out of another error recovery process
                        // or a buggy LUT (LookUp Table):
                        p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);
                        r = this.parseError(p.errStr, p, this.JisonParserError);
                        if (typeof r !== 'undefined') {
                            retval = r;
                        }
                        break;

                    // shift:
                    case 1:
                        stack[sp] = symbol;
                        vstack[sp] = lexer.yytext;
                        lstack[sp] = copy_yylloc(lexer.yylloc);
                        sstack[sp] = newState; // push state

                        ++sp;
                        symbol = 0;

                        ASSERT(preErrorSymbol === 0, "line 1352"); // normal execution / no error
                        ASSERT(recovering === 0, "line 1353"); // normal execution / no error

                        // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:


                        yyloc = lexer.yylloc;
                        continue;

                    // reduce:
                    case 2:
                        ASSERT(preErrorSymbol === 0, "line 1364"); // normal execution / no error
                        ASSERT(recovering === 0, "line 1365"); // normal execution / no error

                        this_production = this.productions_[newState - 1]; // `this.productions_[]` is zero-based indexed while states start from 1 upwards...
                        yyrulelen = this_production[1];

                        r = this.performAction.call(yyval, yyloc, newState, sp - 1, vstack, lstack);

                        if (typeof r !== 'undefined') {
                            retval = r;
                            break;
                        }

                        // pop off stack
                        sp -= yyrulelen;

                        // don't overwrite the `symbol` variable: use a local var to speed things up:
                        var ntsymbol = this_production[0]; // push nonterminal (reduce)
                        stack[sp] = ntsymbol;
                        vstack[sp] = yyval.$;
                        lstack[sp] = yyval._$;
                        // goto new state = table[STATE][NONTERMINAL]
                        newState = table[sstack[sp - 1]][ntsymbol];
                        sstack[sp] = newState;
                        ++sp;

                        continue;

                    // accept:
                    case 3:
                        if (sp !== -2) {
                            retval = true;
                            // Return the `$accept` rule's `$$` result, if available.
                            //
                            // Also note that JISON always adds this top-most `$accept` rule (with implicit,
                            // default, action):
                            //
                            //     $accept: <startSymbol> $end
                            //                  %{ $$ = $1; @$ = @1; %}
                            //
                            // which, combined with the parse kernel's `$accept` state behaviour coded below,
                            // will produce the `$$` value output of the <startSymbol> rule as the parse result,
                            // IFF that result is *not* `undefined`. (See also the parser kernel code.)
                            //
                            // In code:
                            //
                            //                  %{
                            //                      @$ = @1;            // if location tracking support is included
                            //                      if (typeof $1 !== 'undefined')
                            //                          return $1;
                            //                      else
                            //                          return true;           // the default parse result if the rule actions don't produce anything
                            //                  %}
                            sp--;
                            if (typeof vstack[sp] !== 'undefined') {
                                retval = vstack[sp];
                            }
                        }
                        break;
                }

                // break out of loop: we accept or fail with error
                break;
            }
        } catch (ex) {
            // report exceptions through the parseError callback too, but keep the exception intact
            // if it is a known parser or lexer error which has been thrown by parseError() already:
            if (ex instanceof this.JisonParserError) {
                throw ex;
            } else if (lexer && typeof lexer.JisonLexerError === 'function' && ex instanceof lexer.JisonLexerError) {
                throw ex;
            } else {
                p = this.constructParseErrorInfo('Parsing aborted due to exception.', ex, null, false);
                retval = false;
                r = this.parseError(p.errStr, p, this.JisonParserError);
                if (typeof r !== 'undefined') {
                    retval = r;
                }
            }
        } finally {
            retval = this.cleanupAfterParse(retval, true, true);
            this.__reentrant_call_depth--;
        } // /finally

        return retval;
    },
    yyError: 1
};
parser$2.originalParseError = parser$2.parseError;
parser$2.originalQuoteName = parser$2.quoteName;
/* lexer generated by jison-lex 0.6.1-210 */

/*
 * Returns a Lexer object of the following structure:
 *
 *  Lexer: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a direct reference!
 *
 *               This "shared context" object was passed to the lexer by way of 
 *               the `lexer.setInput(str, yy)` API before you may use it.
 *
 *               This "shared context" object is passed to the lexer action code in `performAction()`
 *               so userland code in the lexer actions may communicate with the outside world 
 *               and/or other lexer rules' actions in more or less complex ways.
 *
 *  }
 *
 *  Lexer.prototype: {
 *    EOF: 1,
 *    ERROR: 2,
 *
 *    yy:        The overall "shared context" object reference.
 *
 *    JisonLexerError: function(msg, hash),
 *
 *    performAction: function lexer__performAction(yy, yyrulenumber, YY_START),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `lexer` instance. 
 *                               `yy_` is an alias for `this` lexer instance reference used internally.
 *
 *               - `yy`      : a reference to the `yy` "shared state" object which was passed to the lexer
 *                             by way of the `lexer.setInput(str, yy)` API before.
 *
 *                             Note:
 *                             The extra arguments you specified in the `%parse-param` statement in your
 *                             **parser** grammar definition file are passed to the lexer via this object
 *                             reference as member variables.
 *
 *               - `yyrulenumber`   : index of the matched lexer rule (regex), used internally.
 *
 *               - `YY_START`: the current lexer "start condition" state.
 *
 *    parseError: function(str, hash, ExceptionClass),
 *
 *    constructLexErrorInfo: function(error_message, is_recoverable),
 *               Helper function.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this lexer kernel in many places; example usage:
 *
 *                   var infoObj = lexer.constructParseErrorInfo('fail!', true);
 *                   var retVal = lexer.parseError(infoObj.errStr, infoObj, lexer.JisonLexerError);
 *
 *    options: { ... lexer %options ... },
 *
 *    lex: function(),
 *               Produce one token of lexed input, which was passed in earlier via the `lexer.setInput()` API.
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of the **lexer** grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Lexer's additional `args...` parameters (via lexer's `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the **parser** or the jison run-time; 
 *               when such a collision is detected an exception is thrown to prevent the generated run-time 
 *               from silently accepting this confusing and potentially hazardous situation! 
 *
 *    cleanupAfterLex: function(do_not_nuke_errorinfos),
 *               Helper function.
 *
 *               This helper API is invoked when the **parse process** has completed: it is the responsibility
 *               of the **parser** (or the calling userland code) to invoke this method once cleanup is desired. 
 *
 *               This helper may be invoked by user code to ensure the internal lexer gets properly garbage collected.
 *
 *    setInput: function(input, [yy]),
 *
 *
 *    input: function(),
 *
 *
 *    unput: function(str),
 *
 *
 *    more: function(),
 *
 *
 *    reject: function(),
 *
 *
 *    less: function(n),
 *
 *
 *    pastInput: function(n),
 *
 *
 *    upcomingInput: function(n),
 *
 *
 *    showPosition: function(),
 *
 *
 *    test_match: function(regex_match_array, rule_index),
 *
 *
 *    next: function(),
 *
 *
 *    begin: function(condition),
 *
 *
 *    pushState: function(condition),
 *
 *
 *    popState: function(),
 *
 *
 *    topState: function(),
 *
 *
 *    _currentRules: function(),
 *
 *
 *    stateStackSize: function(),
 *
 *
 *    performAction: function(yy, yy_, yyrulenumber, YY_START),
 *
 *
 *    rules: [...],
 *
 *
 *    conditions: {associative list: name ==> set},
 *  }
 *
 *
 *  token location info (`yylloc`): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *  }
 *
 * while `this` will reference the current lexer instance.
 *
 * When `parseError` is invoked by the lexer, the default implementation will
 * attempt to invoke `yy.parser.parseError()`; when this callback is not provided
 * it will try to invoke `yy.parseError()` instead. When that callback is also not
 * provided, a `JisonLexerError` exception will be thrown containing the error
 * message and `hash`, as constructed by the `constructLexErrorInfo()` API.
 *
 * Note that the lexer's `JisonLexerError` error class is passed via the
 * `ExceptionClass` argument, which is invoked to construct the exception
 * instance to be thrown, so technically `parseError` will throw the object
 * produced by the `new ExceptionClass(str, hash)` JavaScript expression.
 *
 * ---
 *
 * You can specify lexer options by setting / modifying the `.options` object of your Lexer instance.
 * These options are available:
 *
 * (Options are permanent.)
 *  
 *  yy: {
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *  }
 *
 *  lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 * WARNING: the next set of options are not meant to be changed. They echo the abilities of
 * the lexer as per when it was compiled!
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this %option has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */

var lexer$1 = function () {
    /**
     * See also:
     * http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
     * but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
     * with userland code which might access the derived class in a 'classic' way.
     *
     * @public
     * @constructor
     * @nocollapse
     */
    function JisonLexerError(msg, hash) {
        Object.defineProperty(this, 'name', {
            enumerable: false,
            writable: false,
            value: 'JisonLexerError'
        });

        if (msg == null) msg = '???';

        Object.defineProperty(this, 'message', {
            enumerable: false,
            writable: true,
            value: msg
        });

        this.hash = hash;
        var stacktrace;

        if (hash && hash.exception instanceof Error) {
            var ex2 = hash.exception;
            this.message = ex2.message || msg;
            stacktrace = ex2.stack;
        }

        if (!stacktrace) {
            if (Error.hasOwnProperty('captureStackTrace')) {
                // V8
                Error.captureStackTrace(this, this.constructor);
            } else {
                stacktrace = new Error(msg).stack;
            }
        }

        if (stacktrace) {
            Object.defineProperty(this, 'stack', {
                enumerable: false,
                writable: false,
                value: stacktrace
            });
        }
    }

    if (typeof Object.setPrototypeOf === 'function') {
        Object.setPrototypeOf(JisonLexerError.prototype, Error.prototype);
    } else {
        JisonLexerError.prototype = Object.create(Error.prototype);
    }

    JisonLexerError.prototype.constructor = JisonLexerError;
    JisonLexerError.prototype.name = 'JisonLexerError';

    var lexer = {

        // Code Generator Information Report
        // ---------------------------------
        //
        // Options:
        //
        //   backtracking: .................... false
        //   location.ranges: ................. true
        //   location line+column tracking: ... true
        //
        //
        // Forwarded Parser Analysis flags:
        //
        //   uses yyleng: ..................... false
        //   uses yylineno: ................... false
        //   uses yytext: ..................... false
        //   uses yylloc: ..................... false
        //   uses lexer values: ............... true / true
        //   location tracking: ............... true
        //   location assignment: ............. true
        //
        //
        // Lexer Analysis flags:
        //
        //   uses yyleng: ..................... ???
        //   uses yylineno: ................... ???
        //   uses yytext: ..................... ???
        //   uses yylloc: ..................... ???
        //   uses ParseError API: ............. ???
        //   uses yyerror: .................... ???
        //   uses location tracking & editing:  ???
        //   uses more() API: ................. ???
        //   uses unput() API: ................ ???
        //   uses reject() API: ............... ???
        //   uses less() API: ................. ???
        //   uses display APIs pastInput(), upcomingInput(), showPosition():
        //        ............................. ???
        //   uses describeYYLLOC() API: ....... ???
        //
        // --------- END OF REPORT -----------

        EOF: 1,
        ERROR: 2,

        // JisonLexerError: JisonLexerError,        /// <-- injected by the code generator

        // options: {},                             /// <-- injected by the code generator

        // yy: ...,                                 /// <-- injected by setInput()

        __currentRuleSet__: null, /// INTERNAL USE ONLY: internal rule set cache for the current lexer state  

        __error_infos: [], /// INTERNAL USE ONLY: the set of lexErrorInfo objects created since the last cleanup  
        __decompressed: false, /// INTERNAL USE ONLY: mark whether the lexer instance has been 'unfolded' completely and is now ready for use  
        done: false, /// INTERNAL USE ONLY  
        _backtrack: false, /// INTERNAL USE ONLY  
        _input: '', /// INTERNAL USE ONLY  
        _more: false, /// INTERNAL USE ONLY  
        _signaled_error_token: false, /// INTERNAL USE ONLY  
        conditionStack: [], /// INTERNAL USE ONLY; managed via `pushState()`, `popState()`, `topState()` and `stateStackSize()`  
        match: '', /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction. `match` is identical to `yytext` except that this one still contains the matched input string after `lexer.performAction()` has been invoked, where userland code MAY have changed/replaced the `yytext` value entirely!  
        matched: '', /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks entire input which has been matched so far  
        matches: false, /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks RE match result for last (successful) match attempt  
        yytext: '', /// ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction; this value is transferred to the parser as the 'token value' when the parser consumes the lexer token produced through a call to the `lex()` API.  
        offset: 0, /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks the 'cursor position' in the input string, i.e. the number of characters matched so far  
        yyleng: 0, /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: length of matched input for the token under construction (`yytext`)  
        yylineno: 0, /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: 'line number' at which the token under construction is located  
        yylloc: null, /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks location info (lines + columns) for the token under construction  

        /**
         * INTERNAL USE: construct a suitable error info hash object instance for `parseError`.
         * 
         * @public
         * @this {RegExpLexer}
         */
        constructLexErrorInfo: function lexer_constructLexErrorInfo(msg, recoverable, show_input_position) {
            msg = '' + msg;

            // heuristic to determine if the error message already contains a (partial) source code dump
            // as produced by either `showPosition()` or `prettyPrintRange()`:
            if (show_input_position == undefined) {
                show_input_position = !(msg.indexOf('\n') > 0 && msg.indexOf('^') > 0);
            }

            if (this.yylloc && show_input_position) {
                if (typeof this.prettyPrintRange === 'function') {
                    var pretty_src = this.prettyPrintRange(this.yylloc);

                    if (!/\n\s*$/.test(msg)) {
                        msg += '\n';
                    }

                    msg += '\n  Erroneous area:\n' + this.prettyPrintRange(this.yylloc);
                } else if (typeof this.showPosition === 'function') {
                    var pos_str = this.showPosition();

                    if (pos_str) {
                        if (msg.length && msg[msg.length - 1] !== '\n' && pos_str[0] !== '\n') {
                            msg += '\n' + pos_str;
                        } else {
                            msg += pos_str;
                        }
                    }
                }
            }

            /** @constructor */
            var pei = {
                errStr: msg,
                recoverable: !!recoverable,
                text: this.match, // This one MAY be empty; userland code should use the `upcomingInput` API to obtain more text which follows the 'lexer cursor position'...  
                token: null,
                line: this.yylineno,
                loc: this.yylloc,
                yy: this.yy,
                lexer: this,

                /**
                 * and make sure the error info doesn't stay due to potential
                 * ref cycle via userland code manipulations.
                 * These would otherwise all be memory leak opportunities!
                 * 
                 * Note that only array and object references are nuked as those
                 * constitute the set of elements which can produce a cyclic ref.
                 * The rest of the members is kept intact as they are harmless.
                 * 
                 * @public
                 * @this {LexErrorInfo}
                 */
                destroy: function destructLexErrorInfo() {
                    // remove cyclic references added to error info:
                    // info.yy = null;
                    // info.lexer = null;
                    // ...
                    var rec = !!this.recoverable;

                    for (var key in this) {
                        if (this.hasOwnProperty(key) && (typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {
                            this[key] = undefined;
                        }
                    }

                    this.recoverable = rec;
                }
            };

            // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
            this.__error_infos.push(pei);

            return pei;
        },

        /**
         * handler which is invoked when a lexer error occurs.
         * 
         * @public
         * @this {RegExpLexer}
         */
        parseError: function lexer_parseError(str, hash, ExceptionClass) {
            if (!ExceptionClass) {
                ExceptionClass = this.JisonLexerError;
            }

            if (this.yy) {
                if (this.yy.parser && typeof this.yy.parser.parseError === 'function') {
                    return this.yy.parser.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
                } else if (typeof this.yy.parseError === 'function') {
                    return this.yy.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
                }
            }

            throw new ExceptionClass(str, hash);
        },

        /**
         * method which implements `yyerror(str, ...args)` functionality for use inside lexer actions.
         * 
         * @public
         * @this {RegExpLexer}
         */
        yyerror: function yyError(str /*, ...args */) {
            var lineno_msg = '';

            if (this.yylloc) {
                lineno_msg = ' on line ' + (this.yylineno + 1);
            }

            var p = this.constructLexErrorInfo('Lexical error' + lineno_msg + ': ' + str, this.options.lexerErrorsAreRecoverable);

            // Add any extra args to the hash under the name `extra_error_attributes`:
            var args = Array.prototype.slice.call(arguments, 1);

            if (args.length) {
                p.extra_error_attributes = args;
            }

            return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
        },

        /**
         * final cleanup function for when we have completed lexing the input;
         * make it an API so that external code can use this one once userland
         * code has decided it's time to destroy any lingering lexer error
         * hash object instances and the like: this function helps to clean
         * up these constructs, which *may* carry cyclic references which would
         * otherwise prevent the instances from being properly and timely
         * garbage-collected, i.e. this function helps prevent memory leaks!
         * 
         * @public
         * @this {RegExpLexer}
         */
        cleanupAfterLex: function lexer_cleanupAfterLex(do_not_nuke_errorinfos) {
            // prevent lingering circular references from causing memory leaks:
            this.setInput('', {});

            // nuke the error hash info instances created during this run.
            // Userland code must COPY any data/references
            // in the error hash instance(s) it is more permanently interested in.
            if (!do_not_nuke_errorinfos) {
                for (var i = this.__error_infos.length - 1; i >= 0; i--) {
                    var el = this.__error_infos[i];

                    if (el && typeof el.destroy === 'function') {
                        el.destroy();
                    }
                }

                this.__error_infos.length = 0;
            }

            return this;
        },

        /**
         * clear the lexer token context; intended for internal use only
         * 
         * @public
         * @this {RegExpLexer}
         */
        clear: function lexer_clear() {
            this.yytext = '';
            this.yyleng = 0;
            this.match = '';

            // - DO NOT reset `this.matched`
            this.matches = false;

            this._more = false;
            this._backtrack = false;
            var col = this.yylloc ? this.yylloc.last_column : 0;

            this.yylloc = {
                first_line: this.yylineno + 1,
                first_column: col,
                last_line: this.yylineno + 1,
                last_column: col,
                range: [this.offset, this.offset]
            };
        },

        /**
         * resets the lexer, sets new input
         * 
         * @public
         * @this {RegExpLexer}
         */
        setInput: function lexer_setInput(input, yy) {
            this.yy = yy || this.yy || {};

            // also check if we've fully initialized the lexer instance,
            // including expansion work to be done to go from a loaded
            // lexer to a usable lexer:
            if (!this.__decompressed) {
                // step 1: decompress the regex list:
                var rules = this.rules;

                for (var i = 0, len = rules.length; i < len; i++) {
                    var rule_re = rules[i];

                    // compression: is the RE an xref to another RE slot in the rules[] table?
                    if (typeof rule_re === 'number') {
                        rules[i] = rules[rule_re];
                    }
                }

                // step 2: unfold the conditions[] set to make these ready for use:
                var conditions = this.conditions;

                for (var k in conditions) {
                    var spec = conditions[k];
                    var rule_ids = spec.rules;
                    var len = rule_ids.length;
                    var rule_regexes = new Array(len + 1); // slot 0 is unused; we use a 1-based index approach here to keep the hottest code in `lexer_next()` fast and simple! 
                    var rule_new_ids = new Array(len + 1);

                    for (var i = 0; i < len; i++) {
                        var idx = rule_ids[i];
                        var rule_re = rules[idx];
                        rule_regexes[i + 1] = rule_re;
                        rule_new_ids[i + 1] = idx;
                    }

                    spec.rules = rule_new_ids;
                    spec.__rule_regexes = rule_regexes;
                    spec.__rule_count = len;
                }

                this.__decompressed = true;
            }

            this._input = input || '';
            this.clear();
            this._signaled_error_token = false;
            this.done = false;
            this.yylineno = 0;
            this.matched = '';
            this.conditionStack = ['INITIAL'];
            this.__currentRuleSet__ = null;

            this.yylloc = {
                first_line: 1,
                first_column: 0,
                last_line: 1,
                last_column: 0,
                range: [0, 0]
            };

            this.offset = 0;
            return this;
        },

        /**
         * edit the remaining input via user-specified callback.
         * This can be used to forward-adjust the input-to-parse, 
         * e.g. inserting macro expansions and alike in the
         * input which has yet to be lexed.
         * The behaviour of this API contrasts the `unput()` et al
         * APIs as those act on the *consumed* input, while this
         * one allows one to manipulate the future, without impacting
         * the current `yyloc` cursor location or any history. 
         * 
         * Use this API to help implement C-preprocessor-like
         * `#include` statements, etc.
         * 
         * The provided callback must be synchronous and is
         * expected to return the edited input (string).
         *
         * The `cpsArg` argument value is passed to the callback
         * as-is.
         *
         * `callback` interface: 
         * `function callback(input, cpsArg)`
         * 
         * - `input` will carry the remaining-input-to-lex string
         *   from the lexer.
         * - `cpsArg` is `cpsArg` passed into this API.
         * 
         * The `this` reference for the callback will be set to
         * reference this lexer instance so that userland code
         * in the callback can easily and quickly access any lexer
         * API. 
         *
         * When the callback returns a non-string-type falsey value,
         * we assume the callback did not edit the input and we
         * will using the input as-is.
         *
         * When the callback returns a non-string-type value, it
         * is converted to a string for lexing via the `"" + retval`
         * operation. (See also why: http://2ality.com/2012/03/converting-to-string.html 
         * -- that way any returned object's `toValue()` and `toString()`
         * methods will be invoked in a proper/desirable order.)
         * 
         * @public
         * @this {RegExpLexer}
         */
        editRemainingInput: function lexer_editRemainingInput(callback, cpsArg) {
            var rv = callback.call(this, this._input, cpsArg);

            if (typeof rv !== 'string') {
                if (rv) {
                    this._input = '' + rv;
                }
                // else: keep `this._input` as is.  
            } else {
                this._input = rv;
            }

            return this;
        },

        /**
         * consumes and returns one char from the input
         * 
         * @public
         * @this {RegExpLexer}
         */
        input: function lexer_input() {
            if (!this._input) {
                //this.done = true;    -- don't set `done` as we want the lex()/next() API to be able to produce one custom EOF token match after this anyhow. (lexer can match special <<EOF>> tokens and perform user action code for a <<EOF>> match, but only does so *once*)
                return null;
            }

            var ch = this._input[0];
            this.yytext += ch;
            this.yyleng++;
            this.offset++;
            this.match += ch;
            this.matched += ch;

            // Count the linenumber up when we hit the LF (or a stand-alone CR).
            // On CRLF, the linenumber is incremented when you fetch the CR or the CRLF combo
            // and we advance immediately past the LF as well, returning both together as if
            // it was all a single 'character' only.
            var slice_len = 1;

            var lines = false;

            if (ch === '\n') {
                lines = true;
            } else if (ch === '\r') {
                lines = true;
                var ch2 = this._input[1];

                if (ch2 === '\n') {
                    slice_len++;
                    ch += ch2;
                    this.yytext += ch2;
                    this.yyleng++;
                    this.offset++;
                    this.match += ch2;
                    this.matched += ch2;
                    this.yylloc.range[1]++;
                }
            }

            if (lines) {
                this.yylineno++;
                this.yylloc.last_line++;
                this.yylloc.last_column = 0;
            } else {
                this.yylloc.last_column++;
            }

            this.yylloc.range[1]++;
            this._input = this._input.slice(slice_len);
            return ch;
        },

        /**
         * unshifts one char (or an entire string) into the input
         * 
         * @public
         * @this {RegExpLexer}
         */
        unput: function lexer_unput(ch) {
            var len = ch.length;
            var lines = ch.split(/(?:\r\n?|\n)/g);
            this._input = ch + this._input;
            this.yytext = this.yytext.substr(0, this.yytext.length - len);
            this.yyleng = this.yytext.length;
            this.offset -= len;
            this.match = this.match.substr(0, this.match.length - len);
            this.matched = this.matched.substr(0, this.matched.length - len);

            if (lines.length > 1) {
                this.yylineno -= lines.length - 1;
                this.yylloc.last_line = this.yylineno + 1;

                // Get last entirely matched line into the `pre_lines[]` array's
                // last index slot; we don't mind when other previously 
                // matched lines end up in the array too. 
                var pre = this.match;

                var pre_lines = pre.split(/(?:\r\n?|\n)/g);

                if (pre_lines.length === 1) {
                    pre = this.matched;
                    pre_lines = pre.split(/(?:\r\n?|\n)/g);
                }

                this.yylloc.last_column = pre_lines[pre_lines.length - 1].length;
            } else {
                this.yylloc.last_column -= len;
            }

            this.yylloc.range[1] = this.yylloc.range[0] + this.yyleng;
            this.done = false;
            return this;
        },

        /**
         * cache matched text and append it on next action
         * 
         * @public
         * @this {RegExpLexer}
         */
        more: function lexer_more() {
            this._more = true;
            return this;
        },

        /**
         * signal the lexer that this rule fails to match the input, so the
         * next matching rule (regex) should be tested instead.
         * 
         * @public
         * @this {RegExpLexer}
         */
        reject: function lexer_reject() {
            if (this.options.backtrack_lexer) {
                this._backtrack = true;
            } else {
                // when the `parseError()` call returns, we MUST ensure that the error is registered.
                // We accomplish this by signaling an 'error' token to be produced for the current
                // `.lex()` run.
                var lineno_msg = '';

                if (this.yylloc) {
                    lineno_msg = ' on line ' + (this.yylineno + 1);
                }

                var p = this.constructLexErrorInfo('Lexical error' + lineno_msg + ': You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).', false);

                this._signaled_error_token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
            }

            return this;
        },

        /**
         * retain first n characters of the match
         * 
         * @public
         * @this {RegExpLexer}
         */
        less: function lexer_less(n) {
            return this.unput(this.match.slice(n));
        },

        /**
         * return (part of the) already matched input, i.e. for error
         * messages.
         * 
         * Limit the returned string length to `maxSize` (default: 20).
         * 
         * Limit the returned string to the `maxLines` number of lines of
         * input (default: 1).
         * 
         * Negative limit values equal *unlimited*.
         * 
         * @public
         * @this {RegExpLexer}
         */
        pastInput: function lexer_pastInput(maxSize, maxLines) {
            var past = this.matched.substring(0, this.matched.length - this.match.length);

            if (maxSize < 0) maxSize = past.length;else if (!maxSize) maxSize = 20;

            if (maxLines < 0) maxLines = past.length; // can't ever have more input lines than this! 
            else if (!maxLines) maxLines = 1;

            // `substr` anticipation: treat \r\n as a single character and take a little
            // more than necessary so that we can still properly check against maxSize
            // after we've transformed and limited the newLines in here:
            past = past.substr(-maxSize * 2 - 2);

            // now that we have a significantly reduced string to process, transform the newlines
            // and chop them, then limit them:
            var a = past.replace(/\r\n|\r/g, '\n').split('\n');

            a = a.slice(-maxLines);
            past = a.join('\n');

            // When, after limiting to maxLines, we still have too much to return,
            // do add an ellipsis prefix...
            if (past.length > maxSize) {
                past = '...' + past.substr(-maxSize);
            }

            return past;
        },

        /**
         * return (part of the) upcoming input, i.e. for error messages.
         * 
         * Limit the returned string length to `maxSize` (default: 20).
         * 
         * Limit the returned string to the `maxLines` number of lines of input (default: 1).
         * 
         * Negative limit values equal *unlimited*.
         *
         * > ### NOTE ###
         * >
         * > *"upcoming input"* is defined as the whole of the both
         * > the *currently lexed* input, together with any remaining input
         * > following that. *"currently lexed"* input is the input 
         * > already recognized by the lexer but not yet returned with
         * > the lexer token. This happens when you are invoking this API
         * > from inside any lexer rule action code block. 
         * >
         * 
         * @public
         * @this {RegExpLexer}
         */
        upcomingInput: function lexer_upcomingInput(maxSize, maxLines) {
            var next = this.match;

            if (maxSize < 0) maxSize = next.length + this._input.length;else if (!maxSize) maxSize = 20;

            if (maxLines < 0) maxLines = maxSize; // can't ever have more input lines than this! 
            else if (!maxLines) maxLines = 1;

            // `substring` anticipation: treat \r\n as a single character and take a little
            // more than necessary so that we can still properly check against maxSize
            // after we've transformed and limited the newLines in here:
            if (next.length < maxSize * 2 + 2) {
                next += this._input.substring(0, maxSize * 2 + 2); // substring is faster on Chrome/V8 
            }

            // now that we have a significantly reduced string to process, transform the newlines
            // and chop them, then limit them:
            var a = next.replace(/\r\n|\r/g, '\n').split('\n');

            a = a.slice(0, maxLines);
            next = a.join('\n');

            // When, after limiting to maxLines, we still have too much to return,
            // do add an ellipsis postfix...
            if (next.length > maxSize) {
                next = next.substring(0, maxSize) + '...';
            }

            return next;
        },

        /**
         * return a string which displays the character position where the
         * lexing error occurred, i.e. for error messages
         * 
         * @public
         * @this {RegExpLexer}
         */
        showPosition: function lexer_showPosition(maxPrefix, maxPostfix) {
            var pre = this.pastInput(maxPrefix).replace(/\s/g, ' ');
            var c = new Array(pre.length + 1).join('-');
            return pre + this.upcomingInput(maxPostfix).replace(/\s/g, ' ') + '\n' + c + '^';
        },

        /**
         * return an YYLLOC info object derived off the given context (actual, preceding, following, current).
         * Use this method when the given `actual` location is not guaranteed to exist (i.e. when
         * it MAY be NULL) and you MUST have a valid location info object anyway:
         * then we take the given context of the `preceding` and `following` locations, IFF those are available,
         * and reconstruct the `actual` location info from those.
         * If this fails, the heuristic is to take the `current` location, IFF available.
         * If this fails as well, we assume the sought location is at/around the current lexer position
         * and then produce that one as a response. DO NOTE that these heuristic/derived location info
         * values MAY be inaccurate!
         *
         * NOTE: `deriveLocationInfo()` ALWAYS produces a location info object *copy* of `actual`, not just
         * a *reference* hence all input location objects can be assumed to be 'constant' (function has no side-effects).
         * 
         * @public
         * @this {RegExpLexer}
         */
        deriveLocationInfo: function lexer_deriveYYLLOC(actual, preceding, following, current) {
            var loc = {
                first_line: 1,
                first_column: 0,
                last_line: 1,
                last_column: 0,
                range: [0, 0]
            };

            if (actual) {
                loc.first_line = actual.first_line | 0;
                loc.last_line = actual.last_line | 0;
                loc.first_column = actual.first_column | 0;
                loc.last_column = actual.last_column | 0;

                if (actual.range) {
                    loc.range[0] = actual.range[0] | 0;
                    loc.range[1] = actual.range[1] | 0;
                }
            }

            if (loc.first_line <= 0 || loc.last_line < loc.first_line) {
                // plan B: heuristic using preceding and following:
                if (loc.first_line <= 0 && preceding) {
                    loc.first_line = preceding.last_line | 0;
                    loc.first_column = preceding.last_column | 0;

                    if (preceding.range) {
                        loc.range[0] = actual.range[1] | 0;
                    }
                }

                if ((loc.last_line <= 0 || loc.last_line < loc.first_line) && following) {
                    loc.last_line = following.first_line | 0;
                    loc.last_column = following.first_column | 0;

                    if (following.range) {
                        loc.range[1] = actual.range[0] | 0;
                    }
                }

                // plan C?: see if the 'current' location is useful/sane too:
                if (loc.first_line <= 0 && current && (loc.last_line <= 0 || current.last_line <= loc.last_line)) {
                    loc.first_line = current.first_line | 0;
                    loc.first_column = current.first_column | 0;

                    if (current.range) {
                        loc.range[0] = current.range[0] | 0;
                    }
                }

                if (loc.last_line <= 0 && current && (loc.first_line <= 0 || current.first_line >= loc.first_line)) {
                    loc.last_line = current.last_line | 0;
                    loc.last_column = current.last_column | 0;

                    if (current.range) {
                        loc.range[1] = current.range[1] | 0;
                    }
                }
            }

            // sanitize: fix last_line BEFORE we fix first_line as we use the 'raw' value of the latter
            // or plan D heuristics to produce a 'sensible' last_line value:
            if (loc.last_line <= 0) {
                if (loc.first_line <= 0) {
                    loc.first_line = this.yylloc.first_line;
                    loc.last_line = this.yylloc.last_line;
                    loc.first_column = this.yylloc.first_column;
                    loc.last_column = this.yylloc.last_column;
                    loc.range[0] = this.yylloc.range[0];
                    loc.range[1] = this.yylloc.range[1];
                } else {
                    loc.last_line = this.yylloc.last_line;
                    loc.last_column = this.yylloc.last_column;
                    loc.range[1] = this.yylloc.range[1];
                }
            }

            if (loc.first_line <= 0) {
                loc.first_line = loc.last_line;
                loc.first_column = 0; // loc.last_column; 
                loc.range[1] = loc.range[0];
            }

            if (loc.first_column < 0) {
                loc.first_column = 0;
            }

            if (loc.last_column < 0) {
                loc.last_column = loc.first_column > 0 ? loc.first_column : 80;
            }

            return loc;
        },

        /**
         * return a string which displays the lines & columns of input which are referenced 
         * by the given location info range, plus a few lines of context.
         * 
         * This function pretty-prints the indicated section of the input, with line numbers 
         * and everything!
         * 
         * This function is very useful to provide highly readable error reports, while
         * the location range may be specified in various flexible ways:
         * 
         * - `loc` is the location info object which references the area which should be
         *   displayed and 'marked up': these lines & columns of text are marked up by `^`
         *   characters below each character in the entire input range.
         * 
         * - `context_loc` is the *optional* location info object which instructs this
         *   pretty-printer how much *leading* context should be displayed alongside
         *   the area referenced by `loc`. This can help provide context for the displayed
         *   error, etc.
         * 
         *   When this location info is not provided, a default context of 3 lines is
         *   used.
         * 
         * - `context_loc2` is another *optional* location info object, which serves
         *   a similar purpose to `context_loc`: it specifies the amount of *trailing*
         *   context lines to display in the pretty-print output.
         * 
         *   When this location info is not provided, a default context of 1 line only is
         *   used.
         * 
         * Special Notes:
         * 
         * - when the `loc`-indicated range is very large (about 5 lines or more), then
         *   only the first and last few lines of this block are printed while a
         *   `...continued...` message will be printed between them.
         * 
         *   This serves the purpose of not printing a huge amount of text when the `loc`
         *   range happens to be huge: this way a manageable & readable output results
         *   for arbitrary large ranges.
         * 
         * - this function can display lines of input which whave not yet been lexed.
         *   `prettyPrintRange()` can access the entire input!
         * 
         * @public
         * @this {RegExpLexer}
         */
        prettyPrintRange: function lexer_prettyPrintRange(loc, context_loc, context_loc2) {
            loc = this.deriveLocationInfo(loc, context_loc, context_loc2);
            var CONTEXT = 3;
            var CONTEXT_TAIL = 1;
            var MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT = 2;
            var input = this.matched + this._input;
            var lines = input.split('\n');
            var l0 = Math.max(1, context_loc ? context_loc.first_line : loc.first_line - CONTEXT);
            var l1 = Math.max(1, context_loc2 ? context_loc2.last_line : loc.last_line + CONTEXT_TAIL);
            var lineno_display_width = 1 + Math.log10(l1 | 1) | 0;
            var ws_prefix = new Array(lineno_display_width).join(' ');
            var nonempty_line_indexes = [];

            var rv = lines.slice(l0 - 1, l1 + 1).map(function injectLineNumber(line, index) {
                var lno = index + l0;
                var lno_pfx = (ws_prefix + lno).substr(-lineno_display_width);
                var rv = lno_pfx + ': ' + line;
                var errpfx = new Array(lineno_display_width + 1).join('^');
                var offset = 2 + 1;
                var len = 0;

                if (lno === loc.first_line) {
                    offset += loc.first_column;

                    len = Math.max(2, (lno === loc.last_line ? loc.last_column : line.length) - loc.first_column + 1);
                } else if (lno === loc.last_line) {
                    len = Math.max(2, loc.last_column + 1);
                } else if (lno > loc.first_line && lno < loc.last_line) {
                    len = Math.max(2, line.length + 1);
                }

                if (len) {
                    var lead = new Array(offset).join('.');
                    var mark = new Array(len).join('^');
                    rv += '\n' + errpfx + lead + mark;

                    if (line.trim().length > 0) {
                        nonempty_line_indexes.push(index);
                    }
                }

                rv = rv.replace(/\t/g, ' ');
                return rv;
            });

            // now make sure we don't print an overly large amount of error area: limit it 
            // to the top and bottom line count:
            if (nonempty_line_indexes.length > 2 * MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT) {
                var clip_start = nonempty_line_indexes[MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT - 1] + 1;
                var clip_end = nonempty_line_indexes[nonempty_line_indexes.length - MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT] - 1;
                var intermediate_line = new Array(lineno_display_width + 1).join(' ') + '  (...continued...)';
                intermediate_line += '\n' + new Array(lineno_display_width + 1).join('-') + '  (---------------)';
                rv.splice(clip_start, clip_end - clip_start + 1, intermediate_line);
            }

            return rv.join('\n');
        },

        /**
         * helper function, used to produce a human readable description as a string, given
         * the input `yylloc` location object.
         * 
         * Set `display_range_too` to TRUE to include the string character index position(s)
         * in the description if the `yylloc.range` is available.
         * 
         * @public
         * @this {RegExpLexer}
         */
        describeYYLLOC: function lexer_describe_yylloc(yylloc, display_range_too) {
            var l1 = yylloc.first_line;
            var l2 = yylloc.last_line;
            var c1 = yylloc.first_column;
            var c2 = yylloc.last_column;
            var dl = l2 - l1;
            var dc = c2 - c1;
            var rv;

            if (dl === 0) {
                rv = 'line ' + l1 + ', ';

                if (dc <= 1) {
                    rv += 'column ' + c1;
                } else {
                    rv += 'columns ' + c1 + ' .. ' + c2;
                }
            } else {
                rv = 'lines ' + l1 + '(column ' + c1 + ') .. ' + l2 + '(column ' + c2 + ')';
            }

            if (yylloc.range && display_range_too) {
                var r1 = yylloc.range[0];
                var r2 = yylloc.range[1] - 1;

                if (r2 <= r1) {
                    rv += ' {String Offset: ' + r1 + '}';
                } else {
                    rv += ' {String Offset range: ' + r1 + ' .. ' + r2 + '}';
                }
            }

            return rv;
        },

        /**
         * test the lexed token: return FALSE when not a match, otherwise return token.
         * 
         * `match` is supposed to be an array coming out of a regex match, i.e. `match[0]`
         * contains the actually matched text string.
         * 
         * Also move the input cursor forward and update the match collectors:
         * 
         * - `yytext`
         * - `yyleng`
         * - `match`
         * - `matches`
         * - `yylloc`
         * - `offset`
         * 
         * @public
         * @this {RegExpLexer}
         */
        test_match: function lexer_test_match(match, indexed_rule) {
            var token, lines, backup, match_str, match_str_len;

            if (this.options.backtrack_lexer) {
                // save context
                backup = {
                    yylineno: this.yylineno,

                    yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.yylloc.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                        range: this.yylloc.range.slice(0)
                    },

                    yytext: this.yytext,
                    match: this.match,
                    matches: this.matches,
                    matched: this.matched,
                    yyleng: this.yyleng,
                    offset: this.offset,
                    _more: this._more,
                    _input: this._input,

                    //_signaled_error_token: this._signaled_error_token,
                    yy: this.yy,

                    conditionStack: this.conditionStack.slice(0),
                    done: this.done
                };
            }

            match_str = match[0];
            match_str_len = match_str.length;

            // if (match_str.indexOf('\n') !== -1 || match_str.indexOf('\r') !== -1) {
            lines = match_str.split(/(?:\r\n?|\n)/g);

            if (lines.length > 1) {
                this.yylineno += lines.length - 1;
                this.yylloc.last_line = this.yylineno + 1;
                this.yylloc.last_column = lines[lines.length - 1].length;
            } else {
                this.yylloc.last_column += match_str_len;
            }

            // }
            this.yytext += match_str;

            this.match += match_str;
            this.matched += match_str;
            this.matches = match;
            this.yyleng = this.yytext.length;
            this.yylloc.range[1] += match_str_len;

            // previous lex rules MAY have invoked the `more()` API rather than producing a token:
            // those rules will already have moved this `offset` forward matching their match lengths,
            // hence we must only add our own match length now:
            this.offset += match_str_len;

            this._more = false;
            this._backtrack = false;
            this._input = this._input.slice(match_str_len);

            // calling this method:
            //
            //   function lexer__performAction(yy, yyrulenumber, YY_START) {...}
            token = this.performAction.call(this, this.yy, indexed_rule, this.conditionStack[this.conditionStack.length - 1] /* = YY_START */
            );

            // otherwise, when the action codes are all simple return token statements:
            //token = this.simpleCaseActionClusters[indexed_rule];

            if (this.done && this._input) {
                this.done = false;
            }

            if (token) {
                return token;
            } else if (this._backtrack) {
                // recover context
                for (var k in backup) {
                    this[k] = backup[k];
                }

                this.__currentRuleSet__ = null;
                return false; // rule action called reject() implying the next rule should be tested instead. 
            } else if (this._signaled_error_token) {
                // produce one 'error' token as `.parseError()` in `reject()`
                // did not guarantee a failure signal by throwing an exception!
                token = this._signaled_error_token;

                this._signaled_error_token = false;
                return token;
            }

            return false;
        },

        /**
         * return next match in input
         * 
         * @public
         * @this {RegExpLexer}
         */
        next: function lexer_next() {
            if (this.done) {
                this.clear();
                return this.EOF;
            }

            if (!this._input) {
                this.done = true;
            }

            var token, match, tempMatch, index;

            if (!this._more) {
                this.clear();
            }

            var spec = this.__currentRuleSet__;

            if (!spec) {
                // Update the ruleset cache as we apparently encountered a state change or just started lexing.
                // The cache is set up for fast lookup -- we assume a lexer will switch states much less often than it will
                // invoke the `lex()` token-producing API and related APIs, hence caching the set for direct access helps
                // speed up those activities a tiny bit.
                spec = this.__currentRuleSet__ = this._currentRules();

                // Check whether a *sane* condition has been pushed before: this makes the lexer robust against
                // user-programmer bugs such as https://github.com/zaach/jison-lex/issues/19
                if (!spec || !spec.rules) {
                    var lineno_msg = '';

                    if (this.options.trackPosition) {
                        lineno_msg = ' on line ' + (this.yylineno + 1);
                    }

                    var p = this.constructLexErrorInfo('Internal lexer engine error' + lineno_msg + ': The lex grammar programmer pushed a non-existing condition name "' + this.topState() + '"; this is a fatal error and should be reported to the application programmer team!', false);

                    // produce one 'error' token until this situation has been resolved, most probably by parse termination!
                    return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
                }
            }

            var rule_ids = spec.rules;
            var regexes = spec.__rule_regexes;
            var len = spec.__rule_count;

            // Note: the arrays are 1-based, while `len` itself is a valid index,
            // hence the non-standard less-or-equal check in the next loop condition!
            for (var i = 1; i <= len; i++) {
                tempMatch = this._input.match(regexes[i]);

                if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                    match = tempMatch;
                    index = i;

                    if (this.options.backtrack_lexer) {
                        token = this.test_match(tempMatch, rule_ids[i]);

                        if (token !== false) {
                            return token;
                        } else if (this._backtrack) {
                            match = undefined;
                            continue; // rule action called reject() implying a rule MISmatch. 
                        } else {
                            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                            return false;
                        }
                    } else if (!this.options.flex) {
                        break;
                    }
                }
            }

            if (match) {
                token = this.test_match(match, rule_ids[index]);

                if (token !== false) {
                    return token;
                }

                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                return false;
            }

            if (!this._input) {
                this.done = true;
                this.clear();
                return this.EOF;
            } else {
                var lineno_msg = '';

                if (this.options.trackPosition) {
                    lineno_msg = ' on line ' + (this.yylineno + 1);
                }

                var p = this.constructLexErrorInfo('Lexical error' + lineno_msg + ': Unrecognized text.', this.options.lexerErrorsAreRecoverable);

                var pendingInput = this._input;
                var activeCondition = this.topState();
                var conditionStackDepth = this.conditionStack.length;
                token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;

                if (token === this.ERROR) {
                    // we can try to recover from a lexer error that `parseError()` did not 'recover' for us
                    // by moving forward at least one character at a time IFF the (user-specified?) `parseError()`
                    // has not consumed/modified any pending input or changed state in the error handler:
                    if (!this.matches && // and make sure the input has been modified/consumed ...
                    pendingInput === this._input && // ...or the lexer state has been modified significantly enough
                    // to merit a non-consuming error handling action right now.
                    activeCondition === this.topState() && conditionStackDepth === this.conditionStack.length) {
                        this.input();
                    }
                }

                return token;
            }
        },

        /**
         * return next match that has a token
         * 
         * @public
         * @this {RegExpLexer}
         */
        lex: function lexer_lex() {
            var r;

            // allow the PRE/POST handlers set/modify the return token for maximum flexibility of the generated lexer:
            if (typeof this.pre_lex === 'function') {
                r = this.pre_lex.call(this, 0);
            }

            if (typeof this.options.pre_lex === 'function') {
                // (also account for a userdef function which does not return any value: keep the token as is)
                r = this.options.pre_lex.call(this, r) || r;
            }

            if (this.yy && typeof this.yy.pre_lex === 'function') {
                // (also account for a userdef function which does not return any value: keep the token as is)
                r = this.yy.pre_lex.call(this, r) || r;
            }

            while (!r) {
                r = this.next();
            }

            if (this.yy && typeof this.yy.post_lex === 'function') {
                // (also account for a userdef function which does not return any value: keep the token as is)
                r = this.yy.post_lex.call(this, r) || r;
            }

            if (typeof this.options.post_lex === 'function') {
                // (also account for a userdef function which does not return any value: keep the token as is)
                r = this.options.post_lex.call(this, r) || r;
            }

            if (typeof this.post_lex === 'function') {
                // (also account for a userdef function which does not return any value: keep the token as is)
                r = this.post_lex.call(this, r) || r;
            }

            return r;
        },

        /**
         * return next match that has a token. Identical to the `lex()` API but does not invoke any of the 
         * `pre_lex()` nor any of the `post_lex()` callbacks.
         * 
         * @public
         * @this {RegExpLexer}
         */
        fastLex: function lexer_fastLex() {
            var r;

            while (!r) {
                r = this.next();
            }

            return r;
        },

        /**
         * return info about the lexer state that can help a parser or other lexer API user to use the
         * most efficient means available. This API is provided to aid run-time performance for larger
         * systems which employ this lexer.
         * 
         * @public
         * @this {RegExpLexer}
         */
        canIUse: function lexer_canIUse() {
            var rv = {
                fastLex: !(typeof this.pre_lex === 'function' || typeof this.options.pre_lex === 'function' || this.yy && typeof this.yy.pre_lex === 'function' || this.yy && typeof this.yy.post_lex === 'function' || typeof this.options.post_lex === 'function' || typeof this.post_lex === 'function') && typeof this.fastLex === 'function'
            };

            return rv;
        },

        /**
         * backwards compatible alias for `pushState()`;
         * the latter is symmetrical with `popState()` and we advise to use
         * those APIs in any modern lexer code, rather than `begin()`.
         * 
         * @public
         * @this {RegExpLexer}
         */
        begin: function lexer_begin(condition) {
            return this.pushState(condition);
        },

        /**
         * activates a new lexer condition state (pushes the new lexer
         * condition state onto the condition stack)
         * 
         * @public
         * @this {RegExpLexer}
         */
        pushState: function lexer_pushState(condition) {
            this.conditionStack.push(condition);
            this.__currentRuleSet__ = null;
            return this;
        },

        /**
         * pop the previously active lexer condition state off the condition
         * stack
         * 
         * @public
         * @this {RegExpLexer}
         */
        popState: function lexer_popState() {
            var n = this.conditionStack.length - 1;

            if (n > 0) {
                this.__currentRuleSet__ = null;
                return this.conditionStack.pop();
            } else {
                return this.conditionStack[0];
            }
        },

        /**
         * return the currently active lexer condition state; when an index
         * argument is provided it produces the N-th previous condition state,
         * if available
         * 
         * @public
         * @this {RegExpLexer}
         */
        topState: function lexer_topState(n) {
            n = this.conditionStack.length - 1 - Math.abs(n || 0);

            if (n >= 0) {
                return this.conditionStack[n];
            } else {
                return 'INITIAL';
            }
        },

        /**
         * (internal) determine the lexer rule set which is active for the
         * currently active lexer condition state
         * 
         * @public
         * @this {RegExpLexer}
         */
        _currentRules: function lexer__currentRules() {
            if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
                return this.conditions[this.conditionStack[this.conditionStack.length - 1]];
            } else {
                return this.conditions['INITIAL'];
            }
        },

        /**
         * return the number of states currently on the stack
         * 
         * @public
         * @this {RegExpLexer}
         */
        stateStackSize: function lexer_stateStackSize() {
            return this.conditionStack.length;
        },

        options: {
            xregexp: true,
            ranges: true,
            trackPosition: true,
            parseActionsUseYYMERGELOCATIONINFO: true,
            easy_keyword_rules: true
        },

        JisonLexerError: JisonLexerError,

        performAction: function lexer__performAction(yy, yyrulenumber, YY_START) {
            var yy_ = this;
            switch (yyrulenumber) {
                case 2:
                    /*! Conditions:: action */
                    /*! Rule::       \/[^ /]*?['"{}][^ ]*?\/ */
                    return 43; // regexp with braces or quotes (and no spaces)  

                    break;

                case 7:
                    /*! Conditions:: action */
                    /*! Rule::       \{ */
                    yy.depth++;

                    return 12;
                    break;

                case 8:
                    /*! Conditions:: action */
                    /*! Rule::       \} */
                    if (yy.depth === 0) {
                        this.popState();
                    } else {
                        yy.depth--;
                    }

                    return 13;
                    break;

                case 9:
                    /*! Conditions:: token */
                    /*! Rule::       {BR} */
                    this.popState();

                    break;

                case 10:
                    /*! Conditions:: token */
                    /*! Rule::       %% */
                    this.popState();

                    break;

                case 11:
                    /*! Conditions:: token */
                    /*! Rule::       ; */
                    this.popState();

                    break;

                case 12:
                    /*! Conditions:: bnf ebnf */
                    /*! Rule::       %% */
                    this.pushState('code');

                    return 14;
                    break;

                case 25:
                    /*! Conditions:: options */
                    /*! Rule::       = */
                    this.pushState('option_values');

                    return 3;
                    break;

                case 26:
                    /*! Conditions:: option_values */
                    /*! Rule::       "{DOUBLEQUOTED_STRING_CONTENT}" */
                    yy_.yytext = unescQuote(this.matches[1], /\\"/g);

                    this.popState();
                    return 29; // value is always a string type  
                    break;

                case 27:
                    /*! Conditions:: option_values */
                    /*! Rule::       '{QUOTED_STRING_CONTENT}' */
                    yy_.yytext = unescQuote(this.matches[1], /\\'/g);

                    this.popState();
                    return 29; // value is always a string type  
                    break;

                case 28:
                    /*! Conditions:: option_values */
                    /*! Rule::       `{ES2017_STRING_CONTENT}` */
                    yy_.yytext = unescQuote(this.matches[1], /\\`/g);

                    this.popState();
                    return 29; // value is always a string type  
                    break;

                case 29:
                    /*! Conditions:: INITIAL ebnf bnf token path options option_values */
                    /*! Rule::       \/\/[^\r\n]* */
                    /* skip single-line comment */
                    break;

                case 30:
                    /*! Conditions:: INITIAL ebnf bnf token path options option_values */
                    /*! Rule::       \/\*[^]*?\*\/ */
                    /* skip multi-line comment */
                    break;

                case 31:
                    /*! Conditions:: option_values */
                    /*! Rule::       [^\s\r\n]+ */
                    this.popState();

                    return 30;
                    break;

                case 32:
                    /*! Conditions:: options */
                    /*! Rule::       {BR}{WS}+(?=\S) */
                    /* skip leading whitespace on the next line of input, when followed by more options */
                    break;

                case 33:
                    /*! Conditions:: options */
                    /*! Rule::       {BR} */
                    this.popState();

                    return 28;
                    break;

                case 34:
                    /*! Conditions:: options option_values */
                    /*! Rule::       {WS}+ */
                    /* skip whitespace */
                    break;

                case 35:
                    /*! Conditions:: token bnf ebnf INITIAL */
                    /*! Rule::       {WS}+ */
                    /* skip whitespace */
                    break;

                case 36:
                    /*! Conditions:: token bnf ebnf INITIAL */
                    /*! Rule::       {BR}+ */
                    /* skip newlines */
                    break;

                case 37:
                    /*! Conditions:: token bnf ebnf INITIAL */
                    /*! Rule::       \[{ID}\] */
                    yy_.yytext = this.matches[1];

                    return 39;
                    break;

                case 42:
                    /*! Conditions:: token bnf ebnf INITIAL */
                    /*! Rule::       "{DOUBLEQUOTED_STRING_CONTENT}" */
                    yy_.yytext = unescQuote(this.matches[1], /\\"/g);

                    return 26;
                    break;

                case 43:
                    /*! Conditions:: token bnf ebnf INITIAL */
                    /*! Rule::       '{QUOTED_STRING_CONTENT}' */
                    yy_.yytext = unescQuote(this.matches[1], /\\'/g);

                    return 26;
                    break;

                case 48:
                    /*! Conditions:: token bnf ebnf INITIAL */
                    /*! Rule::       %% */
                    this.pushState(yy.ebnf ? 'ebnf' : 'bnf');

                    return 14;
                    break;

                case 49:
                    /*! Conditions:: token bnf ebnf INITIAL */
                    /*! Rule::       %ebnf\b */
                    yy.ebnf = true;

                    return 20;
                    break;

                case 57:
                    /*! Conditions:: token bnf ebnf INITIAL */
                    /*! Rule::       %token\b */
                    this.pushState('token');

                    return 18;
                    break;

                case 59:
                    /*! Conditions:: token bnf ebnf INITIAL */
                    /*! Rule::       %option[s]? */
                    this.pushState('options');

                    return 27;
                    break;

                case 60:
                    /*! Conditions:: token bnf ebnf INITIAL */
                    /*! Rule::       %lex{LEX_CONTENT}\/lex\b */
                    // remove the %lex../lex wrapper and return the pure lex section:
                    yy_.yytext = this.matches[1];

                    return 17;
                    break;

                case 63:
                    /*! Conditions:: INITIAL ebnf bnf code */
                    /*! Rule::       %include\b */
                    this.pushState('path');

                    return 44;
                    break;

                case 64:
                    /*! Conditions:: token bnf ebnf INITIAL */
                    /*! Rule::       %{NAME}([^\r\n]*) */
                    /* ignore unrecognized decl */
                    this.warn(rmCommonWS(_templateObject79, dquote(yy_.yytext), dquote(this.topState())) + this.prettyPrintRange(yy_.yylloc));

                    yy_.yytext = [this.matches[1], // {NAME}  
                    this.matches[2].trim() // optional value/parameters 
                    ];

                    return 21;
                    break;

                case 65:
                    /*! Conditions:: token bnf ebnf INITIAL */
                    /*! Rule::       <{ID}> */
                    yy_.yytext = this.matches[1];

                    return 36;
                    break;

                case 66:
                    /*! Conditions:: token bnf ebnf INITIAL */
                    /*! Rule::       \{\{([^]*?)\}\} */
                    yy_.yytext = this.matches[1].replace(/\}\\\}/g, '}}'); // unescape any literal '}\}' that exists within the action code block 

                    return 15;
                    break;

                case 67:
                    /*! Conditions:: token bnf ebnf INITIAL */
                    /*! Rule::       %\{([^]*?)%\} */
                    yy_.yytext = this.matches[1].replace(/%\\\}/g, '%}'); // unescape any literal '%\}' that exists within the action code block 

                    return 15;
                    break;

                case 68:
                    /*! Conditions:: token bnf ebnf INITIAL */
                    /*! Rule::       \{ */
                    yy.depth = 0;

                    this.pushState('action');
                    return 12;
                    break;

                case 69:
                    /*! Conditions:: token bnf ebnf INITIAL */
                    /*! Rule::       ->.* */
                    yy_.yytext = yy_.yytext.substr(2, yy_.yyleng - 2).trim();

                    return 42;
                    break;

                case 70:
                    /*! Conditions:: token bnf ebnf INITIAL */
                    /*! Rule::       .* */
                    yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 1).trim();

                    return 42;
                    break;

                case 71:
                    /*! Conditions:: token bnf ebnf INITIAL */
                    /*! Rule::       =>.* */
                    yy_.yytext = yy_.yytext.substr(2, yy_.yyleng - 2).trim();

                    return 42;
                    break;

                case 72:
                    /*! Conditions:: token bnf ebnf INITIAL */
                    /*! Rule::       {HEX_NUMBER} */
                    yy_.yytext = parseInt(yy_.yytext, 16);

                    return 37;
                    break;

                case 73:
                    /*! Conditions:: token bnf ebnf INITIAL */
                    /*! Rule::       {DECIMAL_NUMBER}(?![xX0-9a-fA-F]) */
                    yy_.yytext = parseInt(yy_.yytext, 10);

                    return 37;
                    break;

                case 75:
                    /*! Conditions:: code */
                    /*! Rule::       [^\r\n]+ */
                    return 46; // the bit of CODE just before EOF...  

                    break;

                case 76:
                    /*! Conditions:: path */
                    /*! Rule::       {BR} */
                    this.popState();

                    this.unput(yy_.yytext);
                    break;

                case 77:
                    /*! Conditions:: path */
                    /*! Rule::       "{DOUBLEQUOTED_STRING_CONTENT}" */
                    yy_.yytext = unescQuote(this.matches[1]);

                    this.popState();
                    return 45;
                    break;

                case 78:
                    /*! Conditions:: path */
                    /*! Rule::       '{QUOTED_STRING_CONTENT}' */
                    yy_.yytext = unescQuote(this.matches[1]);

                    this.popState();
                    return 45;
                    break;

                case 79:
                    /*! Conditions:: path */
                    /*! Rule::       {WS}+ */
                    // skip whitespace in the line 
                    break;

                case 80:
                    /*! Conditions:: path */
                    /*! Rule::       [^\s\r\n]+ */
                    this.popState();

                    return 45;
                    break;

                case 81:
                    /*! Conditions:: action */
                    /*! Rule::       " */
                    yy_.yyerror(rmCommonWS(_templateObject31) + this.prettyPrintRange(yy_.yylloc));

                    return 2;
                    break;

                case 82:
                    /*! Conditions:: action */
                    /*! Rule::       ' */
                    yy_.yyerror(rmCommonWS(_templateObject31) + this.prettyPrintRange(yy_.yylloc));

                    return 2;
                    break;

                case 83:
                    /*! Conditions:: action */
                    /*! Rule::       ` */
                    yy_.yyerror(rmCommonWS(_templateObject31) + this.prettyPrintRange(yy_.yylloc));

                    return 2;
                    break;

                case 84:
                    /*! Conditions:: option_values */
                    /*! Rule::       " */
                    yy_.yyerror(rmCommonWS(_templateObject32) + this.prettyPrintRange(yy_.yylloc));

                    return 2;
                    break;

                case 85:
                    /*! Conditions:: option_values */
                    /*! Rule::       ' */
                    yy_.yyerror(rmCommonWS(_templateObject32) + this.prettyPrintRange(yy_.yylloc));

                    return 2;
                    break;

                case 86:
                    /*! Conditions:: option_values */
                    /*! Rule::       ` */
                    yy_.yyerror(rmCommonWS(_templateObject32) + this.prettyPrintRange(yy_.yylloc));

                    return 2;
                    break;

                case 87:
                    /*! Conditions:: * */
                    /*! Rule::       " */
                    var rules = this.topState() === 'macro' ? 'macro\'s' : this.topState();

                    yy_.yyerror(rmCommonWS(_templateObject33, rules) + this.prettyPrintRange(yy_.yylloc));

                    return 2;
                    break;

                case 88:
                    /*! Conditions:: * */
                    /*! Rule::       ' */
                    var rules = this.topState() === 'macro' ? 'macro\'s' : this.topState();

                    yy_.yyerror(rmCommonWS(_templateObject33, rules) + this.prettyPrintRange(yy_.yylloc));

                    return 2;
                    break;

                case 89:
                    /*! Conditions:: * */
                    /*! Rule::       ` */
                    var rules = this.topState() === 'macro' ? 'macro\'s' : this.topState();

                    yy_.yyerror(rmCommonWS(_templateObject33, rules) + this.prettyPrintRange(yy_.yylloc));

                    return 2;
                    break;

                case 90:
                    /*! Conditions:: * */
                    /*! Rule::       . */
                    /* b0rk on bad characters */
                    yy_.yyerror(rmCommonWS(_templateObject80, dquote(yy_.yytext), dquote(this.topState())) + this.prettyPrintRange(yy_.yylloc));

                    break;

                default:
                    return this.simpleCaseActionClusters[yyrulenumber];
            }
        },

        simpleCaseActionClusters: {
            /*! Conditions:: action */
            /*! Rule::       \/\*[^]*?\*\/ */
            0: 43,

            /*! Conditions:: action */
            /*! Rule::       \/\/[^\r\n]* */
            1: 43,

            /*! Conditions:: action */
            /*! Rule::       "{DOUBLEQUOTED_STRING_CONTENT}" */
            3: 43,

            /*! Conditions:: action */
            /*! Rule::       '{QUOTED_STRING_CONTENT}' */
            4: 43,

            /*! Conditions:: action */
            /*! Rule::       [/"'][^{}/"']+ */
            5: 43,

            /*! Conditions:: action */
            /*! Rule::       [^{}/"']+ */
            6: 43,

            /*! Conditions:: bnf ebnf */
            /*! Rule::       %empty\b */
            13: 38,

            /*! Conditions:: bnf ebnf */
            /*! Rule::       %epsilon\b */
            14: 38,

            /*! Conditions:: bnf ebnf */
            /*! Rule::       \u0190 */
            15: 38,

            /*! Conditions:: bnf ebnf */
            /*! Rule::       \u025B */
            16: 38,

            /*! Conditions:: bnf ebnf */
            /*! Rule::       \u03B5 */
            17: 38,

            /*! Conditions:: bnf ebnf */
            /*! Rule::       \u03F5 */
            18: 38,

            /*! Conditions:: ebnf */
            /*! Rule::       \( */
            19: 7,

            /*! Conditions:: ebnf */
            /*! Rule::       \) */
            20: 8,

            /*! Conditions:: ebnf */
            /*! Rule::       \* */
            21: 9,

            /*! Conditions:: ebnf */
            /*! Rule::       \? */
            22: 10,

            /*! Conditions:: ebnf */
            /*! Rule::       \+ */
            23: 11,

            /*! Conditions:: options */
            /*! Rule::       {NAME} */
            24: 25,

            /*! Conditions:: token bnf ebnf INITIAL */
            /*! Rule::       {ID} */
            38: 24,

            /*! Conditions:: token bnf ebnf INITIAL */
            /*! Rule::       {NAME} */
            39: 25,

            /*! Conditions:: token bnf ebnf INITIAL */
            /*! Rule::       \$end\b */
            40: 40,

            /*! Conditions:: token bnf ebnf INITIAL */
            /*! Rule::       \$eof\b */
            41: 40,

            /*! Conditions:: token */
            /*! Rule::       [^\s\r\n]+ */
            44: 'TOKEN_WORD',

            /*! Conditions:: token bnf ebnf INITIAL */
            /*! Rule::       : */
            45: 5,

            /*! Conditions:: token bnf ebnf INITIAL */
            /*! Rule::       ; */
            46: 4,

            /*! Conditions:: token bnf ebnf INITIAL */
            /*! Rule::       \| */
            47: 6,

            /*! Conditions:: token bnf ebnf INITIAL */
            /*! Rule::       %debug\b */
            50: 19,

            /*! Conditions:: token bnf ebnf INITIAL */
            /*! Rule::       %parser-type\b */
            51: 32,

            /*! Conditions:: token bnf ebnf INITIAL */
            /*! Rule::       %prec\b */
            52: 41,

            /*! Conditions:: token bnf ebnf INITIAL */
            /*! Rule::       %start\b */
            53: 16,

            /*! Conditions:: token bnf ebnf INITIAL */
            /*! Rule::       %left\b */
            54: 33,

            /*! Conditions:: token bnf ebnf INITIAL */
            /*! Rule::       %right\b */
            55: 34,

            /*! Conditions:: token bnf ebnf INITIAL */
            /*! Rule::       %nonassoc\b */
            56: 35,

            /*! Conditions:: token bnf ebnf INITIAL */
            /*! Rule::       %parse-param[s]? */
            58: 31,

            /*! Conditions:: token bnf ebnf INITIAL */
            /*! Rule::       %code\b */
            61: 23,

            /*! Conditions:: token bnf ebnf INITIAL */
            /*! Rule::       %import\b */
            62: 22,

            /*! Conditions:: code */
            /*! Rule::       [^\r\n]*(\r|\n)+ */
            74: 46,

            /*! Conditions:: * */
            /*! Rule::       $ */
            91: 1
        },

        rules: [
        /*  0: */new XRegExp('^(?:\\/\\*[^]*?\\*\\/)', ''),
        /*  1: *//^(?:\/\/[^\r\n]*)/,
        /*  2: *//^(?:\/[^ \/]*?['"{}][^ ]*?\/)/,
        /*  3: *//^(?:"((?:\\"|\\[^"]|[^\n\r"\\])*)")/,
        /*  4: *//^(?:'((?:\\'|\\[^']|[^\n\r'\\])*)')/,
        /*  5: *//^(?:[\/"'][^{}\/"']+)/,
        /*  6: *//^(?:[^{}\/"']+)/,
        /*  7: *//^(?:\{)/,
        /*  8: *//^(?:\})/,
        /*  9: *//^(?:(\r\n|\n|\r))/,
        /* 10: *//^(?:%%)/,
        /* 11: *//^(?:;)/,
        /* 12: *//^(?:%%)/,
        /* 13: *//^(?:%empty\b)/,
        /* 14: *//^(?:%epsilon\b)/,
        /* 15: *//^(?:\u0190)/,
        /* 16: *//^(?:\u025B)/,
        /* 17: *//^(?:\u03B5)/,
        /* 18: *//^(?:\u03F5)/,
        /* 19: *//^(?:\()/,
        /* 20: *//^(?:\))/,
        /* 21: *//^(?:\*)/,
        /* 22: *//^(?:\?)/,
        /* 23: *//^(?:\+)/,
        /* 24: */new XRegExp('^(?:([\\p{Alphabetic}_](?:[\\p{Alphabetic}\\p{Number}\\-_]*(?:[\\p{Alphabetic}\\p{Number}_]))?))', ''),
        /* 25: *//^(?:=)/,
        /* 26: *//^(?:"((?:\\"|\\[^"]|[^\n\r"\\])*)")/,
        /* 27: *//^(?:'((?:\\'|\\[^']|[^\n\r'\\])*)')/,
        /* 28: *//^(?:`((?:\\`|\\[^`]|[^\\`])*)`)/,
        /* 29: *//^(?:\/\/[^\r\n]*)/,
        /* 30: */new XRegExp('^(?:\\/\\*[^]*?\\*\\/)', ''),
        /* 31: *//^(?:\S+)/,
        /* 32: *//^(?:(\r\n|\n|\r)([^\S\n\r])+(?=\S))/,
        /* 33: *//^(?:(\r\n|\n|\r))/,
        /* 34: *//^(?:([^\S\n\r])+)/,
        /* 35: *//^(?:([^\S\n\r])+)/,
        /* 36: *//^(?:(\r\n|\n|\r)+)/,
        /* 37: */new XRegExp('^(?:\\[([\\p{Alphabetic}_](?:[\\p{Alphabetic}\\p{Number}_])*)\\])', ''),
        /* 38: */new XRegExp('^(?:([\\p{Alphabetic}_](?:[\\p{Alphabetic}\\p{Number}_])*))', ''),
        /* 39: */new XRegExp('^(?:([\\p{Alphabetic}_](?:[\\p{Alphabetic}\\p{Number}\\-_]*(?:[\\p{Alphabetic}\\p{Number}_]))?))', ''),
        /* 40: *//^(?:\$end\b)/,
        /* 41: *//^(?:\$eof\b)/,
        /* 42: *//^(?:"((?:\\"|\\[^"]|[^\n\r"\\])*)")/,
        /* 43: *//^(?:'((?:\\'|\\[^']|[^\n\r'\\])*)')/,
        /* 44: *//^(?:\S+)/,
        /* 45: *//^(?::)/,
        /* 46: *//^(?:;)/,
        /* 47: *//^(?:\|)/,
        /* 48: *//^(?:%%)/,
        /* 49: *//^(?:%ebnf\b)/,
        /* 50: *//^(?:%debug\b)/,
        /* 51: *//^(?:%parser-type\b)/,
        /* 52: *//^(?:%prec\b)/,
        /* 53: *//^(?:%start\b)/,
        /* 54: *//^(?:%left\b)/,
        /* 55: *//^(?:%right\b)/,
        /* 56: *//^(?:%nonassoc\b)/,
        /* 57: *//^(?:%token\b)/,
        /* 58: *//^(?:%parse-param[s]?)/,
        /* 59: *//^(?:%option[s]?)/,
        /* 60: */new XRegExp('^(?:%lex((?:[^\\S\\n\\r])*(?:(?:\\r\\n|\\n|\\r)[^]*?)?(?:\\r\\n|\\n|\\r)(?:[^\\S\\n\\r])*)\\/lex\\b)', ''),
        /* 61: *//^(?:%code\b)/,
        /* 62: *//^(?:%import\b)/,
        /* 63: *//^(?:%include\b)/,
        /* 64: */new XRegExp('^(?:%([\\p{Alphabetic}_](?:[\\p{Alphabetic}\\p{Number}\\-_]*(?:[\\p{Alphabetic}\\p{Number}_]))?)([^\\n\\r]*))', ''),
        /* 65: */new XRegExp('^(?:<([\\p{Alphabetic}_](?:[\\p{Alphabetic}\\p{Number}_])*)>)', ''),
        /* 66: */new XRegExp('^(?:\\{\\{([^]*?)\\}\\})', ''),
        /* 67: */new XRegExp('^(?:%\\{([^]*?)%\\})', ''),
        /* 68: *//^(?:\{)/,
        /* 69: *//^(?:->.*)/,
        /* 70: *//^(?:.*)/,
        /* 71: *//^(?:=>.*)/,
        /* 72: *//^(?:(0[Xx][\dA-Fa-f]+))/,
        /* 73: *//^(?:([1-9]\d*)(?![\dA-FXa-fx]))/,
        /* 74: *//^(?:[^\r\n]*(\r|\n)+)/,
        /* 75: *//^(?:[^\r\n]+)/,
        /* 76: *//^(?:(\r\n|\n|\r))/,
        /* 77: *//^(?:"((?:\\"|\\[^"]|[^\n\r"\\])*)")/,
        /* 78: *//^(?:'((?:\\'|\\[^']|[^\n\r'\\])*)')/,
        /* 79: *//^(?:([^\S\n\r])+)/,
        /* 80: *//^(?:\S+)/,
        /* 81: *//^(?:")/,
        /* 82: *//^(?:')/,
        /* 83: *//^(?:`)/,
        /* 84: *//^(?:")/,
        /* 85: *//^(?:')/,
        /* 86: *//^(?:`)/,
        /* 87: *//^(?:")/,
        /* 88: *//^(?:')/,
        /* 89: *//^(?:`)/,
        /* 90: *//^(?:.)/,
        /* 91: *//^(?:$)/],

        conditions: {
            'action': {
                rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 81, 82, 83, 87, 88, 89, 90, 91],
                inclusive: false
            },

            'code': {
                rules: [63, 74, 75, 87, 88, 89, 90, 91],
                inclusive: false
            },

            'path': {
                rules: [29, 30, 76, 77, 78, 79, 80, 87, 88, 89, 90, 91],
                inclusive: false
            },

            'options': {
                rules: [24, 25, 29, 30, 32, 33, 34, 87, 88, 89, 90, 91],
                inclusive: false
            },

            'option_values': {
                rules: [26, 27, 28, 29, 30, 31, 34, 84, 85, 86, 87, 88, 89, 90, 91],
                inclusive: false
            },

            'token': {
                rules: [9, 10, 11, 29, 30, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 87, 88, 89, 90, 91],

                inclusive: true
            },

            'bnf': {
                rules: [12, 13, 14, 15, 16, 17, 18, 29, 30, 35, 36, 37, 38, 39, 40, 41, 42, 43, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 87, 88, 89, 90, 91],

                inclusive: true
            },

            'ebnf': {
                rules: [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 29, 30, 35, 36, 37, 38, 39, 40, 41, 42, 43, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 87, 88, 89, 90, 91],

                inclusive: true
            },

            'INITIAL': {
                rules: [29, 30, 35, 36, 37, 38, 39, 40, 41, 42, 43, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 87, 88, 89, 90, 91],

                inclusive: true
            }
        }
    };

    var rmCommonWS = helpers.rmCommonWS;
    var dquote = helpers.dquote;

    function unescQuote(str) {
        str = '' + str;
        var a = str.split('\\\\');

        a = a.map(function (s) {
            return s.replace(/\\'/g, '\'').replace(/\\"/g, '"');
        });

        str = a.join('\\\\');
        return str;
    }

    lexer.warn = function l_warn() {
        if (this.yy && this.yy.parser && typeof this.yy.parser.warn === 'function') {
            return this.yy.parser.warn.apply(this, arguments);
        } else {
            console.warn.apply(console, arguments);
        }
    };

    lexer.log = function l_log() {
        if (this.yy && this.yy.parser && typeof this.yy.parser.log === 'function') {
            return this.yy.parser.log.apply(this, arguments);
        } else {
            console.log.apply(console, arguments);
        }
    };

    return lexer;
}();
parser$2.lexer = lexer$1;

var ebnf = false;

var rmCommonWS$4 = helpers.rmCommonWS;
var dquote$2 = helpers.dquote;
var checkActionBlock$2 = helpers.checkActionBlock;

// transform ebnf to bnf if necessary
function extend(json, grammar) {
    if (ebnf) {
        json.ebnf = grammar.grammar; // keep the original source EBNF around for possible pretty-printing & AST exports.
        json.bnf = transform(grammar.grammar);
    } else {
        json.bnf = grammar.grammar;
    }
    if (grammar.actionInclude) {
        json.actionInclude = grammar.actionInclude;
    }
    return json;
}

// convert string value to number or boolean value, when possible
// (and when this is more or less obviously the intent)
// otherwise produce the string itself as value.
function parseValue$1(v) {
    if (v === 'false') {
        return false;
    }
    if (v === 'true') {
        return true;
    }
    // http://stackoverflow.com/questions/175739/is-there-a-built-in-way-in-javascript-to-check-if-a-string-is-a-valid-number
    // Note that the `v` check ensures that we do not convert `undefined`, `null` and `''` (empty string!)
    if (v && !isNaN(v)) {
        var rv = +v;
        if (isFinite(rv)) {
            return rv;
        }
    }
    return v;
}

parser$2.warn = function p_warn() {
    console.warn.apply(console, arguments);
};

parser$2.log = function p_log() {
    console.log.apply(console, arguments);
};

function Parser$2() {
    this.yy = {};
}
Parser$2.prototype = parser$2;
parser$2.Parser = Parser$2;

function yyparse$1() {
    return parser$2.parse.apply(parser$2, arguments);
}

var bnf = {
    parser: parser$2,
    Parser: Parser$2,
    parse: yyparse$1

};

var version$2 = '0.6.1-210'; // require('./package.json').version;

function parse(grammar) {
    return bnf.parser.parse(grammar);
}

// adds a declaration to the grammar
bnf.parser.yy.addDeclaration = function bnfAddDeclaration(grammar, decl) {
    if (decl.start) {
        grammar.start = decl.start;
    } else if (decl.lex) {
        grammar.lex = parseLex(decl.lex.text, decl.lex.position);
    } else if (decl.operator) {
        if (!grammar.operators) grammar.operators = [];
        grammar.operators.push(decl.operator);
    } else if (decl.token) {
        if (!grammar.extra_tokens) grammar.extra_tokens = [];
        grammar.extra_tokens.push(decl.token);
    } else if (decl.token_list) {
        if (!grammar.extra_tokens) grammar.extra_tokens = [];
        decl.token_list.forEach(function (tok) {
            grammar.extra_tokens.push(tok);
        });
    } else if (decl.parseParams) {
        if (!grammar.parseParams) grammar.parseParams = [];
        grammar.parseParams = grammar.parseParams.concat(decl.parseParams);
    } else if (decl.parserType) {
        if (!grammar.options) grammar.options = {};
        grammar.options.type = decl.parserType;
    } else if (decl.include) {
        if (!grammar.moduleInclude) grammar.moduleInclude = '';
        grammar.moduleInclude += decl.include;
    } else if (decl.options) {
        if (!grammar.options) grammar.options = {};
        // last occurrence of `%options` wins:
        for (var i = 0; i < decl.options.length; i++) {
            grammar.options[decl.options[i][0]] = decl.options[i][1];
        }
    } else if (decl.unknownDecl) {
        if (!grammar.unknownDecls) grammar.unknownDecls = [];
        grammar.unknownDecls.push(decl.unknownDecl);
    } else if (decl.imports) {
        if (!grammar.imports) grammar.imports = [];
        grammar.imports.push(decl.imports);
    } else if (decl.actionInclude) {
        if (!grammar.actionInclude) {
            grammar.actionInclude = '';
        }
        grammar.actionInclude += decl.actionInclude;
    } else if (decl.initCode) {
        if (!grammar.moduleInit) {
            grammar.moduleInit = [];
        }
        grammar.moduleInit.push(decl.initCode); // {qualifier: <name>, include: <source code chunk>}
    }
};

// parse an embedded lex section
function parseLex(text, position) {
    text = text.replace(/(?:^%lex)|(?:\/lex$)/g, '');
    // We want the lex input to start at the given 'position', if any,
    // so that error reports will produce a line number and character index
    // which matches the original input file:
    position = position || {};
    position.range = position.range || [];
    var l = position.first_line | 0;
    var c = position.range[0] | 0;
    var prelude = '';
    if (l > 1) {
        prelude += new Array(l).join('\n');
        c -= prelude.length;
    }
    if (c > 3) {
        prelude = '// ' + new Array(c - 3).join('.') + prelude;
    }
    return jisonlex.parse(prelude + text);
}

var ebnf_parser = {
    transform: transform
};

var ebnfParser = {
    parse: parse,

    transform: transform,

    // assistant exports for debugging/testing:
    bnf_parser: bnf,
    ebnf_parser: ebnf_parser,
    bnf_lexer: jisonlex,

    version: version$2
};

// import Lexer from '../../packages/jison-lex';
// import ebnfParser from '../../packages/ebnf-parser';
// import lexParser from '../../packages/lex-parser';
// import XRegExp from '@gerhobbelt/xregexp';
// import recast from '@gerhobbelt/recast';
// import astUtils from '@gerhobbelt/ast-util';
// import prettier from '@gerhobbelt/prettier-miscellaneous';
var rmCommonWS$5 = helpers.rmCommonWS;
/**
 * Output the `raw` input (JSON format or plain STRING containing JSON-formatted data)
 * as JISON source file format in the returned string.
 *
 * @returns a string containing the file contents of an input-equivalent JISON parser/lexer source file.
 * @public
 */
function grammarPrinter(raw, options) {
    if ((typeof raw === 'undefined' ? 'undefined' : _typeof(raw)) !== 'object') {
        raw = json5.parse(raw);
    }
    options = options || {};
    options.showLexer = options.showLexer !== undefined ? !!options.showLexer : true;
    options.showParser = options.showParser !== undefined ? !!options.showParser : true;
    switch (String(options.format).toLowerCase()) {
        default:
        case 'jison':
            options.format = 'jison';
            break;

        case 'json5':
            options.format = 'json5';
            break;

        case '.y':
        case '.yacc':
            options.format = 'jison';
            options.showLexer = false;
            options.showParser = true;
            break;

        case '.l':
        case '.lex':
            options.format = 'jison';
            options.showLexer = true;
            options.showParser = false;
            break;
    }

    function makeIndent(num) {
        return new Array(num + 1).join(' ');
    }

    function padRight(str, num) {
        return str + new Array(Math.max(0, num - str.length) + 1).join(' ');
    }

    function indentAction(src, num) {
        // It's dangerous to indent an action code chunk as it MAY contain **template strings**
        // which MAY get corrupted that way as their actual content would change then!

        // construct fake nesting levels to arrive at the intended start indent value: `num`
        var nesting_levels = num / 2;
        var pre = '// **PRE**',
            post = '// **POST**';
        for (; nesting_levels > 0; nesting_levels--) {
            pre = 'function x() {\n' + pre;
            post += '\n}';
        }
        src = '\n' + pre + '\n' + src + '\n' + post + '\n';

        var ast = helpers.parseCodeChunkToAST(src);
        var new_src = helpers.prettyPrintAST(ast);

        var start = new_src.indexOf('// **PRE**');
        var end = new_src.lastIndexOf('// **POST**');
        new_src = new_src.substring(start + 10, end).trim();

        return new_src;
    }

    function isEmptyObj(obj) {
        var keys = obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && Object.keys(obj);
        return keys && keys.length === 0;
    }

    function isEmptyArr(arr) {
        if (arr && arr instanceof Array) {
            for (var i = 0, len = arr.length; i < len; i++) {
                if (arr[i] !== undefined) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }

    // Copied from Crokford's implementation of JSON
    // See https://github.com/douglascrockford/JSON-js/blob/e39db4b7e6249f04a195e7dd0840e610cc9e941e/json2.js#L195
    // Begin
    var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        meta = { // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"': '\\"',
        '\\': '\\\\'
    };

    function escapeString(string) {
        // If the string contains no control characters, no quote characters, and no
        // backslash characters, then we can safely slap some quotes around it.
        // Otherwise we must also replace the offending characters with safe escape
        // sequences.
        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string' ? c : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }

    var ref_list;
    var ref_names;

    // create a deep copy of the input, so we can delete the parts we converted and dump the remainder
    // so that we always output the entire thing, even when we don't know all the details about the
    // actual input:
    function deepClone(from, sub) {
        if (sub == null) {
            ref_list = [];
            ref_names = [];
            sub = 'root';
        }
        if (typeof from === 'function') return '[Function]';
        if (from == null || (typeof from === 'undefined' ? 'undefined' : _typeof(from)) !== 'object') return from;
        if (from.constructor !== Object && from.constructor !== Array) {
            return from;
        }

        for (var i = 0, len = ref_list.length; i < len; i++) {
            if (ref_list[i] === from) {
                return '[Circular/Xref:' + ref_names[i] + ']'; // circular or cross reference
            }
        }
        ref_list.push(from);
        ref_names.push(sub);
        sub += '.';

        var to = new from.constructor();
        for (var name in from) {
            to[name] = deepClone(from[name], sub + name);
        }
        return to;
    }

    var originalInput = raw;
    raw = deepClone(raw);

    var lex_out_str = '';
    if (raw.lex) {
        var lex_pre = [];
        var lex_rules = [];
        var lex_post = [];
        var key, src;

        src = raw.lex.macros;
        delete raw.lex.macros;
        if (src && !isEmptyObj(src)) {
            lex_pre.push(rmCommonWS$5(_templateObject81));

            var keylen = 0;
            for (key in src) {
                keylen = Math.max(keylen, key.length);
            }
            console.log('macros keylen:', keylen);
            keylen = (keylen / 4 | 0) * 4 + 4;
            console.log('macros keylen B:', keylen);
            for (key in src) {
                lex_pre.push(padRight(key, keylen) + src[key]);
            }

            lex_pre.push(rmCommonWS$5(_templateObject82));
        }

        src = raw.lex.unknownDecls;
        delete raw.lex.unknownDecls;
        if (src && !isEmptyObj(src)) {
            lex_pre.push(rmCommonWS$5(_templateObject83));

            for (var i = 0, len = src.length; i < len; i++) {
                var entry = src[i];
                var key = entry[0];
                var value = entry[1];

                lex_pre.push('%' + key + ' ' + value);
            }

            lex_pre.push(rmCommonWS$5(_templateObject84));
        }

        src = raw.lex.options;
        delete raw.lex.options;
        if (src && !isEmptyObj(src)) {
            lex_pre.push(rmCommonWS$5(_templateObject85));

            for (key in src) {
                var value = src[key];
                if (value) {
                    lex_pre.push('%options ' + key + '=' + value);
                } else {
                    lex_pre.push('%options ' + key);
                }
            }
        }

        src = raw.lex.startConditions;
        delete raw.lex.startConditions;
        if (src && !isEmptyObj(src)) {
            for (key in src) {
                var value = src[key];

                lex_pre.push((value ? '%x ' : '%s ') + key);
            }
        }

        src = raw.lex.actionInclude;
        delete raw.lex.actionInclude;
        if (src && src.trim()) {
            lex_pre.push('%{\n' + indentAction(src.trim(), 4) + '\n%}');
        }

        src = raw.lex.rules;
        delete raw.lex.rules;
        if (src) {
            for (var i = 0, len = src.length; i < len; i++) {
                var entry = src[i];
                key = entry[0];
                var action = indentAction(entry[1], 4);

                var actionHasLF = /[\r\n]/.test(action);
                console.log('indented action:', {
                    entry: entry[1],
                    action: action,
                    actionHasLF: actionHasLF
                });
                if (key.length <= 12) {
                    if (!actionHasLF) {
                        lex_rules.push(padRight(key, 16) + indentAction(action, 16));
                    } else {
                        lex_rules.push(padRight(key, 16) + '%' + indentAction('{ ' + action + ' }', 16) + '%');
                    }
                } else {
                    if (!actionHasLF) {
                        lex_rules.push(key, makeIndent(16) + indentAction(action, 16));
                    } else {
                        lex_rules.push(key, makeIndent(16) + '%' + indentAction('{ ' + action + ' }', 16) + '%');
                    }
                }
            }
        }

        src = raw.lex.moduleInclude;
        delete raw.lex.moduleInclude;
        if (src && src.trim()) {
            lex_post.push(indentAction(src.trim(), 0));
        }

        var out = '';

        if (!isEmptyObj(raw.lex)) {
            // dump the remainder as a comment:
            var rem = json5.stringify(raw.lex, null, 2);
            out += rmCommonWS$5(_templateObject86, rem.replace(/\*\//g, '*\\/'));
        }
        delete raw.lex;

        out += lex_pre.join('\n') + '\n\n';
        out += rmCommonWS$5(_templateObject87) + lex_rules.join('\n') + '\n\n';
        if (lex_post.length > 0) {
            out += rmCommonWS$5(_templateObject88) + lex_post.join('\n') + '\n\n';
        }
        lex_out_str = out;
    }

    var grammar_pre = [];
    var grammar_mid = [];
    var ebnf_rules = [];
    var bnf_rules = [];
    var grammar_post = [];
    var key, src;

    var fmtprod = function fmtprod(rule, prodset) {
        var backup = deepClone(prodset);

        rule += prodset[0] ? prodset[0] : '%epsilon';
        var prec = null;
        var lead = rule.split(/\r\n\|\n|\r/).pop();
        delete prodset[0];

        if (prodset.length === 3 && _typeof(prodset[2]) === 'object') {
            prec = '%prec ' + prodset[2].prec;
            if (lead.length < 12) {
                rule += makeIndent(12 - lead.length);
            }
            rule += '  ' + prec;

            delete prodset[2].prec;
            if (isEmptyObj(prodset[2])) {
                delete prodset[2];
            }
        } else if (prodset.length === 2 && _typeof(prodset[1]) === 'object') {
            prec = '%prec ' + prodset[1].prec;
            if (lead.length < 12) {
                rule += makeIndent(12 - lead.length);
            }
            rule += '  ' + prec;

            delete prodset[1].prec;
            if (isEmptyObj(prodset[1])) {
                delete prodset[1];
            }
        }
        if (typeof prodset[1] === 'string') {
            var action = prodset[1];
            if (lead.length < 12 - 1) {
                rule += makeIndent(12 - lead.length) + indentAction('{ ' + action + ' }', 12);
            } else {
                rule += '\n' + makeIndent(12) + indentAction('{ ' + action + ' }', 12);
            }
            delete prodset[1];
        }

        if (isEmptyArr(prodset)) {
            prodset.length = 0;
        } else {
            prodset = backup;
        }
        return rule;
    };

    var grammarfmt = function grammarfmt(src) {
        var key;
        var dst = [];

        for (key in src) {
            var prodset = src[key];
            var rule;
            console.log('format one rule:', {
                key: key,
                prodset: prodset
            });

            if (typeof prodset === 'string') {
                rule = fmtprod(key + ' : ', [prodset]) + ';';
                delete src[key];
            } else if (prodset instanceof Array) {
                if (prodset.length === 1) {
                    if (typeof prodset[0] === 'string') {
                        rule = fmtprod(key + ' : ', [prodset]) + ';';
                        delete src[key];
                    } else if (prodset[0] instanceof Array) {
                        rule = fmtprod(key + ' : ', prodset[0]);
                        rule += '\n    ;';
                        if (prodset[0].length === 0) {
                            delete src[key];
                        }
                    } else {
                        rule = key + '\n    : **ERRONEOUS PRODUCTION** (see the dump for more): ' + prodset[0];
                    }
                } else if (prodset.length > 1) {
                    if (typeof prodset[0] === 'string') {
                        rule = fmtprod(key + '\n    : ', [prodset[0]]);
                        delete prodset[0];
                    } else if (prodset[0] instanceof Array) {
                        rule = fmtprod(key + '\n    : ', prodset[0]);
                        if (prodset[0].length === 0) {
                            delete prodset[0];
                        }
                    } else {
                        rule = key + '\n    : **ERRONEOUS PRODUCTION** (see the dump for more): ' + prodset[0];
                    }
                    for (var i = 1, len = prodset.length; i < len; i++) {
                        if (typeof prodset[i] === 'string') {
                            rule += fmtprod('\n    | ', [prodset[i]]);
                            delete prodset[i];
                        } else if (prodset[i] instanceof Array) {
                            rule += fmtprod('\n    | ', prodset[i]);
                            if (prodset[i].length === 0) {
                                delete prodset[i];
                            }
                        } else {
                            rule += '\n    | **ERRONEOUS PRODUCTION** (see the dump for more): ' + prodset[i];
                        }
                    }
                    rule += '\n    ;';

                    if (isEmptyArr(prodset)) {
                        delete src[key];
                    }
                }
            } else {
                rule = key + '\n    : **ERRONEOUS PRODUCTION** (see the dump for more): ' + prodset;
            }
            dst.push(rule);
        }

        return dst;
    };

    src = raw.ebnf;
    if (src) {
        ebnf_rules = grammarfmt(src);

        if (isEmptyObj(src)) {
            delete raw.ebnf;
        }
    }

    src = raw.bnf;
    //delete raw.bnf;
    if (src) {
        bnf_rules = grammarfmt(src);

        if (isEmptyObj(src)) {
            delete raw.bnf;
        }
    }

    src = raw.unknownDecls;
    delete raw.unknownDecls;
    if (src && !isEmptyObj(src)) {
        lex_pre.push(rmCommonWS$5(_templateObject89));

        for (var i = 0, len = src.length; i < len; i++) {
            var entry = src[i];
            var key = entry[0];
            var value = entry[1];

            lex_pre.push('%' + key + ' ' + value);
        }

        lex_pre.push(rmCommonWS$5(_templateObject90));
    }

    //src = raw.lex;
    //delete raw.lex;
    //if (src) {
    if (lex_out_str.trim() && options.showLexer) {
        grammar_pre.push(rmCommonWS$5(_templateObject91, lex_out_str));
    }

    src = raw.options;
    delete raw.options;
    if (src && !isEmptyObj(src)) {
        var a = [];
        for (key in src) {
            var value = src[key];
            switch (key) {
                default:
                    if (value !== true) {
                        a.push('options', '%options ' + key + '=' + value);
                    } else {
                        a.push('options', '%options ' + key);
                    }
                    break;

                case 'ebnf':
                    if (value) {
                        a.push(key, '%ebnf');
                    }
                    break;

                case 'type':
                    if (value) {
                        a.push(key, '%parser-type ' + value);
                    }
                    break;

                case 'debug':
                    if (typeof value !== 'boolean') {
                        a.push(key, '%debug ' + value);
                    } else if (value) {
                        a.push(key, '%debug');
                    }
                    break;
            }
        }
        var type = null;
        for (var i = 0, len = a.length; i < len; i += 2) {
            var t = a[i];
            var line = a[i + 1];
            if (t !== type) {
                type = t;
                grammar_pre.push('');
            }
            grammar_pre.push(line);
        }
        grammar_pre.push('');
    }

    src = raw.imports;
    if (src) {
        var clean = true;
        for (var i = 0, len = src.length; i < len; i++) {
            var entry = src[i];

            grammar_pre.push('%import ' + entry.name + '  ' + entry.path);
            delete entry.name;
            delete entry.path;
            if (isEmptyObj(entry)) {
                delete src[i];
            } else {
                clean = false;
            }
        }
        if (clean) {
            delete raw.imports;
        }
    }

    src = raw.moduleInit;
    if (src) {
        var clean = true;
        for (var i = 0, len = src.length; i < len; i++) {
            var entry = src[i];

            grammar_pre.push('%code ' + entry.qualifier + '  ' + entry.include);
            delete entry.qualifier;
            delete entry.include;
            if (isEmptyObj(entry)) {
                delete src[i];
            } else {
                clean = false;
            }
        }
        if (clean) {
            delete raw.moduleInit;
        }
    }

    src = raw.operators;
    if (src) {
        var clean = true;
        for (var i = 0, len = src.length; i < len; i++) {
            var entry = src[i];
            var tokens = entry[1];
            var line = '%' + entry[0] + ' ';

            for (var t = 0, tlen = tokens.length; t < tlen; t++) {
                line += ' ' + tokens[t];
            }

            grammar_pre.push(line);

            if (entry.length === 2) {
                delete src[i];
            } else {
                clean = false;
            }
        }
        if (clean) {
            delete raw.operators;
        }
    }

    src = raw.extra_tokens;
    if (src) {
        var clean = true;
        for (var i = 0, len = src.length; i < len; i++) {
            var entry = src[i];
            var line = '%token ' + entry.id;

            if (entry.type) {
                line += ' <' + entry.type + '>';
                delete entry.type;
            }
            if (entry.value) {
                line += ' ' + entry.value;
                delete entry.value;
            }
            if (entry.description) {
                line += ' ' + escapeString(entry.description);
                delete entry.description;
            }

            grammar_pre.push(line);

            delete entry.id;
            if (isEmptyObj(entry)) {
                delete src[i];
            } else {
                clean = false;
            }
        }
        if (clean) {
            delete raw.extra_tokens;
        }
    }

    src = raw.parseParams;
    delete raw.parseParams;
    if (src) {
        grammar_pre.push('%parse-param ' + src.join(' '));
    }

    src = raw.start;
    delete raw.start;
    if (src) {
        grammar_pre.push('%start ' + src);
    }

    src = raw.moduleInclude;
    delete raw.moduleInclude;
    if (src && src.trim()) {
        grammar_post.push(indentAction(src.trim(), 0));
    }

    src = raw.actionInclude;
    delete raw.actionInclude;
    if (src && src.trim()) {
        grammar_mid.push('%{\n' + indentAction(src.trim(), 4) + '\n%}');
    }

    var out = '';

    if (!isEmptyObj(raw)) {
        // dump the remainder as a comment:
        var rem = json5.stringify(raw, null, 2);
        out += rmCommonWS$5(_templateObject92, rem.replace(/\*\//g, '*\\/'));
        // delete raw;
    }

    if (!options.showParser) {
        out += lex_out_str;
    } else {
        out += grammar_pre.join('\n') + '\n\n';
        out += rmCommonWS$5(_templateObject87);
        if (grammar_mid.length > 0) {
            out += grammar_mid.join('\n') + '\n\n';
        }
        if (ebnf_rules.length > 0) {
            if (bnf_rules.length > 0) {
                // dump the original EBNF grammar as source and dump the BNF derivative as COMMENT:
                var bnf_deriv = bnf_rules.join('\n\n');
                var a = bnf_deriv.split(/\r\n|\n|\r/).map(function (line) {
                    return '// ' + line;
                });

                out += rmCommonWS$5(_templateObject93, a.join('\n'));
            }
            out += ebnf_rules.join('\n\n') + '\n\n';
        } else if (bnf_rules.length > 0) {
            out += bnf_rules.join('\n\n') + '\n\n';
        }

        if (grammar_post.length > 0) {
            out += rmCommonWS$5(_templateObject88) + grammar_post.join('\n') + '\n\n';
        }
    }

    if (options.format === 'json5') {
        var a = out.split(/\r\n|\n|\r/).map(function (line) {
            return '// ' + line;
        });

        out = rmCommonWS$5(_templateObject94, options.showParser ? 'grammar' : 'lexer', a.join('\n'));

        // process the original input once again: this time via JSON5
        raw = deepClone(originalInput);

        if (!options.showLexer) {
            delete raw.lex;
            out += JSON5.stringify(raw, null, 2);
        } else if (!options.showParser) {
            out += JSON5.stringify(raw.lex, null, 2);
        }
    }

    return out;
}

// Jison, an LR(0), SLR(1), LARL(1), LR(1) Parser Generator
// Zachary Carter <zach@carter.name>
// MIT Licensed

var rmCommonWS = helpers.rmCommonWS;
var camelCase = helpers.camelCase;
var code_exec = helpers.exec;
var version = '0.6.1-210';

var devDebug = 0;

// WARNING: this regex MUST match the regex for `ID` in ebnf-parser::bnf.l jison language lexer spec! (`ID = [{ALPHA}]{ALNUM}*`)
//
// This is the base XRegExp ID regex used in many places; this should match the ID macro definition in the EBNF/BNF parser et al as well!
var ID_REGEX_BASE = '[\\p{Alphabetic}_][\\p{Alphabetic}_\\p{Number}]*';

var Jison = {
    version: version
};

// see also ./lib/cli.js
var defaultJisonOptions = {
    moduleType: 'commonjs',
    debug: false,
    enableDebugLogs: false,
    numExpectedConflictStates: 0,
    json: false,
    type: 'lalr', // CLI: --parserType option
    compressTables: 2, // 0, 1, 2
    outputDebugTables: false,
    noDefaultResolve: false,
    defaultActionMode: ["classic", "merge"], // {classic, ast, none, skip}, {classic, ast, merge, none, skip}
    noTryCatch: false,
    hasPartialLrUpgradeOnConflict: true,
    errorRecoveryTokenDiscardCount: 3,
    exportAllTables: false,
    exportSourceCode: false,
    noMain: true, // CLI: not:(--main option)
    moduleMain: null, // `main()` function source code if `!noMain` is true
    moduleMainImports: null, // require()/import statements required by the `moduleMain` function source code if `!noMain` is true
    tokenStack: false,
    dumpSourceCodeOnFailure: true,
    throwErrorOnCompileFailure: true,

    moduleName: undefined,
    defaultModuleName: 'parser',
    file: undefined,
    outfile: undefined,
    inputPath: undefined,
    inputFilename: undefined,
    lexfile: undefined,
    warn_cb: undefined, // function(msg) | true (= use Jison.Print) | false (= throw Exception)

    parseParams: undefined,
    parserErrorsAreRecoverable: false,
    lexerErrorsAreRecoverable: false,
    ranges: undefined,
    showSource: false,
    reportStats: false,
    exportAST: false, // output grammar in JSON / JSON5 format (CLI version of JISON only)
    prettyCfg: true, // use `prettier` (or not) to (re)format the generated parser code.

    // internal analysis flags which MAY be forced by special %options
    // to override default jison behaviour for a given grammar.
    //
    // Do note that some analysis options CANNOT be overridden directly
    // as that would allow the user to produce GUARANTEED DEFECTIVE PARSERS
    // when they utilize this advanced behaviour modification power.
    //
    //    actionsAreAllDefault,
    actionsUseLocationAssignment: false,
    actionsUseLocationTracking: false,
    actionsUseParseError: false,
    actionsUseValueAssignment: false,
    actionsUseValueTracking: false,
    actionsUseYYCLEARIN: false,
    actionsUseYYERROK: false,
    actionsUseYYERROR: false,
    actionsUseYYLENG: false,
    actionsUseYYLINENO: false,
    actionsUseYYLOC: false,
    actionsUseYYRECOVERING: false,
    actionsUseYYRULELENGTH: false,
    actionsUseYYMERGELOCATIONINFO: false,
    actionsUseYYSSTACK: false,
    actionsUseYYSTACK: false,
    actionsUseYYSTACKPOINTER: false,
    actionsUseYYTEXT: false,
    hasErrorRecovery: false,
    hasErrorReporting: false
};

Jison.defaultJisonOptions = defaultJisonOptions;

// Merge sets of options.
//
// Convert alternative jison option names to their base option.
//
// The *last* option set which overrides the default wins, where 'override' is
// defined as specifying a not-undefined value which is not equal to the
// default value.
//
// When the FIRST argument is STRING "NODEFAULT", then we MUST NOT mix the
// default values avialable in Jison.defaultJisonOptions.
//
// Return a fresh set of options.
/** @public */
function mkStdOptions() {
    var h = Object.prototype.hasOwnProperty;

    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
    }

    if (devDebug > 3) {
        Jison.print('mkStdOptions:\n', args);
    }

    var opts = {};
    //var args = Array.prototype.concat.apply([], args);
    // clone defaults, so we do not modify those constants?
    if (args[0] !== "NODEFAULT") {
        args.unshift(Jison.defaultJisonOptions);
    } else {
        args.shift();
    }

    for (var i = 0, len = args.length; i < len; i++) {
        var o = args[i];
        if (!o) continue;

        // clone input (while camel-casing the options), so we do not modify those either.
        var o2 = {};

        for (var p in o) {
            if (typeof o[p] !== 'undefined' && h.call(o, p)) {
                o2[camelCase(p)] = o[p];
            }
        }

        // now clean them options up:
        if (typeof o2.main !== 'undefined') {
            o2.noMain = !o2.main;
        }

        if (typeof o2.noDefaultAction !== 'undefined') {
            throw new Error('option "no-default-action" has been OBSOLETED. Use "default-action-mode=[for-value,for-location]" instead (see \'jison --help\' for usage description).');
        }
        if (typeof o2.defaultAction !== 'undefined') {
            throw new Error('option "default-action" has been OBSOLETED. Use "default-action-mode=[for-value,for-location]" instead (see \'jison --help\' for usage description).');
        }
        if (typeof o2.hasDefaultResolve !== 'undefined') {
            o2.noDefaultResolve = !o2.hasDefaultResolve;
        }
        switch (_typeof(o2.defaultActionMode)) {
            case 'undefined':
                break;

            case 'object':
                if (typeof o2.defaultActionMode.slice === 'function') {
                    // make a copy of `defaultActionMode` to ensure the default source cannot be mutated through this `opts` instance:
                    o2.defaultActionMode = o2.defaultActionMode.slice(0);
                    break;
                }
            // fall through
            case 'string':
                var a = String(o2.defaultActionMode).split(',').map(function (m) {
                    return m.trim();
                });
                if (a.length === 1) {
                    a[1] = a[0];
                }
                o2.defaultActionMode = a;
                break;

            default:
                throw new Error('option "default-action-mode" must be a STRING or 2-element ARRAY value, when specified (see \'jison --help\' for usage description).');
        }

        if (typeof o2.hasTryCatch !== 'undefined') {
            o2.noTryCatch = !o2.hasTryCatch;
        }
        if (typeof o2.parserType !== 'undefined') {
            o2.type = o2.parserType;
        }
        if (typeof o2.moduleType !== 'undefined') {
            switch (o2.moduleType) {
                case 'js':
                case 'amd':
                case 'es':
                case 'commonjs':
                    break;

                // aliases a la `rollup` c.s.:
                case 'cjs':
                    o2.moduleType = 'commonjs';
                    break;

                case 'iife':
                    o2.moduleType = 'js';
                    break;

                case 'umd':
                    o2.moduleType = 'amd';
                    break;

                default:
                    throw new Error('unsupported moduleType: ' + dquote(opt.moduleType));
            }
        }

        if (o2.errorRecoveryTokenDiscardCount != null) {
            if (typeof o2.errorRecoveryTokenDiscardCount !== 'number') {
                throw new Error('options.errorRecoveryTokenDiscardCount should be a number or undefined; instead it has type: ' + _typeof(o2.errorRecoveryTokenDiscardCount));
            }
        }

        delete o2.parserType;
        delete o2.main;
        delete o2.hasDefaultResolve;
        delete o2.hasTryCatch;
        delete o2.noDefaultAction;

        // special check for `moduleName` to ensure we detect the 'default' moduleName entering from the CLI
        // NOT overriding the moduleName set in the grammar definition file via an `%options` entry:
        if (o2.moduleName === o2.defaultModuleName) {
            delete o2.moduleName;
        }

        // now see if we have an overriding option here:
        for (var p in o2) {
            if (h.call(o2, p)) {
                if (typeof o2[p] !== 'undefined') {
                    opts[p] = o2[p];
                }
            }
        }
    }

    if (devDebug > 3) {
        Jison.print('GENERATE::OPTIONS: RESULTING OPTIONS SET\n', opts);
    }

    return opts;
}

// set up export/output attributes of the `options` object instance
function prepExportStructures(options) {
    // set up the 'option' `exportAllTables` as a hash object for returning
    // all generated tables to the caller
    var exportDest = options.exportAllTables;
    if (!exportDest || (typeof exportDest === 'undefined' ? 'undefined' : _typeof(exportDest)) !== 'object') {
        exportDest = {
            enabled: !!exportDest
        };
    } else if (typeof exportDest.enabled !== 'boolean') {
        exportDest.enabled = true;
    }
    options.exportAllTables = exportDest;

    // set up the 'option' `exportSourceCode` as a hash object for returning
    // all generated source code chunks to the caller
    var exportSourceCode = options.exportSourceCode;
    if (!exportSourceCode || (typeof exportSourceCode === 'undefined' ? 'undefined' : _typeof(exportSourceCode)) !== 'object') {
        exportSourceCode = {
            enabled: !!exportSourceCode
        };
    } else if (typeof exportSourceCode.enabled !== 'boolean') {
        exportSourceCode.enabled = true;
    }
    options.exportSourceCode = exportSourceCode;
}

// Autodetect if the input grammar and optional lexer spec is in JSON or JISON
// format when the `options.json` flag is `true`.
//
// Produce the JSON parse result when these are JSON formatted already as that
// would save us the trouble of doing this again, anywhere else in the JISON
// compiler/generator.
//
// Otherwise return the *parsed* grammar and optional lexer specs as they have
// been processed through EBNFParser and LEXParser respectively.
function autodetectAndConvertToJSONformat(grammar, optionalLexerSection, options) {
    var chk_g = null;
    var chk_l = null;
    var ex1, err;

    if (typeof grammar === 'string') {
        if (options.json) {
            try {
                chk_g = json5.parse(grammar);

                // When JSON5-based parsing of the grammar succeeds, this implies the grammar is specified in `JSON mode`
                // *OR* there's a JSON/JSON5 format error in the input:
            } catch (e) {
                ex1 = e;
            }
        }
        if (!chk_g) {
            try {
                chk_g = ebnfParser.parse(grammar, options);
            } catch (e) {
                if (options.json) {
                    err = new Error('Could not parse jison grammar in JSON AUTODETECT mode\nError: ' + ex1.message + ' (' + e.message + ')');
                    err.secondary_exception = e;
                    err.stack = ex1.stack;
                } else {
                    err = new Error('Could not parse jison grammar\nError: ' + e.message);
                    err.stack = e.stack;
                }
                throw err;
            }
        }

        // Save time! Don't reparse the entire grammar *again* inside the code generators when that's not necessary:
        // if (chk_g) {
        //   grammar = chk_g;
        // }
    } else {
        chk_g = grammar;
    }

    // Now the same treatment for the lexer:
    if (chk_g && optionalLexerSection) {
        if (chk_g.lex) {
            throw new Error('Cannot invoke with both a lexer section in the grammar input and a separate lexer input at the same time!');
        }

        if (typeof optionalLexerSection === 'string') {
            if (options.json) {
                try {
                    chk_l = json5.parse(optionalLexerSection);

                    // When JSON5-based parsing of the lexer spec succeeds, this implies the lexer spec is specified in `JSON mode`
                    // *OR* there's a JSON/JSON5 format error in the input:
                } catch (e) {
                    ex1 = e;
                }
            }
            if (!chk_l) {
                // // WARNING: the lexer may receive options specified in the **grammar spec file**,
                // //          hence we should mix the options to ensure the lexParser always
                // //          receives the full set!
                // //
                // // make sure all options are 'standardized' before we go and mix them together:
                // options = mkStdOptions(grammar.options, options);
                try {
                    chk_l = jisonlex.parse(optionalLexerSection, options);
                } catch (e) {
                    if (options.json) {
                        err = new Error('Could not parse lexer spec in JSON AUTODETECT mode\nError: ' + ex1.message + ' (' + e.message + ')');
                        err.secondary_exception = e;
                        err.stack = ex1.stack;
                    } else {
                        err = new Error('Could not parse lexer spec\nError: ' + e.message);
                        err.stack = e.stack;
                    }
                    throw err;
                }
            }
        } else {
            chk_l = optionalLexerSection;
        }

        // Save time! Don't reparse the entire lexer spec *again* inside the code generators when that's not necessary:
        if (chk_l) {
            chk_g.lex = chk_l;
        }
    }

    return chk_g;
}

Jison.rmCommonWS = rmCommonWS;
Jison.mkStdOptions = mkStdOptions;
Jison.camelCase = camelCase;
Jison.autodetectAndConvertToJSONformat = autodetectAndConvertToJSONformat;

// detect print
if (typeof console !== 'undefined' && console.log) {
    // wrap console.log to prevent 'Illegal Invocation' exceptions when Jison.print() is used, e.g.
    // in the web tryout pages where this code is employed.
    Jison.print = function console_log() /* ... */{
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift(''); // prevent `%.` printf-style expansions; see https://nodejs.org/api/console.html#console_console_log_data_args
        console.log.apply(console, args);
    };
} else if (typeof puts !== 'undefined') {
    Jison.print = function puts_print() {
        puts([].join.call(arguments, ' '));
    };
} else if (typeof print !== 'undefined') {
    Jison.print = print;
} else {
    Jison.print = function no_op_print() {};
}

// Also export other APIs: the JISON module should act as a 'facade' for the others,
// so applications using the JISON compiler itself can rely on it providing everything
// in a guaranteed compatible version as it allows userland code to use the precise
// same APIs as JISON will be using itself:
Jison.Lexer = RegExpLexer;
Jison.ebnfParser = ebnfParser;
Jison.lexParser = jisonlex;
Jison.codeExec = code_exec;
Jison.XRegExp = XRegExp;
Jison.recast = recast;
Jison.astUtils = astUtils;
//Jison.prettier = prettier;
//Jison.codeShift = codeshift;
Jison.JSON5 = json5;
Jison.prettyPrint = grammarPrinter;

// iterator utility
function each(obj, func) {
    if (typeof obj.forEach === 'function') {
        obj.forEach(func);
    } else {
        var p;
        for (p in obj) {
            if (obj.hasOwnProperty(p)) {
                func.call(obj, obj[p], p, obj);
            }
        }
    }
}

// This was Set.union() but it's not about *Set* at all: it is purely *Array* oriented!
function union(a, b) {
    assert(Array.isArray(a));
    assert(Array.isArray(b));
    // Naive indexOf()-based scanning delivers a faster union()
    // (which takes the brunt of the load for large grammars):
    // for examples/jscore this drops 13.2 seconds down to
    // 8.9 seconds total time spent in the generator!
    //
    // The idea there was that the FIRST/FOLLOW sets are generally
    // quite small; bad cases could run this up to > 128 entries
    // to scan through, but overall the FIRST and FOLLOW sets will
    // be a few tens of entries at best, and thus it was expected
    // that a naive scan would be faster than hash-object creation
    // and O(1) checking that hash... Turns out I was right.
    //
    // The 'arbitrary' threshold of 52 entries in the array to check
    // against is probably at or near the worst-case FIRST/FOLLOW set
    // site for this jscore grammar as the naive scan consistently
    // outperformed the old smarter hash-object code for smaller
    // thresholds (10, 20, 32, 42!)
    var k, len;

    if (a.length > 52) {
        var ar = {};
        for (k = 0, len = a.length; k < len; k++) {
            ar[a[k]] = true;
        }
        for (k = 0, len = b.length; k < len; k++) {
            if (!ar[b[k]]) {
                a.push(b[k]);
            }
        }
    } else {
        var bn = [];
        for (k = 0, len = b.length; k < len; k++) {
            if (a.indexOf(b[k]) < 0) {
                bn.push(b[k]);
            }
        }
        a = a.concat(bn);
    }
    return a;
}

var Nonterminal = typal.construct({
    constructor: function Nonterminal(symbol) {
        this.symbol = symbol;
        this.productions = new Set();
        this.first = [];
        this.follows = [];
        this.nullable = false;
    },
    toString: function Nonterminal_toString() {
        var str = this.symbol;
        var attr_str = [];

        if (this.nullable) {
            attr_str.push('nullable');
        }

        if (attr_str.length) {
            str += '        [' + attr_str.join(' ') + ']';
        }
        str += '\n  Firsts:  [' + this.first.join(']  [') + ']';
        str += '\n  Follows: [' + this.follows.join(']  [') + ']';
        str += '\n  Productions:\n    ' + this.productions.join('\n    ');

        return str;
    }
});

var Production = typal.construct({
    constructor: function Production(symbol, handle, id, handle_aliases, handle_action) {
        this.symbol = symbol;
        this.handle = handle;
        this.nullable = false;
        this.id = id;
        this.aliases = handle_aliases;
        this.action = handle_action;
        this.first = [];
        this.follows = [];
        this.precedence = 0;
        this.reachable = false;
    },
    toString: function Production_toString() {
        var str = this.symbol;

        var attr_str = [];

        if (this.nullable) {
            attr_str.push('~');
        }
        if (this.precedence) {
            attr_str.push('@' + this.precedence);
        }
        if (!this.reachable) {
            attr_str.push('*RIP*');
        }

        if (attr_str.length) {
            str += '[' + attr_str.join(' ') + ']';
        }
        str += ' -> ' + this.handle.join(' ');

        return str;
    },
    describe: function Production_describe() {
        var str = this.symbol;

        var attr_str = [];

        if (this.nullable) {
            attr_str.push('nullable');
        }
        if (this.precedence) {
            attr_str.push('precedence: ' + this.precedence);
        }

        if (attr_str.length) {
            str += '        [' + attr_str.join(' ') + ']';
        }
        str += '\n  Firsts: [' + this.first.join(']  [') + ']';
        str += '\n  -->  ' + this.handle.join(' ');

        return str;
    }
});

var generator = typal.beget();

// `optionalLexerSection` is an optional {String} argument, specifying the lexer rules.
// May only be specified when the specified `grammar` also is a yet-unparsed
// {String} defining the grammar.
//
// Hence these invocations are legal:
//
// - `Generator("String")`
//   --> `String` contains entire grammar, including
//   optional `%lex` lexer rules section
//
//
// - `Generator("String-1", "String-2")`
//   --> The `String-1` string contains grammar, *excluding* `%lex` lexer rules section,
//   while the `String-2` string contains the `%lex` lexer rules section
//
//
// - `Generator("String", {Options})`
//   --> `String` contains entire grammar, including
//   optional `%lex` lexer rules section
//
//   The `Options` object specifies the desired jison options' settings.
//
//
// - `Generator("String", NULL, {Options})`
//   --> `String` contains entire grammar, including
//   optional `%lex` lexer rules section
//
//   The `Options` object specifies the desired jison options' settings.
//
//
// - `Generator("String-1", "String-2", {Options})`
//   --> The `String-1` string contains grammar, *excluding* `%lex` lexer rules section,
//   while the `String-2` string contains the `%lex` lexer rules section
//
//   The `Options` object specifies the desired jison options' settings.
//
//
// - `Generator({Grammar})`
//   --> The `Grammar` object contains the entire grammar as an already parsed *structure*,
//   including optional `%lex` lexer rules section in its `.lex` member.
//
//
// - `Generator({Grammar}, {Options})`
//   --> The `Grammar` object contains the entire grammar as an already parsed *structure*,
//   including optional `%lex` lexer rules section in its `.lex` member.
//
//   The `Options` object specifies the desired jison options' settings.
//
//
// - `Generator({Grammar}, NULL, {Options})`
//   --> The `Grammar` object contains the entire grammar as an already parsed *structure*,
//   including optional `%lex` lexer rules section in its `.lex` member.
//
//   The `Options` object specifies the desired jison options' settings.
//
//
// - `Generator({Grammar}, "String-2")`
//   --> The `Grammar` object contains grammar, *excluding* `%lex` lexer rules section,
//   while the `String-2` string contains the `%lex` lexer rules section
//
//
// - `Generator({Grammar}, "String-2", {Options})`
//   --> The `Grammar` object contains grammar, *excluding* `%lex` lexer rules section,
//   while the `String-2` string contains the `%lex` lexer rules section
//
//   The `Options` object specifies the desired jison options' settings.
//
//
// Any other arguments / arguments' types sequence is illegal.
//
generator.constructor = function Jison_Generator(grammar, optionalLexerSection, options) {
    // pick the correct argument for the `options` for this call:
    if (!options && optionalLexerSection && typeof optionalLexerSection !== 'string') {
        options = optionalLexerSection;
        optionalLexerSection = null;
    }
    // and standardize it:
    var preliminary_options = mkStdOptions(options);

    grammar = autodetectAndConvertToJSONformat(grammar, optionalLexerSection, preliminary_options);

    // make sure all options are 'standardized' before we go and mix them together
    //
    // WARNING:
    // make sure to mix together the **original options sets** as it's last-come-last-serve
    // in `mkStdOptions` and you don't want the mixed in defaults carried in `preliminary_options`
    // to percolate into the final options set as if those we overrides coming in from
    // the API (via the `options` parameter above)!
    //
    // Anyway, API/CLI options **override** options coming in from the grammar spec.
    //
    options = mkStdOptions(grammar.options, options);

    prepExportStructures(options);

    this.terms = {};
    this.operators = {};
    this.productions = [];
    this.conflicts = 0;
    this.new_conflicts_found_this_round = 0;
    this.conflicting_states = [];
    this.resolutions = [];
    this.conflict_productions_LU = {};
    this.conflict_states_LU = {};
    this.conflict_fixing_round = false;
    this.parseParams = grammar.parseParams;
    this.yy = {}; // accessed as yy free variable in the parser/lexer actions

    // also export the grammar itself *and* the cleaned-up generator options:
    this.options = options;
    this.grammar = grammar;

    this.DEBUG = !!options.debug;

    // // propagate %parse-params into the lexer!
    // if (grammar.lex) {
    //     if (!grammar.lex.options) {
    //         grammar.lex.options = {};
    //     }
    //     if (this.parseParams) {
    //         grammar.lex.options.parseParams = this.parseParams;
    //     }
    // }

    // calculate the input path; if none is specified, it's the present working directory
    var inpath = options.file || options.outfile || './dummy';
    inpath = path.normalize(inpath);
    options.inputPath = path.dirname(inpath);
    options.inputFilename = path.basename(inpath);

    // source included in semantic action execution scope
    if (grammar.actionInclude) {
        if (typeof grammar.actionInclude === 'function') {
            grammar.actionInclude = String(grammar.actionInclude).replace(/^\s*function \(\) \{/, '').replace(/\}\s*$/, '');
        }
        this.actionInclude = grammar.actionInclude;
    }
    this.moduleInclude = grammar.moduleInclude || '';
    this.moduleInit = grammar.moduleInit || [];
    assert(Array.isArray(this.moduleInit));

    this.DEBUG = !!this.options.debug;
    this.enableDebugLogs = !!options.enableDebugLogs;
    this.numExpectedConflictStates = options.numExpectedConflictStates || 0;

    if (this.DEBUG) {
        this.mix(generatorDebug); // mixin debug methods

        Jison.print('Grammar::OPTIONS:\n', this.options);
    }

    this.processGrammar(grammar);

    if (grammar.lex) {
        var lexer_options = {
            // include the knowledge about which parser/lexer
            // features will actually be *used* by the environment:
            //
            // (this stuff comes straight from the jison Optimization Analysis.)
            //
            parseActionsAreAllDefault: this.actionsAreAllDefault,
            parseActionsUseYYLENG: this.actionsUseYYLENG,
            parseActionsUseYYLINENO: this.actionsUseYYLINENO,
            parseActionsUseYYTEXT: this.actionsUseYYTEXT,
            parseActionsUseYYLOC: this.actionsUseYYLOC,
            parseActionsUseParseError: this.actionsUseParseError,
            parseActionsUseYYERROR: this.actionsUseYYERROR,
            parseActionsUseYYRECOVERING: this.actionsUseYYRECOVERING,
            parseActionsUseYYERROK: this.actionsUseYYERROK,
            parseActionsUseYYCLEARIN: this.actionsUseYYCLEARIN,
            parseActionsUseValueTracking: this.actionsUseValueTracking,
            parseActionsUseValueAssignment: this.actionsUseValueAssignment,
            parseActionsUseLocationTracking: this.actionsUseLocationTracking,
            parseActionsUseLocationAssignment: this.actionsUseLocationAssignment,
            parseActionsUseYYSTACK: this.actionsUseYYSTACK,
            parseActionsUseYYSSTACK: this.actionsUseYYSSTACK,
            parseActionsUseYYSTACKPOINTER: this.actionsUseYYSTACKPOINTER,
            parseActionsUseYYRULELENGTH: this.actionsUseYYRULELENGTH,
            parseActionsUseYYMERGELOCATIONINFO: this.actionsUseYYMERGELOCATIONINFO,
            parserHasErrorRecovery: this.hasErrorRecovery,
            parserHasErrorReporting: this.hasErrorReporting,

            // and re-use any useful options:
            moduleType: this.options.moduleType,
            debug: this.options.debug,
            enableDebugLogs: this.options.enableDebugLogs,
            json: this.options.json,
            main: false,
            dumpSourceCodeOnFailure: this.options.dumpSourceCodeOnFailure,
            throwErrorOnCompileFailure: this.options.throwErrorOnCompileFailure,
            moduleName: 'lexer', // this.options.moduleName + '_Lexer',
            file: this.options.file,
            outfile: this.options.outfile,
            inputPath: this.options.inputPath,
            inputFilename: this.options.inputFilename, // or should we feed it `this.options.lexfile` instead?
            warn_cb: this.options.warn_cb,
            //parseParams: this.options.parseParams,
            xregexp: this.options.xregexp,
            //parserErrorsAreRecoverable: this.options.parserErrorsAreRecoverable,
            lexerErrorsAreRecoverable: this.options.lexerErrorsAreRecoverable,
            flex: this.options.flex,
            backtrack_lexer: this.options.backtrack_lexer,
            ranges: this.options.ranges,
            caseInsensitive: this.options.caseInsensitive,
            showSource: this.options.showSource,
            exportSourceCode: this.options.exportSourceCode,
            exportAST: this.options.exportAST,
            prettyCfg: this.options.prettyCfg,
            pre_lex: this.options.pre_lex,
            post_lex: this.options.post_lex
        };

        this.lexer = new RegExpLexer(grammar.lex, null, this.terminals_, lexer_options);
    }
};

generator.processGrammar = function processGrammarDef(grammar) {
    var bnf = grammar.bnf,
        tokens = grammar.tokens,
        nonterminals = this.nonterminals = {},
        productions = this.productions;

    if (!grammar.bnf && grammar.ebnf) {
        bnf = grammar.bnf = ebnfParser.transform(grammar.ebnf);
    }
    if (devDebug) {
        Jison.print('processGrammar: ', JSON.stringify({
            bnf: bnf,
            tokens: tokens,
            productions: productions
        }, null, 2));
    }
    if (tokens) {
        if (typeof tokens === 'string') {
            tokens = tokens.trim().split(' ');
        } else {
            tokens = tokens.slice(0);
        }
    }

    // did the grammar user also provide a predefined set of symbols to be (re)used with this grammar?
    // (This is used when you want to generate multiple lexers and parsers which share a common symbol set
    // so as to make the parsers and lexers mutually interchangeable.)
    var predefined_symbols = null;
    if (grammar.imports) {
        var symbols_import = grammar.imports.find(function (el, idx) {
            if (el.name === 'symbols') {
                return el;
            }
            return false;
        });
        if (symbols_import) {
            var filepath = path.resolve(symbols_import.path);

            var source = fs.readFileSync(filepath, 'utf8');
            // It's either a JSON file or a JISON generated output file:
            //
            //     symbols_: {
            //       "symbol": ID, ...
            //     },
            try {
                predefined_symbols = json5.parse(source);
            } catch (ex) {
                if (devDebug) {
                    console.error('', '%import symbols JSON fail: ', ex);
                }
                try {
                    var m = /[\r\n]\s*symbols_:\s*(\{[\s\S]*?\}),\s*[\r\n]/.exec(source);
                    if (m && m[1]) {
                        source = m[1];
                        predefined_symbols = json5.parse(source);
                    }
                } catch (ex) {
                    if (devDebug) {
                        console.error('', '%import symbols JISON output fail: ', ex);
                    }
                    throw new Error('Error: `%import symbols <path>` must point to either a JSON file containing a symbol table (hash table) or a previously generated JISON JavaScript file, which contains such a symbol table. Error message: ' + ex.message);
                }
            }

            if (!predefined_symbols || (typeof predefined_symbols === 'undefined' ? 'undefined' : _typeof(predefined_symbols)) !== 'object') {
                throw new Error('Error: `%import symbols <path>` must point to either a JSON file containing a symbol table (hash table) or a previously generated JISON JavaScript file, which contains such a symbol table.');
            }

            // Make sure all predefined symbols are unique and *numeric* and do not include predefined tokens JISON already defines to a fixed ID on its own:
            delete predefined_symbols['$accept'];
            delete predefined_symbols['$end'];
            delete predefined_symbols['error'];
            delete predefined_symbols['$eof'];
            delete predefined_symbols['EOF'];

            var symdef_uniq_check = {};
            // Only these symbols are allowed to have the values 1 or 2:
            symdef_uniq_check[1] = 'EOF';
            symdef_uniq_check[2] = 'error';
            Object.keys(predefined_symbols).forEach(function cvt_symbol_id_to_numeric(sym) {
                var v = predefined_symbols[sym];

                // Symbol value may be defined as boolean TRUE, in which case we let JISON pick the value for us:
                if (v === true) return;

                // Symbol value may be defined as a one-character string:
                if (typeof v !== 'number') {
                    if (typeof v !== 'string' || v.length !== 1) {
                        throw new Error('Error: `%import symbols <path>`: symbol table contains invalid entry at key \'' + sym + '\': a non-numeric symbol ID value must be a single-character string.');
                    }
                    v = v.charCodeAt(0);
                }
                v = v | 0;
                if (!v || v < 0) {
                    throw new Error('Error: `%import symbols <path>`: symbol table contains invalid entry at key \'' + sym + '\': a symbol ID value must be an integer value, 3 or greater.');
                }
                if (symdef_uniq_check[v]) {
                    if (symdef_uniq_check[v] !== sym) {
                        throw new Error('Error: `%import symbols <path>`: symbol table contains duplicate ID values for keys \'' + sym + '\' and \'' + symdef_uniq_check[v] + '\'');
                    }
                }
                symdef_uniq_check[v] = sym;
                predefined_symbols[sym] = v;
            });
        }
    }

    var symbols = this.symbols = [];

    // calculate precedence of operators
    var operators = this.operators = processOperators(grammar.operators);

    // build productions from CFG and calculate the symbol sets (terminals and nonterminals) and their name-to-ID mappings
    this.buildProductions(bnf, productions, nonterminals, symbols, operators, predefined_symbols, grammar.extra_tokens);

    if (devDebug > 1) {
        Jison.print('terminals vs tokens: ', this.terminals.length, tokens && tokens.length, this.terminals, '\n###################################### TOKENS\n', tokens, '\n###################################### EXTRA TOKENS\n', grammar.extra_tokens, '\n###################################### LEX\n', grammar.lex, '\n###################################### GRAMMAR\n', grammar);
    }
    if (tokens) {
        var termset = this.terminals.filter(function (t) {
            switch (t) {
                case 'EOF':
                case 'error':
                case '$eof':
                case '$end':
                    return false;

                default:
                    return true;
            }
        });
        var diffset = termset.filter(function (t) {
            return tokens.indexOf(t) === -1;
        });
        diffset = diffset.concat(tokens.filter(function (t) {
            return termset.indexOf(t) === -1;
        }));

        if (termset.length !== tokens.length) {
            this.trace('\nWarning: declared tokens differ from terminals set found in rules.');
            this.trace('difference: ', diffset);
            this.trace('Terminals:  ', termset);
            this.trace('Tokens:     ', tokens);
        }
    }

    // augment the grammar
    this.augmentGrammar(grammar);

    // detect unused productions and flag them
    this.signalUnusedProductions();

    // build production action code chunks (originally done in `buildProductions` as a side-effect)
    this.buildProductionActions();
};

generator.augmentGrammar = function augmentGrammar(grammar) {
    if (this.productions.length === 0) {
        throw new Error('Grammar error: must have at least one rule.');
    }
    // use specified start symbol, or default to first user defined production
    this.startSymbol = grammar.start || grammar.startSymbol || this.productions[0].symbol;
    if (!this.nonterminals[this.startSymbol]) {
        throw new Error('Grammar error: startSymbol must be a non-terminal found in your grammar.');
    }
    //this.EOF = '$end';       // moved to generator.buildProductions()

    // Augment the grammar:
    //
    // Add the top-most accept rule (and implicit, default, action):
    //
    //     $accept: <startSymbol> $end
    //                  %{ $$ = $1; @$ = @1; %}
    //
    // which, combined with the new parse kernel's `$accept` state behaviour will produce the
    // `$$` value output of the <startSymbol> rule as the parse result, IFF that result is
    // *not* `undefined`. (See also the parser kernel code.)
    //
    // In code:
    //
    //                  %{
    //                      @$ = @1;
    //                      if (typeof $1 !== 'undefined')
    //                          return $1;
    //                      else
    //                          return true;           // the default parse result if the rule actions don't produce anything
    //                  %}
    //
    var acceptProduction = new Production('$accept', [this.startSymbol, '$end'], 0);
    this.productions.unshift(acceptProduction);

    // prepend parser tokens       // moved to generator.buildProductions()
    //this.symbols.unshift('$accept', this.EOF);
    //this.symbols_.$accept = 0;
    //this.symbols_[this.EOF] = 1;
    //this.terminals.unshift(this.EOF);

    //this.nonterminals.$accept = new Nonterminal('$accept');

    this.nonterminals.$accept.productions.push(acceptProduction);

    // add follow $ to start symbol
    this.nonterminals[this.startSymbol].follows.push(this.EOF);
};

// Mark unused productions
generator.signalUnusedProductions = function () {
    var mark = {};

    var productions = this.productions;
    var nonterminals = this.nonterminals;
    var i, p, len, nt, sym;

    for (i = 0, len = nonterminals.length; i < len; i++) {
        nt = nonterminals[i];
        assert(nt.symbol);
        mark[nt.symbol] = false;
    }

    // scan & mark all visited productions
    function traverseGrammar(nt) {
        assert(nt);
        assert(nt.symbol);
        mark[nt.symbol] = true;

        var prods = nt.productions;
        assert(prods);
        prods.forEach(function (p) {
            assert(p.symbol === nt.symbol);
            assert(p.handle);
            var rhs = p.handle;
            if (devDebug > 0) {
                Jison.print('traverse / mark: ', nt.symbol, ' --> ', rhs);
            }

            for (var j = 0, len = rhs.length; j < len; j++) {
                var sym = rhs[j];
                assert(!sym ? !nonterminals[sym] : true);
                if (nonterminals[sym] && !mark[sym]) {
                    traverseGrammar(nonterminals[sym]);
                }
            }
        });
    }

    traverseGrammar(nonterminals['$accept' /* this.startSymbol */]);

    // now any production which is not yet marked is *unused*:
    for (sym in mark) {
        nt = nonterminals[sym];
        assert(nt);
        var prods = nt.productions;
        assert(prods);
        var in_use = mark[sym];
        prods.forEach(function (p) {
            assert(p);
            if (in_use) {
                p.reachable = true;
            } else {
                p.reachable = false;
            }
        });

        if (!in_use) {
            // and kill the unused nonterminals:
            delete this.nonterminals[sym];
        }
    }

    this.unused_productions = productions.filter(function (p) {
        return !p.reachable;
    });

    // and kill the unused productions:
    this.productions = productions.filter(function (p) {
        return p.reachable;
    });
};

// set precedence and associativity of operators
function processOperators(ops) {
    if (!ops) return {};
    var operators = {};
    for (var i = 0, k, prec; prec = ops[i]; i++) {
        for (k = 1; k < prec.length; k++) {
            operators[prec[k]] = {
                precedence: i + 1,
                assoc: prec[0]
            };
        }
    }
    return operators;
}

// Detect the indentation of the given sourcecode chunk and shift the chunk to be indented the given number of spaces.
//
// Note that the first line doesn't count as the chunk is very probably trimmed!
function reindentCodeBlock(action, indent_level) {
    var width = 0;
    var lines = action.trim().split('\n')
    // measure the indent:
    .map(function checkIndentation(line, idx) {
        if (idx === 1) {
            // first line didn't matter: reset width to help us find the block indent level:
            width = Infinity;
        }
        if (line.trim() === '') return '';

        // take out any TABs: turn them into spaces (4 per TAB)
        line = line.replace(/^[ \t]+/, function expandTabs(s) {
            return s.replace(/\t/g, '    ');
        });

        var m = /^[ ]+/.exec(line);
        if (m) {
            width = Math.min(m[0].length, width);
        }

        return line;
    })
    // remove/adjust the indent:
    .map(function checkIndentation(line, idx) {
        line = line.replace(/^[ ]*/, function adjustIndent(s) {
            var l = Math.max(s.length - width, 0) + indent_level;
            var shift = new Array(l + 1).join(' ');
            return shift;
        });
        return line;
    });

    return lines.join('\n');
}

generator.buildProductions = function buildProductions(bnf, productions, nonterminals, symbols, operators, predefined_symbols, descriptions) {
    var self = this;
    var prods, symbol, symId;
    var productions_ = [];
    var symbols_ = {};
    var descriptions_ = {};
    var usedSymbolIds = [/* $accept = 0 */true, /* $end = 1 */true, /* error = 2 */true];
    var usedSymbolIdsLowIndex = 3;

    // set up the required symbols `$accept` and `$end` (a.k.a. EOF) and make sure they occupy the expected slots:
    this.EOF = '$end';

    symbols_.$accept = 0;
    symbols_[this.EOF] = 1;
    symbols_['$eof'] = 1; // `$eof` is a synonym of `$end` for bison compatibility; this is the only place where two symbol names may map to a single symbol ID number!
    symbols_['EOF'] = 1; // `EOF` is a synonym of `$end` for bison compatibility; this is the only place where two symbol names may map to a single symbol ID number!
    symbols[0] = '$accept';
    symbols[1] = this.EOF;

    nonterminals.$accept = new Nonterminal('$accept');

    // always add the error symbol; will be third symbol, or "2": ($accept, $end, error)
    symbols_.error = 2;
    symbols[2] = 'error';

    if (predefined_symbols) {
        for (symbol in predefined_symbols) {
            symId = predefined_symbols[symbol];
            if (symId === true) {
                // add symbol to queue which must be assigned a value by JISON; after all the other predefined symbols have been processed.
                continue;
            }

            // skip $accept, $end and error:
            if (symId <= 2) continue;

            // has this ID already been taken? If not, pick this ID, otherwise throw a tantrum.
            if (!usedSymbolIds[symId]) {
                usedSymbolIds[symId] = true;
                symbols_[symbol] = symId;
                symbols[symId] = symbol;
            } else {
                throw new Error('Error: Predefined symbol (imported via `%import symbols`) "' + symbol + '" has an ID ' + symId + ' which is already in use by symbol "' + symbols[symId] + '"');
            }
        }

        // preferably assign readable ASCII-range token IDs to tokens added from the predefined list
        // but only when maximum table compression isn't demanded:
        usedSymbolIdsLowIndex = (this.options.compressTables | 0) < 2 ? 32 : 3;
        for (symbol in predefined_symbols) {
            symId = predefined_symbols[symbol];
            addSymbol(symbol);
        }

        // reset ID low water mark: nonterminals etc. can be assigned any number, preferably a small/low one!
        usedSymbolIdsLowIndex = 3;
    }

    if (descriptions) {
        this.trace('descriptions obtained from grammar: ', descriptions);
        descriptions.forEach(function (tokdef) {
            // fields: id, type, value, description
            if (tokdef.description && tokdef.id) {
                descriptions_[tokdef.id] = tokdef.description;
            }
        });
    }

    var hasErrorRecovery = false; // has error recovery

    // Produce the next available unique symbolID:
    function getNextSymbolId() {
        for (var i = usedSymbolIdsLowIndex;; i++) {
            if (!usedSymbolIds[i]) {
                usedSymbolIds[i] = true;
                usedSymbolIdsLowIndex = i + 1;
                return i;
            }
        }
    }

    function addSymbol(s) {
        if (s && !symbols_[s]) {
            var i;

            // assign the Unicode codepoint index to single-character symbols,
            // but only when maximum table compression isn't demanded:
            if (s.length === 1 && (self.options.compressTables | 0) < 2) {
                i = s.charCodeAt(0);
                // has this ID already been taken? If not, pick this ID.
                if (i < 128 /* only allow this within the ASCII range */ && !usedSymbolIds[i]) {
                    usedSymbolIds[i] = true;
                } else {
                    i = getNextSymbolId();
                }
            } else {
                // otherwise simply obtain the next available ID number as usual.
                i = getNextSymbolId();
            }
            symbols_[s] = i;
            symbols[i] = s;
        }
        return symbols_[s] || false;
    }

    // `this` is options object with `maxTokenLength` option to guide us which literal tokens we want to process:
    function collectLiteralTokensInProduction(handle) {
        var r, rhs, i, sym;

        if (devDebug) Jison.print('\ncollectLiteralTokensInProduction: ', symbol, ':', JSON.stringify(handle, null, 2), ' @ options: ', this);

        var maxlen = this.maxTokenLength || Infinity;

        if (handle.constructor === Array) {
            var rhs_i;
            rhs = typeof handle[0] === 'string' ? splitStringIntoSymbols(handle[0]) : handle[0].slice(0);

            for (i = 0; i < rhs.length; i++) {
                sym = rhs[i];
                // check for aliased names, e.g., id[alias] and strip them
                rhs_i = sym.match(new XRegExp('\\[' + ID_REGEX_BASE + '\\]$'));
                if (rhs_i) {
                    sym = sym.substr(0, sym.length - rhs_i[0].length);
                }

                if (!bnf[sym] && sym.length <= maxlen) {
                    addSymbol(sym);
                }
            }
        } else {
            // no action -> don't care about aliases; strip them.
            handle = handle.replace(new XRegExp('\\[' + ID_REGEX_BASE + '\\]', 'g'), '');
            rhs = splitStringIntoSymbols(handle);
            for (i = 0; i < rhs.length; i++) {
                sym = rhs[i];
                if (!bnf[sym] && sym.length <= maxlen) {
                    addSymbol(sym);
                }
            }
        }
    }

    // Before we go process the grammar for real, we collect the 'literal' non-terminals and add them to the symbol table
    // before all others: this way these tokens have the maximum chance to get assigned their ASCII value as symbol ID,
    // which helps debugging/diagnosis of generated grammars.
    // (This is why previously we had set `usedSymbolIdsLowIndex` to 127 instead of 3!)

    var prodsLUT = {};
    for (symbol in bnf) {
        if (!bnf.hasOwnProperty(symbol)) continue;

        if (typeof bnf[symbol] === 'string') {
            prods = bnf[symbol].split(/\s*\|\s*/g);
        } else {
            prods = bnf[symbol].slice(0);
        }
        if (devDebug) Jison.print('\ngenerator.buildProductions: ', symbol, JSON.stringify(prods, null, 2));

        prodsLUT[symbol] = prods;
    }

    // First we collect all single-character literal tokens:
    for (symbol in prodsLUT) {
        if (!prodsLUT.hasOwnProperty(symbol)) continue;

        prods = prodsLUT[symbol];
        prods.forEach(collectLiteralTokensInProduction, {
            maxTokenLength: 1
        });
    }
    // Next we collect all other literal tokens:
    for (symbol in prodsLUT) {
        if (!prodsLUT.hasOwnProperty(symbol)) continue;

        prods = prodsLUT[symbol];
        prods.forEach(collectLiteralTokensInProduction, {
            maxTokenLength: Infinity
        });
    }

    // and now go and process the entire grammar:
    // first collect all nonterminals in a symbol table, then build the productions
    // for each of those: nonterminals should all have IDs assigned before they
    // should be processed as part of a *production* rule, where these MAY be
    // referenced:
    for (symbol in bnf) {
        if (!bnf.hasOwnProperty(symbol)) continue;

        addSymbol(symbol);
        nonterminals[symbol] = new Nonterminal(symbol);
    }

    // now that we have collected all nonterminals in our symbol table, it's finally
    // time to process the productions:
    for (symbol in prodsLUT) {
        if (!prodsLUT.hasOwnProperty(symbol)) continue;

        prods = prodsLUT[symbol];
        prods.forEach(buildProduction);
    }

    var sym,
        terms = [],
        terms_ = {};
    each(symbols_, function (id, sym) {
        // `$eof` and `EOF` are synonyms of `$end` (`$eof` is for bison compatibility);
        // this is the only place where two symbol names may map to a single symbol ID number
        // and we do not want `$eof`/`EOF` to show up in the symbol tables of generated parsers
        // as we use `$end` for that one!
        if (!nonterminals[sym] && sym !== '$eof') {
            terms.push(sym);
            terms_[id] = sym;
        }
    });

    this.hasErrorRecovery = hasErrorRecovery;
    // fix error recovery related options now that we know whether we actually have any recovery
    // rules at all:
    if (!this.hasErrorRecovery) {
        var chk_er_opt = function check_error_recovery_option(opt, label) {
            if (self.options[opt]) {
                self.options[opt] = false;
                self.warn('The grammar does not have any error recovery rules, so using the ' + label + ' is rather useless.');
            }
        };

        chk_er_opt('parserErrorsAreRecoverable', 'parser-errors-are-recoverable feature/option');

        // Hmmmm... why would lexer errors need to be NON-recoverable when there's no ERROR rules in the GRAMMAR?!
        chk_er_opt('lexerErrorsAreRecoverable', 'lexer-errors-are-recoverable feature/option');

        chk_er_opt('parseActionsUseYYRECOVERING', 'YYRECOVERING macro/API in grammar rules\' action code');
        chk_er_opt('parseActionsUseYYERROK', 'yyerrok() function/API in grammar rules\' action code');
        chk_er_opt('parseActionsUseYYCLEARIN', 'yyclearin() function/API in grammar rules\' action code');
    }

    this.terminals = terms;
    this.terminals_ = terms_;
    this.symbols_ = symbols_;
    this.symbolIds = symbols;
    this.descriptions_ = descriptions_;

    this.productions_ = productions_;
    assert(this.productions === productions);

    // Cope with literal symbols in the string, including *significant whitespace* tokens
    // as used in a rule like this: `rule: A ' ' B;` which should produce 3 tokens for the
    // rhs: ['A', ' ', 'B']
    function splitStringIntoSymbols(rhs) {
        // when there's no literal tokens in there, we can fast-track this baby:
        rhs = rhs.trim();
        var pos1 = rhs.indexOf("'");
        var pos2 = rhs.indexOf('"');
        if (pos1 < 0 && pos2 < 0) {
            return rhs.split(' ');
        }
        // else:
        //
        // rhs has at least one literal: we will need to parse the rhs into tokens
        // with a little more effort now.
        var tokens = [];
        while (pos1 >= 0 || pos2 >= 0) {
            var pos = pos1;
            var marker = "'";
            if (pos < 0) {
                assert(pos2 >= 0);
                pos = pos2;
                marker = '"';
            } else if (pos >= 0 && pos2 >= 0 && pos2 < pos) {
                pos = pos2;
                marker = '"';
            }
            var ls = rhs.substr(0, pos).trim();
            if (ls.length > 0) {
                tokens.push.apply(tokens, ls.split(' '));
            }
            rhs = rhs.substr(pos + 1);
            // now find the matching end marker.
            //
            // Edge case: token MAY include the ESCAPED MARKER... or other escapes!
            // Hence we need to skip over ALL escapes inside the token!
            var pos3 = rhs.indexOf('\\');
            pos = rhs.indexOf(marker);
            ls = '';
            while (pos3 >= 0 && pos3 < pos) {
                ls += rhs.substr(0, pos3 + 2); // chop off entire escape (2 chars) and keep as part of next token
                rhs = rhs.substr(pos3 + 2);
                pos3 = rhs.indexOf('\\');
                pos = rhs.indexOf(marker);
            }
            if (pos < 0) {
                throw new Error('internal error parsing literal token(s) in grammar rule');
            }
            ls += rhs.substr(0, pos);
            // check for aliased literals, e.g., `'>'[gt]` and keep it and the alias together
            rhs = rhs.substr(pos + 1);
            var alias = rhs.match(new XRegExp('^\\[' + ID_REGEX_BASE + '\\]'));
            if (alias) {
                ls += alias[0];
                rhs = rhs.substr(alias[0].length);
            }
            tokens.push(ls);

            rhs = rhs.trim();

            pos1 = rhs.indexOf("'");
            pos2 = rhs.indexOf('"');
        }
        // Now, outside the loop, we're left with the remainder of the rhs, which does NOT
        // contain any literal tokens.
        if (rhs.length > 0) {
            tokens.push.apply(tokens, rhs.split(' '));
        }
        return tokens;
    }

    function buildProduction(handle) {
        var r,
            rhs,
            i,
            precedence_override,
            aliased = [],
            action = null;

        if (devDebug) Jison.print('\nbuildProduction: ', symbol, ':', JSON.stringify(handle, null, 2));

        if (handle.constructor === Array) {
            var rhs_i;

            rhs = typeof handle[0] === 'string' ? splitStringIntoSymbols(handle[0]) : handle[0].slice(0);

            for (i = 0; i < rhs.length; i++) {
                // check for aliased names, e.g., id[alias] and strip them
                rhs_i = rhs[i].match(new XRegExp('\\[' + ID_REGEX_BASE + '\\]$'));
                if (rhs_i) {
                    rhs[i] = rhs[i].substr(0, rhs[i].length - rhs_i[0].length);
                    rhs_i = rhs_i[0].substr(1, rhs_i[0].length - 2);
                    aliased[i] = rhs_i;
                } else {
                    aliased[i] = rhs[i];
                }

                if (rhs[i] === 'error') {
                    hasErrorRecovery = true;
                }
                assert(bnf[rhs[i]] ? symbols_[rhs[i]] : true, 'all nonterminals must already exist in the symbol table');
                assert(rhs[i] ? symbols_[rhs[i]] : true, 'all symbols (terminals and nonterminals) must already exist in the symbol table');
                //addSymbol(rhs[i]);
            }

            assert(handle.length === 3 ? typeof handle[1] === 'string' : true);
            if (typeof handle[1] === 'string') {
                // semantic action specified
                action = handle[1];

                // precedence specified also
                if (handle[2] && operators[handle[2].prec]) {
                    precedence_override = {
                        symbol: handle[2].prec,
                        spec: operators[handle[2].prec]
                    };
                }
            } else {
                // only precedence specified
                if (operators[handle[1].prec]) {
                    precedence_override = {
                        symbol: handle[1].prec,
                        spec: operators[handle[1].prec]
                    };
                }
            }
        } else {
            // no action -> don't care about aliases; strip them.
            handle = handle.replace(new XRegExp('\\[' + ID_REGEX_BASE + '\\]', 'g'), '');
            rhs = splitStringIntoSymbols(handle);
            for (i = 0; i < rhs.length; i++) {
                if (rhs[i] === 'error') {
                    hasErrorRecovery = true;
                }
                assert(bnf[rhs[i]] ? symbols_[rhs[i]] : true, 'all nonterminals must already exist in the symbol table');
                assert(rhs[i] ? symbols_[rhs[i]] : true, 'all symbols (terminals and nonterminals) must already exist in the symbol table');
                //addSymbol(rhs[i]);
            }
        }

        r = new Production(symbol, rhs, productions.length + 1, aliased, action);

        // set precedence
        assert(r.precedence === 0);
        if (precedence_override) {
            r.precedence = precedence_override.spec.precedence;
        } else {
            var prec_symbols = [];
            var winning_symbol;

            for (i = r.handle.length - 1; i >= 0; i--) {
                if (!(r.handle[i] in nonterminals) && r.handle[i] in operators) {
                    var old_prec = r.precedence;
                    var new_prec = operators[r.handle[i]].precedence;
                    if (old_prec !== 0 && old_prec !== new_prec) {
                        prec_symbols.push(r.handle[i]);
                        // Jison.print('precedence set twice: ', old_prec, new_prec, r.handle[i], symbol, handle[0]);
                        if (new_prec < old_prec) {
                            winning_symbol = r.handle[i];
                        } else {
                            // keep previously set precedence:
                            new_prec = old_prec;
                        }
                    } else if (old_prec === 0) {
                        prec_symbols.push(r.handle[i]);
                        winning_symbol = r.handle[i];
                        // Jison.print('precedence set first time: ', old_prec, r.handle[i], symbol, handle[0]);
                    }
                    r.precedence = new_prec;
                }
            }

            if (prec_symbols.length > 1) {
                if (self.DEBUG || 1) {
                    self.warn('Ambiguous rule precedence in grammar: picking the (highest) precedence from operator "' + winning_symbol + '" for rule "' + symbol + ': ' + r.handle.join(' ') + '" which contains multiple operators with different precedences: {' + prec_symbols.join(', ') + '}');
                }
            }
        }

        productions.push(r);
        productions_.push([symbols_[r.symbol], r.handle[0] === '' ? 0 : r.handle.length]);
        nonterminals[symbol].productions.push(r);
    }
};

// Preprocess the action code block before we perform any `$n`, `@n` ,`##n` or `#n` expansions:
// Any comment blocks in there should be kept intact (and not cause trouble either as those comments MAY
// contain `$`, `@`, `##` or `#` prefixed bits which might look like references but aren't!)
//
// Also do NOT replace any $x, @x, ##x or #x macros inside any strings!
//
// Note:
// We also replace '/*' comment markers which may (or may not) be lurking inside other comments.
function preprocessActionCode(s) {
    function replace_markers(cmt) {
        cmt = cmt.replace(/##/g, '\x01\x89').replace(/#/g, '\x01\x81').replace(/\$/g, '\x01\x82').replace(/@/g, '\x01\x83').replace(/\/\*/g, '\x01\x85').replace(/\/\//g, '\x01\x86').replace(/\'/g, '\x01\x87').replace(/\"/g, '\x01\x88')
        // and also whiteout any other macros we're about to expand in there:
        .replace(/\bYYABORT\b/g, '\x01\x94').replace(/\bYYACCEPT\b/g, '\x01\x95').replace(/\byyvstack\b/g, '\x01\x96').replace(/\byylstack\b/g, '\x01\x97').replace(/\byyerror\b/g, '\x01\x98').replace(/\bYYRECOVERING\b/g, '\x01\x99').replace(/\byyerrok\b/g, '\x01\x9A').replace(/\byyclearin\b/g, '\x01\x9B').replace(/\byysp\b/g, '\x01\x9C').replace(/\byy([a-zA-Z]+)\b/g, '\x01\x9D__$1'); // `yyxxx`: all `yy`-prefixed (camelCased) identifiers are RESERVED USE for jison.

        return cmt;
    }

    s = s
    // do not trim any NEWLINES in the action block:
    .replace(/^\s+/, '').replace(/\s+$/, '')
    // unify CR/LF combo's:
    .replace(/\r\n|\r/g, '\n')
    // replace any '$', '@' and '#' in any C++-style comment line to prevent
    // them from being expanded as if they were part of the action code proper:
    .replace(/^\s*\/\/.+$/mg, replace_markers)
    // also process any //-comments trailing a line of code:
    // (we need to ensure these are real and not a bit of string,
    // which leaves those comments that are very hard to correctly
    // recognize with a simple regex, e.g. '// this isn't a #666 location ref!':
    // we accept that we don't actually *parse* the action block and let these
    // slip through... :-( )
    //
    // WARNING: without that `\n` inside the regex `[...]` set, the set *will*
    // match a NEWLINE and thus *possibly* gobble TWO lines for the price of ONE,
    // when the first line is an *empty* comment line, i.e. nothing trailing
    // the `//` in there and thus the `[^'"]` regex matching the terminating NL *before*
    // the `$` in the regex can get at it. Cave canem therefor!       |8-(
    .replace(/\/\/[^'"\n]+$/mg, replace_markers)
    // now MARK all the not-too-tricky-to-recognize /*...*/ comment blocks and process those!
    // (Here again we accept that we don't actually *parse* the action code and
    // permit to let some of these slip, i.e. comment blocks which trail
    // a line of code and contain string delimiter(s). :-( )
    .replace(/^([^'"\n]*?)\/\*/mg, '$1\x01\x84') // comment starts the line, guaranteed not to be inside a string
    .replace(/\/\*([^'"\n]*)$/mg, '\x01\x84$1') // comment does not contain any string sentinel in its first line
    .replace(/\/\*([^\/]*?\*\/[^'"\n]*)$/mg, '\x01\x84$1') // comment end marker near end of line and since the end is definitely not inside a string, there's bound to be comment start as well
    // and find their END marker: first '*/' found wins!
    // (The `[\s\S]` regex expression is a hack to ensure NEWLINES are matched
    // by that set as well, i.e. this way we can easily cross line boundaries
    // while searching for he end of the multiline comment we're trying to
    // dig out by regex matching. Also note that we employ non-aggressive
    // matching to ensure the regex matcher will find the FIRST occurrence of
    // `*/` and mark that as the end of the regex match!)
    .replace(/\x01\x84[\s\S]*?\*\//g, replace_markers)
    // Now that we have processed all comments in the code, it's time
    // to tackle the strings in the code: any strings must be kept intact
    // as well. Regrettably, there's regexes which may carry quotes,
    // e.g. `/'/`, and escapes of quotes inside strings, e.g. `'\''`,
    // which makes this a non-trivial task. This is when we reconsider whether
    // we should run this stuff through Esprima and deal with that AST
    // verbosity instead...? For now, we accept that regexes can screw
    // us up, but we can handle strings of any kind, by first taking
    // out all explicit `\\` non-escaping characters:
    .replace(/\\\\/g, '\x01\x90')
    // and then we take out all escaped quotes:
    .replace(/\\\'/g, '\x01\x91').replace(/\\\"/g, '\x01\x92')
    // and to top it off, we also take out any more-or-less basic regexes:
    .replace(/\\\//g, '\x01\x93')

    // WARNING: Without that prefix check this would also catch
    // `6/7 + $$ + 8/9` as if `/7 + $$ + 8/` would be a regex   :-(
    // but we need this one to ensure any quotes hiding inside
    // any regex in there are caught and marked, e.g. `/'/g`.
    // Besides, this regex prefix is constructed to prevent
    // the regex matching a `//....` comment line either!
    .replace(/[^_a-zA-Z0-9\$\)\/][\s\n\r]*\/[^\n\/\*][^\n\/]*\//g, replace_markers);

    // ... which leaves us with plain strings of both persuasions to cover
    // next: we MUST do both at the same time, though or we'll be caught
    // with our pants down in constructs like
    // `'"' + $$ + '"'` vs. `"'" + $$ + "'"`

    var dqpos,
        sqpos,
        ccmtpos,
        cppcmtpos,
        first = -1;
    for (var c = 0;; c++) {
        first++;
        dqpos = s.indexOf('"', first);
        sqpos = s.indexOf("'", first);
        // also look for remaining comments which contain quotes of any kind,
        // as those will not have been caught by the previous global regexes:
        ccmtpos = s.indexOf('/*', first);
        cppcmtpos = s.indexOf('//', first);
        first = s.length;
        first = Math.min(dqpos >= 0 ? dqpos : first, sqpos >= 0 ? sqpos : first, ccmtpos >= 0 ? ccmtpos : first, cppcmtpos >= 0 ? cppcmtpos : first);
        // now it matters which one came up first:
        if (dqpos === first) {
            s = s.replace(/"[^"\n]*"/, replace_markers);
        } else if (sqpos === first) {
            s = s.replace(/'[^'\n]*'/, replace_markers);
        } else if (ccmtpos === first) {
            s = s.replace(/\/\*[\s\S]*?\*\//, replace_markers);
        } else if (cppcmtpos === first) {
            s = s.replace(/\/\/[^\n]*$/m, replace_markers);
        } else {
            break;
        }
    }
    // Presto!
    return s;
}

// Postprocess the action code block after we perform any `$n`, `@n`, `##n` or `#n` expansions:
// revert the preprocessing!
function postprocessActionCode(s) {
    s = s
    // multiline comment start markers:
    .replace(/\x01\x84/g, '/*').replace(/\x01\x85/g, '/*').replace(/\x01\x86/g, '//')
    // revert markers:
    .replace(/\x01\x81/g, '#').replace(/\x01\x82/g, '$').replace(/\x01\x83/g, '@')
    // and revert the string and regex markers:
    .replace(/\x01\x87/g, '\'').replace(/\x01\x88/g, '\"').replace(/\x01\x89/g, '##').replace(/\x01\x90/g, '\\\\').replace(/\x01\x91/g, '\\\'').replace(/\x01\x92/g, '\\\"').replace(/\x01\x93/g, '\\\/').replace(/\x01\x94/g, 'YYABORT').replace(/\x01\x95/g, 'YYACCEPT').replace(/\x01\x96/g, 'yyvstack').replace(/\x01\x97/g, 'yylstack').replace(/\x01\x98/g, 'yyerror').replace(/\x01\x99/g, 'YYRECOVERING').replace(/\x01\x9A/g, 'yyerrok').replace(/\x01\x9B/g, 'yyclearin').replace(/\x01\x9C/g, 'yysp').replace(/\x01\x9D__/g, 'yy');

    // And a final, minimal, fixup for the semicolon-lovers -- like me! ;-)
    //
    // Make sure the last statement is properly semicolon-terminated 99.9% of the time:
    s = s.replace(/[\s\r\n]+$/, '') // trim trailing whitespace and empty lines
    .replace(/([^\;}])$/, '$1;'); // append a semicolon to the last statement if it doesn't end with one (or a closing brace, e.g. a function definition)

    return s;
}

// Strip off any insignificant whitespace from the user code to ensure that
// otherwise identical actions are indeed matched up into a single actionGroup:
function mkHashIndex(s) {
    return s.trim().replace(/\s+$/mg, '') // strip any trailing whitespace for each line of action code
    .replace(/^\s+/mg, ''); // ditto for leading whitespace for each line: we don't care about more or less clean indenting practices in the user code
}

function analyzeFeatureUsage(sourcecode, feature, threshold) {
    var found = sourcecode.match(feature);
    return !!(found && found.length > threshold);
}

function mkParserFeatureHash(self) {
    assert(self.options.exportAllTables); // check that this function isn't called too early in the process or the hash will be bogus
    assert(self.options.exportSourceCode);
    var h = [self.actionsAreAllDefault, self.actionsUseLocationAssignment, self.actionsUseLocationTracking, self.actionsUseParseError, self.actionsUseValueAssignment, self.actionsUseValueTracking, self.actionsUseYYCLEARIN, self.actionsUseYYERROK, self.actionsUseYYERROR, self.actionsUseYYLENG, self.actionsUseYYLINENO, self.actionsUseYYLOC, self.actionsUseYYRECOVERING, self.actionsUseYYRULELENGTH, self.actionsUseYYMERGELOCATIONINFO, self.actionsUseYYSSTACK, self.actionsUseYYSTACK, self.actionsUseYYSTACKPOINTER, self.actionsUseYYTEXT, self.hasErrorRecovery, self.hasErrorReporting, self.onDemandLookahead, self.options.compressTables, self.options.debug, self.options.errorRecoveryTokenDiscardCount, self.options.exportAllTables.enabled, self.options.exportSourceCode.enabled, self.options.hasPartialLrUpgradeOnConflict, self.options.lexerErrorsAreRecoverable, self.options.moduleType, self.options.defaultActionMode.join(','), self.options.noDefaultResolve, self.options.noMain, self.options.moduleMain, self.options.moduleMainImports, self.options.noTryCatch, self.options.numExpectedConflictStates, self.options.outputDebugTables, self.options.parserErrorsAreRecoverable, self.options.tokenStack, self.options.type, '======================================', self.performAction, '======================================'];
    return h.join(',');
}

generator.buildProductionActions = function buildProductionActions() {
    /*
        this.terminals = terms;
        this.terminals_ = terms_;
        this.symbols_ = symbols_;
        this.descriptions_ = descriptions_;
         this.productions_ = productions_;
        assert(this.productions === productions);
    */
    var productions = this.productions,
        nonterminals = this.nonterminals,
        symbols = this.symbols,
        operators = this.operators,
        self = this;

    // As a SIDE EFFECT of this call, we also fixup
    // the other code chunks specified in the grammar file:
    //
    // Replace direct symbol references, e.g. #NUMBER# when there's a `%token NUMBER` for your grammar.
    // We allow these tokens to be referenced anywhere in your code as #TOKEN#.
    var moduleInclude = preprocessActionCode(this.moduleInclude).replace(/#([^#\s\r\n]+)#/g, function (_, sym) {
        return provideSymbolAsSourcecode(sym);
    });
    // and COPY the `moduleInit` array, after preprocessing the individual COPIES:
    var moduleInit = this.moduleInit.map(function (chunk) {
        assert(chunk.qualifier);
        assert(typeof chunk.include === 'string');
        return {
            qualifier: chunk.qualifier,
            include: preprocessActionCode(chunk.include).replace(/#([^#\s\r\n]+)#/g, function (_, sym) {
                return provideSymbolAsSourcecode(sym);
            })
        };
    });
    assert(Array.isArray(moduleInit));

    // We potentially need multiple (2+) rounds to produce the correct actions
    // as userland action code determines whether the default actions should
    // include location tracking or not:
    var gen_level = 0;
    var prev_gen_hash = 'n';
    var gen_hash = 'y';
    this.performAction = null;
    while (gen_hash !== prev_gen_hash) {
        var preludeCode = preprocessActionCode(this.actionInclude || '');
        var actions = ['\n          /* this == yyval */\n\n          // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!\n          var yy = this.yy;\n          var yyparser = yy.parser;\n          var yylexer = yy.lexer;\n\n          ' + preludeCode + '\n\n          switch (yystate) {'];
        var actionGroups = {}; // used to combine identical actions into single instances: no use duplicating action code needlessly
        var actionGroupValue = {}; // stores the unaltered, expanded, user-defined action code for each action group.
        var stateHasAction = []; // marks which state IDs have an action, either user-specified or default.
        var symbol;

        // and now go and process the entire grammar:
        productions.forEach(buildProductionAction);

        for (var hash in actionGroups) {
            actions.push([].concat.apply([], actionGroups[hash]).join('\n') + '\n\n' + actionGroupValue[hash] + '\n    break;\n');
        }

        // add the special error recovery reduction action:
        if (this.hasErrorRecovery) {
            var userland_err_recov_redux_code = '';

            actions.push('case YY_ERROR_RECOVERY_COMBINE_ID:       // === NO_ACTION[1] :: ensures that anyone (but us) using this new state will fail dramatically!\n                // error recovery reduction action (action generated by jison,\n                // using the user-specified `%code error_recovery_reduction` %{...%}\n                // code chunk below.\n\n                ' + userland_err_recov_redux_code + '\n                break;\n            ');
        }

        // check if all IDs have an action now:
        var missingActions = [];
        for (var idx = 0, len = stateHasAction.length; idx < len; idx++) {
            if (!stateHasAction[idx]) {
                missingActions.push(idx);
            }
        }
        if (missingActions.length) {
            console.warn("WARNING: missing actions for states: ", missingActions);

            actions.push('default:\n                // default action for all unlisted resolve states: ' + missingActions.join(', ') + '\n\n                // When we hit this entry, it\'s always a non-recoverable issue as this is a severe internal parser state failure:\n                function __b0rk_on_internal_failure(str) {\n                    var hash = yyparser.constructParseErrorInfo(str, null, null, false);\n\n                    var r = yyparser.parseError(str, hash, yyparser.JisonParserError);\n                    return r;\n                }\n\n                return __b0rk_on_internal_failure("internal parser failure: resolving unlisted state: " + yystate);');
        }
        actions.push('}');

        var parameters = 'yytext, yyleng, yylineno, yyloc, yystate /* action[1] */, yysp, yyrulelength, yyvstack, yylstack, yystack, yysstack';

        this.performAction = [].concat('function parser__PerformAction(' + parameters + ') {', actions, '}').join('\n').replace(/\bYYABORT\b/g, 'return false').replace(/\bYYACCEPT\b/g, 'return true')

        // Replace direct symbol references, e.g. #NUMBER# when there's a `%token NUMBER` for your grammar.
        // We allow these tokens to be referenced anywhere in your code as #TOKEN#.
        .replace(/#([^#\s\r\n]+)#/g, function (_, sym) {
            return provideSymbolAsSourcecode(sym);
        });

        this.performAction = this.performAction.replace(/\byyerror\b/g, 'yyparser.yyError').replace(/\bYYRECOVERING\b(?:\s*\(\s*\))?/g, 'yyparser.yyRecovering()').replace(/\byyerrok\b(?:\s*\(\s*\))?/g, 'yyparser.yyErrOk()').replace(/\byyclearin\b(?:\s*\(\s*\))?/g, 'yyparser.yyClearIn()');

        this.actionsUseYYLENG = this.actionsUseYYLENG || analyzeFeatureUsage(this.performAction, /\byyleng\b/g, 1);
        this.actionsUseYYLINENO = this.actionsUseYYLINENO || analyzeFeatureUsage(this.performAction, /\byylineno\b/g, 1);
        this.actionsUseYYTEXT = this.actionsUseYYTEXT || analyzeFeatureUsage(this.performAction, /\byytext\b/g, 1);
        this.actionsUseYYLOC = this.actionsUseYYLOC || analyzeFeatureUsage(this.performAction, /\byyloc\b/g, 1);
        this.actionsUseParseError = this.actionsUseParseError || analyzeFeatureUsage(this.performAction, /\.parseError\b/g, 0);
        this.actionsUseYYERROR = this.actionsUseYYERROR || analyzeFeatureUsage(this.performAction, /\.yyError\b/g, 0);
        this.actionsUseYYRECOVERING = this.actionsUseYYRECOVERING || analyzeFeatureUsage(this.performAction, /\.yyRecovering\b/g, 0);
        this.actionsUseYYERROK = this.actionsUseYYERROK || analyzeFeatureUsage(this.performAction, /\.yyErrOk\b/g, 0);
        this.actionsUseYYCLEARIN = this.actionsUseYYCLEARIN || analyzeFeatureUsage(this.performAction, /\.yyClearIn\b/g, 0);
        // At this point in time, we have already expanded `$name`, `$$` and `$n` to its `$$[n]` index expression.
        //
        // Also note we cannot use regex `\b` with `\$` as the regex doesn't consider the literal `$` to be a *word* character
        // hence the *boundary check* `\b` won't deliver as expected. Hence we'll have to wing it but we can, assured
        // in the knowledge that the 'sourcecode' we have here is a complete generated *function* which will include
        // the `function ` prelude and `}` postlude at least! Hence we can replace `\b` with `[^\w]` and we'll be good.
        this.actionsUseValueTracking = this.actionsUseValueTracking || analyzeFeatureUsage(this.performAction, /\byyvstack\b/g, 1);
        // Ditto for the specific case where we are assigning a value to `$$`, i.e. `this.$`:
        this.actionsUseValueAssignment = this.actionsUseValueAssignment || analyzeFeatureUsage(this.performAction, /\bthis\.\$[^\w]/g, 0);
        // Ditto for the expansion of `@name`, `@$` and `@n` to its `yylstack[n]` index expression:
        this.actionsUseLocationTracking = this.actionsUseLocationTracking || analyzeFeatureUsage(this.performAction, /\byylstack\b/g, 1);
        // Ditto for the specific case where we are assigning a value to `@$`, i.e. `this._$`:
        this.actionsUseLocationAssignment = this.actionsUseLocationAssignment || analyzeFeatureUsage(this.performAction, /\bthis\._\$[^\w]/g, 0);
        // Note that the `#name`, `#$` and `#n` constructs are expanded directly to their symbol number without
        // the need to use yystack! Hence yystack is only there for very special use action code.)
        this.actionsUseYYSTACK = this.actionsUseYYSTACK || analyzeFeatureUsage(this.performAction, /\byystack\b/g, 1);
        // Ditto for yysstack...
        this.actionsUseYYSSTACK = this.actionsUseYYSSTACK || analyzeFeatureUsage(this.performAction, /\byysstack\b/g, 1);
        this.actionsUseYYSTACKPOINTER = this.actionsUseYYSTACKPOINTER || analyzeFeatureUsage(this.performAction, /\byysp\b/g, 1);
        this.actionsUseYYRULELENGTH = this.actionsUseYYRULELENGTH || analyzeFeatureUsage(this.performAction, /\byyrulelength\b/g, 1);
        this.actionsUseYYMERGELOCATIONINFO = this.actionsUseYYMERGELOCATIONINFO || analyzeFeatureUsage(this.performAction, /\.yyMergeLocationInfo\b/g, 1);

        // ------------------------------------------------------------------------------------
        // And Check if any of these features occur in the other user-defined chunks of code
        // that will end up as part of the parser at large:
        //
        // ---
        //
        // It does NOT matter that other user code accesses lexer-specific items; this analysis is
        // abut accessing PARSER INTERNALS, hence we have commented out the items which cannot ever
        // reach those variables from here.
        //
        //
        // ### NOTE ###
        //
        // We DO NOT care if some very obscure piece of code transfers a `this` (= yyval) reference from
        // and action code chunk to an outside function: if you are *that* devious, we also reckon you
        // are very well aware of what you are doing and quite capable of 'forcing' these feature
        // flags via the `%options` route. ;-))
        //
        // HOWVER, writing a custom `parseError` handler in there is considered rather more mundane,
        // so we reckon you have found a way to grab yyvstack et al from the error hash in that
        // wicked `parseError` callback of yours! ;-))
        //
        //   (Do note that `constructParseErrorInfo()` **intentionally** DOES NOT include the internal
        //    `yyval` in the produced error info chunk! Meanwhile, `yyvstack` is known under a different
        //    name inside the error info object and that is, as far as we are concerned, the only
        //    sensible way to get access to the internal parse stacks *outside* `performAction()`!
        //    ... Just because we like our copy-pasta, we wave our hands and check for both incantations...)
        //

        //this.actionsUseYYLENG = this.actionsUseYYLENG || analyzeFeatureUsage(moduleInclude, /\byyleng\b/g, 0);
        //this.actionsUseYYLINENO = this.actionsUseYYLINENO || analyzeFeatureUsage(moduleInclude, /\byylineno\b/g, 0);
        //this.actionsUseYYTEXT = this.actionsUseYYTEXT || analyzeFeatureUsage(moduleInclude, /\byytext\b/g, 0);
        //this.actionsUseYYLOC = this.actionsUseYYLOC || analyzeFeatureUsage(moduleInclude, /\byyloc\b/g, 0);
        this.actionsUseParseError = this.actionsUseParseError || analyzeFeatureUsage(moduleInclude, /\.parseError\b/g, 0);
        this.actionsUseYYERROR = this.actionsUseYYERROR || analyzeFeatureUsage(moduleInclude, /\.yyError\b/g, 0);
        this.actionsUseYYRECOVERING = this.actionsUseYYRECOVERING || analyzeFeatureUsage(moduleInclude, /\.yyRecovering\b/g, 0);
        this.actionsUseYYERROK = this.actionsUseYYERROK || analyzeFeatureUsage(moduleInclude, /\.yyErrOk\b/g, 0);
        this.actionsUseYYCLEARIN = this.actionsUseYYCLEARIN || analyzeFeatureUsage(moduleInclude, /\.yyClearIn\b/g, 0);
        // We cannot use regex `\b` with `\$` as the regex doesn't consider the literal `$` to be a *word* character
        // hence the *boundary check* `\b` won't deliver as expected. Hence we'll have to wing it but we can, assured
        // in the knowledge that the 'sourcecode' we have here is a complete generated *function* which will include
        // the `function ` prelude and `}` postlude at least! Hence we can replace `\b` with `[^\w]` and we'll be good.
        this.actionsUseValueTracking = this.actionsUseValueTracking || analyzeFeatureUsage(moduleInclude, /\byyvstack\b/g, 0);
        this.actionsUseValueTracking = this.actionsUseValueTracking || analyzeFeatureUsage(moduleInclude, /\.value_stack\b/g, 0);
        // Ditto for the specific case where we are assigning a value to `$$`, i.e. `this.$`:
        //this.actionsUseValueAssignment = this.actionsUseValueAssignment || analyzeFeatureUsage(moduleInclude, /\bthis\.\$[^\w]/g, 0);
        // Ditto for the expansion of `@name`, `@$` and `@n` to its `yylstack[n]` index expression:
        this.actionsUseLocationTracking = this.actionsUseLocationTracking || analyzeFeatureUsage(moduleInclude, /\byylstack\b/g, 0);
        this.actionsUseLocationTracking = this.actionsUseLocationTracking || analyzeFeatureUsage(moduleInclude, /\.location_stack\b/g, 0);
        // Ditto for the specific case where we are assigning a value to `@$`, i.e. `this._$`:
        //this.actionsUseLocationAssignment = this.actionsUseLocationAssignment || analyzeFeatureUsage(moduleInclude, /\bthis\._\$[^\w]/g, 0);
        // Note that the `#name`, `#$` and `#n` constructs are expanded directly to their symbol number without
        // the need to use yystack! Hence yystack is only there for very special use action code.)
        this.actionsUseYYSTACK = this.actionsUseYYSTACK || analyzeFeatureUsage(moduleInclude, /\byystack\b/g, 0);
        this.actionsUseYYSTACK = this.actionsUseYYSTACK || analyzeFeatureUsage(moduleInclude, /\.symbol_stack\b/g, 0);
        // Ditto for yysstack...
        this.actionsUseYYSSTACK = this.actionsUseYYSSTACK || analyzeFeatureUsage(moduleInclude, /\byysstack\b/g, 0);
        this.actionsUseYYSSTACK = this.actionsUseYYSSTACK || analyzeFeatureUsage(moduleInclude, /\.state_stack\b/g, 0);
        this.actionsUseYYSTACKPOINTER = this.actionsUseYYSTACKPOINTER || analyzeFeatureUsage(moduleInclude, /\byysp\b/g, 0);
        this.actionsUseYYSTACKPOINTER = this.actionsUseYYSTACKPOINTER || analyzeFeatureUsage(moduleInclude, /\.stack_pointer\b/g, 0);
        //this.actionsUseYYRULELENGTH = this.actionsUseYYRULELENGTH || analyzeFeatureUsage(moduleInclude, /\byyrulelength\b/g, 0);
        this.actionsUseYYMERGELOCATIONINFO = this.actionsUseYYMERGELOCATIONINFO || analyzeFeatureUsage(moduleInclude, /\.yyMergeLocationInfo\b/g, 0);

        moduleInit.forEach(function (chunk) {
            assert(chunk.qualifier);
            assert(typeof chunk.include === 'string');
            var moduleInclude = chunk.include;

            //self.actionsUseYYLENG = self.actionsUseYYLENG || analyzeFeatureUsage(moduleInclude, /\byyleng\b/g, 0);
            //self.actionsUseYYLINENO = self.actionsUseYYLINENO || analyzeFeatureUsage(moduleInclude, /\byylineno\b/g, 0);
            //self.actionsUseYYTEXT = self.actionsUseYYTEXT || analyzeFeatureUsage(moduleInclude, /\byytext\b/g, 0);
            //self.actionsUseYYLOC = self.actionsUseYYLOC || analyzeFeatureUsage(moduleInclude, /\byyloc\b/g, 0);
            self.actionsUseParseError = self.actionsUseParseError || analyzeFeatureUsage(moduleInclude, /\.parseError\b/g, 0);
            self.actionsUseYYERROR = self.actionsUseYYERROR || analyzeFeatureUsage(moduleInclude, /\.yyError\b/g, 0);
            self.actionsUseYYRECOVERING = self.actionsUseYYRECOVERING || analyzeFeatureUsage(moduleInclude, /\.yyRecovering\b/g, 0);
            self.actionsUseYYERROK = self.actionsUseYYERROK || analyzeFeatureUsage(moduleInclude, /\.yyErrOk\b/g, 0);
            self.actionsUseYYCLEARIN = self.actionsUseYYCLEARIN || analyzeFeatureUsage(moduleInclude, /\.yyClearIn\b/g, 0);
            // We cannot use regex `\b` with `\$` as the regex doesn't consider the literal `$` to be a *word* character
            // hence the *boundary check* `\b` won't deliver as expected. Hence we'll have to wing it but we can, assured
            // in the knowledge that the 'sourcecode' we have here is a complete generated *function* which will include
            // the `function ` prelude and `}` postlude at least! Hence we can replace `\b` with `[^\w]` and we'll be good.
            self.actionsUseValueTracking = self.actionsUseValueTracking || analyzeFeatureUsage(moduleInclude, /\byyvstack\b/g, 0);
            self.actionsUseValueTracking = self.actionsUseValueTracking || analyzeFeatureUsage(moduleInclude, /\.value_stack\b/g, 0);
            // Ditto for the specific case where we are assigning a value to `$$`, i.e. `self.$`:
            //self.actionsUseValueAssignment = self.actionsUseValueAssignment || analyzeFeatureUsage(moduleInclude, /\bself\.\$[^\w]/g, 0);
            // Ditto for the expansion of `@name`, `@$` and `@n` to its `yylstack[n]` index expression:
            self.actionsUseLocationTracking = self.actionsUseLocationTracking || analyzeFeatureUsage(moduleInclude, /\byylstack\b/g, 0);
            self.actionsUseLocationTracking = self.actionsUseLocationTracking || analyzeFeatureUsage(moduleInclude, /\.location_stack\b/g, 0);
            // Ditto for the specific case where we are assigning a value to `@$`, i.e. `self._$`:
            //self.actionsUseLocationAssignment = self.actionsUseLocationAssignment || analyzeFeatureUsage(moduleInclude, /\bself\._\$[^\w]/g, 0);
            // Note that the `#name`, `#$` and `#n` constructs are expanded directly to their symbol number without
            // the need to use yystack! Hence yystack is only there for very special use action code.)
            self.actionsUseYYSTACK = self.actionsUseYYSTACK || analyzeFeatureUsage(moduleInclude, /\byystack\b/g, 0);
            self.actionsUseYYSTACK = self.actionsUseYYSTACK || analyzeFeatureUsage(moduleInclude, /\.symbol_stack\b/g, 0);
            // Ditto for yysstack...
            self.actionsUseYYSSTACK = self.actionsUseYYSSTACK || analyzeFeatureUsage(moduleInclude, /\byysstack\b/g, 0);
            self.actionsUseYYSSTACK = self.actionsUseYYSSTACK || analyzeFeatureUsage(moduleInclude, /\.state_stack\b/g, 0);
            self.actionsUseYYSTACKPOINTER = self.actionsUseYYSTACKPOINTER || analyzeFeatureUsage(moduleInclude, /\byysp\b/g, 0);
            self.actionsUseYYSTACKPOINTER = self.actionsUseYYSTACKPOINTER || analyzeFeatureUsage(moduleInclude, /\.stack_pointer\b/g, 0);
            //self.actionsUseYYRULELENGTH = self.actionsUseYYRULELENGTH || analyzeFeatureUsage(moduleInclude, /\byyrulelength\b/g, 0);
            self.actionsUseYYMERGELOCATIONINFO = self.actionsUseYYMERGELOCATIONINFO || analyzeFeatureUsage(moduleInclude, /\.yyMergeLocationInfo\b/g, 0);
        });

        // ------------------------------------------------------------------------------------
        // Mix in user overrides via CLI or %options:
        this.actionsUseLocationAssignment = this.actionsUseLocationAssignment || this.options.actionsUseLocationAssignment;
        this.actionsUseLocationTracking = this.actionsUseLocationTracking || this.options.actionsUseLocationTracking;
        this.actionsUseParseError = this.actionsUseParseError || this.options.actionsUseParseError;
        this.actionsUseValueAssignment = this.actionsUseValueAssignment || this.options.actionsUseValueAssignment;
        this.actionsUseValueTracking = this.actionsUseValueTracking || this.options.actionsUseValueTracking;
        this.actionsUseYYCLEARIN = this.actionsUseYYCLEARIN || this.options.actionsUseYYCLEARIN;
        this.actionsUseYYERROK = this.actionsUseYYERROK || this.options.actionsUseYYERROK;
        this.actionsUseYYERROR = this.actionsUseYYERROR || this.options.actionsUseYYERROR;
        this.actionsUseYYLENG = this.actionsUseYYLENG || this.options.actionsUseYYLENG;
        this.actionsUseYYLINENO = this.actionsUseYYLINENO || this.options.actionsUseYYLINENO;
        this.actionsUseYYLOC = this.actionsUseYYLOC || this.options.actionsUseYYLOC;
        this.actionsUseYYRECOVERING = this.actionsUseYYRECOVERING || this.options.actionsUseYYRECOVERING;
        this.actionsUseYYRULELENGTH = this.actionsUseYYRULELENGTH || this.options.actionsUseYYRULELENGTH;
        this.actionsUseYYMERGELOCATIONINFO = this.actionsUseYYMERGELOCATIONINFO || this.options.actionsUseYYMERGELOCATIONINFO;
        this.actionsUseYYSSTACK = this.actionsUseYYSSTACK || this.options.actionsUseYYSSTACK;
        this.actionsUseYYSTACK = this.actionsUseYYSTACK || this.options.actionsUseYYSTACK;
        this.actionsUseYYSTACKPOINTER = this.actionsUseYYSTACKPOINTER || this.options.actionsUseYYSTACKPOINTER;
        this.actionsUseYYTEXT = this.actionsUseYYTEXT || this.options.actionsUseYYTEXT;
        this.hasErrorRecovery = this.hasErrorRecovery || this.options.hasErrorRecovery;
        this.hasErrorReporting = this.hasErrorReporting || this.options.hasErrorReporting;

        // ------------------------------------------------------------------------------------
        // Now combine fature flags which are related:
        switch (self.options.defaultActionMode[0]) {
            default:
                this.actionsUseValueTracking = true;
                this.actionsUseValueAssignment = true;
                break;

            case "none": // <-- this one injects "$$ = undefined;", which doesn't count as 'non-trivial code' on its own.
            case "skip":
                // <-- this one injects *nothing*
                break;
        }
        this.actionsUseValueTracking = this.actionsUseValueTracking || this.actionsUseYYLENG || this.actionsUseYYTEXT || this.actionsUseValueAssignment;

        switch (self.options.defaultActionMode[1]) {
            default:
                // WARNING: we only turn on default location tracking code **at all** iff
                // any part of the user code actually uses it, otherwise we would be
                // instrumenting an entire parser with location tracking code which' efforts
                // will be discarded at the end of the parse anyhow.
                //
                // Do note that this is different from the **value tracking** default code
                // policy: it **IS** sane to instrument an entire parser with value
                // tracking action code because *those* efforts will ultimately end up
                // as/in the parse **result**!

                break;

            case "none": // <-- this one injects "$$ = undefined;", which doesn't count as 'non-trivial code' on its own.
            case "skip":
                // <-- this one injects *nothing*
                break;
        }
        this.actionsUseLocationTracking = this.actionsUseLocationTracking || this.actionsUseYYLINENO || this.actionsUseYYLOC || this.actionsUseLocationAssignment || this.actionsUseYYMERGELOCATIONINFO;

        this.hasErrorReporting = this.hasErrorReporting || this.actionsUseParseError || this.actionsUseYYERROR;
        // --------------------- done! --------------------------------------------------------

        // Now that we've completed all macro expansions, it's time to execute
        // the recovery code, i.e. the postprocess:
        this.performAction = postprocessActionCode(this.performAction);

        // Now check if we produced an *EMPTY* `parser__PerformAction()`.
        // If so, we can discard the entire function!
        this.actionsAreAllDefault = false; // TODO

        gen_level++;
        prev_gen_hash = gen_hash;
        gen_hash = null;

        // create check hash of the new generated code:
        var new_hash = mkParserFeatureHash(this);

        if (devDebug || this.DEBUG) {
            Jison.print('Optimization analysis:\n', {
                cycle: gen_level,
                SAME: prev_gen_hash === new_hash,
                actionsAreAllDefault: this.actionsAreAllDefault,
                actionsUseYYLENG: this.actionsUseYYLENG,
                actionsUseYYLINENO: this.actionsUseYYLINENO,
                actionsUseYYTEXT: this.actionsUseYYTEXT,
                actionsUseYYLOC: this.actionsUseYYLOC,
                actionsUseParseError: this.actionsUseParseError,
                actionsUseYYERROR: this.actionsUseYYERROR,
                actionsUseYYRECOVERING: this.actionsUseYYRECOVERING,
                actionsUseYYERROK: this.actionsUseYYERROK,
                actionsUseYYCLEARIN: this.actionsUseYYCLEARIN,
                actionsUseValueTracking: this.actionsUseValueTracking,
                actionsUseValueAssignment: this.actionsUseValueAssignment,
                actionsUseLocationTracking: this.actionsUseLocationTracking,
                actionsUseLocationAssignment: this.actionsUseLocationAssignment,
                actionsUseYYSTACK: this.actionsUseYYSTACK,
                actionsUseYYSSTACK: this.actionsUseYYSSTACK,
                actionsUseYYSTACKPOINTER: this.actionsUseYYSTACKPOINTER,
                actionsUseYYRULELENGTH: this.actionsUseYYRULELENGTH,
                actionsUseYYMERGELOCATIONINFO: this.actionsUseYYMERGELOCATIONINFO,
                hasErrorRecovery: this.hasErrorRecovery,
                hasErrorReporting: this.hasErrorReporting,
                defaultActionMode: this.options.defaultActionMode,
                noTryCatch: this.options.noTryCatch
            });
        }

        gen_hash = new_hash;
    }

    // And before we leave, as a SIDE EFFECT of this call, we also fixup
    // the other code chunks specified in the grammar file.
    this.moduleInclude = postprocessActionCode(moduleInclude);
    this.moduleInit = moduleInit.map(function (chunk) {
        assert(chunk.qualifier);
        assert(typeof chunk.include === 'string');
        chunk.include = postprocessActionCode(chunk.include);
        return chunk;
    });
    assert(Array.isArray(this.moduleInit));

    // add helper methods to `this.moduleInit` for later use by our code generator:
    moduleInit = this.moduleInit;
    moduleInit.__consumedInitCodeSlots__ = [];

    moduleInit.getInitCodeSection = function getInitCodeSection(section) {
        var rv = [];
        for (var i = 0, len = this.length; i < len; i++) {
            var m = this[i];
            if (m.qualifier === section) {
                if (m.include.trim()) {
                    rv.push(m.include);
                }
                this.__consumedInitCodeSlots__[i] = true;
            }
        }
        return rv;
    };

    moduleInit.getRemainingInitCodeSections = function getRemainingInitCodeSections() {
        var rv = [];
        for (var i = 0, len = this.length; i < len; i++) {
            var m = this[i];
            if (!this.__consumedInitCodeSlots__[i]) {
                rv.push(rmCommonWS(_templateObject95, m.qualifier, m.include, m.qualifier));
                this.__consumedInitCodeSlots__[i] = true;
            }
        }
        return rv;
    };

    // make sure a comment does not contain any embedded '*/' end-of-comment marker
    // as that would break the generated code
    function postprocessComment(str) {
        if (Array.isArray(str)) {
            str = str.map(function (_) {
                return _ === '' || _ == null ? '' : _;
            }).join(' ');
        }
        if (str === '') {
            str = '';
        }
        str = str.replace(/\*\//g, '*\\/'); // destroy any inner `*/` comment terminator sequence.
        return str;
    }

    function getSymbolId(s) {
        if (s && !self.symbols_[s]) {
            throw new Error('Your action code is trying to reference non-existing symbol "' + s + '"');
        }
        return self.symbols_[s] || 0;
    }

    function provideSymbolAsSourcecode(sym) {
        var ss = String(sym);
        return ' /* ' + postprocessComment(ss) + ' */ ' + getSymbolId(sym);
    }

    // helper: convert index string/number to proper JS add/subtract expression
    function indexToJsExpr(n, len, rule4msg) {
        var v = parseInt(n, 10);
        // the usual situation: `$3`; MUST reference an rhs[] element or it will be considered an ERROR:
        if (v > 0) {
            if (v > len) {
                throw new Error('invalid token reference "$' + v + '" in action code for rule: "' + rule4msg + '"');
            }
            v = len - v;
            if (v) {
                return ' - ' + v;
            }
            // do not generate code for superfluous `- 0` JS expression:
            return '';
        }
        // the VERY UNusual situation: `$-1`: referencing *parent* rules' values
        if (v < 0) {
            return ' - ' + (len - v);
        }
        // decode error?
        if (v !== 0) {
            throw new Error('invalid token reference "$' + v + '" in action code for rule: "' + rule4msg + '"');
        }
        // the slightly unusual situation: `$0` (instead of `$$`)
        v = len;
        if (v) {
            return ' - ' + v;
        }
        // do not generate code for superfluous `- 0` JS expression:
        return '';
    }

    function buildProductionAction(handle) {
        var r, i;

        if (devDebug) Jison.print('\nbuildProductionAction: ', handle.symbol, ':', JSON.stringify(handle, null, 2));

        var aliased = handle.aliases,
            rhs_i;

        var rhs = handle.handle;
        var named_token_re = new XRegExp('^' + ID_REGEX_BASE + '$');

        // semantic action specified
        var label = ['case ', handle.id, ':', '\n    /*! Production::    ', postprocessComment(handle.symbol), ' : '].concat(postprocessComment(rhs.map(function (sym) {
            // check if the symbol is a literal terminal, and if it is, quote it:
            if (sym && !self.nonterminals[sym] && !named_token_re.test(sym) && sym !== self.EOF) {
                return '"' + sym.replace(/["]/g, '\\"') + '"';
            } else if (!sym) {
                sym = '%epsilon';
            }
            return sym;
        })), ' */').join('');
        var action = preprocessActionCode(handle.action || '');
        var rule4msg = handle.symbol + ': ' + rhs.join(' ');

        assert(typeof handle.id === 'number');
        assert(handle.id >= 0);
        stateHasAction[handle.id] = true;

        // before anything else, replace direct symbol references, e.g. #NUMBER# when there's a %token NUMBER for your grammar.
        // This is done to prevent incorrect expansions where tokens are used in rules as RHS elements: we allow these to
        // be referenced as both #TOKEN# and #TOKEN where the first is a literal token/symbol reference (unrelated to its use
        // in the rule) and the latter is a reference to the token/symbol being used in the rule.
        //
        // Here we expand those direct token/symbol references: #TOKEN#
        action = action.replace(/#([^#\s\r\n]+)#/g, function (_, sym) {
            return provideSymbolAsSourcecode(sym);
        });

        // replace named semantic values ($nonterminal)
        if (action.match(new XRegExp('(?:[$@#]|##)' + ID_REGEX_BASE))) {
            var count = {},
                names = {},
                donotalias = {};

            // When the rule is fitted with aliases it doesn't mean that the action code MUST use those:
            // we therefor allow access to both the original (non)terminal and the alias.
            //
            // Also note that each (non)terminal can also be uniquely addressed by [$@]<nonterminal><N>
            // where N is a number representing the number of this particular occurrence of the given
            // (non)terminal.
            //
            // For example, given this (intentionally contrived) production:
            //     elem[alias] elem[another_alias] another_elem[alias] elem[alias] another_elem[another_alias]
            // all the items can be accessed as:
            //     $1 $2 $3 $4 $5
            //     $elem1 $elem2 $another_elem1 $elem3 $another_elem2
            //     $elem $elem2 $another_elem $elem3 $another_elem2
            //     $alias1 $another_alias1 $alias2 $alias3 $another_alias2
            //     $alias $another_alias $alias2 $alias3 $another_alias2
            // where each line above is equivalent to the top-most line. Note the numbers postfixed to
            // both (non)terminal identifiers and aliases alike and also note alias2 === another_elem1:
            // the postfix numbering is independent.
            //
            // WARNING: this feature is disabled for a term when there already exists an
            //          (human-defined) *alias* for this term *or* when the numbered auto-alias already
            //          exists because the user has used it as an alias for another term, e.g.
            //
            //             e: WORD[e1] '=' e '+' e;
            //
            //          would *not* produce the `e1` and `e2` aliases, as `e1` is already defined
            //          as an explicit alias: adding auto-alias `e1` would then break the system,
            //          while `e2` would be ambiguous from the human perspective as he *might* then
            //          expect `e2` and `e3`.
            var addName = function addName(s) {
                var base = s.replace(/[0-9]+$/, '');
                var dna = donotalias[base];

                if (names[s]) {
                    count[s]++;
                    if (!dna) {
                        names[s + count[s]] = i + 1;
                        count[s + count[s]] = 1;
                    }
                } else {
                    names[s] = i + 1;
                    count[s] = 1;
                    if (!dna) {
                        names[s + count[s]] = i + 1;
                        count[s + count[s]] = 1;
                    }
                }
            };

            // register the alias/rule name when the real one ends with a number, e.g. `rule5` as
            // *blocking* the auto-aliasing process for the term of the same base, e.g. `rule`.
            // This will catch the `WORD[e1]` example above too, via `e1` --> `donotalias['e']`
            var markBasename = function markBasename(s) {
                if (/[0-9]$/.test(s)) {
                    s = s.replace(/[0-9]+$/, '');
                    donotalias[s] = true;
                }
            };

            for (i = 0; i < rhs.length; i++) {
                // mark both regular and aliased names, e.g., `id[alias1]` and `id1`
                rhs_i = aliased[i];
                markBasename(rhs_i);
                if (rhs_i !== rhs[i]) {
                    markBasename(rhs[i]);
                }
            }

            for (i = 0; i < rhs.length; i++) {
                // check for aliased names, e.g., id[alias]
                rhs_i = aliased[i];
                addName(rhs_i);
                if (rhs_i !== rhs[i]) {
                    addName(rhs[i]);
                }
            }
            action = action.replace(new XRegExp('([$@#]|##)(' + ID_REGEX_BASE + ')', 'g'), function (str, mrkr, pl) {
                if (names[pl] && count[pl] !== 1) {
                    throw new Error('The action block references the ambiguous named alias or term reference "' + pl + '" which is mentioned ' + count[pl] + ' times in production "' + handle.handle + '", implicit and explicit aliases included.' + '\nYou should either provide unambiguous = uniquely named aliases for these terms or use numeric index references (e.g. `$3`) as a stop-gap in your action code.');
                }
                return names[pl] ? mrkr + names[pl] : str;
            });
        }
        action = action
        // replace references to `$$` with `this.$`, `@$` with `this._$` and `#$` with the token ID of the current rule
        .replace(/\$\$/g, 'this.$').replace(/@\$/g, 'this._$').replace(/#\$/g, function (_) {
            return provideSymbolAsSourcecode(symbol);
        })
        // replace semantic value references ($n) with stack value (stack[n])
        .replace(/\$(-?\d+)\b/g, function (_, n) {
            return 'yyvstack[yysp' + indexToJsExpr(n, rhs.length, rule4msg) + ']';
        })
        // same as above for location references (@n)
        .replace(/@(-?\d+)\b/g, function (_, n) {
            return 'yylstack[yysp' + indexToJsExpr(n, rhs.length, rule4msg) + ']';
        })
        // same as above for positional value references (##n): these represent stack indexes
        .replace(/##(-?\d+)\b/g, function (_, n) {
            return '(yysp' + indexToJsExpr(n, rhs.length, rule4msg) + ')';
        }).replace(/##\$/g, function (_) {
            return 'yysp';
        })
        // same as above for token ID references (#n)
        .replace(/#(-?\d+)\b/g, function (_, n) {
            var i = parseInt(n, 10) - 1;
            if (!rhs[i]) {
                throw new Error('invalid token location reference in action code for rule: "' + rule4msg + '" - location reference: "' + _ + '"');
            }
            return provideSymbolAsSourcecode(rhs[i]);
        });

        // Now that the user action (if any) has been expanded to valid JavaScript code
        // (we're SOL and very probably looking at bugs in the user-written action code
        // if it is NOT VALID by now!) we can perform code analysis to see which,
        // if any, default actions have to be injected in the code snippet.
        //
        // The rules of the game are:
        // - when there's *use* of `$$` or `@$` *before* they are assigned a value,
        //   the corresponding default action is required.
        // - when there's *nothing* about (no use of, no assignment to) `$$` or `@$`
        //   then the corresponding default action should be injected IFF the
        //   code analysis flags have been set, i.e. only inject the default action
        //   when we already *know* that other parts of the parser state machine
        //   (other rules' actions!) *are* using these.
        //   We DO NOT include "flow analysis" so we cannot determine if
        //   *this particular* rule's values will be accessed; iff location tracking
        //   is used at all, we inject it everywhere. Ditto for value tracking.
        // - value tracking (`$$` et al) is considered *independently* from location
        //   tracking (`@$` et al): the one or the other may need the default
        //   actions for more-or-less sensible (or at least *deterministic*!) results
        //   and consequently should get them, indenpent of whether the user-written
        //   action code fuly addresses the other.
        //
        //   Generally, user actions concern themselves with assigning a value to `$$`,
        //   while not addressing `@$`: in that case, the location tracking default
        //   action `@$ = ...` will be injected in that action snippet.
        //
        //   Also note that, in order to prevent obscure failures due to analysis
        //   false positives, all default actions are injected *before* the user-written
        //   action code.
        //
        // Technical Note
        //
        // We perform the action code analysis *after* jison variable expansions are done
        // because we want the analysis to be *independent* of how the user wrote
        // the action code: if some Smart Alec decides to code `this.$` instead of
        // `$$` it SHOULD NOT confuse the code analysis here!

        var uses_$$ = analyzeFeatureUsage(action, /\bthis\.\$[^\w]/g, 0); // use includes assignment, not just read accesses!

        // the next check is very rough; we need the AST of the code to do better than this.
        function analyzeFeatureAssignmentBeforeUse(source, assignment_re, access_re) {
            // first match agains the assignment regex: it MUST have a closure
            // to catch all code that came before this first assignment.
            //
            // If no assignment can be found at all, we're probably looking at access-only
            // OR weird constructs we don't yet understand, in which case we play it safe.
            var prelude = source;
            var m = source.match(assignment_re);
            if (m) {
                // check the closure exists in the regex: m[1] is filled with its content:
                assert(m[1] != null);
                prelude = m[1];
            }
            // now check if there's any mention of the feature before its first
            // assignment.
            //
            // We MAY get thwarted by complex action code such as this:
            //
            //     function closure_func(a) {
            //       $$ = a;
            //     }
            //
            //     if ($term1) {
            //       print($$);         // actually this is use before assignment, but we won't recognize it as such!
            //     } else {
            //       closure_func($term2);
            //       print('alt');
            //     }
            //
            // but for now we ignore the complexity of the situation and move on.
            m = prelude.match(access_re);
            if (m) {
                return true; // access before assignment
            }
            return false; // assignment before access (or no usage and assignments at all!)
        }

        var uses_$$_before_assignment = uses_$$ && analyzeFeatureAssignmentBeforeUse(action, /^([^]*?)\bthis\.\$\s*=[^=>]/, /\bthis\.\$[^\w]/g);

        // ditto for location tracking, but only iff we use it at all:
        var uses_$loc = false;
        var uses_$loc_before_assignment = false;

        if (self.actionsUseLocationTracking) {
            uses_$loc = analyzeFeatureUsage(action, /\bthis\._\$[^\w]/g, 0);
            uses_$loc_before_assignment = uses_$loc && analyzeFeatureAssignmentBeforeUse(action, /^([^]*?)\bthis\._\$\s*=[^=>]/, /\bthis\._\$[^\w]/g);
        }

        var inject_default_value_action = uses_$$_before_assignment || self.actionsUseValueTracking && !uses_$$;
        var inject_default_loc_action = uses_$loc_before_assignment || self.actionsUseLocationTracking && !uses_$loc;

        var default_action = [];

        // Note:
        //
        // when the option defaultActionMode="none,none" has been set, we still strive to produce
        // a deterministic output, hence we take the swiftest route towards producing
        // a deterministic rule result: we assign it the value `undefined`:
        //
        //     $$ = undefined;
        //     $@ = undefined;
        //
        var vmode = !inject_default_value_action ? "skip" : self.options.defaultActionMode[0];
        var lmode = !inject_default_loc_action ? "skip" : self.options.defaultActionMode[1];

        // check if there's no user action specified. Insert default action if it isn't.

        // first determine the actual number of terms in the production:
        var rhs = handle.handle.slice(0);
        var real_rhs_length = rhs.length;

        // strip away EOF terms at the end of the rule, ditto for epsilon terms:
        if (rhs.length) {
            switch (rhs[rhs.length - 1]) {
                case '$end':
                    rhs.length--;
                    break;

                case '':
                    // %epsilon
                    rhs.length--;
                    break;
            }
        }

        // then we can choose what to do, depending on the number of terms in the production.
        //
        // There are a few reasons *why* one would choose to inject the default action:
        //
        // 1. there's use (read access) before assignment (write).
        // 2. there's no use nor any assignment, but the rest of the parser *does* use rule values.
        //    (In which case we would need flow analysis to determine if our default action would
        //    really matter, but absent that, we just inject the default action everywhere and
        //    we can be certain the other action code chunks will work as expected, though
        //    the parser may be a bit sub-optimal due to possibly unused default actions being
        //    executed in some states.)
        //
        // Ditto for location tracking default actions...
        //
        switch (rhs.length) {
            case 0:
                switch (vmode) {
                    case "classic":
                    // $$ = $1;   <-- but that would cause nondeterministic behaviour, so
                    //                we fall back to the default here!
                    case "ast":
                    case "none":
                        default_action.push("this.$ = undefined;");
                        break;

                    case "skip":
                        // nothing to inject
                        break;

                    default:
                        throw new Error('unsupported defaultAction value mode: "' + vmode + '"');
                }

                switch (lmode) {
                    case "classic":
                    case "ast":
                    case "merge":
                        // an empty production has no location as there are no terms parsed.
                        // ergo: we produce a zero-width location which points at the tail
                        // end of the previous content:
                        // @$ = yyparser.yyMergeLocationInfo(null, null, null, null, true);
                        default_action.push("this._$ = yyparser.yyMergeLocationInfo(null, null, null, null, true);");
                        break;

                    case "none":
                        // @$ = undefined;
                        default_action.push("this._$ = undefined;");
                        break;

                    case "skip":
                        // nothing to inject
                        break;

                    default:
                        throw new Error('unsupported defaultAction location mode: "' + lmode + '"');
                }
                break;

            case 1:
                switch (vmode) {
                    case "classic":
                        // $$ = $1;
                        //
                        // WARNING: be careful with the ACCEPT rule as that one's production has
                        // rhs.length === 1 **BUT** has real_rhs_length === 2 as we have discarded
                        // the `$end` term at the end!
                        // Here we need to account for that magick though!
                        default_action.push("this.$ = yyvstack[yysp" + indexToJsExpr(1, real_rhs_length, rule4msg) + "];");
                        break;

                    case "ast":
                        // bundle all production terms in an array:
                        //   $$ = yyvstack.slice(yysp - ${rhs.length - 1}, yysp + 1);
                        // As we're looking at a production which has one(1) useful term, we can simply
                        // reference-copy that one intom a fresh array, instead of `slice()`-ing it out
                        // of the vstack.
                        //   $$ = [$1];
                        //
                        // WARNING/NOTE: as above, and ditto BTW for rule productions which end with
                        // `EOF` as a last term: as we now construct an entire AST, we DO NOT include
                        // those 'values' here!
                        default_action.push("this.$ = [yyvstack[yysp" + indexToJsExpr(1, real_rhs_length, rule4msg) + "]];");
                        break;

                    case "none":
                        default_action.push("this.$ = undefined;");
                        break;

                    case "skip":
                        // nothing to inject
                        break;

                    default:
                        throw new Error('unsupported defaultAction value mode: "' + vmode + '"');
                }

                switch (lmode) {
                    case "classic":
                    case "ast":
                    case "merge":
                        // merge all production terms' locations into a single range:
                        // as we have a production length of 1 only, we can simply ref-copy @1:
                        // @$ = @1;
                        //
                        // WARNING: same as above for the value copying: we may have discarded an `EOF` or `$end` term!
                        default_action.push("this._$ = yylstack[yysp" + indexToJsExpr(1, real_rhs_length, rule4msg) + "];");
                        break;

                    case "none":
                        // @$ = undefined;
                        default_action.push("this._$ = undefined;");
                        break;

                    case "skip":
                        // nothing to inject
                        break;

                    default:
                        throw new Error('unsupported defaultAction location mode: "' + lmode + '"');
                }
                break;

            default:
                switch (vmode) {
                    case "classic":
                        // $$ = $1;
                        default_action.push("this.$ = yyvstack[yysp" + indexToJsExpr(1, real_rhs_length, rule4msg) + "];");
                        break;

                    case "ast":
                        // bundle all production terms in an array:
                        // $$ = yyvstack.slice(yysp - ${rhs.length - 1}, yysp + 1);
                        //
                        // WARNING: as with the situation further above where rhs.length === 1 after we
                        // have got rid of a possible `EOF` or `$end` at the end of the production,
                        // we again have to account for our trickery earlier and compensate the
                        // action above: again we DO NOT include the value of the EOF/$end token in the
                        // resulting array 'AST', hence our `slice()` end index may vary by one(1):
                        var end_offset = 1 - real_rhs_length + rhs.length;
                        default_action.push("this.$ = yyvstack.slice(yysp" + indexToJsExpr(1, real_rhs_length, rule4msg) + ", yysp" + ( /* CANNOT USE indexToJsExpr(rhs.length + 1, real_rhs_length, rule4msg) HERE! */end_offset === 0 ? "" : " + " + end_offset) + ");");
                        break;

                    case "none":
                        default_action.push("this.$ = undefined;");
                        break;

                    case "skip":
                        // nothing to inject
                        break;

                    default:
                        throw new Error('unsupported defaultAction value mode: "' + vmode + '"');
                }

                switch (lmode) {
                    case "classic":
                    case "ast":
                    case "merge":
                        // merge all production terms' locations into a single range:
                        // @$ = yyparser.yyMergeLocationInfo(yysp - ${rhs.length - 1}, yysp);
                        default_action.push("this._$ = yyparser.yyMergeLocationInfo(yysp" + indexToJsExpr(1, real_rhs_length, rule4msg) + ", yysp);");
                        break;

                    case "none":
                        // @$ = undefined;
                        default_action.push("this._$ = undefined;");
                        break;

                    case "skip":
                        // nothing to inject
                        break;

                    default:
                        throw new Error('unsupported defaultAction location mode: "' + lmode + '"');
                }
                break;
        }

        // comment/mark the default action chunk, if any, so we can simply observe
        // what is user code and what is generated by us in the final product:
        if (default_action.length > 0) {
            var flags = [rhs.length, self.actionsUseValueTracking ? "VT" : "-", self.actionsUseValueAssignment ? "VA" : "-", uses_$$ ? "VU" : "-", uses_$$_before_assignment ? "VUbA" : "-", self.actionsUseLocationTracking ? "LT" : "-", self.actionsUseLocationAssignment ? "LA" : "-", uses_$loc ? "LU" : "-", uses_$loc_before_assignment ? "LUbA" : "-"].join(',');

            default_action.unshift('// default action (generated by JISON mode ' + self.options.defaultActionMode[0] + '/' + self.options.defaultActionMode[1] + ' :: ' + flags + '):');
            default_action.push('// END of default action (generated by JISON mode ' + self.options.defaultActionMode[0] + '/' + self.options.defaultActionMode[1] + ' :: ' + flags + ')');

            if (action.trim() !== '') {
                default_action.push('\n', action);
            }
            action = default_action.join('\n');
        }

        action = reindentCodeBlock(action, 4);

        var actionHash = mkHashIndex(action);

        // Delay running the postprocess (restore) process until we've done ALL macro expansions:
        //action = postprocessActionCode(action);

        if (actionHash in actionGroups) {
            actionGroups[actionHash].push(label);
        } else {
            actionGroups[actionHash] = [label];
            actionGroupValue[actionHash] = action;
        }
    }
};

generator.createParser = function createParser() {
    throw new Error('Calling abstract method.');
};

generator.createLexer = function createLexer() {
    throw new Error('Calling abstract method.');
};

// no-op. implemented in debug mixin
generator.trace = function no_op_trace() {};

generator.warn = function warn() {
    var args = Array.prototype.slice.call(arguments, 0);
    Jison.print.call(null, args.join(''));
};

generator.error = function error(msg) {
    throw new Error(msg);
};

// Report a few things about the grammar:
//
// - unused rules
// - stats:
//   + production count     (-> parser table size indicator)
//   + state count          (-> parser table size indicator)
//
generator.reportGrammarInformation = function reportGrammarInformation() {
    if (this.unused_productions.length) {
        this.warn('\nUnused productions in your grammar:\n  ' + this.unused_productions.join('\n  ') + '\n\n');
    }

    if (!this.options.reportStats) {
        return;
    }

    // nonterminals = this.nonterminals,
    // operators = this.operators,
    // this.table
    // this.states
    // this.defaultActions
    // this.productions,
    // this.terms = {};
    // this.operators = {};
    // this.productions = [];
    // this.conflicts = 0;
    // this.new_conflicts_found_this_round = 0;
    // this.conflicting_states = [];
    // this.resolutions = [];
    // this.options = options;
    // this.parseParams = grammar.parseParams;
    // exportDest.parseTable = this.table;
    // exportDest.defaultParseActions = this.defaultActions;
    // exportDest.parseProductions = this.productions_;

    // TODO: the next bit of code is LR type specific: refactor into a
    //       LR specific mixin class later on, so that we can have another
    //       implementation/report for LL and PEG type grammars.

    var rows = 0,
        cols = 0;
    var colmarks = {};
    var i, j, len;

    for (i = 0, len = this.table.length; i < len; i++) {
        rows++;
        for (j in this.table[i]) {
            if (!colmarks[j]) {
                colmarks[j] = true;
                cols++;
            }
        }
    }
    var defrows = 0;
    var rowmarks = {};
    for (j in this.defaultActions) {
        if (!rowmarks[j]) {
            rowmarks[j] = true;
            defrows++;
        }
    }

    var ntc = 0;
    for (var nt in this.nonterminals) {
        ntc++;
    }

    if (devDebug > 3) Jison.print('LALR parse table: ', {
        table: this.table,
        defaultActions: this.defaultActions
    });

    this.warn('Number of productions in parser:........ ' + this.productions_.length);
    this.warn('Number of non-terminals in grammar:..... ' + ntc);
    this.warn('Number of states:....................... ' + this.states.size());
    this.warn('Number of rows (states) in table:....... ' + this.table.length);
    this.warn('Number of rows in table:................ ' + rows);
    this.warn('Number of columns in table:............. ' + cols);
    this.warn('Number of defaulted rows in table:...... ' + defrows);
    this.warn('Number of unresolvable conflicts:....... ' + this.conflicts);
    this.warn('\n');
};

// Generator debug mixin

var generatorDebug = {
    trace: function debug_trace() {
        if (typeof Jison !== 'undefined' && Jison.print) {
            Jison.print.apply(null, arguments);
        } else if (typeof print !== 'undefined') {
            print.apply(null, arguments);
        } else if (typeof console !== 'undefined' && console.log) {
            var args = Array.prototype.slice.call(arguments, 0);
            args.unshift(''); // prevent `%.` printf-style expansions; see https://nodejs.org/api/console.html#console_console_log_data_args
            console.log.apply(null, args);
        }
    },
    beforeprocessGrammar: function beforeprocessGrammar() {
        this.trace('Processing grammar.');
    },
    afteraugmentGrammar: function afteraugmentGrammar() {
        var trace = this.trace;
        trace('\nSymbols:\n');
        each(this.symbols, function (sym, i) {
            trace(sym + '(' + i + ')');
        });
        trace('\n');
    }
};

/*
 * Mixin for common behaviors of lookahead parsers
 */
var lookaheadMixin = {};

lookaheadMixin.computeLookaheads = function computeLookaheads() {
    if (this.DEBUG) {
        this.mix(lookaheadDebug); // mixin debug methods
    }

    this.computeLookaheads = function () {};
    this.nullableSets();
    this.firstSets();
    this.followSets();
};

lookaheadMixin.displayFollowSets = function displayFollowSets() {
    var self = this;
    var symfollowdbg = {};
    this.productions.forEach(function Follow_prod_forEach_debugOut(production, k) {
        var key = ['prod-', k, ':  ', production.symbol, ' := ', production.handle.join(' ')].join('');
        var flw = '[' + self.nonterminals[production.symbol].follows.join(']  [') + ']';
        if (!symfollowdbg[flw]) {
            symfollowdbg[flw] = {};
        }
        if (!symfollowdbg[flw][key]) {
            symfollowdbg[flw][key] = 1;
        } else {
            assert(0);
            symfollowdbg[flw][key]++;
        }
    });
    for (var l in symfollowdbg) {
        var lst = [];
        for (var k in symfollowdbg[l]) {
            lst.push(k);
        }
        self.trace('Symbol/Follows:\n   ', lst.join('\n    '), ' -->\n        ', l);
    }
};

// calculate follow sets based on first and nullable
lookaheadMixin.followSets = function followSets() {
    var productions = this.productions,
        nonterminals = this.nonterminals,
        self = this,
        cont = true,
        count = 0;

    // loop until no further changes have been made
    while (cont) {
        cont = false;
        count++;

        productions.forEach(function Follow_prod_forEach(production, k) {
            if (devDebug > 3) Jison.print('Symbol/Follows: ', 'round:' + count, 'prod:' + k, ':', production.symbol, ' --> ', nonterminals[production.symbol].follows.join(', '));

            // q is used in Simple LALR algorithm determine follows in context
            var q;
            var ctx = !!self.go_;

            for (var i = 0, t; t = production.handle[i]; ++i) {
                if (!nonterminals[t]) continue;

                // for Simple LALR algorithm, self.go_ checks if
                if (ctx) {
                    q = self.go_(production.symbol, production.handle.slice(0, i));
                }
                var bool = !ctx || q === self.nterms_[t];
                var set;

                if (i === production.handle.length - 1 && bool) {
                    set = nonterminals[production.symbol].follows;
                } else {
                    var part = production.handle.slice(i + 1);

                    set = self.first(part);
                    if (self.nullable(part) && bool) {
                        assert(nonterminals[production.symbol].follows);
                        set.push.apply(set, nonterminals[production.symbol].follows);
                    }
                }
                var follows = nonterminals[t].follows;
                var oldcount = follows.length;
                follows = union(follows, set);
                if (oldcount !== follows.length) {
                    cont = true;
                }
                nonterminals[t].follows = follows;
            }
        });
    }

    if (devDebug || this.DEBUG) {
        this.displayFollowSets();
    }
};

// return the FIRST set of a symbol or series of symbols
lookaheadMixin.first = function first(symbol) {
    // epsilon
    if (symbol === '') {
        return [];
        // RHS
    } else if (symbol instanceof Array) {
        var firsts = [];
        for (var i = 0, t; t = symbol[i]; ++i) {
            if (!this.nonterminals[t]) {
                if (firsts.indexOf(t) === -1) {
                    firsts.push(t);
                }
            } else {
                firsts = union(firsts, this.nonterminals[t].first);
            }
            if (!this.nullable(t)) break;
        }
        return firsts;
        // terminal
    } else if (!this.nonterminals[symbol]) {
        return [symbol];
        // nonterminal
    } else {
        return this.nonterminals[symbol].first;
    }
};

// fixed-point calculation of FIRST sets
lookaheadMixin.firstSets = function firstSets() {
    var productions = this.productions,
        nonterminals = this.nonterminals,
        self = this,
        cont = true,
        symbol,
        firsts;

    // loop until no further changes have been made
    while (cont) {
        cont = false;

        productions.forEach(function FirstSets_forEach(production, k) {
            var firsts = self.first(production.handle);
            if (firsts.length !== production.first.length) {
                production.first = firsts;
                cont = true;
            }
        });

        for (symbol in nonterminals) {
            firsts = [];
            nonterminals[symbol].productions.forEach(function FirstSets_forEachNonTerm(production) {
                firsts = union(firsts, production.first);
            });
            if (firsts.length !== nonterminals[symbol].first.length) {
                nonterminals[symbol].first = firsts;
                cont = true;
            }
        }
    }
};

// fixed-point calculation of NULLABLE
lookaheadMixin.nullableSets = function nullableSets() {
    var nonterminals = this.nonterminals,
        self = this,
        cont = true;

    // loop until no further changes have been made
    while (cont) {
        cont = false;

        // check if each production is nullable
        this.productions.forEach(function isEachProductionNullable(production, k) {
            if (!production.nullable) {
                for (var i = 0, n = 0, t; t = production.handle[i]; ++i) {
                    if (self.nullable(t)) n++;
                }
                if (n === i) {
                    // production is nullable if all tokens are nullable
                    production.nullable = cont = true;
                }
            }
        });

        // check if each symbol is nullable
        for (var symbol in nonterminals) {
            if (!this.nullable(symbol)) {
                for (var i = 0, production; production = nonterminals[symbol].productions.item(i); i++) {
                    if (production.nullable) {
                        nonterminals[symbol].nullable = cont = true;
                    }
                }
            }
        }
    }
};

// check if a token or series of tokens is nullable
lookaheadMixin.nullable = function nullable(symbol) {
    // epsilon
    if (symbol === '') {
        return true;
        // RHS
    } else if (symbol instanceof Array) {
        for (var i = 0, t; t = symbol[i]; ++i) {
            if (!this.nullable(t)) {
                return false;
            }
        }
        return true;
        // terminal
    } else if (!this.nonterminals[symbol]) {
        return false;
        // nonterminal
    } else {
        return this.nonterminals[symbol].nullable;
    }
};

// lookahead debug mixin
var lookaheadDebug = {
    beforenullableSets: function beforenullableSets() {
        this.trace('Computing Nullable sets.');
    },
    beforefirstSets: function beforefirstSets() {
        this.trace('Computing First sets.');
    },
    beforefollowSets: function beforefollowSets() {
        this.trace('Computing Follow sets.');
    },
    afterfollowSets: function afterfollowSets() {
        var trace = this.trace;
        trace('\nNonterminals:\n');
        each(this.nonterminals, function (nt, t) {
            trace(nt.toString(), '\n');
        });
        trace('\n');
    }
};

/*
 * Mixin for common LR parser behavior
 */
var lrGeneratorMixin = {};

// LR state machine actions:
var NONASSOC = 0;
var SHIFT = 1; // shift
var REDUCE = 2; // reduce
var ACCEPT = 3; // accept


lrGeneratorMixin.buildTable = function buildTable() {
    if (this.DEBUG) {
        this.mix(lrGeneratorDebug); // mixin debug methods
    }

    this.states = this.canonicalCollection();

    if (devDebug || this.DEBUG) {
        Jison.print('\n-------------------------------------------\nSymbol/Follow sets AFTER canonicalCollection:');
        this.displayFollowSets();
        Jison.print('\n');
    }

    this.table = this.parseTable(this.states);

    if (devDebug || this.DEBUG) {
        Jison.print('\n-------------------------------------------\nSymbol/Follow sets AFTER parseTable:');
        this.displayFollowSets();
        Jison.print('\n');
    }

    this.defaultActions = findDefaults(this.table, this.hasErrorRecovery);
    cleanupTable(this.table);

    traceStates(this.trace, this.states, 'at the end of LR::buildTable(), after cleanupTable()');
};

lrGeneratorMixin.Item = typal.construct({
    constructor: function Item(production, dotPosition, followSet, predecessor) {
        this.production = production;
        this.dotPosition = dotPosition || 0;
        this.follows = followSet || [];
        this.predecessor = predecessor;
        this.id = production.id + '#' + this.dotPosition;
        this.markedSymbol = this.production.handle[this.dotPosition];
    },
    remainingHandle: function remainingHandle() {
        return this.production.handle.slice(this.dotPosition + 1);
    },
    eq: function eq(e) {
        return e.id === this.id;
    },
    handleToString: function handleToString() {
        var handle = this.production.handle.slice(0);
        handle[this.dotPosition] = '.' + (handle[this.dotPosition] || '');
        return handle.join(' ');
    },
    toString: function toString() {
        var temp = this.production.handle.slice(0);
        temp[this.dotPosition] = '.' + (temp[this.dotPosition] || '');
        var s = this.production.symbol + ' -> ' + temp.join(' ');
        var padlen = Math.max(4, 40 - s.length);
        var pad = new Array(padlen);
        if (this.follows.length) {
            s += pad.join(' ') + '#lookaheads= [' + this.follows.join(']  [') + ']';
            pad = new Array(2);
        }
        if (this.reductions && this.reductions.length) {
            s += pad.join(' ') + '#reductions= [' + this.reductions.join(']  [') + ']';
            pad = new Array(2);
        }
        return s;
    }
});

lrGeneratorMixin.ItemSet = Set.prototype.construct({
    afterconstructor: function afterconstructor() {
        this.reductions = [];
        this.goes = {};
        this.edges = {};
        this.shifts = false;
        this.inadequate = false;
        this.hash_ = {};
        for (var i = this._items.length - 1; i >= 0; i--) {
            this.hash_[this._items[i].id] = true; //i;
        }
    },
    concat: function concat(set) {
        var a = set._items || set;
        for (var i = a.length - 1; i >= 0; i--) {
            this.hash_[a[i].id] = true;
        }
        this._items.push.apply(this._items, a);
        return this;
    },
    push: function push(item) {
        this.hash_[item.id] = true;
        return this._items.push(item);
    },
    contains: function contains(item) {
        return this.hash_[item.id];
    },
    valueOf: function toValue() {
        var v = this._items.map(function (a) {
            return a.id;
        }).sort().join('|');
        this.valueOf = function valueOf_inner() {
            return v;
        };
        return v;
    }
});

lrGeneratorMixin.closureOperation = function closureOperation(itemSet) {
    var closureSet = new this.ItemSet();
    var self = this;

    var set = itemSet,
        itemQueue,
        syms = {};

    do {
        itemQueue = new Set();
        closureSet = closureSet.concat(set);
        set.forEach(function CO_set_forEach(item) {
            var symbol = item.markedSymbol;

            // if token is a non-terminal, recursively add closures
            if (symbol && self.nonterminals[symbol]) {
                if (!syms[symbol]) {
                    self.nonterminals[symbol].productions.forEach(function CO_nt_forEach(production) {
                        var newItem = new self.Item(production, 0);
                        if (!closureSet.contains(newItem)) {
                            itemQueue.push(newItem);
                        }
                    });
                    syms[symbol] = true;
                }
            } else if (!symbol) {
                // reduction
                closureSet.reductions.push(item);
                closureSet.inadequate = closureSet.reductions.length > 1 || closureSet.shifts;
            } else {
                // shift
                closureSet.shifts = true;
                closureSet.inadequate = closureSet.reductions.length > 0;
            }
        });

        set = itemQueue;
    } while (!itemQueue.isEmpty());

    return closureSet;
};

lrGeneratorMixin.gotoOperation = function gotoOperation(itemSet, symbol) {
    var gotoSet = new this.ItemSet(),
        self = this;

    itemSet.forEach(function goto_forEach(item, n) {
        if (item.markedSymbol === symbol) {
            gotoSet.push(new self.Item(item.production, item.dotPosition + 1, item.follows, n));
        }
    });

    return gotoSet;
};

/*
 * Create unique set of item sets
 */
lrGeneratorMixin.canonicalCollection = function canonicalCollection() {
    var item1 = new this.Item(this.productions[0], 0, [this.EOF]);
    var firstStateNoClosure = new this.ItemSet(item1),
        firstState = this.closureOperation(firstStateNoClosure),
        states = new Set(firstState),
        marked = 0,
        self = this,
        itemSet,
        markedSymbols;

    states.has = {};
    states.has[firstStateNoClosure.valueOf()] = 0;

    if (devDebug > 0) Jison.print('canonicalCollection: ', states.has);

    while (marked !== states.size()) {
        itemSet = states.item(marked);
        markedSymbols = {};
        itemSet.forEach(function CC_itemSet_forEach(item) {
            if (item.markedSymbol && !markedSymbols[item.markedSymbol] && item.markedSymbol !== self.EOF) {
                markedSymbols[item.markedSymbol] = true;
                self.canonicalCollectionInsert(item.markedSymbol, itemSet, states, marked);
            }
        });
        marked++;
    }

    return states;
};

// Pushes a unique state into the queue. Some parsing algorithms may perform additional operations
lrGeneratorMixin.canonicalCollectionInsert = function canonicalCollectionInsert(symbol, itemSet, states, stateNum) {
    var g = this.gotoOperation(itemSet, symbol),
        state = states.has[g.valueOf()];

    if (typeof state !== 'undefined') {
        itemSet.edges[symbol] = state; // store goto transition for table
        states.item(state).predecessors[symbol].push(stateNum);
    } else {
        // add g to queue if not empty or duplicate
        if (!g.isEmpty()) {
            states.has[g.valueOf()] = states.size();
            g = this.closureOperation(g);
            if (!g.predecessors) {
                g.predecessors = {};
            }
            itemSet.edges[symbol] = states.size(); // store goto transition for table
            states.push(g);
            g.predecessors[symbol] = [stateNum];
        }
    }
};

lrGeneratorMixin.parseTable = function lrParseTable(itemSets) {
    var states = [],
        nonterminals = this.nonterminals,
        operators = this.operators,
        conflictedStates = {},
        // set of [state, token] tuples
    self = this;

    // for each item set
    itemSets.forEach(function parseTableItem(itemSet, k) {
        k = +k;
        var state = states[k] = {};
        var action, stackSymbol;

        // set shift and goto actions
        for (stackSymbol in itemSet.edges) {
            itemSet.forEach(function findShiftAndGotoActions(item, j) {
                // find shift and goto actions
                if (item.markedSymbol === stackSymbol) {
                    var gotoState = itemSet.edges[stackSymbol];
                    assert(gotoState);
                    if (nonterminals[stackSymbol]) {
                        // store state to go to after a reduce
                        state[self.symbols_[stackSymbol]] = gotoState;
                    } else {
                        state[self.symbols_[stackSymbol]] = [SHIFT, gotoState];
                    }
                }
            });
        }

        // set accept action
        itemSet.forEach(function setAcceptAction(item, j) {
            if (item.markedSymbol === self.EOF) {
                // accept
                state[self.symbols_[self.EOF]] = [ACCEPT];
            }
        });

        var allterms = self.lookAheads ? false : self.terminals;

        // set reductions and resolve potential conflicts
        itemSet.reductions.forEach(function calcReduction(item, j) {
            // if parser uses lookahead, only enumerate those terminals
            var terminals = allterms || self.lookAheads(itemSet, item);

            terminals.forEach(function (stackSymbol) {
                action = state[self.symbols_[stackSymbol]];
                var op = operators[stackSymbol];

                // Reading a terminal and current position is at the end of a production, try to reduce
                if (action) {
                    var sol = resolveConflict(item.production, op, [REDUCE, item.production.id], action[0] instanceof Array ? action[0] : action);
                    self.resolutions.push([k, stackSymbol, sol]);
                    if (sol.bydefault) {
                        self.conflicts++;

                        if (self.conflict_fixing_round && self.options.hasPartialLrUpgradeOnConflict) {
                            // have we encountered a *new* conflict, compared to previous rounds?
                            if (!self.conflict_productions_LU[item.production.id]) {
                                self.new_conflicts_found_this_round++;
                                // and we RESET the `conflict_fixing_round` flag to signal that
                                // this round needs another one to attempt a *complete* fix
                                // of the grammar.
                                //
                                // This little act also conveniently helps to manage the
                                // *finity* of the big parsetable production loop, which
                                // wraps around all this work (and more).
                                self.conflict_fixing_round = false;
                                if (self.enableDebugLogs) {
                                    self.warn('RESET conflict fixing: we need another round to see us through...');
                                }
                            }
                        }
                        if (!self.conflict_fixing_round && self.options.hasPartialLrUpgradeOnConflict) {
                            self.conflict_productions_LU[item.production.id] = true;
                            self.conflict_states_LU[k] = true;

                            if (devDebug > 4) Jison.print('Registering conflict: ', {
                                prod_id: item.production.id,
                                stateNum: k,
                                state: state,
                                production: item.production
                            });
                        }

                        if (self.enableDebugLogs) {
                            self.warn('Conflict in grammar: multiple actions possible when lookahead token is ', stackSymbol, ' in state ', k, '\n- ', printAction(sol.r, self), '\n- ', printAction(sol.s, self), '\n  (', sol.msg, ')');
                        }
                        conflictedStates[k] = {
                            reduction: item,
                            symbol: stackSymbol,
                            resolution: sol,
                            state: k
                        };

                        if (self.options.noDefaultResolve) {
                            if (!(action[0] instanceof Array)) {
                                action = [action];
                            }
                            action.push(sol.r);
                        }
                    } else {
                        action = sol.action;
                    }
                } else {
                    action = [REDUCE, item.production.id];
                }
                if (action && action.length) {
                    state[self.symbols_[stackSymbol]] = action;
                } else if (action === NONASSOC) {
                    state[self.symbols_[stackSymbol]] = NONASSOC;
                    // ^- Can't delete this node right away as it will influence
                    // `findDefaults()` decision-making process adversely when this state is
                    // not visible at that time. Hence we defer cleanup to the function
                    // `cleanupTable()` which will be invoked at the very end: the NONASSOC
                    // transition signals a transition into an ERROR state and we don't care
                    // for the explicit zero(0) to be present in our table as anything
                    // 'falsey' as an action code will be considered an error state in
                    // the parser and not having these zeroes around keeps the table small(er).
                }
            });
        });
    });

    self.conflicting_states = conflictedStates;

    if (self.conflicts > 0) {
        if (this.numExpectedConflictStates !== self.conflicts || self.enableDebugLogs) {
            self.warn('\nStates with conflicts:');
            each(conflictedStates, function report_conflict_state(val, state) {
                self.warn('\nState ' + state, '    (' + val.symbol + ' @ ' + val.reduction.production.symbol + ' -> ' + val.reduction.handleToString() + ')\n');
                self.warn('  ', itemSets.item(state).join('\n  '));
            });
            self.warn('\n');
        }
    }

    return states;
};

// find states with only one action: a reduction.
//
// Note: only the state columns for EOF/ERROR/terminals are relevant here as those
// columns are the only ones ever visited by the table lookup code at the top
// of the loop in the parse kernel as the `symbol` index used there cannot ever
// contain a *nonterminal* value!
//
// The nonterminals are recognizable in the table by having numeric entries, rather
// than 1-or-2-element array values, as they only store a GOTO state.
//
// ---
//
// Another 'default' is when all listed terminals all point to the exact same reduce state;
// only this time we are careful about the TERROR symbol as a state carrying that one
// is an explicitly encoded error recovery rule and should remain as-is.
function findDefaults(states, hasErrorRecovery) {
    var defaults = {};
    states.forEach(function (state, k) {
        var act, sym, st;
        var i = 0;
        var gotos = {};

        for (sym in state) {
            assert({}.hasOwnProperty.call(state, sym)); // it this isn't true, the last part of this function won't work!
            // keep state rows where there's an error recovery state:
            if (sym === 2 /* TERROR */) {
                    return;
                }
            st = state[sym];
            if (typeof st !== 'number') {
                if (st[0] !== REDUCE) {
                    // not a reduce action: forget about this row!
                    return;
                }
                var go = st[1];
                if (!gotos[go]) {
                    gotos[go] = true;
                    i++;
                    act = sym;
                }
            } else if (st === NONASSOC) {
                // forget about this row: it's a state where we should kick up an error
                // because you're trying to get associativity going where there is none!
                return;
            }
        }

        if (i === 1) {
            // only one action in state and it's a reduction; hence we only need to store the new (goto production) state:
            defaults[k] = state[act][1];

            // ... and nuke the entry/entries in the parse table to save space in the generated output: we won't be needing
            // it any more! But make sure we keep the slots for the nonterminal symbols, so only nuke the *terminal* entries!
            //
            // Aber Oh-ho! The table[] entries themselves *are* used: they are needed by
            // the error recovery code to decide, when SHIFTING, if the ERROR token would
            // improve (fix) matters when it is treated as an *inserted* token.  This code
            // is therefor not executed then!
            //
            // ... hence we only nuke these table entries (as that makes for a smaller table --> smaller parser file)
            // when there's no error recovery code included in the generated parser:
            if (!hasErrorRecovery) {
                for (sym in state) {
                    st = state[sym];
                    if (typeof st !== 'number') {
                        delete state[sym];
                    }
                }
            }
        }
    });

    return defaults;
}

// Remove all NONASSOC state transitions from the generated table now that we don't need them any longer
function cleanupTable(table) {
    table.forEach(function (state, k) {
        var symbol;

        for (symbol in state) {
            if (state[symbol] === NONASSOC) {
                delete state[symbol];
            }
        }
    });
}

// resolves shift-reduce and reduce-reduce conflicts
function resolveConflict(production, op, reduce, shift) {
    var sln = {
        production: production,
        operator: op,
        r: reduce,
        s: shift,

        msg: null,
        action: null,
        bydefault: false
    };

    if (shift[0] === REDUCE) {
        sln.msg = 'Resolved R/R conflict: use first production declared in grammar.';
        sln.action = shift[1] < reduce[1] ? shift : reduce;
        if (shift[1] !== reduce[1]) sln.bydefault = true;
        return sln;
    }

    if (production.precedence === 0 || !op) {
        sln.msg = 'Resolved S/R conflict: shift by default.';
        sln.bydefault = true;
        sln.action = shift;
    } else if (production.precedence < op.precedence) {
        sln.msg = 'Resolved S/R conflict: shift for higher precedent operator.';
        sln.action = shift;
    } else if (production.precedence === op.precedence) {
        if (op.assoc === 'right') {
            sln.msg = 'Resolved S/R conflict: shift for right associative operator.';
            sln.action = shift;
        } else if (op.assoc === 'left') {
            sln.msg = 'Resolved S/R conflict: reduce for left associative operator.';
            sln.action = reduce;
        } else if (op.assoc === 'nonassoc') {
            sln.msg = 'Resolved S/R conflict: no action for non-associative operator.';
            sln.action = NONASSOC;
        }
    } else {
        sln.msg = 'Resolved conflict: reduce for higher precedent production.';
        sln.action = reduce;
    }

    return sln;
}

/*
 * Mixin for common LR/LL/*any* parser behavior
 */
var generatorMixin = {};

// internal helper function:
generatorMixin.__prepareOptions = function parser___prepare_Options(opt) {
    opt = mkStdOptions(this.options, opt);

    prepExportStructures(opt);

    this.options = opt;
    this.DEBUG = !!opt.debug;
    if (devDebug > 3) {
        Jison.print('GENERATE::OPTIONS:\n', this.options);
    }

    // check for illegal identifier
    if (!opt.moduleName || !opt.moduleName.match(/^[a-zA-Z_$][a-zA-Z0-9_$\.]*?[a-zA-Z0-9_$]$/)) {
        if (opt.moduleName) {
            var msg = 'WARNING: The specified moduleName "' + opt.moduleName + '" is illegal (only characters [a-zA-Z0-9_$] and "." dot are accepted); using the default moduleName "parser" instead.';
            if (typeof opt.warn_cb === 'function') {
                opt.warn_cb(msg);
            } else if (opt.warn_cb) {
                Jison.print(msg);
            } else {
                // do not treat as warning; barf hairball instead so that this oddity gets noticed right away!
                throw new Error(msg);
            }
        }
        opt.moduleName = opt.defaultModuleName;
    }
    return opt;
};

generatorMixin.generateGenericHeaderComment = function generateGenericHeaderComment() {
    var out = '\n/* parser generated by jison ' + version + ' */\n\n/*\n * Returns a Parser object of the following structure:\n *\n *  Parser: {\n *    yy: {}     The so-called "shared state" or rather the *source* of it;\n *               the real "shared state" `yy` passed around to\n *               the rule actions, etc. is a derivative/copy of this one,\n *               not a direct reference!\n *  }\n *\n *  Parser.prototype: {\n *    yy: {},\n *    EOF: 1,\n *    TERROR: 2,\n *\n *    trace: function(errorMessage, ...),\n *\n *    JisonParserError: function(msg, hash),\n *\n *    quoteName: function(name),\n *               Helper function which can be overridden by user code later on: put suitable\n *               quotes around literal IDs in a description string.\n *\n *    originalQuoteName: function(name),\n *               The basic quoteName handler provided by JISON.\n *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function\n *               at the end of the `parse()`.\n *\n *    describeSymbol: function(symbol),\n *               Return a more-or-less human-readable description of the given symbol, when\n *               available, or the symbol itself, serving as its own \'description\' for lack\n *               of something better to serve up.\n *\n *               Return NULL when the symbol is unknown to the parser.\n *\n *    symbols_: {associative list: name ==> number},\n *    terminals_: {associative list: number ==> name},\n *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},\n *    terminal_descriptions_: (if there are any) {associative list: number ==> description},\n *    productions_: [...],\n *\n *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),\n *\n *               The function parameters and `this` have the following value/meaning:\n *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)\n *                             to store/reference the rule value `$$` and location info `@$`.\n *\n *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets\n *                 to see the same object via the `this` reference, i.e. if you wish to carry custom\n *                 data from one reduce action through to the next within a single parse run, then you\n *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.\n *\n *                 `this.yy` is a direct reference to the `yy` shared state object.\n *\n *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`\n *                 object at `parse()` start and are therefore available to the action code via the\n *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from\n *                 the %parse-param` list.\n *\n *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used\n *                             to match this rule. This is *not* the look-ahead token, but the last token\n *                             that\'s actually part of this rule.\n *\n *                 Formulated another way, `yytext` is the value of the token immediately preceeding\n *                 the current look-ahead token.\n *                 Caveats apply for rules which don\'t require look-ahead, such as epsilon rules.\n *\n *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.\n *\n *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.\n *\n *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.\n *\n *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead\n *                               of an empty object when no suitable location info can be provided.\n *\n *               - `yystate` : the current parser state number, used internally for dispatching and\n *                               executing the action code chunk matching the rule currently being reduced.\n *\n *               - `yysp`    : the current state stack position (a.k.a. \'stack pointer\')\n *\n *                 This one comes in handy when you are going to do advanced things to the parser\n *                 stacks, all of which are accessible from your action code (see the next entries below).\n *\n *                 Also note that you can access this and other stack index values using the new double-hash\n *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things\n *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.\n *                 This is made available to write very advanced grammar action rules, e.g. when you want\n *                 to investigate the parse state stack in your action code, which would, for example,\n *                 be relevant when you wish to implement error diagnostics and reporting schemes similar\n *                 to the work described here:\n *\n *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.\n *                   In Journ\xE9es Francophones des Languages Applicatifs.\n *\n *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.\n *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631\u2013640.\n *\n *               - `yyrulelength`: the current rule\'s term count, i.e. the number of entries occupied on the stack.\n *\n *                 This one comes in handy when you are going to do advanced things to the parser\n *                 stacks, all of which are accessible from your action code (see the next entries below).\n *\n *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.\n *                             constructs.\n *\n *               - `yylstack`: reference to the parser token location stack. Also accessed via\n *                             the `@1` etc. constructs.\n *\n *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are\n *                             UNDEFINED rather than an empty (location) object, when the lexer/parser\n *                             action code did not provide a suitable location info object when such a\n *                             slot was filled!\n *\n *               - `yystack` : reference to the parser token id stack. Also accessed via the\n *                             `#1` etc. constructs.\n *\n *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to\n *                 its numeric token id value, hence that code wouldn\'t need the `yystack` but *you* might\n *                 want access this array for your own purposes, such as error analysis as mentioned above!\n *\n *                 Note that this stack stores the current stack of *tokens*, that is the sequence of\n *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*\n *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and\n *                 *reduced*.\n *\n *               - `yysstack`: reference to the parser state stack. This one carries the internal parser\n *                             *states* such as the one in `yystate`, which are used to represent\n *                             the parser state machine in the *parse table*. *Very* *internal* stuff,\n *                             what can I say? If you access this one, you\'re clearly doing wicked things\n *\n *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your\n *                             grammar definition file.\n *\n *    table: [...],\n *               State transition table\n *               ----------------------\n *\n *               index levels are:\n *               - `state`  --> hash table\n *               - `symbol` --> action (number or array)\n *\n *                 If the `action` is an array, these are the elements\' meaning:\n *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept\n *                 - index [1]: GOTO `state`\n *\n *                 If the `action` is a number, it is the GOTO `state`\n *\n *    defaultActions: {...},\n *\n *    parseError: function(str, hash, ExceptionClass),\n *    yyError: function(str, ...),\n *    yyRecovering: function(),\n *    yyErrOk: function(),\n *    yyClearIn: function(),\n *\n *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               Produces a new errorInfo \'hash object\' which can be passed into `parseError()`.\n *               See it\'s use in this parser kernel in many places; example usage:\n *\n *                   var infoObj = parser.constructParseErrorInfo(\'fail!\', null,\n *                                     parser.collect_expected_token_set(state), true);\n *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);\n *\n *    originalParseError: function(str, hash, ExceptionClass),\n *               The basic `parseError` handler provided by JISON.\n *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function\n *               at the end of the `parse()`.\n *\n *    options: { ... parser %options ... },\n *\n *    parse: function(input[, args...]),\n *               Parse the given `input` and return the parsed value (or `true` when none was provided by\n *               the root action, in which case the parser is acting as a *matcher*).\n *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:\n *               these extra `args...` are added verbatim to the `yy` object reference as member variables.\n *\n *               WARNING:\n *               Parser\'s additional `args...` parameters (via `%parse-param`) MAY conflict with\n *               any attributes already added to `yy` by the jison run-time;\n *               when such a collision is detected an exception is thrown to prevent the generated run-time\n *               from silently accepting this confusing and potentially hazardous situation!\n *\n *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in\n *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state\n *               object and any collision with those will be reported by the lexer via a thrown exception.\n *\n *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown\n *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY\n *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and\n *               the internal parser gets properly garbage collected under these particular circumstances.\n *\n *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\n *               This helper API can be invoked to calculate a spanning `yylloc` location info object.\n *\n *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case\n *               this function will attempt to obtain a suitable location marker by inspecting the location stack\n *               backwards.\n *\n *               For more info see the documentation comment further below, immediately above this function\'s\n *               implementation.\n *\n *    lexer: {\n *        yy: {...},           A reference to the so-called "shared state" `yy` once\n *                             received via a call to the `.setInput(input, yy)` lexer API.\n *        EOF: 1,\n *        ERROR: 2,\n *        JisonLexerError: function(msg, hash),\n *        parseError: function(str, hash, ExceptionClass),\n *        setInput: function(input, [yy]),\n *        input: function(),\n *        unput: function(str),\n *        more: function(),\n *        reject: function(),\n *        less: function(n),\n *        pastInput: function(n),\n *        upcomingInput: function(n),\n *        showPosition: function(),\n *        test_match: function(regex_match_array, rule_index, ...),\n *        next: function(...),\n *        lex: function(...),\n *        begin: function(condition),\n *        pushState: function(condition),\n *        popState: function(),\n *        topState: function(),\n *        _currentRules: function(),\n *        stateStackSize: function(),\n *        cleanupAfterLex: function()\n *\n *        options: { ... lexer %options ... },\n *\n *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),\n *        rules: [...],\n *        conditions: {associative list: name ==> set},\n *    }\n *  }\n *\n *\n *  token location info (@$, _$, etc.): {\n *    first_line: n,\n *    last_line: n,\n *    first_column: n,\n *    last_column: n,\n *    range: [start_number, end_number]\n *               (where the numbers are indexes into the input string, zero-based)\n *  }\n *\n * ---\n *\n * The `parseError` function receives a \'hash\' object with these members for lexer and\n * parser errors:\n *\n *  {\n *    text:        (matched text)\n *    token:       (the produced terminal token, if any)\n *    token_id:    (the produced terminal token numeric ID, if any)\n *    line:        (yylineno)\n *    loc:         (yylloc)\n *  }\n *\n * parser (grammar) errors will also provide these additional members:\n *\n *  {\n *    expected:    (array describing the set of expected tokens;\n *                  may be UNDEFINED when we cannot easily produce such a set)\n *    state:       (integer (or array when the table includes grammar collisions);\n *                  represents the current internal state of the parser kernel.\n *                  can, for example, be used to pass to the `collect_expected_token_set()`\n *                  API to obtain the expected token set)\n *    action:      (integer; represents the current internal action which will be executed)\n *    new_state:   (integer; represents the next/planned internal state, once the current\n *                  action has executed)\n *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule\n *                  available for this particular error)\n *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    yy:          (object: the current parser internal "shared state" `yy`\n *                  as is also available in the rule actions; this can be used,\n *                  for instance, for advanced error analysis and reporting)\n *    lexer:       (reference to the current lexer instance used by the parser)\n *    parser:      (reference to the current parser instance)\n *  }\n *\n * while `this` will reference the current parser instance.\n *\n * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*\n * instance, while these additional `hash` fields will also be provided:\n *\n *  {\n *    lexer:       (reference to the current lexer instance which reported the error)\n *  }\n *\n * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired\n * from either the parser or lexer, `this` will still reference the related *parser*\n * instance, while these additional `hash` fields will also be provided:\n *\n *  {\n *    exception:   (reference to the exception thrown)\n *  }\n *\n * Please do note that in the latter situation, the `expected` field will be omitted as\n * this type of failure is assumed not to be due to *parse errors* but rather due to user\n * action code in either parser or lexer failing unexpectedly.\n *\n * ---\n *\n * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.\n * These options are available:\n *\n * ### options which are global for all parser instances\n *\n *  Parser.pre_parse: function(yy)\n *                 optional: you can specify a pre_parse() function in the chunk following\n *                 the grammar, i.e. after the last `%%`.\n *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }\n *                 optional: you can specify a post_parse() function in the chunk following\n *                 the grammar, i.e. after the last `%%`. When it does not return any value,\n *                 the parser will return the original `retval`.\n *\n * ### options which can be set up per parser instance\n *\n *  yy: {\n *      pre_parse:  function(yy)\n *                 optional: is invoked before the parse cycle starts (and before the first\n *                 invocation of `lex()`) but immediately after the invocation of\n *                 `parser.pre_parse()`).\n *      post_parse: function(yy, retval, parseInfo) { return retval; }\n *                 optional: is invoked when the parse terminates due to success (\'accept\')\n *                 or failure (even when exceptions are thrown).\n *                 `retval` contains the return value to be produced by `Parser.parse()`;\n *                 this function can override the return value by returning another.\n *                 When it does not return any value, the parser will return the original\n *                 `retval`.\n *                 This function is invoked immediately before `parser.post_parse()`.\n *\n *      parseError: function(str, hash, ExceptionClass)\n *                 optional: overrides the default `parseError` function.\n *      quoteName: function(name),\n *                 optional: overrides the default `quoteName` function.\n *  }\n *\n *  parser.lexer.options: {\n *      pre_lex:  function()\n *                 optional: is invoked before the lexer is invoked to produce another token.\n *                 `this` refers to the Lexer object.\n *      post_lex: function(token) { return token; }\n *                 optional: is invoked when the lexer has produced a token `token`;\n *                 this function can override the returned token value by returning another.\n *                 When it does not return any (truthy) value, the lexer will return\n *                 the original `token`.\n *                 `this` refers to the Lexer object.\n *\n *      ranges: boolean\n *                 optional: `true` ==> token location info will include a .range[] member.\n *      flex: boolean\n *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested\n *                 exhaustively to find the longest match.\n *      backtrack_lexer: boolean\n *                 optional: `true` ==> lexer regexes are tested in order and for invoked;\n *                 the lexer terminates the scan when a token is returned by the action code.\n *      xregexp: boolean\n *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the\n *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer\n *                 rule regexes have been written as standard JavaScript RegExp expressions.\n *  }\n */\n';

    return out;
};

generatorMixin.generate = function parser_generate(opt) {
    opt = this.__prepareOptions(opt);

    var code = '';

    switch (opt.moduleType) {
        case 'js':
            code = this.generateModule(opt);
            break;
        case 'amd':
            code = this.generateAMDModule(opt);
            break;
        case 'es':
            code = this.generateESModule(opt);
            break;
        case 'commonjs':
            code = this.generateCommonJSModule(opt);
            break;
        default:
            throw new Error('unsupported moduleType: ' + opt.moduleType);
    }

    return code;
};

generatorMixin.generateAMDModule = function generateAMDModule(opt) {
    opt = this.__prepareOptions(opt);

    var module = this.generateModule_();
    var out = [this.generateGenericHeaderComment(), '', 'define(function (require) {', module.initCode, module.commonCode, '', 'var parser = ' + module.moduleCode, module.modulePostlude];
    if (this.lexer && this.lexer.generateModule) {
        var lexSrc = this.lexer.generateModule();
        opt.exportSourceCode.lexer = lexSrc;
        out.push(lexSrc);
        out.push('parser.lexer = lexer;');
    }
    out.push('', module.moduleInclude, '', 'return parser;');
    out.push('});');

    var src = out.join('\n') + '\n';
    opt.exportSourceCode.all = src;
    return src;
};

lrGeneratorMixin.generateESModule = function generateESModule(opt) {
    opt = this.__prepareOptions(opt);

    var module = this.generateModule_();
    var out = [this.generateGenericHeaderComment(), '', module.initCode, module.commonCode, '', 'var parser = ' + module.moduleCode, module.modulePostlude];
    if (this.lexer && this.lexer.generateModule) {
        var lexSrc = this.lexer.generateModule();
        opt.exportSourceCode.lexer = lexSrc;
        out.push(this.lexer.generateModule());
        out.push('parser.lexer = lexer;');
    }
    out.push('', module.moduleInclude, '');

    var exportMain = '';
    var invokeMain = '';
    if (!opt.noMain) {
        var moduleNameAsCode = String(opt.moduleMain || commonjsMain);
        var moduleImportsAsCode = String(opt.moduleMainImports || commonjsMainImports);

        out.push(rmCommonWS(_templateObject96, moduleImportsAsCode, moduleNameAsCode.trim()));
        exportMain = 'main: yyExecMain,';
        invokeMain = rmCommonWS(_templateObject97);
    }
    out.push(rmCommonWS(_templateObject98, invokeMain, exportMain));

    var src = out.join('\n') + '\n';
    opt.exportSourceCode.all = src;
    return src;
};

generatorMixin.generateCommonJSModule = function generateCommonJSModule(opt) {
    opt = this.__prepareOptions(opt);

    var moduleName = opt.moduleName;
    var main = '';
    if (!opt.noMain) {
        var moduleNameAsCode = String(opt.moduleMain || commonjsMain);
        var moduleImportsAsCode = String(opt.moduleMainImports || commonjsMainImports);

        main = rmCommonWS(_templateObject99, moduleImportsAsCode, moduleNameAsCode.trim());
    }
    var out = this.generateModule(opt) + rmCommonWS(_templateObject100, moduleName, moduleName, moduleName, moduleName, main);

    opt.exportSourceCode.all = out;
    return out;
};

generatorMixin.generateModule = function generateModule(opt) {
    opt = this.__prepareOptions(opt);

    var moduleName = opt.moduleName;
    var out = this.generateGenericHeaderComment();

    var self = this;
    function _generateNamespace(namespaces, previousNamespace, callback) {
        var subModuleName = namespaces.shift();
        if (subModuleName != null) {
            var moduleName = previousNamespace == null ? subModuleName : previousNamespace + '.' + subModuleName;
            if (namespaces.length > 0) {
                return 'var ' + subModuleName + ';\n' + '(function (' + subModuleName + ') {\n' + _generateNamespace(namespaces, subModuleName, callback) + '\n})(' + subModuleName + (previousNamespace == null ? '' : ' = ' + moduleName) + ' || (' + moduleName + ' = {}));\n';
            }
            return callback(moduleName);
        }
        return '';
    }

    var sourceCodeDef = self.generateModuleExpr();

    out += '\n        ' + sourceCodeDef.init + '\n    ';

    out += _generateNamespace(moduleName.split('.'), null, function _generateNamespace_cb(moduleName) {
        var name = moduleName.match(/\./) ? moduleName : 'var ' + moduleName;
        return '\n            ' + name + ' = ' + sourceCodeDef.src + '\n        ';
    });

    opt.exportSourceCode.all = out;
    return out;
};

generatorMixin.generateModuleExpr = function generateModuleExpr() {
    var out;
    var opt = this.__prepareOptions();
    var module = this.generateModule_();

    out = ['(function () {', module.commonCode, '', 'var parser = ' + module.moduleCode, module.modulePostlude];
    if (this.lexer && this.lexer.generateModule) {
        var lexSrc = this.lexer.generateModule();
        opt.exportSourceCode.lexer = lexSrc;
        out.push(lexSrc);
        out.push('parser.lexer = lexer;');
    }
    out = out.concat(['', module.moduleInclude, '', 'function Parser() {', '  this.yy = {};', '}', 'Parser.prototype = parser;', 'parser.Parser = Parser;', '', 'return new Parser();', '})();']);

    var src = out.join('\n') + '\n';
    opt.exportSourceCode.all = src;

    return {
        src: src,
        init: module.initCode
    };
};

function removeUnusedKernelFeatures(parseFn, info) {
    var actionFn = info.performAction;

    if (info.actionsAreAllDefault) {
        // in this case, there's no need to call the parseAction function at all:
        // it is functionally empty anyway.
        actionFn = '';

        // remove:
        //
        //     r = this.performAction.call(yyval, ...);
        //
        //     if (typeof r !== 'undefined') {
        //         retval = r;
        //         break;
        //     }
        //

        parseFn = parseFn.replace(/\s+r = this\.performAction\.call[^)]+\)\;/g, '').replace(/\s+if \(typeof r !== 'undefined'\) \{[^}]+\}/g, '');
    }

    if (!info.actionsUseYYTEXT) {
        // Wait with this bit of cleanup until the very end to help keep the
        // other cleanup/optimization options below that much simpler to code:
        parseFn = parseFn.replace(/, yytext\b/g, '').replace(/^.*?\bvar yytext\b.*?$/gm, '').replace(/^.*[^.]\byytext = .+$/gm, '').replace(/^.+ = yytext\b.+$/gm, '');
    }

    if (!info.actionsUseYYLENG) {
        actionFn = actionFn.replace(/, yyleng\b/g, '');

        // remove:
        //
        //     if (typeof lexer.yyleng === 'undefined') {
        //       lexer.yyleng = 0;
        //     }
        //     var yyleng;
        //     ...

        parseFn = parseFn.replace(/, yyleng\b/g, '').replace(/^.*?\bvar yyleng\b.*?$/gm, '').replace(/\s+if\b.*?\.yyleng\b.*?\{[^}]+\}/g, '\n').replace(/^.*?\byyleng = .+$/gm, '').replace(/^.*?\byyleng\b.*?=.*?\byyleng\b.*?$/gm, '');
    }

    if (!info.actionsUseYYLINENO) {
        // The error handling code inside the kernel still uses this one, but only straight off the lexer
        // so we can kill the local var and its usage at least:
        actionFn = actionFn.replace(/, yylineno\b/g, '');

        // remove:
        //
        //     var yylineno;
        //     ...

        parseFn = parseFn.replace(/\bvar yylineno\b/g, '').replace(/, yylineno\b/g, '').replace(/^.*?\byylineno\b.*?=.*?\byylineno\b.*?$/gm, '');
    }

    if (!info.actionsUseYYSTACK) {
        actionFn = actionFn.replace(/, yystack\b/g, '');

        parseFn = parseFn.replace(/, stack\b/g, '');
    }

    if (!info.actionsUseYYSSTACK) {
        actionFn = actionFn.replace(/, yysstack\b/g, '');

        parseFn = parseFn.replace(/, sstack\b/g, '');
    }

    if (!info.actionsUseYYRULELENGTH) {
        actionFn = actionFn.replace(/, yyrulelength\b/g, '');

        parseFn = parseFn.replace(/, yyrulelen\b/g, '');
    }

    if (!info.actionsUseYYSTACKPOINTER) {
        actionFn = actionFn.replace(/, yysp\b/g, '');

        parseFn = parseFn.replace(/, sp - 1\b/g, '');
    }

    if (!info.actionsUseYYMERGELOCATIONINFO) {
        // remove the entire function plus all leading comment:
        parseFn = parseFn.replace(/\n.*?merge yylloc info into a new yylloc instance[^]*?\bthis\.yyMergeLocationInfo\b[^]*?\};[^]*?\n/g, new Array(134).join('\n'))
        // also remove its invocation in the error recovery code:
        .replace(/\n.*?\bthis\.yyMergeLocationInfo\b[^\n]+\n/g, '\n');
    }

    if (!info.actionsUseLocationTracking) {
        actionFn = actionFn.replace(/\byyloc, (.*?), yylstack\b/g, '$1');

        // remove:
        //
        //    var yyloc = lexer.yylloc;
        //    lstack[sp] = yyloc;
        //    ...
        //        lstack[sp] = copy_yylloc(lexer.yylloc);
        //    ...

        parseFn = parseFn.replace(/\byyloc, (.*?), lstack\b/g, '$1').replace(/\s+yyval\._\$\s*=\s*.+$/gm, '\n').replace(/^.*?\blstack\b.*$/gm, '').replace(/^.*?\byyloc\b.*?$/gm, '').replace(/^.*?\byylloc\b.*?$/gm, '').replace(/^\s*_\$:\s+undefined\s*$/gm, '').replace(/\s+function\s+copy_yylloc\b[^]*?return\s+rv[^}]+\}/g, '').replace(/^.*?\bcopy_yylloc\b.*?$/gm, '').replace(/^.*?\blocation_stack\b.*?$/gm, '');
    }

    if (!info.actionsUseValueTracking) {
        actionFn = actionFn.replace(/, yyvstack\b/g, '');

        parseFn = parseFn.replace(/, vstack\b/g, '');

        // also nuke all `yyval`-related code as we know, when this set of
        // features is set, that the grammar doesn't produce any value:
        // we are looking at a *matcher*, rather than a *parser*!
        //
        // remove
        //
        //     // Return the `$accept` rule's `$$` result, if available.
        //     // ...
        //     sp--;
        //     if (typeof vstack[sp] !== 'undefined') {
        //         retval = vstack[sp];
        //     }
        //
        // and
        // 
        //     if (sp >= 0 && typeof vstack[sp] !== 'undefined') {
        //         retval = vstack[sp];
        //     }
        // 
        // but keep the yyval declaration as either location tracking MAY
        // still be employed by the grammar OR the grammar uses advanced
        // code which uses `yyval` as a run-time store which carries data
        // across multiple reduction calls to `performAction`, as per
        // the suggestion in the document comment for the grammar:
        //
        // >
        // > One important thing to note about `this` a.k.a. `yyval`: ...
        // >
        parseFn = parseFn.replace(/\s+\/\/ Return the \`\$accept\` rule's \`\$\$\` result[\s\S]+?if \((?:sp\b.*?)?typeof vstack\[sp\] !== 'undefined'\)[^\}]+\}[^\n]*\n/g, '\n\n\n\n\n\n');

        // kill all vstack entries which would be copied into the
        // error recovery `value_stack`:
        //
        //     recoveringErrorInfo.value_stack[esp] = ...
        //
        //     if (errStr) {
        //         recoveringErrorInfo.value_stack[esp] = {
        //             ...
        //         };
        //         ...
        //     } else {
        //         recoveringErrorInfo.value_stack[esp] = {
        //             ...
        //         };
        //     }
        //
        //     rv.value_stack = ...
        //
        parseFn = parseFn.replace(/[^\n]+if \(errStr\) \{\s*\n.*?\.value_stack\b[^]*?\};[^]*?\} else \{\s*\n.*?\.value_stack\b[^]*?\};[^}]*\}[^\n]*\n/g, '\n\n\n\n\n\n\n\n\n\n\n\n').replace(/[^\n]+\.value_stack\b[^n]*\n/g, '\n');

        // kill *all* value tracking when there's also no *implicit* `$$ = ...` action any more:

        // remove all lines using `vstack[xyz...]` ...
        parseFn = parseFn.replace(/^.*?\bvstack\b.*$/gm, '');

        // When there's no `performAction()` call at all, then
        // the `yyval` declaration can safely be discarded as well.
        if (info.actionsAreAllDefault) {
            // remove
            //
            //     var yyval = {
            //         $: true,
            //         _$: undefined,
            //         yy: sharedState_yy
            //     };
            parseFn = parseFn.replace(/\s+var yyval =[\s\S]+?\};[^\n]*\n/g, '\n\n\n\n\n\n');
        }
    }

    if (!info.DEBUG) {
        // When 'debug mode' hasn't been turned on during parser generation,
        // then we don't allow it at all: this gives us faster production parsers.
        //
        // When you want debug output at parse run-time, then you MUST produce a parser
        // with either the
        //     %debug
        // option set or by invoking JISON with the debug flag `-t`.

        // remove:
        //
        //     var yydebug = false;
        //     ... and delete yydebug function definition ...
        //     ...
        //     if (yydebug) yydebug(...);
        //
        // and
        //
        //     // disable debugging at run-time ANYWAY when you've *explicitly* set "yy.yydebug = false":
        //     if (sharedState_yy.yydebug === false) {
        //         yydebug = undefined;
        //     }


        parseFn = parseFn.replace(/\s+var yydebug = [\s\S]+?self\.trace[\s\S]+?};[^}]+}/g, '\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n')
        // strip multi-line `if (debug) yydebug(..., {...});` statements
        // also strip simple yet possibly multi-line `if (debug) yydebug('...');` statements
        .replace(/\n\s+if\s+\(yydebug\)\s+yydebug\([^]+?['}]\);[^\r\n]*?/g, '\n\n\n\n\n\n\n\n\n')
        // strip single-line `yydebug(...);` statements
        .replace(/^.*?\byydebug\b[^;]+?\);[^\r\n]*?$/gm, '')
        // strip `if (sharedState_yy.yydebug) {...}` chunk
        .replace(/\n\s+\/\/\s*disable\s*debugging.*?[\r\n]+\s+if\s+\(sharedState_yy\.yydebug[^]+?\}/g, '\n\n\n\n');
    }

    if (!info.actionsUseYYERROK && !info.actionsUseYYRECOVERING && !info.actionsUseYYCLEARIN && !info.actionsUseYYERROR) {
        /*
         * Kill long multi-line comment about yyerror + YYRECOVERING + yyerrok + yyclearin before this code:
         *
         *       if (this.yyError) {
         *           ...
         */
        parseFn = parseFn.replace(/\s+\/\/.*setup `yyError`, `YYRECOVERING`, `yyErrOk` and `yyClearIn` functions[^\0]+?\n\s+if \(/g, '\n\n\n\n\n  if (');
    }

    if (!info.actionsUseYYERROR) {
        /*
         * Kill this code:
         *
         *       if (this.yyError) {
         *           this.yyError = function yyError(str) {
         *               ...
         *           };
         *       }
         */
        parseFn = parseFn.replace(/\s+if \(this\.yyError\) \{[^\0]+?\};\n\s+\}\n/g, '\n\n\n\n\n');
    }

    if (!info.actionsUseYYRECOVERING) {
        /*
         * Kill this code:
         *
         *       if (this.yyRecovering) {
         *           this.yyRecovering = function yyRecovering() {
         *               return recovering;
         *           };
         *       }
         */
        parseFn = parseFn.replace(/\s+if \(this\.yyRecovering\) \{[^\0]+?\};\n\s+\}\n/g, '\n\n\n\n\n');
    }

    if (!info.actionsUseYYERROK) {
        /*
         * Kill this code:
         *
         *       if (this.yyErrOk) {
         *           this.yyErrOk = function yyErrOk() {
         *               recovering = 0;
         *           };
         *       }
         */
        parseFn = parseFn.replace(/\s+if \(this\.yyErrOk\) \{[^\0]+?\};\n\s+\}\n/g, '\n\n\n\n\n');
    }

    if (!info.actionsUseYYCLEARIN) {
        parseFn = parseFn.replace(/\s+if \(this\.yyClearIn\) \{[^\0]+?[^{]\};\n\s+\}\n/g, '\n\n\n\n\n\n');
    }

    if (info.options.noTryCatch) {
        /*
         * Kill this code:
         *
         *     try {
         *         this.__reentrant_call_depth++;
         *         ... keep all this stuff ...
         *     } catch (ex) {
         *         ... remove this stuff ...
         *     } finally {
         *         retval = this.cleanupAfterParse(retval, true, true);       // <-- keep this line
         *     } // /finally
         *
         * and also remove any re-entrant parse() call support:
         *
         *     ... __reentrant_call_depth ...
         */
        parseFn = parseFn.replace(/\s+try \{([\s\r\n]+this\.__reentrant_call_depth[\s\S]+?)\} catch \(ex\) \{[\s\S]+?\} finally \{([^]+?)\}\s+\/\/\s+\/finally/, function replace_noTryCatch(m, p1, p2) {
            p1 = p1.replace(/^        /mg, '    ');
            p2 = p2.replace(/^        /mg, '    ');
            return '\n' + p1 + '\n    // ... AND FINALLY ...\n' + p2;
        }).replace(/^[^\n]+\b__reentrant_call_depth\b[^\n]+$/gm, '\n');
    }

    if (!info.actionsUseYYTEXT) {
        // See the comment for the same section near the start of this function:
        //
        // Wait with this bit of cleanup until the very end to help keep the
        // other cleanup/optimization options below that much simpler to code:
        actionFn = actionFn.replace(/\(\byytext\b(,\s*)?/g, '(');
    }

    // When we're done feature stripping, we can clean up any lingering
    // internals, which would otherwise go unused:
    if (!analyzeFeatureUsage(parseFn, /\bshallowCopyErrorInfo\b/g, 1)) {
        // Remove:
        //
        //     // clone some parts of the (possibly enhanced!) errorInfo object
        //     // to give them some persistence.
        //     this.shallowCopyErrorInfo = function ...(p) {
        //         ...
        //         return rv;
        //     }
        //
        parseFn = parseFn.replace(/\n[^\n]*?clone some parts of the[^\n]*?errorInfo object[^]*?\bshallowCopyErrorInfo\b[^]*?return rv;[^}]*\};[^\n]*/g, '\n\n\n\n\n\n\n\n\n\n\n');
    }
    if (!analyzeFeatureUsage(parseFn, /\bshallow_copy\b/g, 1)) {
        // Remove:
        //
        //     // shallow clone objects, straight copy of simple `src` values
        //     // ...
        //     function shallow_copy(...) {
        //         ...
        //         return src;
        //     }
        //
        parseFn = parseFn.replace(/\n[^\n]*?shallow clone objects, straight copy[^]*?\bshallow_copy\b[^]*?return src;[^}]*\}[^\n]*/g, '\n\n\n\n\n\n');
    }

    info.performAction = actionFn;

    return parseFn;
}

// Fill in the optional, extra parse parameters (`%parse-param ...`)
// in the generated parser.
//
// See for important context:
//
//     https://github.com/zaach/jison/pull/332
function expandParseArguments(parseFn, self) {
    var arglist = self.parseParams;

    if (!arglist || arglist.length === 0) {
        parseFn = parseFn.replace(/, parseParams\b/g, '');
        parseFn = parseFn.replace(/\bparseParams\b/g, '');
        parseFn = parseFn.replace(/,\s*[\r\n]+\s*parseParamsAsMembers:\s+parseParamsAsMembers\b/g, '');
    } else {
        parseFn = parseFn.replace(/, parseParams\b/g, ', ' + arglist.join(', '));
        parseFn = parseFn.replace(/\bparseParams\b/g, arglist.join(', '));
        parseFn = parseFn.replace(/,\s*[\r\n]+(\s*)parseParamsAsMembers:\s+parseParamsAsMembers\b/g, function parseParamsReplF(m, ws) {
            var s = ',';

            // determine longest name of the bunch (for formatting the generated code)
            var max_k_len = 0;
            for (var i = 0, len = arglist.length; i < len; i++) {
                var k = arglist[i];
                max_k_len = Math.max(max_k_len, k.length);
            }
            var wsi2 = new Array(max_k_len + 1).join(' ');

            // generate the member assignment list for the `sharedState_yy` object which will store the `parseParams` for everyone to access
            for (var i = 0, len = arglist.length; i < len; i++) {
                var k = arglist[i];
                s += '\n' + ws + k + ': ' + k + (i < len - 1 ? ',' + wsi2.substr(0, max_k_len - k.length - 1) : wsi2.substr(0, max_k_len - k.length)) + '  // parseParams::' + k;
            }
            return s;
        });
    }
    return parseFn;
}

function expandConstantsInGeneratedCode(src, self) {
    // expand the error recovery 'combine rule' action constant in the generated code
    src = src.replace(/\bYY_ERROR_RECOVERY_COMBINE_ID\b/g, '' + self.table.length)
    // the next 'constant' has explicit `\n` newlines included for protection:
    // it should only occur in *one* place in the *entire* code stream.
    .replace(/\nYY_REMAINING_INIT_CODE_SECTIONS_GO_HERE\n/g, self.moduleInit.getRemainingInitCodeSections().join('\n'));

    return src;
}

function pickOneOfTwoCodeAlternatives(parseFn, pick_A_not_B, A_start_marker, B_start_marker, end_marker) {
    // Notes:
    // 1) we use the special /[^\0]*/ regex set as that one will also munch newlines, etc.
    //    while the obvious /.*/ does not as '.' doesn't eat the newlines.
    return parseFn.replace(new RegExp('(' + A_start_marker + '[^\\n]*\\n)([^\\0]*?)(' + B_start_marker + '[^\\n]*\\n)([^\\0]*?)(' + end_marker + '[^\\n]*\\n)', 'g'), function pick_code_alt(str, mA, cA, mB, cB, mE) {
        if (pick_A_not_B) {
            return cA;
        }
        return cB;
    });
}

function addOrRemoveTokenStack(fn, wantTokenStack) {
    var parseFn = fn;
    // We don't use the Esprima+Escodegen toolchain as those loose the code comments easily;
    // instead we just chop the code using labels as sentinels for our chopping-it-up regexes:
    //
    // if (wantTokenStack) {
    //     try {
    //         var ast = esprima.parse(parseFn);
    //         var stackAst = esprima.parse(String(tokenStackLex)).body[0];
    //         stackAst.id.name = 'lex';
    //
    //         var labeled = JSONSelect.match(':has(:root > .label > .name:val("_token_stack"))', ast);
    //
    //         labeled[0].body = stackAst;
    //
    //         return escodegen.generate(ast);
    //     } catch (e) {
    //         return parseFn;
    //     }
    // } else {
    //     // remove the line:
    //     // var tstack = []; // token stack
    //     parseFn = parseFn.replace(/tstack = .*$/m, '');
    //     return parseFn;
    // }
    parseFn = pickOneOfTwoCodeAlternatives(parseFn, !wantTokenStack, '//_lexer_without_token_stack:', '//_lexer_with_token_stack:', '//_lexer_with_token_stack_end:');
    // and some post-coital touch-ups:
    if (wantTokenStack) {
        // And rename the `tokenStackLex` function to become the new `lex`:
        return parseFn.replace(/\btokenStackLex\b/g, 'lex');
    } else {
        // Also nuke the support declaration statement:
        //     var tstack = [];
        return parseFn.replace(/^.*?\btstack\b.*$/gm, '');
    }
}

// returns parse function with/without error recovery code
function pickErrorHandlingChunk(fn, hasErrorRecovery) {
    var parseFn = fn;

    // We don't use the Esprima+Escodegen toolchain as those loose the code comments easily;
    // instead we just chop the code using labels as sentinels for our chopping-it-up regexes:
    // try {
    //     var ast = esprima.parse(parseFn);

    //     var labeled = JSONSelect.match(':has(:root > .label > .name:val("' +
    //         (!hasErrorRecovery ? '_handle_error_with_recovery' : '_handle_error_no_recovery') +
    //         '"))', ast);
    //     Jison.print('labeled: ', labeled);
    //     assert(labeled[0].body.type === 'IfStatement');
    //     labeled[0].body.type = 'DebuggerStatement';
    //     Jison.print('patched::labeled: ', labeled);

    //     return escodegen.generate(ast);
    // } catch (e) {
    //     return parseFn;
    // }
    parseFn = pickOneOfTwoCodeAlternatives(parseFn, hasErrorRecovery, '//_handle_error_with_recovery:', '//_handle_error_no_recovery:', '//_handle_error_end_of_section:');
    // and some post-coital touch-ups:
    if (!hasErrorRecovery) {
        // Also nuke the support declaration statement:
        //          var recovering = 0;
        // and the recovery support statements:
        //          if (recovering > 0) {
        //              recovering--;
        //          }
        // and these yydebug particles:
        //          , recovering: recovering
        //          ASSERT(recovering === 0);
        parseFn = parseFn.replace(/^\s*var recovering.*$/gm, '').replace(/, recovering: recovering/g, '').replace(/^.*?recovering =.*$/gm, '').replace(/^\s+recovering[,]?\s*$/gm, '').replace(/[ \t]*if \(recovering[^\)]+\) \{[^\0]+?\}\n/g, '\n\n\n\n\n')
        // And nuke the preErrorSymbol code as it is unused when there's no error recovery
        //        if (!preErrorSymbol) {
        //            ... keep this chunk ...
        //        } else {
        //            ... KILL this chunk ...
        //        }
        .replace(/\s+if[^a-z]+preErrorSymbol.*?\{\s*\/\/[^\n]+([\s\S]+?)\} else \{[\s\S]+?\}\n\s+\}\n/g, '\n$1\n\n\n\n').replace(/^\s+(?:var )?preErrorSymbol = .*$/gm, '').replace(/^.*?\bpreErrorSymbol =.*$/gm, '')
        // And nuke the support declaration statement:
        //         var lastEofErrorStateDepth = 0;
        .replace(/^\s*var lastEofErrorStateDepth.*$/gm, '');
    }
    return parseFn;
}

// Generates the code of the parser module, which consists of two parts:
// - module.commonCode: initialization code that should be placed before the module
// - module.moduleCode: code that creates the module object
lrGeneratorMixin.generateModule_ = function generateModule_() {
    var parseFn = String(parser.parse);
    parseFn = pickErrorHandlingChunk(parseFn, this.hasErrorRecovery);

    parseFn = addOrRemoveTokenStack(parseFn, this.options.tokenStack);

    parseFn = removeUnusedKernelFeatures(parseFn, this);

    parseFn = expandParseArguments(parseFn, this);

    var errorClassCode = this.generateErrorClass();

    var exportDest = this.options.exportAllTables;
    assert(exportDest);

    // store the parse tables:
    exportDest.parseTable = this.table;
    exportDest.defaultParseActions = this.defaultActions;
    exportDest.parseProductions = this.productions_;

    var exportSourceCode = this.options.exportSourceCode;
    assert(exportSourceCode);

    var tableCode;
    switch (this.options.compressTables | 0) {
        case 0:
            // no compression
            tableCode = this.generateTableCode0(this.table, this.defaultActions, this.productions_);
            break;

        default:
        case 1:
            // default: vanilla JISON table compression = run-length encoding
            tableCode = this.generateTableCode1(this.table, this.defaultActions, this.productions_);
            break;

        case 2:
            // column-mode compression
            // this compression method corrupts the table when this option is turned on (and one or more conflicts occur)
            if (this.options.noDefaultResolve && this.conflicts > 0) {
                tableCode = this.generateTableCode1(this.table, this.defaultActions, this.productions_);
            } else {
                tableCode = this.generateTableCode2(this.table, this.defaultActions, this.productions_);
            }
            break;
    }

    // Generate the initialization code

    var initCode = [].concat(this.moduleInit.getInitCodeSection('imports'), this.moduleInit.getInitCodeSection('init'));

    var commonCode = [].concat(this.moduleInit.getInitCodeSection('required'), errorClassCode.commonCode, errorClassCode.moduleCode, ['\nYY_REMAINING_INIT_CODE_SECTIONS_GO_HERE\n'], tableCode.commonCode);

    // sort hash table by key to produce a nicer output:
    function produceSymbolTable(tbl) {
        var a = Object.keys(tbl);
        a.sort();
        var nt = {};
        var k;
        for (var i = 0, len = a.length; i < len; i++) {
            k = a[i];
            // `$eof` and `EOF` are synonyms of `$end` (`$eof` is for bison compatibility);
            // this is the only place where two symbol names may map to a single symbol ID number
            // and we do not want `$eof`/`EOF` to show up in the symbol tables of generated parsers
            // as we use `$end` for that one!
            if (k !== '$eof') {
                nt[k] = tbl[k];
            }
        }
        return nt;
    }

    // swap key and value and then sort hash table by key to produce a nicer output:
    function produceTerminalTable(tbl) {
        var a = Object.keys(tbl);
        var nt = {};
        var k, v;
        for (var i = 0, len = a.length; i < len; i++) {
            k = a[i];
            v = tbl[k];
            nt[v] = +k; // convert numeric key back to number type; all terminals have numeric keys
        }
        return produceSymbolTable(nt);
    }

    function produceProductionsForDebugging(options, symbols, base) {
        function get_orig_symbol(s) {
            var a = s.split(':');
            if (a.length === 1 || a[0] === '') {
                return {
                    state: -1,
                    symbol: s
                };
            }
            var state = a[0];
            a.shift();
            return {
                state: +state,
                symbol: a.join(':')
            };
        }
        function get_orig_symbol_set(arr) {
            var rv = {};
            for (var i = 0, len = arr.length; i < len; i++) {
                var item = arr[i];
                var symbol = get_orig_symbol(item);
                rv[symbol.symbol] = symbol.state;
            }
            return Object.keys(rv);
        }

        var tbl = this.nonterminals;
        var sym = this.symbols_ || symbols;

        if (!options.outputDebugTables && !options.exportAllTables.enabled) {
            return undefined;
        }

        var prods = {
            ids: {},
            states: {},
            rules: {},
            nonterminals: {},
            symbols: {},
            first: {},
            follows: {}
        };

        var self = this;
        this.productions.forEach(function Follow_prod_forEach_genDebugTable(production, k) {
            var nonterm = production.symbol;
            prods.states[k] = nonterm;
            prods.ids[nonterm] = sym[nonterm];

            var lst = prods.rules[nonterm] || {};
            lst[k] = gen_lalr_states_production(production, k, false, k, true);
            prods.rules[nonterm] = lst;
        });

        function gen_nonterminal(nt) {
            var l = nt.productions._items;
            var lst = l.map(function (p, i) {
                return gen_lalr_states_production(p, i, false, false, false);
            });
            var rv = {
                symbol: nt.symbol,
                productions: lst,
                first: nt.first,
                base_first: get_orig_symbol_set(nt.first),
                follows: nt.follows,
                base_follows: get_orig_symbol_set(nt.follows),
                nullable: nt.nullable
            };

            // clean up structure: ditch superfluous elements:
            if (rv.base_first.join(' ') === rv.first.join(' ')) {
                delete rv.base_first;
            }
            if (rv.base_follows.join(' ') === rv.follows.join(' ')) {
                delete rv.base_follows;
            }

            return rv;
        }

        for (var key in tbl) {
            prods.nonterminals[key] = gen_nonterminal(tbl[key]);
        }

        if (this.nterms_) {
            prods.nterms_ = this.nterms_;
        }

        function gen_lalr_states_production(production, index, dotPosition, state, patch_base) {
            var nonterm = production.symbol;
            var hlen = production.handle.length;
            var rulestr = production.handle.map(function (t, idx) {
                if (!t) {
                    t = '%epsilon';
                }

                if (dotPosition === idx) {
                    t = '' + t;
                }
                return t;
            }).join(' ');
            if (dotPosition === hlen) {
                rulestr += ' ';
            }

            var base_rulestr = production.handle.map(function (t) {
                if (!t) {
                    t = '%epsilon';
                }
                t = get_orig_symbol(t).symbol;
                return t;
            }).join(' ');

            var rv = {
                symbol: nonterm,
                base_symbol: get_orig_symbol(nonterm).symbol,
                handle: rulestr,
                base_handle: base_rulestr,
                nullable: production.nullable,
                id: production.id,
                index: index,
                state: state !== false ? state : -1,
                base_state: -1,
                first: production.first,
                base_first: get_orig_symbol_set(production.first),
                follows: production.follows,
                base_follows: get_orig_symbol_set(production.follows),
                precedence: production.precedence,
                reachable: production.reachable
            };

            // Determine state for given production, if it's not a production that's listed as part of a state:
            var chk, idx;
            var lst = prods.rules[nonterm];
            chk = rv.symbol + ' : ' + rv.handle;
            for (idx in lst) {
                idx = +idx;
                var p = lst[idx];
                if (p) {
                    if (p.symbol + ' : ' + p.handle === chk) {
                        assert(rv.state === -1);
                        rv.state = idx;
                        break;
                    }
                }
            }

            // Try to reference base productions from newg child productions and vice versa:
            chk = rv.base_symbol + ' : ' + rv.base_handle;
            if (base && base.rules) {
                var pr = base.rules[rv.base_symbol];
                for (idx in pr) {
                    var bprod = pr[idx];
                    if (bprod.symbol + ' : ' + bprod.handle === chk) {
                        assert(rv.base_state === -1);
                        rv.base_state = bprod.state;
                        if (patch_base) {
                            bprod.newg_states = bprod.newg_states || [];
                            bprod.newg_states.push(rv.index);
                        }
                        break;
                    }
                }
            }

            // clean up structure: ditch superfluous elements:
            if (rv.base_symbol === rv.symbol) {
                delete rv.base_symbol;
            }
            if (rv.base_handle === rv.handle) {
                delete rv.base_handle;
            }
            if (rv.base_first.join(' ') === rv.first.join(' ')) {
                delete rv.base_first;
            }
            if (rv.base_follows.join(' ') === rv.follows.join(' ')) {
                delete rv.base_follows;
            }
            if (rv.base_state === -1) {
                delete rv.base_state;
            }
            return rv;
        }

        if (this.states) {
            prods.lalr_states = [];
            var these_states = this.states;
            these_states.forEach(function traverse_states(state, i) {
                //assert(state.inadequate ? these_states.inadequate : true);
                state.forEach(function traverse_state(item, j) {
                    // is this a REDUCE state?
                    var nterm_first = self.nonterminals[item.production.symbol].first;
                    var rv = {
                        state: i,
                        item_index: j,
                        is_reduce_state: item.dotPosition === item.production.handle.length,
                        dot_position: item.dotPosition,
                        state_inadequate: state.inadequate ? true : undefined,
                        item_inadequate: item.inadequate ? true : undefined,
                        production: gen_lalr_states_production(item.production, j, item.dotPosition, i, true),
                        follows: item.follows,
                        base_follows: get_orig_symbol_set(item.follows),
                        nterm_first: nterm_first,
                        base_nterm_first: get_orig_symbol_set(nterm_first),
                        prod_first: item.production.first,
                        base_prod_first: get_orig_symbol_set(item.production.first)
                    };

                    // clean up structure: ditch superfluous elements:
                    if (rv.base_follows.join(' ') === rv.follows.join(' ')) {
                        delete rv.base_follows;
                    }
                    if (rv.base_nterm_first.join(' ') === rv.nterm_first.join(' ')) {
                        delete rv.base_nterm_first;
                    }
                    if (rv.base_prod_first.join(' ') === rv.prod_first.join(' ')) {
                        delete rv.base_prod_first;
                    }

                    prods.lalr_states.push(rv);
                });
            });
        }

        var nt = tbl;
        var sbn;
        for (sbn in nt) {
            var orig_symbol = get_orig_symbol(sbn);
            var item = nt[sbn];
            var firsts = item.first;
            var follows = item.follows;
            if (!prods.symbols[orig_symbol.symbol]) {
                prods.symbols[orig_symbol.symbol] = orig_symbol.state;
            }
            if (!prods.first[orig_symbol.symbol]) {
                prods.first[orig_symbol.symbol] = firsts;
            } else {
                prods.first[orig_symbol.symbol] = prods.first[orig_symbol.symbol].concat(firsts);
            }
            if (!prods.follows[orig_symbol.symbol]) {
                prods.follows[orig_symbol.symbol] = follows;
            } else {
                prods.follows[orig_symbol.symbol] = prods.follows[orig_symbol.symbol].concat(follows);
            }
        }
        for (sbn in prods.first) {
            prods.first[sbn] = get_orig_symbol_set(prods.first[sbn]);
        }
        for (sbn in prods.follows) {
            prods.follows[sbn] = get_orig_symbol_set(prods.follows[sbn]);
        }

        if (this.newg) {
            prods.newg = produceProductionsForDebugging.call(this.newg, options, sym, prods);
        }
        return prods;
    }

    function produceTerminalDescriptions(tbl, sym) {
        var rv = {};
        var count = 0;
        for (var k in tbl) {
            var descr = tbl[k];
            var id = sym[k];
            if (id && descr && descr !== id) {
                rv[id] = descr;
                count++;
            }
        }
        return count ? rv : undefined;
    }

    function produceOptions(opts) {
        var obj = {};
        var do_not_pass = {
            type: 0, // CLI: --parserType option
            debug: !opts.debug, // do not include this item when it is FALSE as there's no debug tracing built into the generated grammar anyway!
            enableDebugLogs: 1,
            numExpectedConflictStates: 1,
            dumpSourceCodeOnFailure: 1,
            throwErrorOnCompileFailure: 1,
            json: 1,
            _: 1,
            noMain: 1,
            moduleMain: 1,
            moduleMainImports: 1,
            noDefaultResolve: 1,
            defaultActionMode: 1,
            noTryCatch: 1,
            hasPartialLrUpgradeOnConflict: 0,
            compressTables: 1,
            outputDebugTables: 1,
            reportStats: 1,
            file: 1,
            outfile: 1,
            inputPath: 1,
            inputFilename: 1,
            lexfile: 1,
            defaultModuleName: 1,
            moduleName: 1,
            moduleType: 1,
            exportAllTables: 1,
            exportSourceCode: 1,
            tokenStack: 0,
            parserErrorsAreRecoverable: 0,
            lexerErrorsAreRecoverable: 1,
            showSource: 1,
            exportAST: 1,
            prettyCfg: 1,

            errorRecoveryTokenDiscardCount: 0,

            warn_cb: 0, // function(msg) | true (= use Jison.Print) | false (= throw Exception)

            parseParams: 1,
            ranges: 0
        };
        for (var k in opts) {
            if (!do_not_pass[k] && opts[k] != null && opts[k] !== false) {
                // make sure numeric values are encoded as numeric, the rest as boolean/string.
                if (typeof opts[k] === 'string') {
                    var f = parseFloat(opts[k]);
                    if (f == opts[k]) {
                        obj[k] = f;
                        continue;
                    }
                }
                obj[k] = opts[k];
            }
        }

        // And now some options which should receive some special processing:
        if (!obj.hasPartialLrUpgradeOnConflict) {
            // only list this option when it's actually TRUE:
            delete obj.hasPartialLrUpgradeOnConflict;
        }

        var pre = obj.pre_parse;
        var post = obj.post_parse;
        // since JSON cannot encode functions, we'll have to do it manually at run-time, i.e. later on:
        if (pre) {
            obj.pre_parse = true;
        }
        if (post) {
            obj.post_parse = true;
        }

        var js = JSON.stringify(obj, null, 2);

        js = js.replace(new XRegExp('  "(' + ID_REGEX_BASE + ')": ', 'g'), '  $1: ');
        js = js.replace(/^( +)pre_parse: true(,)?$/gm, function (m, ls, tc) {
            return ls + 'pre_parse: ' + String(pre) + (tc || '');
        });
        js = js.replace(/^( +)post_parse: true(,)?$/gm, function (m, ls, tc) {
            return ls + 'post_parse: ' + String(post) + (tc || '');
        });
        return js;
    }

    // Generate the module creation code
    var termDescrs = produceTerminalDescriptions(this.descriptions_, this.symbols_);
    exportDest.terminalDescriptions = termDescrs;
    var descrLst = JSON.stringify(termDescrs, null, 2);
    if (descrLst) {
        descrLst = descrLst.replace(/"([0-9]+)":/g, '$1:');
    }

    var rules4Dbg = produceProductionsForDebugging.call(this, this.options);
    exportDest.parseRules = rules4Dbg;
    var rulesLst = this.options.outputDebugTables || this.options.exportAllTables.enabled ? JSON.stringify(rules4Dbg, null, 2) : undefined;
    if (rulesLst) {
        rulesLst = rulesLst.replace(/"([0-9]+)":/g, '$1:').replace(/^(\s+)"([a-z_][a-z_0-9]*)":/gmi, '$1$2:');
    }

    var symbolTable = produceSymbolTable(this.symbols_);
    exportDest.symbolTable = symbolTable;

    // produce a hash lookup table from the terminal set
    exportDest.terminalTable = produceTerminalTable(this.terminals_);

    var moduleCode = '{\n    // Code Generator Information Report\n    // ---------------------------------\n    //\n    // Options:\n    //\n    //   default action mode: ............. ' + this.options.defaultActionMode.join(',') + '\n    //   try..catch: ...................... ' + !this.options.noTryCatch + '\n    //   default resolve on conflict: ..... ' + !this.options.noDefaultResolve + '\n    //   on-demand look-ahead: ............ ' + this.onDemandLookahead + '\n    //   error recovery token skip maximum: ' + this.options.errorRecoveryTokenDiscardCount + '\n    //   yyerror in parse actions is: ..... ' + (this.options.parserErrorsAreRecoverable ? 'recoverable' : 'NOT recoverable') + ',\n    //   yyerror in lexer actions and other non-fatal lexer are:\n    //   .................................. ' + (this.options.lexerErrorsAreRecoverable ? 'recoverable' : 'NOT recoverable') + ',\n    //   debug grammar/output: ............ ' + this.options.debug + '\n    //   has partial LR conflict upgrade:   ' + this.options.hasPartialLrUpgradeOnConflict + '\n    //   rudimentary token-stack support:   ' + this.options.tokenStack + '\n    //   parser table compression mode: ... ' + this.options.compressTables + '\n    //   export debug tables: ............. ' + this.options.outputDebugTables + '\n    //   export *all* tables: ............. ' + this.options.exportAllTables.enabled + '\n    //   module type: ..................... ' + this.options.moduleType + '\n    //   parser engine type: .............. ' + this.options.type + '\n    //   output main() in the module: ..... ' + this.options.noMain + '\n    //   has user-specified main(): ....... ' + !!this.options.moduleMain + '\n    //   has user-specified require()/import modules for main():\n    //   .................................. ' + !!this.options.moduleMainImports + '\n    //   number of expected conflicts: .... ' + this.options.numExpectedConflictStates + '\n    //\n    //\n    // Parser Analysis flags:\n    //\n    //   no significant actions (parser is a language matcher only):\n    //   .................................. ' + this.actionsAreAllDefault + '\n    //   uses yyleng: ..................... ' + this.actionsUseYYLENG + '\n    //   uses yylineno: ................... ' + this.actionsUseYYLINENO + '\n    //   uses yytext: ..................... ' + this.actionsUseYYTEXT + '\n    //   uses yylloc: ..................... ' + this.actionsUseYYLOC + '\n    //   uses ParseError API: ............. ' + this.actionsUseParseError + '\n    //   uses YYERROR: .................... ' + this.actionsUseYYERROR + '\n    //   uses YYRECOVERING: ............... ' + this.actionsUseYYRECOVERING + '\n    //   uses YYERROK: .................... ' + this.actionsUseYYERROK + '\n    //   uses YYCLEARIN: .................. ' + this.actionsUseYYCLEARIN + '\n    //   tracks rule values: .............. ' + this.actionsUseValueTracking + '\n    //   assigns rule values: ............. ' + this.actionsUseValueAssignment + '\n    //   uses location tracking: .......... ' + this.actionsUseLocationTracking + '\n    //   assigns location: ................ ' + this.actionsUseLocationAssignment + '\n    //   uses yystack: .................... ' + this.actionsUseYYSTACK + '\n    //   uses yysstack: ................... ' + this.actionsUseYYSSTACK + '\n    //   uses yysp: ....................... ' + this.actionsUseYYSTACKPOINTER + '\n    //   uses yyrulelength: ............... ' + this.actionsUseYYRULELENGTH + '\n    //   uses yyMergeLocationInfo API: .... ' + this.actionsUseYYMERGELOCATIONINFO + '\n    //   has error recovery: .............. ' + this.hasErrorRecovery + '\n    //   has error reporting: ............. ' + this.hasErrorReporting + '\n    //\n    // --------- END OF REPORT -----------\n\n';
    moduleCode += ['trace: ' + String(this.trace || parser.trace), 'JisonParserError: JisonParserError', 'yy: {}', 'options: ' + produceOptions(this.options), 'symbols_: ' + JSON.stringify(symbolTable, null, 2), 'terminals_: ' + JSON.stringify(this.terminals_, null, 2).replace(/"([0-9]+)":/g, '$1:')].concat(rulesLst ? 'nonterminals_: ' + rulesLst : []).concat(descrLst ? 'terminal_descriptions_: ' + descrLst : []).concat([String(define_parser_APIs_1).replace(/^[\s\S]+?return \{/, '').replace(/\};[s\r\n]+\}\s*$/, '').replace(/^        /mg, '').trim(), 'productions_: ' + tableCode.productionsCode]).concat(String(this.performAction).trim() !== '' ? 'performAction: ' + String(this.performAction) : []).concat(['table: ' + tableCode.tableCode, 'defaultActions: ' + tableCode.defaultActionsCode, 'parseError: ' + String(this.parseError || parseErrorSourceCode), 'parse: ' + parseFn]).concat(this.actionsUseYYERROR ? 'yyError: 1' : []).concat(this.actionsUseYYRECOVERING ? 'yyRecovering: 1' : []).concat(this.actionsUseYYERROK ? 'yyErrOk: 1' : []).concat(this.actionsUseYYCLEARIN ? 'yyClearIn: 1' : []).join(',\n');
    moduleCode += '\n};';

    var exportSourceCode = this.options.exportSourceCode;
    assert(exportSourceCode);
    exportSourceCode.parserChunks = {
        initCode: expandConstantsInGeneratedCode(initCode.join('\n'), this),
        commonCode: expandConstantsInGeneratedCode(commonCode.join('\n'), this),
        moduleCode: expandConstantsInGeneratedCode(moduleCode, this),
        modulePostlude: ['parser.originalParseError = parser.parseError;', 'parser.originalQuoteName = parser.quoteName;'].join('\n'),
        moduleInclude: expandConstantsInGeneratedCode(this.moduleInclude, this)
    };
    return exportSourceCode.parserChunks;
};

lrGeneratorMixin.generateErrorClass = function () {
    // --- START parser error class ---

    var prelude = '// See also:\n// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508\n// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility\n// with userland code which might access the derived class in a \'classic\' way.\nfunction JisonParserError(msg, hash) {\n    Object.defineProperty(this, \'name\', {\n        enumerable: false,\n        writable: false,\n        value: \'JisonParserError\'\n    });\n\n    if (msg == null) msg = \'???\';\n\n    Object.defineProperty(this, \'message\', {\n        enumerable: false,\n        writable: true,\n        value: msg\n    });\n\n    this.hash = hash;\n\n    var stacktrace;\n    if (hash && hash.exception instanceof Error) {\n        var ex2 = hash.exception;\n        this.message = ex2.message || msg;\n        stacktrace = ex2.stack;\n    }\n    if (!stacktrace) {\n        if (Error.hasOwnProperty(\'captureStackTrace\')) {        // V8/Chrome engine\n            Error.captureStackTrace(this, this.constructor);\n        } else {\n            stacktrace = (new Error(msg)).stack;\n        }\n    }\n    if (stacktrace) {\n        Object.defineProperty(this, \'stack\', {\n            enumerable: false,\n            writable: false,\n            value: stacktrace\n        });\n    }\n}\n\nif (typeof Object.setPrototypeOf === \'function\') {\n    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);\n} else {\n    JisonParserError.prototype = Object.create(Error.prototype);\n}\nJisonParserError.prototype.constructor = JisonParserError;\nJisonParserError.prototype.name = \'JisonParserError\';';

    // --- END parser error class ---

    return {
        commonCode: '',
        moduleCode: prelude
    };
};

// Generate code that represents the specified parser table
lrGeneratorMixin.generateTableCode0 = function (table, defaultActions, productions) {
    var tableCode = JSON.stringify(table, null, 2);
    var defaultActionsCode = JSON.stringify(defaultActions, null, 2).replace(/"([0-9]+)":/g, '$1:');
    var productionsCode = JSON.stringify(productions, null, 2);

    // Don't surround numerical property name numbers in quotes
    tableCode = tableCode.replace(/"([0-9]+)"(?=:)/g, '$1');

    var prelude = [];

    // Return the variable initialization code and the table code
    return {
        commonCode: prelude.join('\n'),
        tableCode: tableCode,
        defaultActionsCode: defaultActionsCode,
        productionsCode: productionsCode
    };
};

// Generate code that represents the specified parser table
lrGeneratorMixin.generateTableCode1 = function (table, defaultActions, productions) {
    var tableCode = JSON.stringify(table, null, 2);
    var defaultActionsCode = JSON.stringify(defaultActions, null, 2).replace(/"([0-9]+)":/g, '$1:');
    var productionsCode = JSON.stringify(productions, null, 2);
    var usesCompressor = false;

    // Don't surround numerical property name numbers in quotes
    tableCode = tableCode.replace(/"([0-9]+)"(?=:)/g, '$1');

    // Replace objects with several identical values by function calls
    // e.g., { 1: [6, 7]; 3: [6, 7], 4: [6, 7], 5: 8 } = x([1, 3, 4], [6, 7], { 5: 8 })
    tableCode = tableCode.replace(/\{[\s\r\n]*\d+:[^\}]+,[\s\r\n]*\d+:[^\}]+\}/g, function (object) {
        // Find the value that occurs with the highest number of keys
        var value,
            frequentValue,
            key,
            keys = {},
            keyCount,
            maxKeyCount = 0,
            keyValue,
            keyValues = [],
            keyValueMatcher = /(\d+):[\s\r\n]*([^:\}]+)(?=,[\s\r\n]*\d+:|\})/g;

        while (keyValue = keyValueMatcher.exec(object)) {
            // For each value, store the keys where that value occurs
            key = keyValue[1];
            value = keyValue[2].trim();
            keyCount = 1;

            if (!(value in keys)) {
                keys[value] = [key];
            } else {
                keyCount = keys[value].push(key);
            }
            // Remember this value if it is the most frequent one
            if (keyCount > maxKeyCount) {
                maxKeyCount = keyCount;
                frequentValue = value;
            }
        }
        // Construct the object with a function call if the most frequent value occurs multiple times
        if (maxKeyCount > 1) {
            // Collect all non-frequent values into a remainder object
            for (value in keys) {
                if (value !== frequentValue) {
                    for (var k = keys[value], i = 0, l = k.length; i < l; i++) {
                        keyValues.push(k[i] + ':' + value);
                    }
                }
            }
            keyValues = keyValues.length ? ', {' + keyValues.join(',') + '}' : '';
            // Create the function call `x(keys, value, remainder)`
            object = 'x([' + keys[frequentValue].join(',') + '], ' + frequentValue + keyValues + ')';
            usesCompressor = true;
        }
        return object;
    });

    // Count occurrences of number lists
    var list;
    var lists = {};
    var listMatcher = /\[[0-9,]+\]/g;
    var frequentLists = [];

    while (list = listMatcher.exec(tableCode)) {
        lists[list] = (lists[list] || 0) + 1;
    }

    // Replace frequently occurring number lists with variables
    tableCode = tableCode.replace(listMatcher, function (list) {
        var listId = lists[list];
        // If listId is a number, it represents the list's occurrence frequency
        if (typeof listId === 'number') {
            // If the list does not occur frequently, represent it by the list
            if (listId === 1) {
                lists[list] = listId = list;
                // If the list occurs frequently, represent it by a newly assigned variable
            } else {
                lists[list] = listId = 'u[' + frequentLists.length + ']';
                frequentLists.push(list);
            }
        }
        return listId;
    });

    var prelude = [];

    // Only include the expander function when it's actually used
    // (tiny grammars don't have much state duplication, so this shaves off
    // another couple bytes off the generated output)
    if (usesCompressor) {
        prelude.push(createObjectCode.toString().replace('createObjectCode', 'x'));
        prelude.push('');
    }

    if (frequentLists.length > 0) {
        prelude.push('var u = [\n    ' + frequentLists.join(',\n    ') + '\n];');
        prelude.push('');
    }

    // Return the variable initialization code and the table code
    return {
        commonCode: prelude.join('\n'),
        tableCode: tableCode,
        defaultActionsCode: defaultActionsCode,
        productionsCode: productionsCode
    };
};

// Function that extends an object with the given value for all given keys
// e.g., x([1, 3, 4], [6, 7], { x: 1, y: 2 }) = { 1: [6, 7]; 3: [6, 7], 4: [6, 7], x: 1, y: 2 }
function createObjectCode(k, v, o) {
    o = o || {};
    for (var l = k.length; l--;) {
        o[k[l]] = v;
    }
    return o;
}

// Generate code that represents the specified parser table
lrGeneratorMixin.generateTableCode2 = function (table, defaultActions, productions) {
    if (this.options.noDefaultResolve && this.conflicts > 0) {
        throw new Error("Table Compression mode 2 corrupts the table when the 'noDefaultResolve' option is turned on and one or more conflicts occur. Please use a different compression mode and/or disable this option.");
    }

    var tableCode = JSON.stringify(table, null, 2);
    var defaultActionsCode = JSON.stringify(defaultActions, null, 2).replace(/"([0-9]+)":/g, '$1:');
    var productionsCode = JSON.stringify(productions, null, 2);

    // We know a couple of things about the parse table:
    //
    // - The first level is an array with continuous indexes
    // - Each entry of the array is an object which contains a series of numeric states as a hash table
    // - Each 'hash table' entry is either a state number or a 2-element array
    //
    // So we can start by encoding the table 'vertically', i.e. by column rather than by row,
    // and then provide a bit of code to transform that series of arrays to the real parse table
    // at run time.
    // We can encode the columns by encoding the array-or-number aspect as a separate column,
    // while encoding the size of each hash table in yet another column: number of entries per state.
    // Then thanks to that length info, plus the 'is this hash-table entry going to be a number or an array' flag column,
    // we can transform those back to what we need at run-time.
    //
    // Meanwhile, we can inspect each of the columns and see if we can compress them.
    //
    // Of course the flags array is compressible as it's only 1 bit per entry, but there's sure to
    // be more compression goodies to be had in there, such as run-length encoding and maybe
    // delta-encoding of the hashtable indexes themselves.
    //
    //

    // Don't surround numerical property name numbers in quotes
    tableCode = tableCode.replace(/"([0-9]+)"(?=:)/g, '$1');

    function reportColumnsForCompression(def_arr) {
        var i, key, len;
        var report = [];

        len = 0;
        for (key in def_arr) {
            len = Math.max(len, def_arr[key].length);
        }

        var col_width = 6;
        var col_delta_width = 4;

        function clip(val, width) {
            var s = '        ' + val;
            s = s.substr(s.length - width);
            return s;
        }

        var track_prev4delta = {};
        var c, delta, val, delta_val;
        var line = [];
        line.push('');
        for (c in def_arr) {
            key = clip(c, col_width);
            delta = clip('', col_delta_width);
            line.push(key);
            line.push('');
            line.push(delta);
            line.push('');

            track_prev4delta[c] = 10000000;
        }
        report.push(line.join(''));

        for (i = 0; i < len; i++) {
            line = [];
            line.push('');

            for (c in def_arr) {
                var tbl = def_arr[c];
                if (tbl.length > i) {
                    val = tbl[i] || 0;

                    delta_val = val - track_prev4delta[c];
                    // negative deltas are jumps: don't treat those as delta but as absolute value, sign-flipped:
                    if (delta_val < 0) {
                        delta_val = -val - 1; // so that absolute 0 becomes -1, so it can be recognized from delta=0 ('no change')
                    }
                    track_prev4delta[c] = val;
                } else {
                    val = '.';
                    delta_val = '.';
                }

                key = clip(val, col_width);
                delta = clip(delta_val, col_delta_width);
                line.push(key);
                line.push('');
                line.push(delta);
                line.push('');
            }
            report.push(line.join(''));
        }

        return '\n\n\n// ------------------------------\n\n\n// ' + report.join('\n// ') + '\n\n\n// ------------------\n\n\n';
    }

    // table is array of 1/2-len arrays:
    function analyzeTableForCompression(table) {
        // column: productions' row length
        var len_col = [];
        // column: productions' shift size / action column
        var pop_col = [];
        // column: rule number for each slot ('rule'):
        var rule_col = [];

        var i;
        var row_count = table.length;
        for (i = 0; i < row_count; i++) {
            var prod = table[i];

            len_col.push(prod.length);
            assert(prod.length <= 2);
            assert(prod.length > 0);
            // and the special knowledge about the productions[] table:
            assert(prod.length === 2);
            pop_col.push(prod[0]);
            rule_col.push(prod[1]);
        }

        var def_arr = {
            'len': len_col,
            'pop': pop_col,
            'rule': rule_col
        };
        return def_arr;
    }

    // table is hash of 1/2-len arrays:
    function analyzeSetForCompression(table) {
        // column: row index
        var idx_col = [];
        // column: REDUCE productions' goto column
        var goto_col = [];

        var i;
        for (i in table) {
            i = +i;
            var prod = table[i];
            idx_col.push(i);

            // and the special knowledge about the defaultActions[] table:
            assert(typeof prod === 'number');
            goto_col.push(prod);
        }

        var def_arr = {
            'idx': idx_col,
            'goto': goto_col
        };
        return def_arr;
    }

    function analyzeGotoTableForCompression(table) {
        // column: number of symbol hash entries per state slot ('length'):
        var len_col = [];
        // column: symbol hash entry key for each slot ('symbol'):
        var symbol_col = [];
        // column: symbol hash entry value type: number (0) or array (array.length) ('type'):
        var type_col = [];
        // column: symbol hash entry value if single GOTO state number ('state'):
        var state_col = [];
        // column: symbol hash entry mode value if array slot type (reduce/shift/accept):
        var mode_col = [];
        // column: symbol hash entry goto state value if array slot type:
        var goto_col = [];
        // // column: merged: state_col + goto_col:
        // var next_col = [];

        var row_count = table.length;
        for (var state = 0; state < row_count; state++) {
            var hashtable = table[state];
            var count = 0;
            var symbol;
            for (symbol in hashtable) {
                symbol = +symbol;
                symbol_col.push(symbol);

                var slot = hashtable[symbol];
                if (slot && slot.length) {
                    // array type slot:
                    assert(slot.length === 2 || slot.length === 1);
                    assert(slot.length === 1 ? slot[0] === 3 /* $accept */ : true);
                    type_col.push(slot.length);
                    if (slot.length > 1) {
                        mode_col.push(slot[0]);
                        goto_col.push(slot[1]);
                        //next_col.push(slot[1]);
                    }
                } else if (slot) {
                    // number type slot:
                    type_col.push(0);
                    state_col.push(slot);
                    //next_col.push(slot);
                } else {
                    assert(0);
                    type_col.push(666);
                    state_col.push((typeof slot === 'undefined' ? 'undefined' : _typeof(slot)) + state + '/' + symbol);
                    //next_col.push((typeof slot) + state + '/' + symbol);
                }
                count++;
            }
            len_col.push(count);
        }

        var def_arr = {
            'len': len_col,
            'symbol': symbol_col,
            'type': type_col,
            'state': state_col,
            'mode': mode_col,
            'goto': goto_col
            //'next': next_col,
        };
        return def_arr;
    }

    var has_compressed_a_table = false;

    function generateColumn(name, col) {
        var rv = [];
        var i, j, len, l;

        for (i = 0, len = col.length; i < len; i++) {
            // try basic run-length encoding first:
            var v = col[i];

            for (j = i + 1; j < len; j++) {
                if (col[j] !== v) {
                    break;
                }
            }
            var runlength = j - i;

            // try stepped run-length encoding next:
            var delta = col[i + 1] - v;
            var steplength = 0;

            // we don't want to replicate the runlength result, so only look for a match
            // when delta !== 0:
            if (delta !== 0) {
                for (j = i + 2; j < len; j++) {
                    if (col[j] - col[j - 1] !== delta) {
                        break;
                    }
                }
                steplength = j - i;
            }

            // try to match the pattern in history:
            var best_pos = 0;
            var best_len = 0;
            var upper_bound = i - 2;
            for (j = 0; j < upper_bound; j++) {
                for (l = 0; col[j + l] === col[i + l]; l++) {}
                // No need to check for:
                //    if (j + l === i) break;
                // because we know how the c() helper function will regenerate
                // this pattern: it is perfectly fine to overlap on itself: we always
                // have an offset of relative -1 or more, so we can encode runlength
                // patterns as duplicates this way too:
                //   [4, c(0, 7)]   (note the written offset is 0!)
                // will output an sequence of 7+1 '4' values: one '4' and then 7 more.
                //
                // Encoding such a pattern as direct runlength `s(4, 8)` is cheaper
                // though. Hence we loop until `i - 2`: we want to find ABABABAB...
                // patterns, but no AAAAAA... patterns here.


                // We want the nearest offset for the longest pattern:
                if (l >= best_len) {
                    best_len = l;
                    best_pos = i - j;
                }
            }

            // weight our options now:
            var gain = [runlength - 2, steplength - 3, best_len - 2];
            var optimum_gain = Math.max.apply(null, gain);
            if (optimum_gain <= 0) {
                rv.push(v);
            } else if (optimum_gain === gain[0]) {
                rv.push('s', '[' + v + ', ' + runlength + ']');
                i += runlength - 1;
            } else if (optimum_gain === gain[1]) {
                rv.push('s', '[' + v + ', ' + steplength + ', ' + delta + ']');
                i += steplength - 1;
            } else if (optimum_gain === gain[2]) {
                rv.push('c', '[' + best_pos + ', ' + best_len + ']');
                i += best_len - 1;
            } else {
                rv.push(v);
                //assert(0);      // should never get here!
            }

            if (optimum_gain > 0) {
                has_compressed_a_table = true;
            }
        }

        var code = ['  ', name, ': ', 'u([', '\n  ', rv.join(',\n  '), // JSON.stringify(col, null, 2),
        '\n', '])'].join('');
        return code;
    }

    function generateCompressedTable(def_arr) {
        var code = ['bp({', generateColumn('pop', def_arr.pop) + ',', generateColumn('rule', def_arr.rule), '})'].join('\n');
        return code;
    }

    function generateCompressedSet(def_arr) {
        var code = ['bda({', generateColumn('idx', def_arr.idx) + ',', generateColumn('goto', def_arr.goto), '})'].join('\n');
        return code;
    }

    function generateCompressedGotoTable(def_arr) {
        var code = ['bt({', generateColumn('len', def_arr.len) + ',', generateColumn('symbol', def_arr.symbol) + ',', generateColumn('type', def_arr.type) + ',', generateColumn('state', def_arr.state) + ',', generateColumn('mode', def_arr.mode) + ',', generateColumn('goto', def_arr.goto), '})'].join('\n');
        return code;
    }

    var tableDef = analyzeGotoTableForCompression(table);
    var defaultActionsDef = analyzeSetForCompression(defaultActions);
    var productionsDef = analyzeTableForCompression(productions);

    var bp_code_container = '\n        // helper: reconstruct the productions[] table\n        function bp(s) {\n            var rv = [];\n            var p = s.pop;\n            var r = s.rule;\n            for (var i = 0, l = p.length; i < l; i++) {\n                rv.push([\n                    p[i],\n                    r[i]\n                ]);\n            }\n            return rv;\n        }\n    ';

    var bda_code_container = '\n        // helper: reconstruct the defaultActions[] table\n        function bda(s) {\n            var rv = {};\n            var d = s.idx;\n            var g = s.goto;\n            for (var i = 0, l = d.length; i < l; i++) {\n                var j = d[i];\n                rv[j] = g[i];\n            }\n            return rv;\n        }\n    ';

    var bt_code_container = '\n        // helper: reconstruct the \'goto\' table\n        function bt(s) {\n            var rv = [];\n            var d = s.len;\n            var y = s.symbol;\n            var t = s.type;\n            var a = s.state;\n            var m = s.mode;\n            var g = s.goto;\n            for (var i = 0, l = d.length; i < l; i++) {\n                var n = d[i];\n                var q = {};\n                for (var j = 0; j < n; j++) {\n                    var z = y.shift();\n                    switch (t.shift()) {\n                    case 2:\n                        q[z] = [\n                            m.shift(),\n                            g.shift()\n                        ];\n                        break;\n\n                    case 0:\n                        q[z] = a.shift();\n                        break;\n\n                    default:\n                        // type === 1: accept\n                        q[z] = [\n                            3\n                        ];\n                    }\n                }\n                rv.push(q);\n            }\n            return rv;\n        }\n    ';

    var c_s_u_code_container = '\n        // helper: runlength encoding with increment step: code, length: step (default step = 0)\n        // `this` references an array\n        function s(c, l, a) {\n            a = a || 0;\n            for (var i = 0; i < l; i++) {\n                this.push(c);\n                c += a;\n            }\n        }\n\n        // helper: duplicate sequence from *relative* offset and length.\n        // `this` references an array\n        function c(i, l) {\n            i = this.length - i;\n            for (l += i; i < l; i++) {\n                this.push(this[i]);\n            }\n        }\n\n        // helper: unpack an array using helpers and data, all passed in an array argument \'a\'.\n        function u(a) {\n            var rv = [];\n            for (var i = 0, l = a.length; i < l; i++) {\n                var e = a[i];\n                // Is this entry a helper function?\n                if (typeof e === \'function\') {\n                    i++;\n                    e.apply(rv, a[i]);\n                } else {\n                    rv.push(e);\n                }\n            }\n            return rv;\n        }\n    ';

    has_compressed_a_table = false;
    var tc = generateCompressedGotoTable(tableDef);
    var compressGotoTable = has_compressed_a_table;

    has_compressed_a_table = false;
    var dac = generateCompressedSet(defaultActionsDef);
    var compressDefaultActions = has_compressed_a_table;

    has_compressed_a_table = false;
    var pc = generateCompressedTable(productionsDef);
    var compressProductions = has_compressed_a_table;

    var compressAnything = compressProductions || compressDefaultActions || compressGotoTable;

    tableCode = (this.DEBUG || devDebug ? reportColumnsForCompression(tableDef) : '') + (compressGotoTable ? tc : tableCode);
    defaultActionsCode = (this.DEBUG || devDebug ? reportColumnsForCompression(defaultActionsDef) : '') + (compressDefaultActions ? dac : defaultActionsCode);
    productionsCode = (this.DEBUG || devDebug ? reportColumnsForCompression(productionsDef) : '') + (compressProductions ? pc : productionsCode);

    var prelude = ['', compressProductions ? bp_code_container : '', '', compressDefaultActions ? bda_code_container : '', '', compressGotoTable ? bt_code_container : '', '', c_s_u_code_container];
    if (!compressAnything) {
        prelude = [];
    }

    // Return the variable initialization code and the table code
    return {
        commonCode: prelude.join('\n'),
        tableCode: tableCode,
        defaultActionsCode: defaultActionsCode,
        productionsCode: productionsCode
    };
};

// default main method for generated commonjs modules
var commonjsMain = '\nfunction (args) {\n    // When the parser comes with its own `main` function, then use that one:\n    if (typeof exports.parser.main === \'function\') {\n      return exports.parser.main(args);\n    }\n\n    if (!args[1]) {\n        console.log(\'Usage:\', path.basename(args[0]) + \' FILE\');\n        process.exit(1);\n    }\n    var source = fs.readFileSync(path.normalize(args[1]), \'utf8\');\n    var dst = exports.parser.parse(source);\n    console.log(\'parser output:\\n\\n\', {\n        type: typeof dst,\n        value: dst\n    });\n    try {\n        console.log("\\n\\nor as JSON:\\n", JSON.stringify(dst, null, 2));\n    } catch (e) { /* ignore crashes; output MAY not be serializable! We are a generic bit of code, after all... */ }\n    var rv = 0;\n    if (typeof dst === \'number\' || typeof dst === \'boolean\') {\n        rv = dst;\n    }\n    return dst;\n}';

var commonjsMainImports = '\nvar fs = require(\'fs\');\nvar path = require(\'path\');\n';

// debug mixin for LR parser generators

function printAction(a, gen) {
    var s = a[0] === SHIFT ? 'shift token (then go to state ' + a[1] + ')' : a[0] === REDUCE ? 'reduce by rule: ' + gen.productions[a[1]] : a[0] === ACCEPT ? 'accept' : 'UNDEFINED ACTION: ' + a[0];

    return s;
}

function traceStates(trace, states, title) {
    trace('\nItem sets -- ' + title + '\n------');

    states.forEach(function (state, i) {
        trace('\nitem set', i, '\n' + state.join('\n'), '\ntransitions -> ', JSON.stringify(state.edges));
    });
    trace('\n');
}

var lrGeneratorDebug = {
    beforeparseTable: function beforeparseTable() {
        this.trace('Building parse table.');
    },
    afterparseTable: function afterparseTable() {
        var trace = this.trace;
        var self = this;
        if (this.conflicts > 0) {
            trace('\nConflicts:\n');
            this.resolutions.forEach(function (r, i) {
                if (r[2].bydefault) {
                    trace('Conflict at state: ', r[0], ', token: ', r[1], '\n  ', printAction(r[2].r, self), '\n  ', printAction(r[2].s, self));
                }
            });
            trace('\n' + this.conflicts + ' Conflict(s) found in grammar.');
        }
        trace('Done.\n');
    },
    aftercanonicalCollection: function aftercanonicalCollection(states /* as produced by `this.canonicalCollection()` */) {
        traceStates(this.trace, states, 'as produced by LR::canonicalCollection()');
    }
};

var parser = typal.beget();

generatorMixin.createParser = function createParser() {
    var sourceCodeDef = this.generateModuleExpr();

    // produce a chunk of sourcecode that's suitable for evaluation through `eval()`:
    var sourcecode = rmCommonWS(_templateObject101, sourceCodeDef.init, sourceCodeDef.src);
    var p = code_exec(sourcecode, function generated_code_exec_wrapper_jison(sourcecode) {
        //console.log("===============================PARSER TEST CODE\n", sourcecode, "\n=====================END====================\n");
        var rv = eval(sourcecode);
        return rv;
    }, mkStdOptions(this.options, {
        dumpSourceCodeOnFailure: this.DEBUG,
        throwErrorOnCompileFailure: true
    }), "parser");

    assert((typeof p === 'undefined' ? 'undefined' : _typeof(p)) === 'object');
    assert(typeof p.parse === 'function');
    assert(typeof p.parser === 'undefined');
    assert(typeof p.Parser === 'function');
    assert(_typeof(p.yy) === 'object');
    assert(typeof p.EOF === 'number');
    assert(typeof p.TERROR === 'number');
    // assert(typeof p.trace === 'function');
    assert(typeof p.JisonParserError === 'function');
    assert(typeof p.quoteName === 'function');
    assert(typeof p.originalQuoteName === 'function');
    assert(typeof p.describeSymbol === 'function');
    assert(_typeof(p.symbols_) === 'object');
    assert(_typeof(p.terminals_) === 'object');
    // assert(typeof p.nonterminals === 'undefined');
    // assert(typeof p.terminal_descriptions_ === 'undefined');
    // assert(typeof p.productions_ === 'object');
    assert(typeof p.performAction === 'function');
    assert(_typeof(p.table) === 'object');
    // assert(typeof p.defaultActions === 'object');
    assert(typeof p.parseError === 'function');
    // assert(typeof p.yyError === 'undefined');
    // assert(typeof p.yyRecovering === 'undefined');
    // assert(typeof p.yyErrOk === 'undefined');
    // assert(typeof p.yyClearIn === 'undefined');
    assert(_typeof(p.constructParseErrorInfo) === 'object');
    assert(typeof p.originalParseError === 'function');
    assert(_typeof(p.options) === 'object');
    assert(_typeof(p.cleanupAfterParse) === 'object');
    assert(_typeof(p.yyMergeLocationInfo) === 'object');
    assert(_typeof(p.lexer) === 'object' || typeof p.lexer === 'undefined');

    // for debugging
    p.productions = this.productions;
    p.unused_productions = this.unused_productions;
    p.conflicts = this.conflicts;
    if (p.conflicts && this.options.hasPartialLrUpgradeOnConflict) {
        p.conflicts_have_been_fixed = this.conflict_fixing_round;
        p.conflict_productions_LU = this.conflict_productions_LU;
        p.conflict_states_LU = this.conflict_states_LU;
    }
    p.sourceCode = sourceCodeDef;

    var self = this;
    function bind(method) {
        return function () {
            self.lexer = p.lexer;
            return method.apply(self, arguments);
        };
    }

    // backwards compatibility
    p.lexer = this.lexer;
    p.generate = bind(this.generate);
    p.generateAMDModule = bind(this.generateAMDModule);
    p.generateModule = bind(this.generateModule);
    p.generateCommonJSModule = bind(this.generateCommonJSModule);

    this.reportGrammarInformation();

    return p;
};

parser.trace = generator.trace;
parser.warn = generator.warn;
parser.error = generator.error;

var parseErrorSourceCode = '\nfunction parseError(str, hash, ExceptionClass) {\n    if (hash.recoverable) {\n        if (typeof this.trace === \'function\') {\n            this.trace(str);\n        }\n        hash.destroy();             // destroy... well, *almost*!\n    } else {\n        if (typeof this.trace === \'function\') {\n            this.trace(str);\n        }\n        if (!ExceptionClass) {\n            ExceptionClass = this.JisonParserError;\n        }\n        throw new ExceptionClass(str, hash);\n    }\n}'; // END of parseErrorSourceCode chunk

parser.parseError = lrGeneratorMixin.parseError = eval(parseErrorSourceCode + '\n\nparseError;');

generatorMixin.createLexer = function createLexer(lexerSpec, input, tokens, options) {
    // TODO: construct options from generator options:
    // lexer_options = ...
    var lexer = new RegExpLexer(lexerSpec, input, tokens, options);

    return lexer;
};

// wrapper function so we easily stringify the APIs defined inside to code *with comments*
// in the generated code:
function define_parser_APIs_1() {
    return {
        TERROR: 2,
        EOF: 1,

        // internals: defined here so the object *structure* doesn't get modified by parse() et al,
        // thus helping JIT compilers like Chrome V8.
        originalQuoteName: null,
        originalParseError: null,
        cleanupAfterParse: null,
        constructParseErrorInfo: null,
        yyMergeLocationInfo: null,

        __reentrant_call_depth: 0, // INTERNAL USE ONLY
        __error_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup
        __error_recovery_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup

        // APIs which will be set up depending on user action code analysis:
        //yyRecovering: 0,
        //yyErrOk: 0,
        //yyClearIn: 0,

        // Helper APIs
        // -----------

        // Helper function which can be overridden by user code later on: put suitable quotes around
        // literal IDs in a description string.
        quoteName: function parser_quoteName(id_str) {
            return '"' + id_str + '"';
        },

        // Return the name of the given symbol (terminal or non-terminal) as a string, when available.
        //
        // Return NULL when the symbol is unknown to the parser.
        getSymbolName: function parser_getSymbolName(symbol) {
            if (this.terminals_[symbol]) {
                return this.terminals_[symbol];
            }

            // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.
            //
            // An example of this may be where a rule's action code contains a call like this:
            //
            //      parser.getSymbolName(#$)
            //
            // to obtain a human-readable name of the current grammar rule.
            var s = this.symbols_;
            for (var key in s) {
                if (s[key] === symbol) {
                    return key;
                }
            }
            return null;
        },

        // Return a more-or-less human-readable description of the given symbol, when available,
        // or the symbol itself, serving as its own 'description' for lack of something better to serve up.
        //
        // Return NULL when the symbol is unknown to the parser.
        describeSymbol: function parser_describeSymbol(symbol) {
            if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {
                return this.terminal_descriptions_[symbol];
            } else if (symbol === this.EOF) {
                return 'end of input';
            }
            var id = this.getSymbolName(symbol);
            if (id) {
                return this.quoteName(id);
            }
            return null;
        },

        // Produce a (more or less) human-readable list of expected tokens at the point of failure.
        //
        // The produced list may contain token or token set descriptions instead of the tokens
        // themselves to help turning this output into something that easier to read by humans
        // unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,
        // expected terminals and nonterminals is produced.
        //
        // The returned list (array) will not contain any duplicate entries.
        collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {
            var TERROR = this.TERROR;
            var tokenset = [];
            var check = {};
            // Has this (error?) state been outfitted with a custom expectations description text for human consumption?
            // If so, use that one instead of the less palatable token set.
            if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {
                return [this.state_descriptions_[state]];
            }
            for (var p in this.table[state]) {
                p = +p;
                if (p !== TERROR) {
                    var d = do_not_describe ? p : this.describeSymbol(p);
                    if (d && !check[d]) {
                        tokenset.push(d);
                        check[d] = true; // Mark this token description as already mentioned to prevent outputting duplicate entries.
                    }
                }
            }
            return tokenset;
        }
    };
}

var api_set = define_parser_APIs_1();
for (var api in api_set) {
    parser[api] = api_set[api];
}

// --- START parser kernel ---
parser.parse = 'function parse(input, parseParams) {\n    var self = this;\n    var stack = new Array(128);         // token stack: stores token which leads to state at the same index (column storage)\n    var sstack = new Array(128);        // state stack: stores states (column storage)\n    var tstack = [];                    // token stack (only used when `%options token_stack` support has been enabled)\n    var vstack = new Array(128);        // semantic value stack\n    var lstack = new Array(128);        // location stack\n    var table = this.table;\n    var sp = 0;                         // \'stack pointer\': index into the stacks\n    var yyloc;\n    var yytext;\n    var yylineno;\n    var yyleng;\n\n    var symbol = 0;\n    var preErrorSymbol = 0;\n    var lastEofErrorStateDepth = Infinity;\n    var recoveringErrorInfo = null;\n    var recovering = 0;                 // (only used when the grammar contains error recovery rules)\n    var TERROR = this.TERROR;\n    var EOF = this.EOF;\n    var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = (this.options.errorRecoveryTokenDiscardCount | 0) || 3;\n    var NO_ACTION = [0, YY_ERROR_RECOVERY_COMBINE_ID /* === table.length :: ensures that anyone using this new state will fail dramatically! */];\n\n    var lexer;\n    if (this.__lexer__) {\n        lexer = this.__lexer__;\n    } else {\n        lexer = this.__lexer__ = Object.create(this.lexer);\n    }\n\n    var sharedState_yy = {\n        parseError: undefined,\n        quoteName: undefined,\n        lexer: undefined,\n        parser: undefined,\n        pre_parse: undefined,\n        post_parse: undefined,\n        pre_lex: undefined,\n        post_lex: undefined,\n        parseParamsAsMembers: parseParamsAsMembers      // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!\n    };\n\n    var ASSERT;\n    if (typeof assert !== \'function\') {\n        ASSERT = function JisonAssert(cond, msg) {\n            if (!cond) {\n                throw new Error(\'assertion failed: \' + (msg || \'***\'));\n            }\n        };\n    } else {\n        ASSERT = assert;\n    }\n\n    this.yyGetSharedState = function yyGetSharedState() {\n        return sharedState_yy;\n    };\n\n//_handle_error_with_recovery:                    // run this code when the grammar includes error recovery rules\n\n    this.yyGetErrorInfoTrack = function yyGetErrorInfoTrack() {\n        return recoveringErrorInfo;\n    };\n\n//_handle_error_no_recovery:                      // run this code when the grammar does not include any error recovery rules\n//_handle_error_end_of_section:                   // this concludes the error recovery / no error recovery code section choice above\n\n    // shallow clone objects, straight copy of simple `src` values\n    // e.g. `lexer.yytext` MAY be a complex value object,\n    // rather than a simple string/value.\n    function shallow_copy(src) {\n        if (typeof src === \'object\') {\n            var dst = {};\n            for (var k in src) {\n                if (Object.prototype.hasOwnProperty.call(src, k)) {\n                    dst[k] = src[k];\n                }\n            }\n            return dst;\n        }\n        return src;\n    }\n    function shallow_copy_noclobber(dst, src) {\n        for (var k in src) {\n            if (typeof dst[k] === \'undefined\' && Object.prototype.hasOwnProperty.call(src, k)) {\n                dst[k] = src[k];\n            }\n        }\n    }\n    function copy_yylloc(loc) {\n        var rv = shallow_copy(loc);\n        if (rv && rv.range) {\n            rv.range = rv.range.slice(0);\n        }\n        return rv;\n    }\n\n    // copy state\n    shallow_copy_noclobber(sharedState_yy, this.yy);\n\n    sharedState_yy.lexer = lexer;\n    sharedState_yy.parser = this;\n\n    var yydebug = false;\n    if (this.options.debug) {\n        yydebug = function yydebug_impl(msg, obj) {\n            var ref_list;\n            var ref_names;\n\n            function deepClone(from, sub) {\n                if (sub == null) {\n                    ref_list = [];\n                    ref_names = [];\n                    sub = \'root\';\n                }\n                if (typeof from === \'function\') return \'[Function]\';\n                if (from == null || typeof from !== \'object\') return from;\n                if (from.constructor !== Object && from.constructor !== Array) {\n                    return from;\n                }\n\n                for (var i = 0, len = ref_list.length; i < len; i++) {\n                    if (ref_list[i] === from) {\n                        return \'[Circular/Xref:\' + ref_names[i] + \']\';   // circular or cross reference\n                    }\n                }\n                ref_list.push(from);\n                ref_names.push(sub);\n\n                var to = new from.constructor();\n                for (var name in from) {\n                    if (name === \'parser\') continue;\n                    if (name === \'lexer\') continue;\n                    to[name] = deepClone(from[name], name);\n                }\n                return to;\n            }\n\n            obj = obj || {};\n            if (obj.symbol) {\n                obj.local_yytext = yytext;\n                obj.lexer_yytext = lexer.yytext;\n                obj.lexer_yylloc = lexer.yylloc;\n                obj.lexer_yyllineno = lexer.yyllineno;\n            }\n\n            // warning: here we fetch from closure (stack et al)\n            obj.symbol_stack = stack;\n            obj.state_stack = sstack;\n            obj.value_stack = vstack;\n            obj.location_stack = lstack;\n            obj.stack_pointer = sp;\n\n            // ready the object for printing:\n            obj = deepClone(obj);\n\n            // wrap try/catch in a function to help the V8 JIT compiler...\n            function yydebug_cvt(obj) {\n                var js;\n                try {\n                    var re1;\n                    if (typeof XRegExp === \'undefined\') {\n                        re1 = /  \\"([a-z_][a-z_0-9. ]*)\\": /ig;\n                    } else {\n                        re1 = new XRegExp(\'  \\"([\\\\p{Alphabetic}_][\\\\p{Alphabetic}\\\\p{Number}_. ]*)\\": \', \'g\');\n                    }\n                    js = JSON.stringify(obj, null, 2).replace(re1, \'  $1: \').replace(/[\\n\\s]+/g, \' \');\n                } catch (ex) {\n                    js = String(obj);\n                }\n                return js;\n            }\n\n            self.trace(msg, yydebug_cvt(obj), \'\\n\');\n        };\n    }\n\n    // disable debugging at run-time ANYWAY when you\'ve *explicitly* set "yy.yydebug = false":\n    if (sharedState_yy.yydebug === false) {\n        yydebug = undefined;\n    }\n\n    // *Always* setup `yyError`, `YYRECOVERING`, `yyErrOk` and `yyClearIn` functions as it is paramount\n    // to have *their* closure match ours -- if we only set them up once,\n    // any subsequent `parse()` runs will fail in very obscure ways when\n    // these functions are invoked in the user action code block(s) as\n    // their closure will still refer to the `parse()` instance which set\n    // them up. Hence we MUST set them up at the start of every `parse()` run!\n    if (this.yyError) {\n        this.yyError = function yyError(str /*, ...args */) {\n            if (yydebug) yydebug(\'yyerror: \', { message: str, args: arguments, symbol: symbol, state: state, newState: newState, recovering: recovering, action: action });\n\n//_handle_error_with_recovery:                    // run this code when the grammar includes error recovery rules\n\n            var error_rule_depth = (this.options.parserErrorsAreRecoverable ? locateNearestErrorRecoveryRule(state) : -1);\n            var expected = this.collect_expected_token_set(state);\n            var hash = this.constructParseErrorInfo(str, null, expected, (error_rule_depth >= 0));\n            // append to the old one?\n            if (recoveringErrorInfo) {\n                var esp = recoveringErrorInfo.info_stack_pointer;\n\n                recoveringErrorInfo.symbol_stack[esp] = symbol;\n                var v = this.shallowCopyErrorInfo(hash);\n                v.yyError = true;\n                v.errorRuleDepth = error_rule_depth;\n                v.recovering = recovering;\n                // v.stackSampleLength = error_rule_depth + EXTRA_STACK_SAMPLE_DEPTH;\n\n                recoveringErrorInfo.value_stack[esp] = v;\n                recoveringErrorInfo.location_stack[esp] = copy_yylloc(lexer.yylloc);\n                recoveringErrorInfo.state_stack[esp] = newState || NO_ACTION[1];\n\n                ++esp;\n                recoveringErrorInfo.info_stack_pointer = esp;\n            } else {\n                recoveringErrorInfo = this.shallowCopyErrorInfo(hash);\n                recoveringErrorInfo.yyError = true;\n                recoveringErrorInfo.errorRuleDepth = error_rule_depth;\n                recoveringErrorInfo.recovering = recovering;\n            }\n\n//_handle_error_no_recovery:                      // run this code when the grammar does not include any error recovery rules\n\n            var expected = this.collect_expected_token_set(state);\n            var hash = this.constructParseErrorInfo(str, null, expected, false);\n\n//_handle_error_end_of_section:                   // this concludes the error recovery / no error recovery code section choice above\n\n            // Add any extra args to the hash under the name `extra_error_attributes`:\n            var args = Array.prototype.slice.call(arguments, 1);\n            if (args.length) {\n                hash.extra_error_attributes = args;\n            }\n\n            var r = this.parseError(str, hash, this.JisonParserError);\n            return r;\n        };\n    }\n\n//_handle_error_with_recovery:                    // run this code when the grammar includes error recovery rules\n\n    if (this.yyRecovering) {\n        this.yyRecovering = function yyRecovering() {\n            if (yydebug) yydebug(\'yyrecovering: \', { symbol: symbol, state: state, newState: newState, recovering: recovering, action: action });\n            return recovering;\n        };\n    }\n\n    if (this.yyErrOk) {\n        this.yyErrOk = function yyErrOk() {\n            if (yydebug) yydebug(\'yyerrok: \', { symbol: symbol, state: state, newState: newState, recovering: recovering, action: action });\n            recovering = 0;\n\n            // DO NOT reset/cleanup `recoveringErrorInfo` yet: userland code\n            // MAY invoke this API before the error is actually fully\n            // recovered, in which case the parser recovery code won\'t be able\n            // to append the skipped tokens to this info object.\n            // \n            // The rest of the kernel code is safe enough that it won\'t inadvertedly\n            // re-use an old `recoveringErrorInfo` chunk so we\'ld better wait\n            // with destruction/cleanup until the end of the parse or until another\n            // fresh parse error rears its ugly head...\n            //\n            // if (recoveringErrorInfo && typeof recoveringErrorInfo.destroy === \'function\') {\n            //     recoveringErrorInfo.destroy();\n            //     recoveringErrorInfo = undefined;\n            // }\n        };\n    }\n\n    if (this.yyClearIn) {\n        this.yyClearIn = function yyClearIn() {\n            if (yydebug) yydebug(\'yyclearin: \', { symbol: symbol, newState: newState, recovering: recovering, action: action, preErrorSymbol: preErrorSymbol });\n            if (symbol === TERROR) {\n                symbol = 0;\n                yytext = null;\n                yyleng = 0;\n                yyloc = undefined;\n            }\n            preErrorSymbol = 0;\n        };\n    }\n\n//_handle_error_no_recovery:                      // run this code when the grammar does not include any error recovery rules\n//_handle_error_end_of_section:                   // this concludes the error recovery / no error recovery code section choice above\n\n    // Does the shared state override the default `parseError` that already comes with this instance?\n    if (typeof sharedState_yy.parseError === \'function\') {\n        this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {\n            if (!ExceptionClass) {\n                ExceptionClass = this.JisonParserError;\n            }\n            return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);\n        };\n    } else {\n        this.parseError = this.originalParseError;\n    }\n\n    // Does the shared state override the default `quoteName` that already comes with this instance?\n    if (typeof sharedState_yy.quoteName === \'function\') {\n        this.quoteName = function quoteNameAlt(id_str) {\n            return sharedState_yy.quoteName.call(this, id_str);\n        };\n    } else {\n        this.quoteName = this.originalQuoteName;\n    }\n\n    // set up the cleanup function; make it an API so that external code can re-use this one in case of\n    // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which\n    // case this parse() API method doesn\'t come with a `finally { ... }` block any more!\n    //\n    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,\n    //       or else your `sharedState`, etc. references will be *wrong*!\n    this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {\n        var rv;\n\n        if (invoke_post_methods) {\n            var hash;\n\n            if (sharedState_yy.post_parse || this.post_parse) {\n                // create an error hash info instance: we re-use this API in a **non-error situation**\n                // as this one delivers all parser internals ready for access by userland code.\n                hash = this.constructParseErrorInfo(null /* no error! */, null /* no exception! */, null, false);\n            }\n\n            if (sharedState_yy.post_parse) {\n                rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);\n                if (typeof rv !== \'undefined\') resultValue = rv;\n            }\n            if (this.post_parse) {\n                rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);\n                if (typeof rv !== \'undefined\') resultValue = rv;\n            }\n\n            // cleanup:\n            if (hash && hash.destroy) {\n                hash.destroy();\n            }\n        }\n\n        if (this.__reentrant_call_depth > 1) return resultValue;        // do not (yet) kill the sharedState when this is a reentrant run.\n\n        // clean up the lingering lexer structures as well:\n        if (lexer.cleanupAfterLex) {\n            lexer.cleanupAfterLex(do_not_nuke_errorinfos);\n        }\n\n        // prevent lingering circular references from causing memory leaks:\n        if (sharedState_yy) {\n            sharedState_yy.lexer = undefined;\n            sharedState_yy.parser = undefined;\n            if (lexer.yy === sharedState_yy) {\n                lexer.yy = undefined;\n            }\n        }\n        sharedState_yy = undefined;\n        this.parseError = this.originalParseError;\n        this.quoteName = this.originalQuoteName;\n\n        // nuke the vstack[] array at least as that one will still reference obsoleted user values.\n        // To be safe, we nuke the other internal stack columns as well...\n        stack.length = 0;               // fastest way to nuke an array without overly bothering the GC\n        sstack.length = 0;\n        lstack.length = 0;\n        vstack.length = 0;\n        sp = 0;\n\n        // nuke the error hash info instances created during this run.\n        // Userland code must COPY any data/references\n        // in the error hash instance(s) it is more permanently interested in.\n        if (!do_not_nuke_errorinfos) {\n            for (var i = this.__error_infos.length - 1; i >= 0; i--) {\n                var el = this.__error_infos[i];\n                if (el && typeof el.destroy === \'function\') {\n                    el.destroy();\n                }\n            }\n            this.__error_infos.length = 0;\n\n//_handle_error_with_recovery:                    // run this code when the grammar includes error recovery rules\n\n            for (var i = this.__error_recovery_infos.length - 1; i >= 0; i--) {\n                var el = this.__error_recovery_infos[i];\n                if (el && typeof el.destroy === \'function\') {\n                    el.destroy();\n                }\n            }\n            this.__error_recovery_infos.length = 0;\n\n            // `recoveringErrorInfo` is also part of the `__error_recovery_infos` array,\n            // hence has been destroyed already: no need to do that *twice*.\n            if (recoveringErrorInfo) {\n                recoveringErrorInfo = undefined;\n            }\n\n//_handle_error_no_recovery:                      // run this code when the grammar does not include any error recovery rules\n//_handle_error_end_of_section:                   // this concludes the error recovery / no error recovery code section choice above\n\n        }\n\n        return resultValue;\n    };\n\n    // merge yylloc info into a new yylloc instance.\n    //\n    // `first_index` and `last_index` MAY be UNDEFINED/NULL or these are indexes into the `lstack[]` location stack array.\n    //\n    // `first_yylloc` and `last_yylloc` MAY be UNDEFINED/NULL or explicit (custom or regular) `yylloc` instances, in which\n    // case these override the corresponding first/last indexes.\n    //\n    // `dont_look_back` is an optional flag (default: FALSE), which instructs this merge operation NOT to search\n    // through the parse location stack for a location, which would otherwise be used to construct the new (epsilon!)\n    // yylloc info.\n    //\n    // Note: epsilon rule\'s yylloc situation is detected by passing both `first_index` and `first_yylloc` as UNDEFINED/NULL.\n    this.yyMergeLocationInfo = function parser_yyMergeLocationInfo(first_index, last_index, first_yylloc, last_yylloc, dont_look_back) {\n        var i1 = first_index | 0,\n            i2 = last_index | 0;\n        var l1 = first_yylloc,\n            l2 = last_yylloc;\n        var rv;\n\n        // rules:\n        // - first/last yylloc entries override first/last indexes\n\n        if (!l1) {\n            if (first_index != null) {\n                for (var i = i1; i <= i2; i++) {\n                    l1 = lstack[i];\n                    if (l1) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (!l2) {\n            if (last_index != null) {\n                for (var i = i2; i >= i1; i--) {\n                    l2 = lstack[i];\n                    if (l2) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        // - detect if an epsilon rule is being processed and act accordingly:\n        if (!l1 && first_index == null) {\n            // epsilon rule span merger. With optional look-ahead in l2.\n            if (!dont_look_back) {\n                for (var i = (i1 || sp) - 1; i >= 0; i--) {\n                    l1 = lstack[i];\n                    if (l1) {\n                        break;\n                    }\n                }\n            }\n            if (!l1) {\n                if (!l2) {\n                    // when we still don\'t have any valid yylloc info, we\'re looking at an epsilon rule\n                    // without look-ahead and no preceding terms and/or `dont_look_back` set:\n                    // in that case we ca do nothing but return NULL/UNDEFINED:\n                    return undefined;\n                } else {\n                    // shallow-copy L2: after all, we MAY be looking\n                    // at unconventional yylloc info objects...\n                    rv = shallow_copy(l2);\n                    if (rv.range) {\n                        // shallow copy the yylloc ranges info to prevent us from modifying the original arguments\' entries:\n                        rv.range = rv.range.slice(0);\n                    }\n                    return rv;\n                }\n            } else {\n                // shallow-copy L1, then adjust first col/row 1 column past the end.\n                rv = shallow_copy(l1);\n                rv.first_line = rv.last_line;\n                rv.first_column = rv.last_column;\n                if (rv.range) {\n                    // shallow copy the yylloc ranges info to prevent us from modifying the original arguments\' entries:\n                    rv.range = rv.range.slice(0);\n                    rv.range[0] = rv.range[1];\n                }\n\n                if (l2) {\n                    // shallow-mixin L2, then adjust last col/row accordingly.\n                    shallow_copy_noclobber(rv, l2);\n                    rv.last_line = l2.last_line;\n                    rv.last_column = l2.last_column;\n                    if (rv.range && l2.range) {\n                        rv.range[1] = l2.range[1];\n                    }\n                }\n                return rv;\n            }\n        }\n\n        if (!l1) {\n            l1 = l2;\n            l2 = null;\n        }\n        if (!l1) {\n            return undefined;\n        }\n\n        // shallow-copy L1|L2, before we try to adjust the yylloc values: after all, we MAY be looking\n        // at unconventional yylloc info objects...\n        rv = shallow_copy(l1);\n\n        // first_line: ...,\n        // first_column: ...,\n        // last_line: ...,\n        // last_column: ...,\n        if (rv.range) {\n            // shallow copy the yylloc ranges info to prevent us from modifying the original arguments\' entries:\n            rv.range = rv.range.slice(0);\n        }\n\n        if (l2) {\n            shallow_copy_noclobber(rv, l2);\n            rv.last_line = l2.last_line;\n            rv.last_column = l2.last_column;\n            if (rv.range && l2.range) {\n                rv.range[1] = l2.range[1];\n            }\n        }\n\n        return rv;\n    };\n\n    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,\n    //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!\n    this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {\n        var pei = {\n            errStr: msg,\n            exception: ex,\n            text: lexer.match,\n            value: lexer.yytext,\n            token: this.describeSymbol(symbol) || symbol,\n            token_id: symbol,\n            line: lexer.yylineno,\n            loc: copy_yylloc(lexer.yylloc),\n            expected: expected,\n            recoverable: recoverable,\n            state: state,\n            action: action,\n            new_state: newState,\n            symbol_stack: stack,\n            state_stack: sstack,\n            value_stack: vstack,\n            location_stack: lstack,\n            stack_pointer: sp,\n            yy: sharedState_yy,\n            lexer: lexer,\n            parser: this,\n\n            // and make sure the error info doesn\'t stay due to potential\n            // ref cycle via userland code manipulations.\n            // These would otherwise all be memory leak opportunities!\n            //\n            // Note that only array and object references are nuked as those\n            // constitute the set of elements which can produce a cyclic ref.\n            // The rest of the members is kept intact as they are harmless.\n            destroy: function destructParseErrorInfo() {\n                // remove cyclic references added to error info:\n                // info.yy = null;\n                // info.lexer = null;\n                // info.value = null;\n                // info.value_stack = null;\n                // ...\n                var rec = !!this.recoverable;\n                for (var key in this) {\n                    if (this.hasOwnProperty(key) && typeof key === \'object\') {\n                        this[key] = undefined;\n                    }\n                }\n                this.recoverable = rec;\n            }\n        };\n        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!\n        this.__error_infos.push(pei);\n        return pei;\n    };\n\n    // clone some parts of the (possibly enhanced!) errorInfo object\n    // to give them some persistence.\n    this.shallowCopyErrorInfo = function parser_shallowCopyErrorInfo(p) {\n        var rv = shallow_copy(p);\n\n        // remove the large parts which can only cause cyclic references\n        // and are otherwise available from the parser kernel anyway.\n        delete rv.sharedState_yy;\n        delete rv.parser;\n        delete rv.lexer;\n\n        // lexer.yytext MAY be a complex value object, rather than a simple string/value:\n        rv.value = shallow_copy(rv.value);\n\n        // yylloc info:\n        rv.loc = copy_yylloc(rv.loc);\n\n        // the \'expected\' set won\'t be modified, so no need to clone it:\n        //rv.expected = rv.expected.slice(0);\n\n        //symbol stack is a simple array:\n        rv.symbol_stack = rv.symbol_stack.slice(0);\n        // ditto for state stack:\n        rv.state_stack = rv.state_stack.slice(0);\n        // clone the yylloc\'s in the location stack?:\n        rv.location_stack = rv.location_stack.map(copy_yylloc);\n        // and the value stack may carry both simple and complex values:\n        // shallow-copy the latter.\n        rv.value_stack = rv.value_stack.map(shallow_copy);\n\n        // and we don\'t bother with the sharedState_yy reference:\n        //delete rv.yy;\n\n        // now we prepare for tracking the COMBINE actions\n        // in the error recovery code path:\n        //\n        // as we want to keep the maximum error info context, we\n        // *scan* the state stack to find the first *empty* slot.\n        // This position will surely be AT OR ABOVE the current\n        // stack pointer, but we want to keep the \'used but discarded\'\n        // part of the parse stacks *intact* as those slots carry\n        // error context that may be useful when you want to produce\n        // very detailed error diagnostic reports.\n        //\n        // ### Purpose of each stack pointer:\n        //\n        // - stack_pointer: points at the top of the parse stack\n        //                  **as it existed at the time of the error\n        //                  occurrence, i.e. at the time the stack\n        //                  snapshot was taken and copied into the\n        //                  errorInfo object.**\n        // - base_pointer:  the bottom of the **empty part** of the\n        //                  stack, i.e. **the start of the rest of\n        //                  the stack space /above/ the existing\n        //                  parse stack. This section will be filled\n        //                  by the error recovery process as it\n        //                  travels the parse state machine to\n        //                  arrive at the resolving error recovery rule.**\n        // - info_stack_pointer:\n        //                  this stack pointer points to the **top of\n        //                  the error ecovery tracking stack space**, i.e.\n        //                  this stack pointer takes up the role of\n        //                  the `stack_pointer` for the error recovery\n        //                  process. Any mutations in the **parse stack**\n        //                  are **copy-appended** to this part of the\n        //                  stack space, keeping the bottom part of the\n        //                  stack (the \'snapshot\' part where the parse\n        //                  state at the time of error occurrence was kept)\n        //                  intact.\n        // - root_failure_pointer:\n        //                  copy of the `stack_pointer`...\n        //\n        for (var i = rv.stack_pointer; typeof rv.state_stack[i] !== \'undefined\'; i++) {\n            // empty\n        }\n        rv.base_pointer = i;\n        rv.info_stack_pointer = i;\n\n        rv.root_failure_pointer = rv.stack_pointer;\n\n        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!\n        this.__error_recovery_infos.push(rv);\n\n        return rv;\n    };\n\n    function getNonTerminalFromCode(symbol) {\n        var tokenName = self.getSymbolName(symbol);\n        if (!tokenName) {\n            tokenName = symbol;\n        }\n        return tokenName;\n    }\n\n//_lexer_without_token_stack:\n\n    function stdLex() {\n        var token = lexer.lex();\n        // if token isn\'t its numeric value, convert\n        if (typeof token !== \'number\') {\n            token = self.symbols_[token] || token;\n        }\n\n        return token || EOF;\n    }\n\n    function fastLex() {\n        var token = lexer.fastLex();\n        // if token isn\'t its numeric value, convert\n        if (typeof token !== \'number\') {\n            token = self.symbols_[token] || token;\n        }\n\n        return token || EOF;\n    }\n\n    var lex = stdLex;\n\n//_lexer_with_token_stack:\n\n    // lex function that supports token stacks\n    function tokenStackLex() {\n        var token;\n        token = tstack.pop() || lexer.lex() || EOF;\n        // if token isn\'t its numeric value, convert\n        if (typeof token !== \'number\') {\n            if (token instanceof Array) {\n                tstack = token;\n                token = tstack.pop();\n            }\n            // if token isn\'t its numeric value, convert\n            if (typeof token !== \'number\') {\n                token = self.symbols_[token] || token;\n            }\n        }\n\n        return token || EOF;\n    }\n\n//_lexer_with_token_stack_end:\n\n    var state, action, r, t;\n    var yyval = {\n        $: true,\n        _$: undefined,\n        yy: sharedState_yy\n    };\n    var p;\n    var yyrulelen;\n    var this_production;\n    var newState;\n    var retval = false;\n\n//_handle_error_with_recovery:                    // run this code when the grammar includes error recovery rules\n\n    // Return the rule stack depth where the nearest error rule can be found.\n    // Return -1 when no error recovery rule was found.\n    function locateNearestErrorRecoveryRule(state) {\n        var stack_probe = sp - 1;\n        var depth = 0;\n\n        // try to recover from error\n        while (stack_probe >= 0) {\n            // check for error recovery rule in this state\n            if (yydebug) yydebug(\'locateNearestErrorRecoveryRule #test#: \', { symbol: symbol, state: state, depth: depth, stackidx: sp - 1 - depth, lastidx: lastEofErrorStateDepth });\n            var t = table[state][TERROR] || NO_ACTION;\n            if (t[0]) {\n                // We need to make sure we\'re not cycling forever:\n                // once we hit EOF, even when we `yyerrok()` an error, we must\n                // prevent the core from running forever,\n                // e.g. when parent rules are still expecting certain input to\n                // follow after this, for example when you handle an error inside a set\n                // of braces which are matched by a parent rule in your grammar.\n                //\n                // Hence we require that every error handling/recovery attempt\n                // *after we\'ve hit EOF* has a diminishing state stack: this means\n                // we will ultimately have unwound the state stack entirely and thus\n                // terminate the parse in a controlled fashion even when we have\n                // very complex error/recovery code interplay in the core + user\n                // action code blocks:\n                if (yydebug) yydebug(\'locateNearestErrorRecoveryRule #found#: \', { symbol: symbol, state: state, depth: depth, stackidx: sp - 1 - depth, lastidx: lastEofErrorStateDepth });\n                if (symbol === EOF) {\n                    if (lastEofErrorStateDepth > sp - 1 - depth) {\n                        lastEofErrorStateDepth = sp - 1 - depth;\n                    } else {\n                        if (yydebug) yydebug(\'locateNearestErrorRecoveryRule #skip#: \', { symbol: symbol, state: state, depth: depth, stackidx: sp - 1 - depth, lastidx: lastEofErrorStateDepth });\n                        --stack_probe; // popStack(1): [symbol, action]\n                        state = sstack[stack_probe];\n                        ++depth;\n                        continue;\n                    }\n                }\n                return depth;\n            }\n            if (state === 0 /* $accept rule */ || stack_probe < 1) {\n                if (yydebug) yydebug(\'locateNearestErrorRecoveryRule #end=NIL#: \', { symbol: symbol, state: state, depth: depth, stackidx: sp - 1 - depth, lastidx: lastEofErrorStateDepth });\n                return -1; // No suitable error recovery rule available.\n            }\n            --stack_probe; // popStack(1): [symbol, action]\n            state = sstack[stack_probe];\n            ++depth;\n        }\n        if (yydebug) yydebug(\'locateNearestErrorRecoveryRule #EMPTY#: \', { symbol: symbol, state: state, depth: depth, stackidx: sp - 1 - depth, lastidx: lastEofErrorStateDepth });\n        return -1; // No suitable error recovery rule available.\n    }\n\n//_handle_error_no_recovery:                      // run this code when the grammar does not include any error recovery rules\n//_handle_error_end_of_section:                   // this concludes the error recovery / no error recovery code section choice above\n\n    try {\n        this.__reentrant_call_depth++;\n\n        lexer.setInput(input, sharedState_yy);\n\n        // NOTE: we *assume* no lexer pre/post handlers are set up *after* \n        // this initial `setInput()` call: hence we can now check and decide\n        // whether we\'ll go with the standard, slower, lex() API or the\n        // `fast_lex()` one:\n        if (typeof lexer.canIUse === \'function\') {\n            var lexerInfo = lexer.canIUse();\n            if (lexerInfo.fastLex && typeof fastLex === \'function\') {\n                lex = fastLex;\n            }\n        } \n\n        yyloc = lexer.yylloc;\n        lstack[sp] = yyloc;\n        vstack[sp] = null;\n        sstack[sp] = 0;\n        stack[sp] = 0;\n        ++sp;\n\n        yytext = lexer.yytext;\n        yylineno = lexer.yylineno;\n        yyleng = lexer.yyleng;\n\n        if (this.pre_parse) {\n            this.pre_parse.call(this, sharedState_yy);\n        }\n        if (sharedState_yy.pre_parse) {\n            sharedState_yy.pre_parse.call(this, sharedState_yy);\n        }\n\n        newState = sstack[sp - 1];\n        for (;;) {\n            // retrieve state number from top of stack\n            state = newState;               // sstack[sp - 1];\n\n            // use default actions if available\n            if (this.defaultActions[state]) {\n                action = 2;\n                newState = this.defaultActions[state];\n            } else {\n                // The single `==` condition below covers both these `===` comparisons in a single\n                // operation:\n                //\n                //     if (symbol === null || typeof symbol === \'undefined\') ...\n                if (!symbol) {\n                    symbol = lex();\n                }\n                // read action for current state and first input\n                t = (table[state] && table[state][symbol]) || NO_ACTION;\n                newState = t[1];\n                action = t[0];\n\n                if (yydebug) yydebug(\'after FETCH/LEX: \', { symbol: symbol, symbolID: this.terminals_ && this.terminals_[symbol], state: state, newState: newState, recovering: recovering, action: action });\n\n//_handle_error_with_recovery:                // run this code when the grammar includes error recovery rules\n\n                // handle parse error\n                if (!action) {\n                    // first see if there\'s any chance at hitting an error recovery rule:\n                    var error_rule_depth = locateNearestErrorRecoveryRule(state);\n                    var errStr = null;\n                    var errSymbolDescr = (this.describeSymbol(symbol) || symbol);\n                    var expected = this.collect_expected_token_set(state);\n\n                    if (!recovering) {\n                        // Report error\n                        if (typeof lexer.yylineno === \'number\') {\n                            errStr = \'Parse error on line \' + (lexer.yylineno + 1) + \': \';\n                        } else {\n                            errStr = \'Parse error: \';\n                        }\n\n                        if (typeof lexer.showPosition === \'function\') {\n                            errStr += \'\\n\' + lexer.showPosition(79 - 10, 10) + \'\\n\';\n                        }\n                        if (expected.length) {\n                            errStr += \'Expecting \' + expected.join(\', \') + \', got unexpected \' + errSymbolDescr;\n                        } else {\n                            errStr += \'Unexpected \' + errSymbolDescr;\n                        }\n\n                        p = this.constructParseErrorInfo(errStr, null, expected, (error_rule_depth >= 0));\n\n                        // DO NOT cleanup the old one before we start the new error info track:\n                        // the old one will *linger* on the error stack and stay alive until we \n                        // invoke the parser\'s cleanup API!\n                        recoveringErrorInfo = this.shallowCopyErrorInfo(p);\n\n                        r = this.parseError(p.errStr, p, this.JisonParserError);\n\n                        if (yydebug) yydebug(\'error recovery rule detected: \', { error_rule_depth: error_rule_depth, error: p.errStr, error_hash: p });\n                        // Protect against overly blunt userland `parseError` code which *sets*\n                        // the `recoverable` flag without properly checking first:\n                        // we always terminate the parse when there\'s no recovery rule available anyhow!\n                        if (!p.recoverable || error_rule_depth < 0) {\n                            if (typeof r !== \'undefined\') {\n                                retval = r;\n                            }\n                            break;\n                        } else {\n                            // TODO: allow parseError callback to edit symbol and or state at the start of the error recovery process...\n                        }\n                    }\n\n                    if (yydebug) yydebug(\'after ERROR DETECT: \', { error_rule_depth: error_rule_depth, error: p.errStr, error_hash: p });\n\n                    var esp = recoveringErrorInfo.info_stack_pointer;\n\n                    // just recovered from another error\n                    if (recovering === ERROR_RECOVERY_TOKEN_DISCARD_COUNT && error_rule_depth >= 0) {\n                        // SHIFT current lookahead and grab another\n                        recoveringErrorInfo.symbol_stack[esp] = symbol;\n                        recoveringErrorInfo.value_stack[esp] = shallow_copy(lexer.yytext);\n                        recoveringErrorInfo.location_stack[esp] = copy_yylloc(lexer.yylloc);\n                        recoveringErrorInfo.state_stack[esp] = newState; // push state\n                        ++esp;\n\n                        // Pick up the lexer details for the current symbol as that one is not \'look-ahead\' any more:\n                        yyleng = lexer.yyleng;\n                        yytext = lexer.yytext;\n                        yylineno = lexer.yylineno;\n                        yyloc = lexer.yylloc;\n\n                        preErrorSymbol = 0;\n                        symbol = lex();\n\n                        if (yydebug) yydebug(\'after ERROR RECOVERY-3: \', { symbol: symbol, symbolID: this.terminals_ && this.terminals_[symbol] });\n                    }\n\n                    // try to recover from error\n                    if (error_rule_depth < 0) {\n                        ASSERT(recovering > 0, "line 897");\n                        recoveringErrorInfo.info_stack_pointer = esp;\n\n                        // barf a fatal hairball when we\'re out of look-ahead symbols and none hit a match\n                        // while we are still busy recovering from another error:\n                        var po = this.__error_infos[this.__error_infos.length - 1];\n\n                        // Report error\n                        if (typeof lexer.yylineno === \'number\') {\n                            errStr = \'Parsing halted on line \' + (lexer.yylineno + 1) + \' while starting to recover from another error\';\n                        } else {\n                            errStr = \'Parsing halted while starting to recover from another error\';\n                        }\n\n                        if (po) {\n                            errStr += \' -- previous error which resulted in this fatal result: \' + po.errStr;\n                        } else {\n                            errStr += \': \';\n                        }\n\n                        if (typeof lexer.showPosition === \'function\') {\n                            errStr += \'\\n\' + lexer.showPosition(79 - 10, 10) + \'\\n\';\n                        }\n                        if (expected.length) {\n                            errStr += \'Expecting \' + expected.join(\', \') + \', got unexpected \' + errSymbolDescr;\n                        } else {\n                            errStr += \'Unexpected \' + errSymbolDescr;\n                        }\n\n                        p = this.constructParseErrorInfo(errStr, null, expected, false);\n                        if (po) {\n                            p.extra_error_attributes = po;\n                        }\n\n                        r = this.parseError(p.errStr, p, this.JisonParserError);\n                        if (typeof r !== \'undefined\') {\n                            retval = r;\n                        }\n                        break;\n                    }\n\n                    preErrorSymbol = (symbol === TERROR ? 0 : symbol); // save the lookahead token\n                    symbol = TERROR;            // insert generic error symbol as new lookahead\n\n                    const EXTRA_STACK_SAMPLE_DEPTH = 3;\n\n                    // REDUCE/COMBINE the pushed terms/tokens to a new ERROR token:\n                    recoveringErrorInfo.symbol_stack[esp] = preErrorSymbol;\n                    if (errStr) {\n                        recoveringErrorInfo.value_stack[esp] = {\n                            yytext: shallow_copy(lexer.yytext),\n                            errorRuleDepth: error_rule_depth,\n                            errStr: errStr,\n                            errorSymbolDescr: errSymbolDescr,\n                            expectedStr: expected,\n                            stackSampleLength: error_rule_depth + EXTRA_STACK_SAMPLE_DEPTH\n                        };\n                        if (yydebug) yydebug(\'Error recovery process: pushed error info item on the info stack: \', {\n                            item: vstack[sp],\n                            sp,\n                            esp,\n                            vstack,\n                            stack,\n                            sstack,\n                            combineState: NO_ACTION[1]\n                        });\n                    } else {\n                        recoveringErrorInfo.value_stack[esp] = {\n                            yytext: shallow_copy(lexer.yytext),\n                            errorRuleDepth: error_rule_depth,\n                            stackSampleLength: error_rule_depth + EXTRA_STACK_SAMPLE_DEPTH\n                        };\n                    }\n                    recoveringErrorInfo.location_stack[esp] = copy_yylloc(lexer.yylloc);\n                    recoveringErrorInfo.state_stack[esp] = newState || NO_ACTION[1];\n\n                    ++esp;\n                    recoveringErrorInfo.info_stack_pointer = esp;\n\n                    yyval.$ = recoveringErrorInfo;\n                    yyval._$ = undefined;\n\n                    yyrulelen = error_rule_depth;\n\n                    if (yydebug) yydebug(\'Error recovery process: performAction: COMBINE: \', {\n                        yyval, yytext, sp, pop_size: yyrulelen, vstack, stack, sstack,\n                        combineState: NO_ACTION[1]\n                    });\n                    r = this.performAction.call(yyval, yytext, yyleng, yylineno, yyloc, NO_ACTION[1], sp - 1, yyrulelen, vstack, lstack, stack, sstack);\n\n                    if (typeof r !== \'undefined\') {\n                        retval = r;\n                        break;\n                    }\n\n                    // pop off stack\n                    sp -= yyrulelen;\n\n                    // and move the top entries + discarded part of the parse stacks onto the error info stack:\n                    for (var idx = sp - EXTRA_STACK_SAMPLE_DEPTH, top = idx + yyrulelen; idx < top; idx++, esp++) {\n                        recoveringErrorInfo.symbol_stack[esp] = stack[idx];\n                        recoveringErrorInfo.value_stack[esp] = shallow_copy(vstack[idx]);\n                        recoveringErrorInfo.location_stack[esp] = copy_yylloc(lstack[idx]);\n                        recoveringErrorInfo.state_stack[esp] = sstack[idx];\n                    }\n\n                    recoveringErrorInfo.symbol_stack[esp] = TERROR;\n                    recoveringErrorInfo.value_stack[esp] = shallow_copy(yyval.$);\n                    recoveringErrorInfo.location_stack[esp] = copy_yylloc(yyval._$);\n\n                    // goto new state = table[STATE][NONTERMINAL]\n                    newState = sstack[sp - 1];\n\n                    if (this.defaultActions[newState]) {\n                        recoveringErrorInfo.state_stack[esp] = this.defaultActions[newState];\n                    } else {\n                        t = (table[newState] && table[newState][symbol]) || NO_ACTION;\n                        recoveringErrorInfo.state_stack[esp] = t[1];\n                    }\n\n                    ++esp;\n                    recoveringErrorInfo.info_stack_pointer = esp;\n\n                    // allow N (default: 3) real symbols to be shifted before reporting a new error\n                    recovering = ERROR_RECOVERY_TOKEN_DISCARD_COUNT;\n\n                    if (yydebug) yydebug(\'after ERROR POP: \', { error_rule_depth: error_rule_depth, symbol: symbol, preErrorSymbol: preErrorSymbol });\n\n                    // Now duplicate the standard parse machine here, at least its initial\n                    // couple of rounds until the TERROR symbol is **pushed onto the parse stack**,\n                    // as we wish to push something special then!\n                    //\n                    // Run the state machine in this copy of the parser state machine\n                    // until we *either* consume the error symbol (and its related information)\n                    // *or* we run into another error while recovering from this one\n                    // *or* we execute a `reduce` action which outputs a final parse\n                    // result (yes, that MAY happen!).\n                    //\n                    // We stay in this secondary parse loop until we have completed\n                    // the *error recovery phase* as the main parse loop (further below)\n                    // is optimized for regular parse operation and DOES NOT cope with\n                    // error recovery *at all*.\n                    //\n                    // We call the secondary parse loop just below the "slow parse loop",\n                    // while the main parse loop, which is an almost-duplicate of this one,\n                    // yet optimized for regular parse operation, is called the "fast\n                    // parse loop".\n                    //\n                    // Compare this to `bison` & (vanilla) `jison`, both of which have\n                    // only a single parse loop, which handles everything. Our goal is\n                    // to eke out every drop of performance in the main parse loop...\n\n                    ASSERT(recoveringErrorInfo, "line 1049");\n                    ASSERT(symbol === TERROR, "line 1050");\n                    ASSERT(!action, "line 1051");\n                    var errorSymbolFromParser = true;\n                    for (;;) {\n                        // retrieve state number from top of stack\n                        state = newState;               // sstack[sp - 1];\n\n                        // use default actions if available\n                        if (this.defaultActions[state]) {\n                            action = 2;\n                            newState = this.defaultActions[state];\n                        } else {\n                            // The single `==` condition below covers both these `===` comparisons in a single\n                            // operation:\n                            //\n                            //     if (symbol === null || typeof symbol === \'undefined\') ...\n                            if (!symbol) {\n                                symbol = lex();\n                                // **Warning: Edge Case**: the *lexer* may produce\n                                // TERROR tokens of its own volition: *those* TERROR\n                                // tokens should be treated like *regular tokens*\n                                // i.e. tokens which have a lexer-provided `yyvalue`\n                                // and `yylloc`:\n                                errorSymbolFromParser = false;\n                            }\n                            // read action for current state and first input\n                            t = (table[state] && table[state][symbol]) || NO_ACTION;\n                            newState = t[1];\n                            action = t[0];\n\n                            if (yydebug) yydebug(\'after FETCH/LEX: \', { symbol: symbol, symbolID: this.terminals_ && this.terminals_[symbol], state: state, newState: newState, recovering: recovering, action: action });\n\n                            // encountered another parse error? If so, break out to main loop\n                            // and take it from there!\n                            if (!action) {\n                                if (yydebug) yydebug(\'**NESTED ERROR DETECTED** while still recovering from previous error\');\n\n                                ASSERT(recoveringErrorInfo, "line 1087");\n\n                                // Prep state variables so that upon breaking out of\n                                // this "slow parse loop" and hitting the `continue;`\n                                // statement in the outer "fast parse loop" we redo\n                                // the exact same state table lookup as the one above\n                                // so that the outer=main loop will also correctly\n                                // detect the \'parse error\' state (`!action`) we have\n                                // just encountered above.\n                                newState = state;\n                                break;\n                            }\n                        }\n\n                        if (yydebug) yydebug(\'::: SLOW ERROR RECOVERY PHASE CYCLE action: \' + (action === 1 ? \'shift token \' + symbol + \' (then go to state \' + newState + \')\' : action === 2 ? \'reduce by rule: \' + newState + (function __print_rule(nt, state) {\n                            if (!nt || !nt.states || !nt.rules)\n                              return \'\';\n                            var rulename = nt.states[state];\n                            var rulespec = nt.rules[rulename][state];\n                            return \' (\' + rulespec.symbol + \' := \' + rulespec.handle + \')\';\n                        })(this.nonterminals_, newState) : action === 3 ? \'accept\' : \'???unexpected???\'), { action: action, newState: newState, recovering: recovering, symbol: symbol });\n\n                        switch (action) {\n                        // catch misc. parse failures:\n                        default:\n                            // this shouldn\'t happen, unless resolve defaults are off\n                            //\n                            // SILENTLY SIGNAL that the outer "fast parse loop" should\n                            // take care of this internal error condition:\n                            // prevent useless code duplication now/here.\n                            break;\n\n                        // shift:\n                        case 1:\n                            stack[sp] = symbol;\n                            // ### Note/Warning ###\n                            //\n                            // The *lexer* may also produce TERROR tokens on its own,\n                            // so we specifically test for the TERROR we did set up\n                            // in the error recovery logic further above!\n                            if (symbol === TERROR && errorSymbolFromParser) {\n                                // Push a special value onto the stack when we\'re\n                                // shifting the `error` symbol that is related to the\n                                // error we\'re recovering from.\n                                ASSERT(recoveringErrorInfo, "line 1131");\n                                vstack[sp] = recoveringErrorInfo;\n                                lstack[sp] = this.yyMergeLocationInfo(null, null, recoveringErrorInfo.loc, lexer.yylloc, true);\n                            } else {\n                                ASSERT(symbol !== 0, "line 1135");\n                                ASSERT(preErrorSymbol === 0, "line 1136");\n                                vstack[sp] = lexer.yytext;\n                                lstack[sp] = copy_yylloc(lexer.yylloc);\n                            }\n                            sstack[sp] = newState; // push state\n\n                            ++sp;\n                            symbol = 0;\n                            // **Warning: Edge Case**: the *lexer* may have produced\n                            // TERROR tokens of its own volition: *those* TERROR\n                            // tokens should be treated like *regular tokens*\n                            // i.e. tokens which have a lexer-provided `yyvalue`\n                            // and `yylloc`:\n                            errorSymbolFromParser = false;\n                            if (!preErrorSymbol) { // normal execution / no error\n                                // Pick up the lexer details for the current symbol as that one is not \'look-ahead\' any more:\n                                yyleng = lexer.yyleng;\n                                yytext = lexer.yytext;\n                                yylineno = lexer.yylineno;\n                                yyloc = lexer.yylloc;\n\n                                if (recovering > 0) {\n                                    recovering--;\n                                    if (yydebug) yydebug(\'... SHIFT:error rule matching: \', { recovering: recovering, symbol: symbol });\n                                }\n                            } else {\n                                // error just occurred, resume old lookahead f/ before error, *unless* that drops us straight back into error mode:\n                                ASSERT(recovering > 0, "line 1163");\n                                symbol = preErrorSymbol;\n                                preErrorSymbol = 0;\n                                if (yydebug) yydebug(\'... SHIFT:error recovery: \', { recovering: recovering, symbol: symbol });\n                                // read action for current state and first input\n                                t = (table[newState] && table[newState][symbol]) || NO_ACTION;\n                                if (!t[0] || symbol === TERROR) {\n                                    // forget about that symbol and move forward: this wasn\'t a \'forgot to insert\' error type where\n                                    // (simple) stuff might have been missing before the token which caused the error we\'re\n                                    // recovering from now...\n                                    //\n                                    // Also check if the LookAhead symbol isn\'t the ERROR token we set as part of the error\n                                    // recovery, for then this we would we idling (cycling) on the error forever.\n                                    // Yes, this does not take into account the possibility that the *lexer* may have\n                                    // produced a *new* TERROR token all by itself, but that would be a very peculiar grammar!\n                                    if (yydebug) yydebug(\'... SHIFT:error recovery: re-application of old symbol doesn\\\'t work: instead, we\\\'re moving forward now. \', { recovering: recovering, symbol: symbol });\n                                    symbol = 0;\n                                }\n                            }\n\n                            // once we have pushed the special ERROR token value,\n                            // we REMAIN in this inner, "slow parse loop" until\n                            // the entire error recovery phase has completed.\n                            //\n                            // ### Note About Edge Case ###\n                            //\n                            // Userland action code MAY already have \'reset\' the\n                            // error recovery phase marker `recovering` to ZERO(0)\n                            // while the error symbol hasn\'t been shifted onto\n                            // the stack yet. Hence we only exit this "slow parse loop"\n                            // when *both* conditions are met!\n                            ASSERT(preErrorSymbol === 0, "line 1194");\n                            if (recovering === 0) {\n                                break;\n                            }\n                            continue;\n\n                        // reduce:\n                        case 2:\n                            this_production = this.productions_[newState - 1];  // `this.productions_[]` is zero-based indexed while states start from 1 upwards...\n                            yyrulelen = this_production[1];\n\n                            if (yydebug) yydebug(\'~~~ REDUCE: \', { pop_size: yyrulelen, newState: newState, recovering: recovering, symbol: symbol });\n\n                            r = this.performAction.call(yyval, yytext, yyleng, yylineno, yyloc, newState, sp - 1, yyrulelen, vstack, lstack, stack, sstack);\n\n                            if (typeof r !== \'undefined\') {\n                                // signal end of error recovery loop AND end of outer parse loop\n                                action = 3;\n                                sp = -2;      // magic number: signal outer "fast parse loop" ACCEPT state that we already have a properly set up `retval` parser return value.\n                                retval = r;\n                                break;\n                            }\n\n                            // pop off stack\n                            sp -= yyrulelen;\n\n                            // don\'t overwrite the `symbol` variable: use a local var to speed things up:\n                            var ntsymbol = this_production[0];    // push nonterminal (reduce)\n                            stack[sp] = ntsymbol;\n                            vstack[sp] = yyval.$;\n                            lstack[sp] = yyval._$;\n                            // goto new state = table[STATE][NONTERMINAL]\n                            newState = table[sstack[sp - 1]][ntsymbol];\n                            sstack[sp] = newState;\n                            ++sp;\n                            if (yydebug) yydebug(\'REDUCED: \', { newState: newState, recovering: recovering, symbol: symbol });\n                            continue;\n\n                        // accept:\n                        case 3:\n                            retval = true;\n                            // Return the `$accept` rule\'s `$$` result, if available.\n                            //\n                            // Also note that JISON always adds this top-most `$accept` rule (with implicit,\n                            // default, action):\n                            //\n                            //     $accept: <startSymbol> $end\n                            //                  %{ $$ = $1; @$ = @1; %}\n                            //\n                            // which, combined with the parse kernel\'s `$accept` state behaviour coded below,\n                            // will produce the `$$` value output of the <startSymbol> rule as the parse result,\n                            // IFF that result is *not* `undefined`. (See also the parser kernel code.)\n                            //\n                            // In code:\n                            //\n                            //                  %{\n                            //                      @$ = @1;            // if location tracking support is included\n                            //                      if (typeof $1 !== \'undefined\')\n                            //                          return $1;\n                            //                      else\n                            //                          return true;           // the default parse result if the rule actions don\'t produce anything\n                            //                  %}\n                            sp--;\n                            if (sp >= 0 && typeof vstack[sp] !== \'undefined\') {\n                                retval = vstack[sp];\n                            }\n                            sp = -2;      // magic number: signal outer "fast parse loop" ACCEPT state that we already have a properly set up `retval` parser return value.\n                            break;\n                        }\n\n                        // break out of loop: we accept or fail with error\n                        break;\n                    }\n\n                    // should we also break out of the regular/outer parse loop,\n                    // i.e. did the parser already produce a parse result in here?!\n                    // *or* did we hit an unsupported parse state, to be handled\n                    // in the `switch/default` code further below?\n                    ASSERT(action !== 2, "line 1272");\n                    if (action === 0 || action === 1) {\n                        continue;\n                    }\n                }\n\n//_handle_error_no_recovery:                  // run this code when the grammar does not include any error recovery rules\n\n                // handle parse error\n                if (!action) {\n                    var errStr;\n                    var errSymbolDescr = (this.describeSymbol(symbol) || symbol);\n                    var expected = this.collect_expected_token_set(state);\n\n                    // Report error\n                    if (typeof lexer.yylineno === \'number\') {\n                        errStr = \'Parse error on line \' + (lexer.yylineno + 1) + \': \';\n                    } else {\n                        errStr = \'Parse error: \';\n                    }\n                    if (typeof lexer.showPosition === \'function\') {\n                        errStr += \'\\n\' + lexer.showPosition(79 - 10, 10) + \'\\n\';\n                    }\n                    if (expected.length) {\n                        errStr += \'Expecting \' + expected.join(\', \') + \', got unexpected \' + errSymbolDescr;\n                    } else {\n                        errStr += \'Unexpected \' + errSymbolDescr;\n                    }\n                    // we cannot recover from the error!\n                    p = this.constructParseErrorInfo(errStr, null, expected, false);\n                    r = this.parseError(p.errStr, p, this.JisonParserError);\n                    if (typeof r !== \'undefined\') {\n                        retval = r;\n                    }\n                    break;\n                }\n\n//_handle_error_end_of_section:                  // this concludes the error recovery / no error recovery code section choice above\n\n            }\n\n            if (yydebug) yydebug(\'::: MAIN CYCLE action: \' + (action === 1 ? \'shift token \' + symbol + \' (then go to state \' + newState + \')\' : action === 2 ? \'reduce by rule: \' + newState + (function __print_rule(nt, state) {\n                if (!nt || !nt.states || !nt.rules)\n                  return \'\';\n                var rulename = nt.states[state];\n                var rulespec = nt.rules[rulename][state];\n                return \' (\' + rulespec.symbol + \' := \' + rulespec.handle + \')\';\n            })(this.nonterminals_, newState) : action === 3 ? \'accept\' : \'???unexpected???\'), { action: action, newState: newState, recovering: recovering, symbol: symbol });\n\n            switch (action) {\n            // catch misc. parse failures:\n            default:\n                // this shouldn\'t happen, unless resolve defaults are off\n                if (action instanceof Array) {\n                    p = this.constructParseErrorInfo(\'Parse Error: multiple actions possible at state: \' + state + \', token: \' + symbol, null, null, false);\n                    r = this.parseError(p.errStr, p, this.JisonParserError);\n                    if (typeof r !== \'undefined\') {\n                        retval = r;\n                    }\n                    break;\n                }\n                // Another case of better safe than sorry: in case state transitions come out of another error recovery process\n                // or a buggy LUT (LookUp Table):\n                p = this.constructParseErrorInfo(\'Parsing halted. No viable error recovery approach available due to internal system failure.\', null, null, false);\n                r = this.parseError(p.errStr, p, this.JisonParserError);\n                if (typeof r !== \'undefined\') {\n                    retval = r;\n                }\n                break;\n\n            // shift:\n            case 1:\n                stack[sp] = symbol;\n                vstack[sp] = lexer.yytext;\n                lstack[sp] = copy_yylloc(lexer.yylloc);\n                sstack[sp] = newState; // push state\n\n                ++sp;\n                symbol = 0;\n\n                ASSERT(preErrorSymbol === 0, "line 1352");         // normal execution / no error\n                ASSERT(recovering === 0, "line 1353");             // normal execution / no error\n\n                // Pick up the lexer details for the current symbol as that one is not \'look-ahead\' any more:\n                yyleng = lexer.yyleng;\n                yytext = lexer.yytext;\n                yylineno = lexer.yylineno;\n                yyloc = lexer.yylloc;\n                continue;\n\n            // reduce:\n            case 2:\n                ASSERT(preErrorSymbol === 0, "line 1364");         // normal execution / no error\n                ASSERT(recovering === 0, "line 1365");             // normal execution / no error\n\n                this_production = this.productions_[newState - 1];  // `this.productions_[]` is zero-based indexed while states start from 1 upwards...\n                yyrulelen = this_production[1];\n\n                if (yydebug) yydebug(\'~~~ REDUCE: \', { pop_size: yyrulelen, newState: newState, recovering: recovering, symbol: symbol });\n\n                r = this.performAction.call(yyval, yytext, yyleng, yylineno, yyloc, newState, sp - 1, yyrulelen, vstack, lstack, stack, sstack);\n\n                if (typeof r !== \'undefined\') {\n                    retval = r;\n                    break;\n                }\n\n                // pop off stack\n                sp -= yyrulelen;\n\n                // don\'t overwrite the `symbol` variable: use a local var to speed things up:\n                var ntsymbol = this_production[0];    // push nonterminal (reduce)\n                stack[sp] = ntsymbol;\n                vstack[sp] = yyval.$;\n                lstack[sp] = yyval._$;\n                // goto new state = table[STATE][NONTERMINAL]\n                newState = table[sstack[sp - 1]][ntsymbol];\n                sstack[sp] = newState;\n                ++sp;\n                if (yydebug) yydebug(\'REDUCED: \', { newState: newState, recovering: recovering, symbol: symbol });\n                continue;\n\n            // accept:\n            case 3:\n                if (sp !== -2) {\n                    retval = true;\n                    // Return the `$accept` rule\'s `$$` result, if available.\n                    //\n                    // Also note that JISON always adds this top-most `$accept` rule (with implicit,\n                    // default, action):\n                    //\n                    //     $accept: <startSymbol> $end\n                    //                  %{ $$ = $1; @$ = @1; %}\n                    //\n                    // which, combined with the parse kernel\'s `$accept` state behaviour coded below,\n                    // will produce the `$$` value output of the <startSymbol> rule as the parse result,\n                    // IFF that result is *not* `undefined`. (See also the parser kernel code.)\n                    //\n                    // In code:\n                    //\n                    //                  %{\n                    //                      @$ = @1;            // if location tracking support is included\n                    //                      if (typeof $1 !== \'undefined\')\n                    //                          return $1;\n                    //                      else\n                    //                          return true;           // the default parse result if the rule actions don\'t produce anything\n                    //                  %}\n                    sp--;\n                    if (typeof vstack[sp] !== \'undefined\') {\n                        retval = vstack[sp];\n                    }\n                }\n                break;\n            }\n\n            // break out of loop: we accept or fail with error\n            break;\n        }\n    } catch (ex) {\n        // report exceptions through the parseError callback too, but keep the exception intact\n        // if it is a known parser or lexer error which has been thrown by parseError() already:\n        if (ex instanceof this.JisonParserError) {\n            throw ex;\n        }\n        else if (lexer && typeof lexer.JisonLexerError === \'function\' && ex instanceof lexer.JisonLexerError) {\n            throw ex;\n        }\n        else {\n            p = this.constructParseErrorInfo(\'Parsing aborted due to exception.\', ex, null, false);\n            retval = false;\n            r = this.parseError(p.errStr, p, this.JisonParserError);\n            if (typeof r !== \'undefined\') {\n                retval = r;\n            }\n        }\n    } finally {\n        retval = this.cleanupAfterParse(retval, true, true);\n        this.__reentrant_call_depth--;\n    }   // /finally\n\n    return retval;\n}';
// --- END parser kernel ---


/*
 * LR(0) Parser
 */

var lr0 = generator.beget(lookaheadMixin, generatorMixin, lrGeneratorMixin, {
    type: 'LR(0)',
    afterconstructor: function lr0_afterconstructor() {
        this.buildTable();
    }
});

var LR0Generator = Jison.LR0Generator = lr0.construct();

/*
 * Simple LALR(1)
 */

var lalr = generator.beget(lookaheadMixin, generatorMixin, lrGeneratorMixin, {
    type: 'LALR(1)',

    afterconstructor: function lalr_afterconstructor() {
        var self = this;

        if (this.DEBUG) {
            this.mix(lrGeneratorDebug, lalrGeneratorDebug); // mixin debug methods
        }

        for (var round = 1;; /* infinite loop if it weren't for the `break`s at the end */round++) {
            this.states = this.canonicalCollection();

            if (this.DEBUG || devDebug) {
                Jison.print('\n-------------------------------------------\nSymbol/Follow sets AFTER canonicalCollection:');
                this.displayFollowSets();
                Jison.print('\n');
            }

            this.terms_ = {};

            var newg = this.newg = typal.beget(lookaheadMixin, {
                oldg: this,
                trace: this.trace,
                nterms_: {},
                DEBUG: false,
                go_: function go_(productionSymbol, productionHandle) {
                    var stateNum = productionSymbol.split(':')[0]; // grab state #
                    assert(stateNum == +stateNum);
                    stateNum = +stateNum;
                    productionHandle = productionHandle.map(function (rhsElem) {
                        return rhsElem.slice(rhsElem.indexOf(':') + 1);
                    });
                    return this.oldg.go(stateNum, productionHandle, productionSymbol);
                }
            });
            newg.nonterminals = {};
            newg.productions = [];

            //this.inadequateStates = [];

            // if true, only lookaheads in inadequate states are computed (faster, larger table)
            // if false, lookaheads for all reductions will be computed (slower, smaller table)
            //
            // WARNING: using this has a negative effect on your error reports:
            //          a lot of 'expected' symbols are reported which are not in the real FOLLOW set,
            //          resulting in 'illogical' error messages!
            this.onDemandLookahead = !!this.options.onDemandLookahead;
            if (devDebug || this.DEBUG) Jison.print('LALR: using on-demand look-ahead: ', this.onDemandLookahead ? 'yes' : 'no');

            this.buildNewGrammar();

            if (devDebug || this.DEBUG) {
                Jison.print('\n-------------------------------------------\nSymbol/Follow sets AFTER buildNewGrammar: NEW GRAMMAR');
                newg.displayFollowSets();
                Jison.print('\n-------------------------------------------\nSymbol/Follow sets AFTER buildNewGrammar: ORIGINAL GRAMMAR');
                this.displayFollowSets();
            }

            newg.computeLookaheads();

            // backprop `nullable` value for each nonterminal and production back to original grammar:
            each(newg.nonterminals, function (newg_nt, t) {
                // extract original symbol:
                var sym;
                var a = newg_nt.symbol.split(':');
                if (a.length === 1 || a[0] === '') {
                    sym = newg_nt.symbol;
                } else {
                    a.shift();
                    sym = a.join(':');
                }
                if (self.nonterminals[sym] && newg_nt.nullable) {
                    self.nonterminals[sym].nullable = true;
                } else {
                    //console.error('cannot find symbol ', sym);
                }
            });

            if (devDebug || this.DEBUG) {
                Jison.print('\n-------------------------------------------\nSymbol/Follow sets AFTER computeLookaheads: NEW GRAMMAR');
                newg.displayFollowSets();
                Jison.print('\n-------------------------------------------\nSymbol/Follow sets AFTER computeLookaheads: ORIGINAL GRAMMAR');
                this.displayFollowSets();
            }

            this.unionLookaheads();

            if (devDebug || this.DEBUG) {
                Jison.print('\n-------------------------------------------\nSymbol/Follow sets AFTER unionLookaheads: NEW GRAMMAR');
                newg.displayFollowSets();
                Jison.print('\n-------------------------------------------\nSymbol/Follow sets AFTER unionLookaheads: ORIGINAL GRAMMAR');
                this.displayFollowSets();
            }

            this.table = this.parseTable(this.states);

            if (devDebug || this.DEBUG) {
                Jison.print('\n-------------------------------------------\nSymbol/Follow sets AFTER parseTable: NEW GRAMMAR');
                newg.displayFollowSets();
                Jison.print('\n-------------------------------------------\nSymbol/Follow sets AFTER parseTable: ORIGINAL GRAMMAR');
                this.displayFollowSets();
            }

            // When some productions are flagged as conflicting, we redo the G' generation and consequent union-ing of the productions
            // in the `.goes[]` arrays.
            //
            // Also quit when we're at the end of the conflict resolution round (which is round #2)
            if (this.conflicts === 0 || this.conflict_fixing_round || !this.options.hasPartialLrUpgradeOnConflict) {
                break;
            }

            if (devDebug > 4) {
                Jison.print('\n-------------------------------------------\nNew round to fix conflicts? Completed round:', {
                    round: round,
                    conflict_fixing_round: this.conflict_fixing_round,
                    states: this.conflict_states_LU,
                    productions: this.conflict_productions_LU
                });
            } else {
                Jison.print('\n' + '----------------------------------- NOTICE -------------------------------\n' + 'Attempting to resolve the unresolved conflicts in partial LR mode...\n\n' + 'When no conflicts are reported in the next round below, your grammar is\n' + 'accepted as mixed LR/LALR and should work as expected.\n' + '--------------------------------------------------------------------------\n\n');
            }

            this.conflict_fixing_round = true;

            // and reset the conflict trackers, which we do not use to attempt to fix the conflict in round #2:
            this.conflicts = 0;
            this.new_conflicts_found_this_round = 0;
            this.conflicting_states = [];
            this.resolutions = [];
        }

        this.defaultActions = findDefaults(this.table, this.hasErrorRecovery);
        cleanupTable(this.table);

        traceStates(this.trace, this.states, 'at the end of the LALR constructor, after cleanupTable() and findDefaults()');
    },

    lookAheads: function LALR_lookaheads(state, item) {
        return this.onDemandLookahead && !state.inadequate ? this.terminals : item.follows;
    },

    go: function LALR_go(stateNum, productionHandle, productionSymbol) {
        assert(typeof stateNum === 'number');
        var endStateNum = stateNum;
        for (var i = 0; i < productionHandle.length; i++) {
            endStateNum = this.states.item(endStateNum).edges[productionHandle[i]] || endStateNum;
        }
        if (devDebug > 0) {
            Jison.print('GO: ', {
                stateNum: stateNum,
                symbol: productionSymbol,
                endState: endStateNum
            });
        }
        return endStateNum;
    },

    goPath: function LALR_goPath(stateNum, productionHandle, productionSymbol) {
        assert(typeof stateNum === 'number');
        var endStateNum = stateNum,
            t,
            path$$1 = [];
        for (var i = 0; i < productionHandle.length; i++) {
            t = productionHandle[i] ? endStateNum + ':' + productionHandle[i] /* + ':' + productionSymbol */ : '';
            if (t) {
                this.newg.nterms_[t] = endStateNum;
            }
            path$$1.push(t);
            endStateNum = this.states.item(endStateNum).edges[productionHandle[i]] || endStateNum;
            assert(t ? typeof this.terms_[t] === 'undefined' || this.terms_[t] === productionHandle[i] : true);
            this.terms_[t] = productionHandle[i];
        }
        if (devDebug > 0) {
            Jison.print('GOPATH: ', {
                stateNum: stateNum,
                symbol: productionSymbol,
                path: path$$1,
                endState: endStateNum
            });
        }
        return {
            path: path$$1,
            endState: endStateNum
        };
    },

    // every disjoint reduction of a nonterminal becomes a production in G'
    buildNewGrammar: function LALR_buildNewGrammar() {
        var self = this,
            newg = this.newg;

        this.states.forEach(function (state, i) {
            i = +i;
            state.forEach(function LALR_buildNewHandle(item) {
                if (item.dotPosition === 0) {
                    // new symbols are a combination of state and transition symbol
                    var symbol = i + ':' + item.production.symbol;
                    assert(typeof self.terms_[symbol] === 'undefined' || self.terms_[symbol] === item.production.symbol);
                    self.terms_[symbol] = item.production.symbol;
                    newg.nterms_[symbol] = i;
                    if (!newg.nonterminals[symbol]) {
                        newg.nonterminals[symbol] = new Nonterminal(symbol);
                    }
                    var pathInfo = self.goPath(i, item.production.handle, item.production.symbol);
                    var p = new Production(symbol, pathInfo.path, newg.productions.length);
                    newg.productions.push(p);
                    newg.nonterminals[symbol].productions.push(p);

                    // store the transition that gets 'backed up to' after reduction on path
                    var handle = item.production.handle.join(' ');
                    if (self.conflict_fixing_round && self.conflict_states_LU[i]) {
                        // handle += ':C' + i;
                    }
                    if (self.conflict_fixing_round && self.conflict_productions_LU[item.production.id]) {
                        handle += ':P' + item.production.id;
                    }

                    var goes = self.states.item(pathInfo.endState).goes;
                    if (!goes[handle]) {
                        goes[handle] = [];
                    }
                    goes[handle].push(symbol);

                    if (devDebug > 2) Jison.print('new production:', {
                        prod_id: item.production.id,
                        new_prod_id: p.id,
                        state: state,
                        stateNum: i,
                        production: p,
                        item_production: item.production,
                        goes: goes,
                        handle: handle,
                        symbol: symbol,
                        pathInfo: pathInfo
                    });
                }
            });
            // if (state.inadequate) {
            //     self.inadequateStates.push(i);
            // }
        });
    },

    unionLookaheads: function LALR_unionLookaheads() {
        var self = this,
            newg = this.newg;
        // var states = !!this.onDemandLookahead ? this.inadequateStates : this.states;

        var these_states = this.states;
        these_states.forEach(function union_states_forEach(state, i) {
            i = +i;
            //assert(state.inadequate ? these_states.inadequate : true);
            var treat_me = self.onDemandLookahead ? these_states.inadequate || state.inadequate : true;
            if (state.reductions.length && treat_me) {
                state.reductions.forEach(function union_reduction_forEach(item) {
                    var follows = {};
                    for (var k = 0; k < item.follows.length; k++) {
                        follows[item.follows[k]] = true;
                    }
                    var handle = item.production.handle.join(' ');
                    if (self.conflict_fixing_round && self.conflict_states_LU[i]) {
                        // handle += ':C' + i;
                    }
                    if (self.conflict_fixing_round && self.conflict_productions_LU[item.production.id]) {
                        handle += ':P' + item.production.id;
                    }
                    if (!state.goes[handle]) {
                        state.goes[handle] = [];
                    }

                    if (devDebug > 2) Jison.print('not-yet-unioned item', {
                        handle: handle,
                        item: item,
                        follows: follows,
                        goes: state.goes,
                        state: state,
                        stateNum: i
                    });

                    state.goes[handle].forEach(function reduction_goes_forEach(symbol) {
                        newg.nonterminals[symbol].follows.forEach(function goes_follows_forEach(symbol) {
                            var terminal = self.terms_[symbol];
                            if (!follows[terminal]) {
                                follows[terminal] = true;

                                if (devDebug > 2) Jison.print('adding to FOLLOW set (union)', {
                                    terminal: terminal,
                                    nonterminal: symbol,
                                    in_follows: newg.nonterminals[symbol],
                                    out_follows: item.follows
                                });

                                item.follows.push(terminal);
                            }
                        });
                    });

                    if (devDebug > 2) Jison.print('unioned item', item);
                });
            }
        });
    }
});

var LALRGenerator = Jison.LALRGenerator = lalr.construct();

// LALR generator debug mixin

var lalrGeneratorDebug = {
    beforebuildNewGrammar: function beforebuildNewGrammar() {
        this.trace(this.states.size() + ' states.');
        this.trace('Building lookahead grammar.');
    },
    beforeunionLookaheads: function beforeunionLookaheads() {
        this.trace('Computing lookaheads.');
    },
    afterbuildNewGrammar: function afterbuildNewGrammar() {
        traceStates(this.trace, this.states, 'after LALR::buildNewGrammar()');
    },
    afterunionLookaheads: function afterunionLookaheads() {
        traceStates(this.trace, this.states, 'after LALR::unionLookaheads()');
    },
    aftercomputeLookaheads: function aftercomputeLookaheads() {
        traceStates(this.trace, this.states, 'after LALR::computeLookaheads()');
    },
    aftercanonicalCollection: function aftercanonicalCollection(states /* as produced by `this.canonicalCollection()` */) {
        traceStates(this.trace, states, 'as produced by LALR::canonicalCollection()');
    }
};

/*
 * Lookahead parser definitions
 *
 * Define base type
 */
var lrLookaheadGenerator = generator.beget(lookaheadMixin, generatorMixin, lrGeneratorMixin, {
    afterconstructor: function lr_aftercontructor() {
        this.computeLookaheads();

        if (devDebug || this.DEBUG) {
            Jison.print('\n-------------------------------------------\nSymbol/Follow sets AFTER computeLookaheads:');
            this.displayFollowSets();
            Jison.print('\n');
        }

        this.buildTable();
    }
});

/*
 * SLR Parser
 */
var SLRGenerator = Jison.SLRGenerator = lrLookaheadGenerator.construct({
    type: 'SLR(1)',

    lookAheads: function SLR_lookAhead(state, item) {
        return this.nonterminals[item.production.symbol].follows;
    }
});

/*
 * LR(1) Parser
 */
var lr1 = lrLookaheadGenerator.beget({
    type: 'Canonical LR(1)',

    lookAheads: function LR_lookAheads(state, item) {
        return item.follows;
    },

    Item: lrGeneratorMixin.Item.prototype.construct({
        afterconstructor: function afterconstructor() {
            this.id = this.production.id + '#' + this.dotPosition + '#' + this.follows.sort().join(',');
        },
        eq: function eq(e) {
            return e.id === this.id;
        }
    }),

    closureOperation: function LR_ClosureOperation(itemSet) {
        var closureSet = new this.ItemSet();
        var self = this;

        var set = itemSet,
            itemQueue;

        do {
            itemQueue = new Set();
            closureSet = closureSet.concat(set);
            set.forEach(function LR_AddItemToClosureSets(item) {
                var symbol = item.markedSymbol;
                var b, r;

                // if token is a nonterminal, recursively add closures
                if (symbol && self.nonterminals[symbol]) {
                    r = item.remainingHandle();
                    b = self.first(r);
                    if (b.length === 0 || item.production.nullable || self.nullable(r)) {
                        b = b.concat(item.follows);
                    }
                    self.nonterminals[symbol].productions.forEach(function (production) {
                        var newItem = new self.Item(production, 0, b);
                        if (!closureSet.contains(newItem) && !itemQueue.contains(newItem)) {
                            itemQueue.push(newItem);
                        }
                    });
                } else if (!symbol) {
                    // reduction
                    closureSet.reductions.push(item);
                }
            });

            set = itemQueue;
        } while (!itemQueue.isEmpty());

        return closureSet;
    }
});

var LR1Generator = Jison.LR1Generator = lr1.construct();

/*
 * LL Parser
 */
var ll = generator.beget(lookaheadMixin, generatorMixin, lrGeneratorMixin, {
    type: 'LL(1)',

    afterconstructor: function ll_aftercontructor() {
        this.computeLookaheads();

        if (devDebug || this.DEBUG) {
            Jison.print('\n-------------------------------------------\nSymbol/Follow sets AFTER computeLookaheads:');
            this.displayFollowSets();
        }

        this.table = this.parseTable(this.productions);

        if (devDebug || this.DEBUG) {
            Jison.print('\n-------------------------------------------\nSymbol/Follow sets AFTER parseTable:');
            this.displayFollowSets();
        }

        this.defaultActions = {}; // findDefaults(this.table, this.hasErrorRecovery);
        //cleanupTable(this.table);
    },

    parseTable: function ll_ParseTable(productions) {
        var table = {},
            symbols_ = this.symbols_,
            self = this;

        productions.forEach(function (production, i) {
            var row = table[production.symbol] || {};
            var tokens = production.first;
            if (self.nullable(production.handle)) {
                tokens = union(tokens, self.nonterminals[production.symbol].follows);
            }
            tokens.forEach(function (token) {
                if (row[token]) {
                    row[token].push(i);
                    self.conflicts++;
                } else {
                    row[token] = [i];
                }
            });
            table[production.symbol] = row;
            production.first = tokens;
        });

        return table;
    }
});

var LLGenerator = Jison.LLGenerator = ll.construct();

Jison.Generator = function Jison_Generator(grammar, optionalLexerSection, options) {
    // pick the correct argument for the `options` for this call:
    if (!options && optionalLexerSection && typeof optionalLexerSection !== 'string') {
        options = optionalLexerSection;
        optionalLexerSection = null;
    }
    // and standardize it:
    var preliminary_options = mkStdOptions(options);

    // Provisionally parse the grammar, really only to obtain the *options.type*
    // specified within the grammar, if specified (via `%parser-type`).
    //
    // Meanwhile, we *auto-detect* if the input is in JSON or JISON format
    // and parse the specs, so we don't have to, nor should we have to, do
    // *that* activity again in the specific generators below: they all
    // share a common grammar+lexer spec format (JSON/JSON5/JISON) which will
    // be parsed by `autodetectAndConvertToJSONformat()` right now!
    grammar = autodetectAndConvertToJSONformat(grammar, optionalLexerSection, preliminary_options);

    // make sure all options are 'standardized' before we go and mix them together
    //
    // WARNING:
    // make sure to mix together the **original options sets** as it's last-come-last-serve
    // in `mkStdOptions` and you don't want the mixed in defaults carried in `preliminary_options`
    // to percolate into the final options set as if those we overrides coming in from
    // the API (via the `options` parameter above)!
    //
    // Anyway, API/CLI options **override** options coming in from the grammar spec.
    //
    options = mkStdOptions("NODEFAULT", grammar.options, options);
    switch (options.type || Jison.defaultJisonOptions.type) {
        case 'lr0':
            options.hasPartialLrUpgradeOnConflict = false; // kill this unsupported option
            return new LR0Generator(grammar, null, options);
        case 'slr':
            options.hasPartialLrUpgradeOnConflict = false; // kill this unsupported option
            return new SLRGenerator(grammar, null, options);
        case 'lr':
        case 'lr1':
            options.hasPartialLrUpgradeOnConflict = false; // kill this unsupported option
            return new LR1Generator(grammar, null, options);
        case 'll':
        case 'll1':
            options.hasPartialLrUpgradeOnConflict = false; // kill this unsupported option
            return new LLGenerator(grammar, null, options);
        case 'lalr1':
        case 'lalr':
        case '':
            return new LALRGenerator(grammar, null, options);
        default:
            throw new Error('Unsupported parser type: ' + options.type);
    }
};

function Parser(g, l, options) {
    var gen = Jison.Generator(g, l, options);
    return gen.createParser();
}

Jison.Parser = Parser;

module.exports = Jison;

}).call(this,require('_process'))
},{"@gerhobbelt/ast-util":27,"@gerhobbelt/json5":30,"@gerhobbelt/recast":41,"@gerhobbelt/xregexp":70,"_process":146,"assert":72,"fs":74,"path":144}],2:[function(require,module,exports){

Jison = require('./dist/jison-cjs-es5.js');

},{"./dist/jison-cjs-es5.js":1}],3:[function(require,module,exports){
module.exports = function (fork) {
    fork.use(require("./es7"));

    var types = fork.use(require("../lib/types"));
    var defaults = fork.use(require("../lib/shared")).defaults;
    var def = types.Type.def;
    var or = types.Type.or;

    def("Noop")
        .bases("Node")
        .build();

    def("DoExpression")
        .bases("Expression")
        .build("body")
        .field("body", [def("Statement")]);

    def("Super")
        .bases("Expression")
        .build();

    def("BindExpression")
        .bases("Expression")
        .build("object", "callee")
        .field("object", or(def("Expression"), null))
        .field("callee", def("Expression"));

    def("Decorator")
        .bases("Node")
        .build("expression")
        .field("expression", def("Expression"));

    def("Property")
        .field("decorators",
            or([def("Decorator")], null),
            defaults["null"]);

    def("MethodDefinition")
        .field("decorators",
            or([def("Decorator")], null),
            defaults["null"]);

    def("MetaProperty")
        .bases("Expression")
        .build("meta", "property")
        .field("meta", def("Identifier"))
        .field("property", def("Identifier"));

    def("ParenthesizedExpression")
        .bases("Expression")
        .build("expression")
        .field("expression", def("Expression"));

    def("ImportSpecifier")
        .bases("ModuleSpecifier")
        .build("imported", "local")
        .field("imported", def("Identifier"));

    def("ImportDefaultSpecifier")
        .bases("ModuleSpecifier")
        .build("local");

    def("ImportNamespaceSpecifier")
        .bases("ModuleSpecifier")
        .build("local");

    def("ExportDefaultDeclaration")
        .bases("Declaration")
        .build("declaration")
        .field("declaration", or(def("Declaration"), def("Expression")));

    def("ExportNamedDeclaration")
        .bases("Declaration")
        .build("declaration", "specifiers", "source")
        .field("declaration", or(def("Declaration"), null))
        .field("specifiers", [def("ExportSpecifier")], defaults.emptyArray)
        .field("source", or(def("Literal"), null), defaults["null"]);

    def("ExportSpecifier")
        .bases("ModuleSpecifier")
        .build("local", "exported")
        .field("exported", def("Identifier"));

    def("ExportNamespaceSpecifier")
        .bases("Specifier")
        .build("exported")
        .field("exported", def("Identifier"));

    def("ExportDefaultSpecifier")
        .bases("Specifier")
        .build("exported")
        .field("exported", def("Identifier"));

    def("ExportAllDeclaration")
        .bases("Declaration")
        .build("exported", "source")
        .field("exported", or(def("Identifier"), null))
        .field("source", def("Literal"));

    def("CommentBlock")
        .bases("Comment")
        .build("value", /*optional:*/ "leading", "trailing");

    def("CommentLine")
        .bases("Comment")
        .build("value", /*optional:*/ "leading", "trailing");
};
},{"../lib/shared":20,"../lib/types":21,"./es7":9}],4:[function(require,module,exports){
module.exports = function (fork) {
  fork.use(require("./babel"));

  // var types = fork.types;
  var types = fork.use(require("../lib/types"));
  // var defaults = fork.shared.defaults;
  var defaults = fork.use(require("../lib/shared")).defaults;
  var def = types.Type.def;
  var or = types.Type.or;

  def("Directive")
    .bases("Node")
    .build("value")
    .field("value", def("DirectiveLiteral"));

  def("DirectiveLiteral")
    .bases("Node", "Expression")
    .build("value")
    .field("value", String, defaults["use strict"]);

  def("BlockStatement")
    .bases("Statement")
    .build("body")
    .field("body", [def("Statement")])
    .field("directives", [def("Directive")], defaults.emptyArray);

  def("Program")
    .bases("Node")
    .build("body")
    .field("body", [def("Statement")])
    .field("directives", [def("Directive")], defaults.emptyArray);

  // Split Literal
  def("StringLiteral")
    .bases("Literal")
    .build("value")
    .field("value", String);

  def("NumericLiteral")
    .bases("Literal")
    .build("value")
    .field("value", Number);

  def("NullLiteral")
    .bases("Literal")
    .build()
    .field("value", null, defaults["null"]);

  def("BooleanLiteral")
    .bases("Literal")
    .build("value")
    .field("value", Boolean);

  def("RegExpLiteral")
    .bases("Literal")
    .build("pattern", "flags")
    .field("pattern", String)
    .field("flags", String)
    .field("value", RegExp, function () {
      return new RegExp(this.pattern, this.flags);
    });

  var ObjectExpressionProperty = or(
    def("Property"),
    def("ObjectMethod"),
    def("ObjectProperty"),
    def("SpreadProperty")
  );

  // Split Property -> ObjectProperty and ObjectMethod
  def("ObjectExpression")
    .bases("Expression")
    .build("properties")
    .field("properties", [ObjectExpressionProperty]);

  // ObjectMethod hoist .value properties to own properties
  def("ObjectMethod")
    .bases("Node", "Function")
    .build("kind", "key", "params", "body", "computed")
    .field("kind", or("method", "get", "set"))
    .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
    .field("params", [def("Pattern")])
    .field("body", def("BlockStatement"))
    .field("computed", Boolean, defaults["false"])
    .field("generator", Boolean, defaults["false"])
    .field("async", Boolean, defaults["false"])
    .field("decorators",
           or([def("Decorator")], null),
           defaults["null"]);

  def("ObjectProperty")
    .bases("Node")
    .build("key", "value")
    .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
    .field("value", or(def("Expression"), def("Pattern")))
    .field("computed", Boolean, defaults["false"]);

  var ClassBodyElement = or(
    def("MethodDefinition"),
    def("VariableDeclarator"),
    def("ClassPropertyDefinition"),
    def("ClassProperty"),
    def("ClassMethod")
  );

  // MethodDefinition -> ClassMethod
  def("ClassBody")
    .bases("Declaration")
    .build("body")
    .field("body", [ClassBodyElement]);

  def("ClassMethod")
    .bases("Declaration", "Function")
    .build("kind", "key", "params", "body", "computed", "static")
    .field("kind", or("get", "set", "method", "constructor"))
    .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
    .field("params", [def("Pattern")])
    .field("body", def("BlockStatement"))
    .field("computed", Boolean, defaults["false"])
    .field("static", Boolean, defaults["false"])
    .field("generator", Boolean, defaults["false"])
    .field("async", Boolean, defaults["false"])
    .field("decorators",
           or([def("Decorator")], null),
           defaults["null"]);

  var ObjectPatternProperty = or(
    def("Property"),
    def("PropertyPattern"),
    def("SpreadPropertyPattern"),
    def("SpreadProperty"), // Used by Esprima
    def("ObjectProperty"), // Babel 6
    def("RestProperty") // Babel 6
  );

  // Split into RestProperty and SpreadProperty
  def("ObjectPattern")
    .bases("Pattern")
    .build("properties")
    .field("properties", [ObjectPatternProperty])
    .field("decorators",
           or([def("Decorator")], null),
           defaults["null"]);

  def("SpreadProperty")
    .bases("Node")
    .build("argument")
    .field("argument", def("Expression"));

  def("RestProperty")
    .bases("Node")
    .build("argument")
    .field("argument", def("Expression"));

  def("ForAwaitStatement")
    .bases("Statement")
    .build("left", "right", "body")
    .field("left", or(
      def("VariableDeclaration"),
      def("Expression")))
    .field("right", def("Expression"))
    .field("body", def("Statement"));

  // The callee node of a dynamic import(...) expression.
  def("Import")
    .bases("Expression")
    .build();
};

},{"../lib/shared":20,"../lib/types":21,"./babel":3}],5:[function(require,module,exports){
module.exports = function (fork) {
  fork.use(require("./babel6-core"));
  fork.use(require("./flow"));
};

},{"./babel6-core":4,"./flow":11}],6:[function(require,module,exports){
module.exports = function (fork) {
    var types = fork.use(require("../lib/types"));
    var Type = types.Type;
    var def = Type.def;
    var or = Type.or;
    var shared = fork.use(require("../lib/shared"));
    var defaults = shared.defaults;
    var geq = shared.geq;

    // Abstract supertype of all syntactic entities that are allowed to have a
    // .loc field.
    def("Printable")
        .field("loc", or(
            def("SourceLocation"),
            null
        ), defaults["null"], true);

    def("Node")
        .bases("Printable")
        .field("type", String)
        .field("comments", or(
            [def("Comment")],
            null
        ), defaults["null"], true);

    def("SourceLocation")
        .build("start", "end", "source")
        .field("start", def("Position"))
        .field("end", def("Position"))
        .field("source", or(String, null), defaults["null"]);

    def("Position")
        .build("line", "column")
        .field("line", geq(1))
        .field("column", geq(0));

    def("File")
        .bases("Node")
        .build("program", "name")
        .field("program", def("Program"))
        .field("name", or(String, null), defaults["null"]);

    def("Program")
        .bases("Node")
        .build("body")
        .field("body", [def("Statement")]);

    def("Function")
        .bases("Node")
        .field("id", or(def("Identifier"), null), defaults["null"])
        .field("params", [def("Pattern")])
        .field("body", def("BlockStatement"));

    def("Statement").bases("Node");

// The empty .build() here means that an EmptyStatement can be constructed
// (i.e. it's not abstract) but that it needs no arguments.
    def("EmptyStatement").bases("Statement").build();

    def("BlockStatement")
        .bases("Statement")
        .build("body")
        .field("body", [def("Statement")]);

    // TODO Figure out how to silently coerce Expressions to
    // ExpressionStatements where a Statement was expected.
    def("ExpressionStatement")
        .bases("Statement")
        .build("expression")
        .field("expression", def("Expression"));

    def("IfStatement")
        .bases("Statement")
        .build("test", "consequent", "alternate")
        .field("test", def("Expression"))
        .field("consequent", def("Statement"))
        .field("alternate", or(def("Statement"), null), defaults["null"]);

    def("LabeledStatement")
        .bases("Statement")
        .build("label", "body")
        .field("label", def("Identifier"))
        .field("body", def("Statement"));

    def("BreakStatement")
        .bases("Statement")
        .build("label")
        .field("label", or(def("Identifier"), null), defaults["null"]);

    def("ContinueStatement")
        .bases("Statement")
        .build("label")
        .field("label", or(def("Identifier"), null), defaults["null"]);

    def("WithStatement")
        .bases("Statement")
        .build("object", "body")
        .field("object", def("Expression"))
        .field("body", def("Statement"));

    def("SwitchStatement")
        .bases("Statement")
        .build("discriminant", "cases", "lexical")
        .field("discriminant", def("Expression"))
        .field("cases", [def("SwitchCase")])
        .field("lexical", Boolean, defaults["false"]);

    def("ReturnStatement")
        .bases("Statement")
        .build("argument")
        .field("argument", or(def("Expression"), null));

    def("ThrowStatement")
        .bases("Statement")
        .build("argument")
        .field("argument", def("Expression"));

    def("TryStatement")
        .bases("Statement")
        .build("block", "handler", "finalizer")
        .field("block", def("BlockStatement"))
        .field("handler", or(def("CatchClause"), null), function () {
            return this.handlers && this.handlers[0] || null;
        })
        .field("handlers", [def("CatchClause")], function () {
            return this.handler ? [this.handler] : [];
        }, true) // Indicates this field is hidden from eachField iteration.
        .field("guardedHandlers", [def("CatchClause")], defaults.emptyArray)
        .field("finalizer", or(def("BlockStatement"), null), defaults["null"]);

    def("CatchClause")
        .bases("Node")
        .build("param", "guard", "body")
        .field("param", def("Pattern"))
        .field("guard", or(def("Expression"), null), defaults["null"])
        .field("body", def("BlockStatement"));

    def("WhileStatement")
        .bases("Statement")
        .build("test", "body")
        .field("test", def("Expression"))
        .field("body", def("Statement"));

    def("DoWhileStatement")
        .bases("Statement")
        .build("body", "test")
        .field("body", def("Statement"))
        .field("test", def("Expression"));

    def("ForStatement")
        .bases("Statement")
        .build("init", "test", "update", "body")
        .field("init", or(
            def("VariableDeclaration"),
            def("Expression"),
            null))
        .field("test", or(def("Expression"), null))
        .field("update", or(def("Expression"), null))
        .field("body", def("Statement"));

    def("ForInStatement")
        .bases("Statement")
        .build("left", "right", "body")
        .field("left", or(
            def("VariableDeclaration"),
            def("Expression")))
        .field("right", def("Expression"))
        .field("body", def("Statement"));

    def("DebuggerStatement").bases("Statement").build();

    def("Declaration").bases("Statement");

    def("FunctionDeclaration")
        .bases("Function", "Declaration")
        .build("id", "params", "body")
        .field("id", def("Identifier"));

    def("FunctionExpression")
        .bases("Function", "Expression")
        .build("id", "params", "body");

    def("VariableDeclaration")
        .bases("Declaration")
        .build("kind", "declarations")
        .field("kind", or("var", "let", "const"))
        .field("declarations", [def("VariableDeclarator")]);

    def("VariableDeclarator")
        .bases("Node")
        .build("id", "init")
        .field("id", def("Pattern"))
        .field("init", or(def("Expression"), null));

    // TODO Are all Expressions really Patterns?
    def("Expression").bases("Node", "Pattern");

    def("ThisExpression").bases("Expression").build();

    def("ArrayExpression")
        .bases("Expression")
        .build("elements")
        .field("elements", [or(def("Expression"), null)]);

    def("ObjectExpression")
        .bases("Expression")
        .build("properties")
        .field("properties", [def("Property")]);

    // TODO Not in the Mozilla Parser API, but used by Esprima.
    def("Property")
        .bases("Node") // Want to be able to visit Property Nodes.
        .build("kind", "key", "value")
        .field("kind", or("init", "get", "set"))
        .field("key", or(def("Literal"), def("Identifier")))
        .field("value", def("Expression"));

    def("SequenceExpression")
        .bases("Expression")
        .build("expressions")
        .field("expressions", [def("Expression")]);

    var UnaryOperator = or(
        "-", "+", "!", "~",
        "typeof", "void", "delete");

    def("UnaryExpression")
        .bases("Expression")
        .build("operator", "argument", "prefix")
        .field("operator", UnaryOperator)
        .field("argument", def("Expression"))
        // Esprima doesn't bother with this field, presumably because it's
        // always true for unary operators.
        .field("prefix", Boolean, defaults["true"]);

    var BinaryOperator = or(
        "==", "!=", "===", "!==",
        "<", "<=", ">", ">=",
        "<<", ">>", ">>>",
        "+", "-", "*", "/", "%",
        "&", // TODO Missing from the Parser API.
        "|", "^", "in",
        "instanceof", "..");

    def("BinaryExpression")
        .bases("Expression")
        .build("operator", "left", "right")
        .field("operator", BinaryOperator)
        .field("left", def("Expression"))
        .field("right", def("Expression"));

    var AssignmentOperator = or(
        "=", "+=", "-=", "*=", "/=", "%=",
        "<<=", ">>=", ">>>=",
        "|=", "^=", "&=");

    def("AssignmentExpression")
        .bases("Expression")
        .build("operator", "left", "right")
        .field("operator", AssignmentOperator)
        .field("left", def("Pattern"))
        .field("right", def("Expression"));

    var UpdateOperator = or("++", "--");

    def("UpdateExpression")
        .bases("Expression")
        .build("operator", "argument", "prefix")
        .field("operator", UpdateOperator)
        .field("argument", def("Expression"))
        .field("prefix", Boolean);

    var LogicalOperator = or("||", "&&");

    def("LogicalExpression")
        .bases("Expression")
        .build("operator", "left", "right")
        .field("operator", LogicalOperator)
        .field("left", def("Expression"))
        .field("right", def("Expression"));

    def("ConditionalExpression")
        .bases("Expression")
        .build("test", "consequent", "alternate")
        .field("test", def("Expression"))
        .field("consequent", def("Expression"))
        .field("alternate", def("Expression"));

    def("NewExpression")
        .bases("Expression")
        .build("callee", "arguments")
        .field("callee", def("Expression"))
        // The Mozilla Parser API gives this type as [or(def("Expression"),
        // null)], but null values don't really make sense at the call site.
        // TODO Report this nonsense.
        .field("arguments", [def("Expression")]);

    def("CallExpression")
        .bases("Expression")
        .build("callee", "arguments")
        .field("callee", def("Expression"))
        // See comment for NewExpression above.
        .field("arguments", [def("Expression")]);

    def("MemberExpression")
        .bases("Expression")
        .build("object", "property", "computed")
        .field("object", def("Expression"))
        .field("property", or(def("Identifier"), def("Expression")))
        .field("computed", Boolean, function () {
            var type = this.property.type;
            if (type === 'Literal' ||
                type === 'MemberExpression' ||
                type === 'BinaryExpression') {
                return true;
            }
            return false;
        });

    def("Pattern").bases("Node");

    def("SwitchCase")
        .bases("Node")
        .build("test", "consequent")
        .field("test", or(def("Expression"), null))
        .field("consequent", [def("Statement")]);

    def("Identifier")
        // But aren't Expressions and Patterns already Nodes? TODO Report this.
        .bases("Node", "Expression", "Pattern")
        .build("name")
        .field("name", String);

    def("Literal")
        // But aren't Expressions already Nodes? TODO Report this.
        .bases("Node", "Expression")
        .build("value")
        .field("value", or(String, Boolean, null, Number, RegExp))
        .field("regex", or({
            pattern: String,
            flags: String
        }, null), function () {
            if (this.value instanceof RegExp) {
                var flags = "";

                if (this.value.ignoreCase) flags += "i";
                if (this.value.multiline) flags += "m";
                if (this.value.global) flags += "g";

                return {
                    pattern: this.value.source,
                    flags: flags
                };
            }

            return null;
        });

    // Abstract (non-buildable) comment supertype. Not a Node.
    def("Comment")
        .bases("Printable")
        .field("value", String)
        // A .leading comment comes before the node, whereas a .trailing
        // comment comes after it. These two fields should not both be true,
        // but they might both be false when the comment falls inside a node
        // and the node has no children for the comment to lead or trail,
        // e.g. { /*dangling*/ }.
        .field("leading", Boolean, defaults["true"])
        .field("trailing", Boolean, defaults["false"]);
};
},{"../lib/shared":20,"../lib/types":21}],7:[function(require,module,exports){
module.exports = function (fork) {
    fork.use(require("./core"));
    var types = fork.use(require("../lib/types"));
    var def = types.Type.def;
    var or = types.Type.or;

    // Note that none of these types are buildable because the Mozilla Parser
    // API doesn't specify any builder functions, and nobody uses E4X anymore.

    def("XMLDefaultDeclaration")
        .bases("Declaration")
        .field("namespace", def("Expression"));

    def("XMLAnyName").bases("Expression");

    def("XMLQualifiedIdentifier")
        .bases("Expression")
        .field("left", or(def("Identifier"), def("XMLAnyName")))
        .field("right", or(def("Identifier"), def("Expression")))
        .field("computed", Boolean);

    def("XMLFunctionQualifiedIdentifier")
        .bases("Expression")
        .field("right", or(def("Identifier"), def("Expression")))
        .field("computed", Boolean);

    def("XMLAttributeSelector")
        .bases("Expression")
        .field("attribute", def("Expression"));

    def("XMLFilterExpression")
        .bases("Expression")
        .field("left", def("Expression"))
        .field("right", def("Expression"));

    def("XMLElement")
        .bases("XML", "Expression")
        .field("contents", [def("XML")]);

    def("XMLList")
        .bases("XML", "Expression")
        .field("contents", [def("XML")]);

    def("XML").bases("Node");

    def("XMLEscape")
        .bases("XML")
        .field("expression", def("Expression"));

    def("XMLText")
        .bases("XML")
        .field("text", String);

    def("XMLStartTag")
        .bases("XML")
        .field("contents", [def("XML")]);

    def("XMLEndTag")
        .bases("XML")
        .field("contents", [def("XML")]);

    def("XMLPointTag")
        .bases("XML")
        .field("contents", [def("XML")]);

    def("XMLName")
        .bases("XML")
        .field("contents", or(String, [def("XML")]));

    def("XMLAttribute")
        .bases("XML")
        .field("value", String);

    def("XMLCdata")
        .bases("XML")
        .field("contents", String);

    def("XMLComment")
        .bases("XML")
        .field("contents", String);

    def("XMLProcessingInstruction")
        .bases("XML")
        .field("target", String)
        .field("contents", or(String, null));
};
},{"../lib/types":21,"./core":6}],8:[function(require,module,exports){
module.exports = function (fork) {
  fork.use(require("./core"));
  var types = fork.use(require("../lib/types"));
  var def = types.Type.def;
  var or = types.Type.or;
  var defaults = fork.use(require("../lib/shared")).defaults;

  def("Function")
    .field("generator", Boolean, defaults["false"])
    .field("expression", Boolean, defaults["false"])
    .field("defaults", [or(def("Expression"), null)], defaults.emptyArray)
    // TODO This could be represented as a RestElement in .params.
    .field("rest", or(def("Identifier"), null), defaults["null"]);

  // The ESTree way of representing a ...rest parameter.
  def("RestElement")
    .bases("Pattern")
    .build("argument")
    .field("argument", def("Pattern"));

  def("SpreadElementPattern")
    .bases("Pattern")
    .build("argument")
    .field("argument", def("Pattern"));

  def("FunctionDeclaration")
    .build("id", "params", "body", "generator", "expression");

  def("FunctionExpression")
    .build("id", "params", "body", "generator", "expression");

  // The Parser API calls this ArrowExpression, but Esprima and all other
  // actual parsers use ArrowFunctionExpression.
  def("ArrowFunctionExpression")
    .bases("Function", "Expression")
    .build("params", "body", "expression")
    // The forced null value here is compatible with the overridden
    // definition of the "id" field in the Function interface.
    .field("id", null, defaults["null"])
    // Arrow function bodies are allowed to be expressions.
    .field("body", or(def("BlockStatement"), def("Expression")))
    // The current spec forbids arrow generators, so I have taken the
    // liberty of enforcing that. TODO Report this.
    .field("generator", false, defaults["false"]);

  def("ForOfStatement")
    .bases("Statement")
    .build("left", "right", "body")
    .field("left", or(
      def("VariableDeclaration"),
      def("Pattern")))
    .field("right", def("Expression"))
    .field("body", def("Statement"));

  def("YieldExpression")
    .bases("Expression")
    .build("argument", "delegate")
    .field("argument", or(def("Expression"), null))
    .field("delegate", Boolean, defaults["false"]);

  def("GeneratorExpression")
    .bases("Expression")
    .build("body", "blocks", "filter")
    .field("body", def("Expression"))
    .field("blocks", [def("ComprehensionBlock")])
    .field("filter", or(def("Expression"), null));

  def("ComprehensionExpression")
    .bases("Expression")
    .build("body", "blocks", "filter")
    .field("body", def("Expression"))
    .field("blocks", [def("ComprehensionBlock")])
    .field("filter", or(def("Expression"), null));

  def("ComprehensionBlock")
    .bases("Node")
    .build("left", "right", "each")
    .field("left", def("Pattern"))
    .field("right", def("Expression"))
    .field("each", Boolean);

  def("Property")
    .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
    .field("value", or(def("Expression"), def("Pattern")))
    .field("method", Boolean, defaults["false"])
    .field("shorthand", Boolean, defaults["false"])
    .field("computed", Boolean, defaults["false"]);

  def("PropertyPattern")
    .bases("Pattern")
    .build("key", "pattern")
    .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
    .field("pattern", def("Pattern"))
    .field("computed", Boolean, defaults["false"]);

  def("ObjectPattern")
    .bases("Pattern")
    .build("properties")
    .field("properties", [or(def("PropertyPattern"), def("Property"))]);

  def("ArrayPattern")
    .bases("Pattern")
    .build("elements")
    .field("elements", [or(def("Pattern"), null)]);

  def("MethodDefinition")
    .bases("Declaration")
    .build("kind", "key", "value", "static")
    .field("kind", or("constructor", "method", "get", "set"))
    .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
    .field("value", def("Function"))
    .field("computed", Boolean, defaults["false"])
    .field("static", Boolean, defaults["false"]);

  def("SpreadElement")
    .bases("Node")
    .build("argument")
    .field("argument", def("Expression"));

  def("ArrayExpression")
    .field("elements", [or(
      def("Expression"),
      def("SpreadElement"),
      def("RestElement"),
      null
    )]);

  def("NewExpression")
    .field("arguments", [or(def("Expression"), def("SpreadElement"))]);

  def("CallExpression")
    .field("arguments", [or(def("Expression"), def("SpreadElement"))]);

  // Note: this node type is *not* an AssignmentExpression with a Pattern on
  // the left-hand side! The existing AssignmentExpression type already
  // supports destructuring assignments. AssignmentPattern nodes may appear
  // wherever a Pattern is allowed, and the right-hand side represents a
  // default value to be destructured against the left-hand side, if no
  // value is otherwise provided. For example: default parameter values.
  def("AssignmentPattern")
    .bases("Pattern")
    .build("left", "right")
    .field("left", def("Pattern"))
    .field("right", def("Expression"));

  var ClassBodyElement = or(
    def("MethodDefinition"),
    def("VariableDeclarator"),
    def("ClassPropertyDefinition"),
    def("ClassProperty")
  );

  def("ClassProperty")
    .bases("Declaration")
    .build("key")
    .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
    .field("computed", Boolean, defaults["false"]);

  def("ClassPropertyDefinition") // static property
    .bases("Declaration")
    .build("definition")
    // Yes, Virginia, circular definitions are permitted.
    .field("definition", ClassBodyElement);

  def("ClassBody")
    .bases("Declaration")
    .build("body")
    .field("body", [ClassBodyElement]);

  def("ClassDeclaration")
    .bases("Declaration")
    .build("id", "body", "superClass")
    .field("id", or(def("Identifier"), null))
    .field("body", def("ClassBody"))
    .field("superClass", or(def("Expression"), null), defaults["null"]);

  def("ClassExpression")
    .bases("Expression")
    .build("id", "body", "superClass")
    .field("id", or(def("Identifier"), null), defaults["null"])
    .field("body", def("ClassBody"))
    .field("superClass", or(def("Expression"), null), defaults["null"])
    .field("implements", [def("ClassImplements")], defaults.emptyArray);

  def("ClassImplements")
    .bases("Node")
    .build("id")
    .field("id", def("Identifier"))
    .field("superClass", or(def("Expression"), null), defaults["null"]);

  // Specifier and ModuleSpecifier are abstract non-standard types
  // introduced for definitional convenience.
  def("Specifier").bases("Node");

  // This supertype is shared/abused by both def/babel.js and
  // def/esprima.js. In the future, it will be possible to load only one set
  // of definitions appropriate for a given parser, but until then we must
  // rely on default functions to reconcile the conflicting AST formats.
  def("ModuleSpecifier")
    .bases("Specifier")
    // This local field is used by Babel/Acorn. It should not technically
    // be optional in the Babel/Acorn AST format, but it must be optional
    // in the Esprima AST format.
    .field("local", or(def("Identifier"), null), defaults["null"])
    // The id and name fields are used by Esprima. The id field should not
    // technically be optional in the Esprima AST format, but it must be
    // optional in the Babel/Acorn AST format.
    .field("id", or(def("Identifier"), null), defaults["null"])
    .field("name", or(def("Identifier"), null), defaults["null"]);

  def("TaggedTemplateExpression")
    .bases("Expression")
    .build("tag", "quasi")
    .field("tag", def("Expression"))
    .field("quasi", def("TemplateLiteral"));

  def("TemplateLiteral")
    .bases("Expression")
    .build("quasis", "expressions")
    .field("quasis", [def("TemplateElement")])
    .field("expressions", [def("Expression")]);

  def("TemplateElement")
    .bases("Node")
    .build("value", "tail")
    .field("value", {"cooked": String, "raw": String})
    .field("tail", Boolean);
};

},{"../lib/shared":20,"../lib/types":21,"./core":6}],9:[function(require,module,exports){
module.exports = function (fork) {
    fork.use(require('./es6'));

    var types = fork.use(require("../lib/types"));
    var def = types.Type.def;
    var or = types.Type.or;
    var builtin = types.builtInTypes;
    var defaults = fork.use(require("../lib/shared")).defaults;

    def("Function")
      .field("async", Boolean, defaults["false"]);

    def("SpreadProperty")
      .bases("Node")
      .build("argument")
      .field("argument", def("Expression"));

    def("ObjectExpression")
      .field("properties", [or(def("Property"), def("SpreadProperty"))]);

    def("SpreadPropertyPattern")
      .bases("Pattern")
      .build("argument")
      .field("argument", def("Pattern"));

    def("ObjectPattern")
      .field("properties", [or(
        def("Property"),
        def("PropertyPattern"),
        def("SpreadPropertyPattern")
      )]);

    def("AwaitExpression")
      .bases("Expression")
      .build("argument", "all")
      .field("argument", or(def("Expression"), null))
      .field("all", Boolean, defaults["false"]);
};
},{"../lib/shared":20,"../lib/types":21,"./es6":8}],10:[function(require,module,exports){
module.exports = function (fork) {
    fork.use(require("./es7"));

    var types = fork.use(require("../lib/types"));
    var defaults = fork.use(require("../lib/shared")).defaults;
    var def = types.Type.def;
    var or = types.Type.or;

    def("VariableDeclaration")
      .field("declarations", [or(
        def("VariableDeclarator"),
        def("Identifier") // Esprima deviation.
      )]);

    def("Property")
      .field("value", or(
        def("Expression"),
        def("Pattern") // Esprima deviation.
      ));

    def("ArrayPattern")
      .field("elements", [or(
        def("Pattern"),
        def("SpreadElement"),
        null
      )]);

    def("ObjectPattern")
      .field("properties", [or(
        def("Property"),
        def("PropertyPattern"),
        def("SpreadPropertyPattern"),
        def("SpreadProperty") // Used by Esprima.
      )]);

// Like ModuleSpecifier, except type:"ExportSpecifier" and buildable.
// export {<id [as name]>} [from ...];
    def("ExportSpecifier")
      .bases("ModuleSpecifier")
      .build("id", "name");

// export <*> from ...;
    def("ExportBatchSpecifier")
      .bases("Specifier")
      .build();

// Like ModuleSpecifier, except type:"ImportSpecifier" and buildable.
// import {<id [as name]>} from ...;
    def("ImportSpecifier")
      .bases("ModuleSpecifier")
      .build("id", "name");

// import <* as id> from ...;
    def("ImportNamespaceSpecifier")
      .bases("ModuleSpecifier")
      .build("id");

// import <id> from ...;
    def("ImportDefaultSpecifier")
      .bases("ModuleSpecifier")
      .build("id");

    def("ExportDeclaration")
      .bases("Declaration")
      .build("default", "declaration", "specifiers", "source")
      .field("default", Boolean)
      .field("declaration", or(
        def("Declaration"),
        def("Expression"), // Implies default.
        null
      ))
      .field("specifiers", [or(
        def("ExportSpecifier"),
        def("ExportBatchSpecifier")
      )], defaults.emptyArray)
      .field("source", or(
        def("Literal"),
        null
      ), defaults["null"]);

    def("ImportDeclaration")
      .bases("Declaration")
      .build("specifiers", "source", "importKind")
      .field("specifiers", [or(
        def("ImportSpecifier"),
        def("ImportNamespaceSpecifier"),
        def("ImportDefaultSpecifier")
      )], defaults.emptyArray)
      .field("source", def("Literal"))
      .field("importKind", or(
        "value",
        "type"
      ), function() {
        return "value";
      });

    def("Block")
      .bases("Comment")
      .build("value", /*optional:*/ "leading", "trailing");

    def("Line")
      .bases("Comment")
      .build("value", /*optional:*/ "leading", "trailing");
};
},{"../lib/shared":20,"../lib/types":21,"./es7":9}],11:[function(require,module,exports){
module.exports = function (fork) {
    fork.use(require("./es7"));

    var types = fork.use(require("../lib/types"));
    var def = types.Type.def;
    var or = types.Type.or;
    var defaults = fork.use(require("../lib/shared")).defaults;

    // Type Annotations
    def("Type").bases("Node");

    def("AnyTypeAnnotation")
      .bases("Type")
      .build();

    def("EmptyTypeAnnotation")
      .bases("Type")
      .build();

    def("MixedTypeAnnotation")
      .bases("Type")
      .build();

    def("VoidTypeAnnotation")
      .bases("Type")
      .build();

    def("NumberTypeAnnotation")
      .bases("Type")
      .build();

    def("NumberLiteralTypeAnnotation")
      .bases("Type")
      .build("value", "raw")
      .field("value", Number)
      .field("raw", String);

    // Babylon 6 differs in AST from Flow
    // same as NumberLiteralTypeAnnotation
    def("NumericLiteralTypeAnnotation")
      .bases("Type")
      .build("value", "raw")
      .field("value", Number)
      .field("raw", String);

    def("StringTypeAnnotation")
      .bases("Type")
      .build();

    def("StringLiteralTypeAnnotation")
      .bases("Type")
      .build("value", "raw")
      .field("value", String)
      .field("raw", String);

    def("BooleanTypeAnnotation")
      .bases("Type")
      .build();

    def("BooleanLiteralTypeAnnotation")
      .bases("Type")
      .build("value", "raw")
      .field("value", Boolean)
      .field("raw", String);

    def("TypeAnnotation")
      .bases("Node")
      .build("typeAnnotation")
      .field("typeAnnotation", def("Type"));

    def("NullableTypeAnnotation")
      .bases("Type")
      .build("typeAnnotation")
      .field("typeAnnotation", def("Type"));

    def("NullLiteralTypeAnnotation")
      .bases("Type")
      .build();

    def("NullTypeAnnotation")
      .bases("Type")
      .build();

    def("ThisTypeAnnotation")
      .bases("Type")
      .build();

    def("ExistsTypeAnnotation")
      .bases("Type")
      .build();

    def("ExistentialTypeParam")
      .bases("Type")
      .build();

    def("FunctionTypeAnnotation")
      .bases("Type")
      .build("params", "returnType", "rest", "typeParameters")
      .field("params", [def("FunctionTypeParam")])
      .field("returnType", def("Type"))
      .field("rest", or(def("FunctionTypeParam"), null))
      .field("typeParameters", or(def("TypeParameterDeclaration"), null));

    def("FunctionTypeParam")
      .bases("Node")
      .build("name", "typeAnnotation", "optional")
      .field("name", def("Identifier"))
      .field("typeAnnotation", def("Type"))
      .field("optional", Boolean);

    def("ArrayTypeAnnotation")
      .bases("Type")
      .build("elementType")
      .field("elementType", def("Type"));

    def("ObjectTypeAnnotation")
      .bases("Type")
      .build("properties", "indexers", "callProperties")
      .field("properties", [def("ObjectTypeProperty")])
      .field("indexers", [def("ObjectTypeIndexer")], defaults.emptyArray)
      .field("callProperties",
        [def("ObjectTypeCallProperty")],
        defaults.emptyArray)
      .field("exact", Boolean, defaults["false"]);

    def("ObjectTypeProperty")
      .bases("Node")
      .build("key", "value", "optional")
      .field("key", or(def("Literal"), def("Identifier")))
      .field("value", def("Type"))
      .field("optional", Boolean)
      .field("variance",
        or("plus", "minus", null),
        defaults["null"]);

    def("ObjectTypeIndexer")
      .bases("Node")
      .build("id", "key", "value")
      .field("id", def("Identifier"))
      .field("key", def("Type"))
      .field("value", def("Type"))
      .field("variance",
        or("plus", "minus", null),
        defaults["null"]);

    def("ObjectTypeCallProperty")
      .bases("Node")
      .build("value")
      .field("value", def("FunctionTypeAnnotation"))
      .field("static", Boolean, defaults["false"]);

    def("QualifiedTypeIdentifier")
      .bases("Node")
      .build("qualification", "id")
      .field("qualification",
        or(def("Identifier"),
          def("QualifiedTypeIdentifier")))
      .field("id", def("Identifier"));

    def("GenericTypeAnnotation")
      .bases("Type")
      .build("id", "typeParameters")
      .field("id", or(def("Identifier"), def("QualifiedTypeIdentifier")))
      .field("typeParameters", or(def("TypeParameterInstantiation"), null));

    def("MemberTypeAnnotation")
      .bases("Type")
      .build("object", "property")
      .field("object", def("Identifier"))
      .field("property",
        or(def("MemberTypeAnnotation"),
          def("GenericTypeAnnotation")));

    def("UnionTypeAnnotation")
      .bases("Type")
      .build("types")
      .field("types", [def("Type")]);

    def("IntersectionTypeAnnotation")
      .bases("Type")
      .build("types")
      .field("types", [def("Type")]);

    def("TypeofTypeAnnotation")
      .bases("Type")
      .build("argument")
      .field("argument", def("Type"));

    def("ObjectTypeSpreadProperty")
      .bases("Node")
      .build("argument")
      .field("argument", def("Type"));

    def("Identifier")
      .field("typeAnnotation", or(def("TypeAnnotation"), null), defaults["null"]);

    def("ObjectPattern")
      .field("typeAnnotation", or(def("TypeAnnotation"), null), defaults["null"]);

    def("TypeParameterDeclaration")
      .bases("Node")
      .build("params")
      .field("params", [def("TypeParameter")]);

    def("TypeParameterInstantiation")
      .bases("Node")
      .build("params")
      .field("params", [def("Type")]);

    def("TypeParameter")
      .bases("Type")
      .build("name", "variance", "bound")
      .field("name", String)
      .field("variance",
        or("plus", "minus", null),
        defaults["null"])
      .field("bound",
        or(def("TypeAnnotation"), null),
        defaults["null"]);

    def("Function")
      .field("returnType",
        or(def("TypeAnnotation"), null),
        defaults["null"])
      .field("typeParameters",
        or(def("TypeParameterDeclaration"), null),
        defaults["null"]);

    def("ClassProperty")
      .build("key", "value", "typeAnnotation", "static")
      .field("value", or(def("Expression"), null))
      .field("typeAnnotation", or(def("TypeAnnotation"), null))
      .field("static", Boolean, defaults["false"])
      .field("variance",
        or("plus", "minus", null),
        defaults["null"]);

    def("ClassImplements")
      .field("typeParameters",
        or(def("TypeParameterInstantiation"), null),
        defaults["null"]);

    def("InterfaceDeclaration")
      .bases("Declaration")
      .build("id", "body", "extends")
      .field("id", def("Identifier"))
      .field("typeParameters",
        or(def("TypeParameterDeclaration"), null),
        defaults["null"])
      .field("body", def("ObjectTypeAnnotation"))
      .field("extends", [def("InterfaceExtends")]);

    def("DeclareInterface")
      .bases("InterfaceDeclaration")
      .build("id", "body", "extends");

    def("InterfaceExtends")
      .bases("Node")
      .build("id")
      .field("id", def("Identifier"))
      .field("typeParameters", or(def("TypeParameterInstantiation"), null));

    def("TypeAlias")
      .bases("Declaration")
      .build("id", "typeParameters", "right")
      .field("id", def("Identifier"))
      .field("typeParameters", or(def("TypeParameterDeclaration"), null))
      .field("right", def("Type"));

    def("OpaqueType")
      .bases("Declaration")
      .build("id", "typeParameters", "impltype", "supertype")
      .field("id", def("Identifier"))
      .field("typeParameters", or(def("TypeParameterDeclaration"), null))
      .field("implType", def("Type"))
      .field("superType", def("Type"));

    def("DeclareTypeAlias")
      .bases("TypeAlias")
      .build("id", "typeParameters", "right");

    def("DeclareOpaqueType")
      .bases("TypeAlias")
      .build("id", "typeParameters", "supertype");

    def("TypeCastExpression")
      .bases("Expression")
      .build("expression", "typeAnnotation")
      .field("expression", def("Expression"))
      .field("typeAnnotation", def("TypeAnnotation"));

    def("TupleTypeAnnotation")
      .bases("Type")
      .build("types")
      .field("types", [def("Type")]);

    def("DeclareVariable")
      .bases("Statement")
      .build("id")
      .field("id", def("Identifier"));

    def("DeclareFunction")
      .bases("Statement")
      .build("id")
      .field("id", def("Identifier"));

    def("DeclareClass")
      .bases("InterfaceDeclaration")
      .build("id");

    def("DeclareModule")
      .bases("Statement")
      .build("id", "body")
      .field("id", or(def("Identifier"), def("Literal")))
      .field("body", def("BlockStatement"));

    def("DeclareModuleExports")
      .bases("Statement")
      .build("typeAnnotation")
      .field("typeAnnotation", def("Type"));

    def("DeclareExportDeclaration")
      .bases("Declaration")
      .build("default", "declaration", "specifiers", "source")
      .field("default", Boolean)
      .field("declaration", or(
        def("DeclareVariable"),
        def("DeclareFunction"),
        def("DeclareClass"),
        def("Type"), // Implies default.
        null
      ))
      .field("specifiers", [or(
        def("ExportSpecifier"),
        def("ExportBatchSpecifier")
      )], defaults.emptyArray)
      .field("source", or(
        def("Literal"),
        null
      ), defaults["null"]);

    def("DeclareExportAllDeclaration")
      .bases("Declaration")
      .build("source")
      .field("source", or(
        def("Literal"),
        null
      ), defaults["null"]);
      
    def("DeclareModuleExports")
      .bases("Statement")
      .build("typeAnnotation")
      .field("typeAnnotation", def("TypeAnnotation"));
};

},{"../lib/shared":20,"../lib/types":21,"./es7":9}],12:[function(require,module,exports){
module.exports = function (fork) {
  fork.use(require("./es7"));

  var types = fork.use(require("../lib/types"));
  var def = types.Type.def;
  var or = types.Type.or;
  var defaults = fork.use(require("../lib/shared")).defaults;

  def("JSXAttribute")
    .bases("Node")
    .build("name", "value")
    .field("name", or(def("JSXIdentifier"), def("JSXNamespacedName")))
    .field("value", or(
      def("Literal"), // attr="value"
      def("JSXExpressionContainer"), // attr={value}
      null // attr= or just attr
    ), defaults["null"]);

  def("JSXIdentifier")
    .bases("Identifier")
    .build("name")
    .field("name", String);

  def("JSXNamespacedName")
    .bases("Node")
    .build("namespace", "name")
    .field("namespace", def("JSXIdentifier"))
    .field("name", def("JSXIdentifier"));

  def("JSXMemberExpression")
    .bases("MemberExpression")
    .build("object", "property")
    .field("object", or(def("JSXIdentifier"), def("JSXMemberExpression")))
    .field("property", def("JSXIdentifier"))
    .field("computed", Boolean, defaults.false);

  var JSXElementName = or(
    def("JSXIdentifier"),
    def("JSXNamespacedName"),
    def("JSXMemberExpression")
  );

  def("JSXSpreadAttribute")
    .bases("Node")
    .build("argument")
    .field("argument", def("Expression"));

  var JSXAttributes = [or(
    def("JSXAttribute"),
    def("JSXSpreadAttribute")
  )];

  def("JSXExpressionContainer")
    .bases("Expression")
    .build("expression")
    .field("expression", def("Expression"));

  def("JSXElement")
    .bases("Expression")
    .build("openingElement", "closingElement", "children")
    .field("openingElement", def("JSXOpeningElement"))
    .field("closingElement", or(def("JSXClosingElement"), null), defaults["null"])
    .field("children", [or(
      def("JSXElement"),
      def("JSXExpressionContainer"),
      def("JSXText"),
      def("Literal") // TODO Esprima should return JSXText instead.
    )], defaults.emptyArray)
    .field("name", JSXElementName, function () {
      // Little-known fact: the `this` object inside a default function
      // is none other than the partially-built object itself, and any
      // fields initialized directly from builder function arguments
      // (like openingElement, closingElement, and children) are
      // guaranteed to be available.
      return this.openingElement.name;
    }, true) // hidden from traversal
    .field("selfClosing", Boolean, function () {
      return this.openingElement.selfClosing;
    }, true) // hidden from traversal
    .field("attributes", JSXAttributes, function () {
      return this.openingElement.attributes;
    }, true); // hidden from traversal

  def("JSXOpeningElement")
    .bases("Node") // TODO Does this make sense? Can't really be an JSXElement.
    .build("name", "attributes", "selfClosing")
    .field("name", JSXElementName)
    .field("attributes", JSXAttributes, defaults.emptyArray)
    .field("selfClosing", Boolean, defaults["false"]);

  def("JSXClosingElement")
    .bases("Node") // TODO Same concern.
    .build("name")
    .field("name", JSXElementName);

  def("JSXText")
    .bases("Literal")
    .build("value")
    .field("value", String);

  def("JSXEmptyExpression").bases("Expression").build();

  // This PR has caused many people issues, but supporting it seems like a
  // good idea anyway: https://github.com/babel/babel/pull/4988
  def("JSXSpreadChild")
    .bases("Expression")
    .build("expression")
    .field("expression", def("Expression"));
};

},{"../lib/shared":20,"../lib/types":21,"./es7":9}],13:[function(require,module,exports){
module.exports = function (fork) {
    fork.use(require("./core"));
    var types = fork.use(require("../lib/types"));
    var def = types.Type.def;
    var or = types.Type.or;
    var shared = fork.use(require("../lib/shared"));
    var geq = shared.geq;
    var defaults = shared.defaults;

    def("Function")
        // SpiderMonkey allows expression closures: function(x) x+1
        .field("body", or(def("BlockStatement"), def("Expression")));

    def("ForInStatement")
        .build("left", "right", "body", "each")
        .field("each", Boolean, defaults["false"]);

    def("LetStatement")
        .bases("Statement")
        .build("head", "body")
        // TODO Deviating from the spec by reusing VariableDeclarator here.
        .field("head", [def("VariableDeclarator")])
        .field("body", def("Statement"));

    def("LetExpression")
        .bases("Expression")
        .build("head", "body")
        // TODO Deviating from the spec by reusing VariableDeclarator here.
        .field("head", [def("VariableDeclarator")])
        .field("body", def("Expression"));

    def("GraphExpression")
        .bases("Expression")
        .build("index", "expression")
        .field("index", geq(0))
        .field("expression", def("Literal"));

    def("GraphIndexExpression")
        .bases("Expression")
        .build("index")
        .field("index", geq(0));
};
},{"../lib/shared":20,"../lib/types":21,"./core":6}],14:[function(require,module,exports){
module.exports = function (defs) {
    var used = [];
    var usedResult = [];
    var fork = {};

    function use(plugin) {
        var idx = used.indexOf(plugin);
        if (idx === -1) {
            idx = used.length;
            used.push(plugin);
            usedResult[idx] = plugin(fork);
        }
        return usedResult[idx];
    }

    fork.use = use;

    var types = use(require('./lib/types'));

    defs.forEach(use);

    types.finalize();

    var exports = {
        Type: types.Type,
        builtInTypes: types.builtInTypes,
        namedTypes: types.namedTypes,
        builders: types.builders,
        defineMethod: types.defineMethod,
        getFieldNames: types.getFieldNames,
        getFieldValue: types.getFieldValue,
        eachField: types.eachField,
        someField: types.someField,
        getSupertypeNames: types.getSupertypeNames,
        astNodesAreEquivalent: use(require("./lib/equiv")),
        finalize: types.finalize,
        Path: use(require('./lib/path')),
        NodePath: use(require("./lib/node-path")),
        PathVisitor: use(require("./lib/path-visitor")),
        use: use
    };

    exports.visit = exports.PathVisitor.visit;

    return exports;
};
},{"./lib/equiv":15,"./lib/node-path":16,"./lib/path":18,"./lib/path-visitor":17,"./lib/types":21}],15:[function(require,module,exports){
module.exports = function (fork) {
    var types = fork.use(require('../lib/types'));
    var getFieldNames = types.getFieldNames;
    var getFieldValue = types.getFieldValue;
    var isArray = types.builtInTypes.array;
    var isObject = types.builtInTypes.object;
    var isDate = types.builtInTypes.Date;
    var isRegExp = types.builtInTypes.RegExp;
    var hasOwn = Object.prototype.hasOwnProperty;

    function astNodesAreEquivalent(a, b, problemPath) {
        if (isArray.check(problemPath)) {
            problemPath.length = 0;
        } else {
            problemPath = null;
        }

        return areEquivalent(a, b, problemPath);
    }

    astNodesAreEquivalent.assert = function (a, b) {
        var problemPath = [];
        if (!astNodesAreEquivalent(a, b, problemPath)) {
            if (problemPath.length === 0) {
                if (a !== b) {
                    throw new Error("Nodes must be equal");
                }
            } else {
                throw new Error(
                  "Nodes differ in the following path: " +
                  problemPath.map(subscriptForProperty).join("")
                );
            }
        }
    };

    function subscriptForProperty(property) {
        if (/[_$a-z][_$a-z0-9]*/i.test(property)) {
            return "." + property;
        }
        return "[" + JSON.stringify(property) + "]";
    }

    function areEquivalent(a, b, problemPath) {
        if (a === b) {
            return true;
        }

        if (isArray.check(a)) {
            return arraysAreEquivalent(a, b, problemPath);
        }

        if (isObject.check(a)) {
            return objectsAreEquivalent(a, b, problemPath);
        }

        if (isDate.check(a)) {
            return isDate.check(b) && (+a === +b);
        }

        if (isRegExp.check(a)) {
            return isRegExp.check(b) && (
                a.source === b.source &&
                a.global === b.global &&
                a.multiline === b.multiline &&
                a.ignoreCase === b.ignoreCase
              );
        }

        return a == b;
    }

    function arraysAreEquivalent(a, b, problemPath) {
        isArray.assert(a);
        var aLength = a.length;

        if (!isArray.check(b) || b.length !== aLength) {
            if (problemPath) {
                problemPath.push("length");
            }
            return false;
        }

        for (var i = 0; i < aLength; ++i) {
            if (problemPath) {
                problemPath.push(i);
            }

            if (i in a !== i in b) {
                return false;
            }

            if (!areEquivalent(a[i], b[i], problemPath)) {
                return false;
            }

            if (problemPath) {
                var problemPathTail = problemPath.pop();
                if (problemPathTail !== i) {
                    throw new Error("" + problemPathTail);
                }
            }
        }

        return true;
    }

    function objectsAreEquivalent(a, b, problemPath) {
        isObject.assert(a);
        if (!isObject.check(b)) {
            return false;
        }

        // Fast path for a common property of AST nodes.
        if (a.type !== b.type) {
            if (problemPath) {
                problemPath.push("type");
            }
            return false;
        }

        var aNames = getFieldNames(a);
        var aNameCount = aNames.length;

        var bNames = getFieldNames(b);
        var bNameCount = bNames.length;

        if (aNameCount === bNameCount) {
            for (var i = 0; i < aNameCount; ++i) {
                var name = aNames[i];
                var aChild = getFieldValue(a, name);
                var bChild = getFieldValue(b, name);

                if (problemPath) {
                    problemPath.push(name);
                }

                if (!areEquivalent(aChild, bChild, problemPath)) {
                    return false;
                }

                if (problemPath) {
                    var problemPathTail = problemPath.pop();
                    if (problemPathTail !== name) {
                        throw new Error("" + problemPathTail);
                    }
                }
            }

            return true;
        }

        if (!problemPath) {
            return false;
        }

        // Since aNameCount !== bNameCount, we need to find some name that's
        // missing in aNames but present in bNames, or vice-versa.

        var seenNames = Object.create(null);

        for (i = 0; i < aNameCount; ++i) {
            seenNames[aNames[i]] = true;
        }

        for (i = 0; i < bNameCount; ++i) {
            name = bNames[i];

            if (!hasOwn.call(seenNames, name)) {
                problemPath.push(name);
                return false;
            }

            delete seenNames[name];
        }

        for (name in seenNames) {
            problemPath.push(name);
            break;
        }

        return false;
    }
    
    return astNodesAreEquivalent;
};

},{"../lib/types":21}],16:[function(require,module,exports){
module.exports = function (fork) {
    var types = fork.use(require("./types"));
    var n = types.namedTypes;
    var b = types.builders;
    var isNumber = types.builtInTypes.number;
    var isArray = types.builtInTypes.array;
    var Path = fork.use(require("./path"));
    var Scope = fork.use(require("./scope"));

    function NodePath(value, parentPath, name) {
        if (!(this instanceof NodePath)) {
            throw new Error("NodePath constructor cannot be invoked without 'new'");
        }
        Path.call(this, value, parentPath, name);
    }

    var NPp = NodePath.prototype = Object.create(Path.prototype, {
        constructor: {
            value: NodePath,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });

    Object.defineProperties(NPp, {
        node: {
            get: function () {
                Object.defineProperty(this, "node", {
                    configurable: true, // Enable deletion.
                    value: this._computeNode()
                });

                return this.node;
            }
        },

        parent: {
            get: function () {
                Object.defineProperty(this, "parent", {
                    configurable: true, // Enable deletion.
                    value: this._computeParent()
                });

                return this.parent;
            }
        },

        scope: {
            get: function () {
                Object.defineProperty(this, "scope", {
                    configurable: true, // Enable deletion.
                    value: this._computeScope()
                });

                return this.scope;
            }
        }
    });

    NPp.replace = function () {
        delete this.node;
        delete this.parent;
        delete this.scope;
        return Path.prototype.replace.apply(this, arguments);
    };

    NPp.prune = function () {
        var remainingNodePath = this.parent;

        this.replace();

        return cleanUpNodesAfterPrune(remainingNodePath);
    };

    // The value of the first ancestor Path whose value is a Node.
    NPp._computeNode = function () {
        var value = this.value;
        if (n.Node.check(value)) {
            return value;
        }

        var pp = this.parentPath;
        return pp && pp.node || null;
    };

    // The first ancestor Path whose value is a Node distinct from this.node.
    NPp._computeParent = function () {
        var value = this.value;
        var pp = this.parentPath;

        if (!n.Node.check(value)) {
            while (pp && !n.Node.check(pp.value)) {
                pp = pp.parentPath;
            }

            if (pp) {
                pp = pp.parentPath;
            }
        }

        while (pp && !n.Node.check(pp.value)) {
            pp = pp.parentPath;
        }

        return pp || null;
    };

    // The closest enclosing scope that governs this node.
    NPp._computeScope = function () {
        var value = this.value;
        var pp = this.parentPath;
        var scope = pp && pp.scope;

        if (n.Node.check(value) &&
          Scope.isEstablishedBy(value)) {
            scope = new Scope(this, scope);
        }

        return scope || null;
    };

    NPp.getValueProperty = function (name) {
        return types.getFieldValue(this.value, name);
    };

    /**
     * Determine whether this.node needs to be wrapped in parentheses in order
     * for a parser to reproduce the same local AST structure.
     *
     * For instance, in the expression `(1 + 2) * 3`, the BinaryExpression
     * whose operator is "+" needs parentheses, because `1 + 2 * 3` would
     * parse differently.
     *
     * If assumeExpressionContext === true, we don't worry about edge cases
     * like an anonymous FunctionExpression appearing lexically first in its
     * enclosing statement and thus needing parentheses to avoid being parsed
     * as a FunctionDeclaration with a missing name.
     */
    NPp.needsParens = function (assumeExpressionContext) {
        var pp = this.parentPath;
        if (!pp) {
            return false;
        }

        var node = this.value;

        // Only expressions need parentheses.
        if (!n.Expression.check(node)) {
            return false;
        }

        // Identifiers never need parentheses.
        if (node.type === "Identifier") {
            return false;
        }

        while (!n.Node.check(pp.value)) {
            pp = pp.parentPath;
            if (!pp) {
                return false;
            }
        }

        var parent = pp.value;

        switch (node.type) {
            case "UnaryExpression":
            case "SpreadElement":
            case "SpreadProperty":
                return parent.type === "MemberExpression"
                  && this.name === "object"
                  && parent.object === node;

            case "BinaryExpression":
            case "LogicalExpression":
                switch (parent.type) {
                    case "CallExpression":
                        return this.name === "callee"
                          && parent.callee === node;

                    case "UnaryExpression":
                    case "SpreadElement":
                    case "SpreadProperty":
                        return true;

                    case "MemberExpression":
                        return this.name === "object"
                          && parent.object === node;

                    case "BinaryExpression":
                    case "LogicalExpression":
                        var po = parent.operator;
                        var pp = PRECEDENCE[po];
                        var no = node.operator;
                        var np = PRECEDENCE[no];

                        if (pp > np) {
                            return true;
                        }

                        if (pp === np && this.name === "right") {
                            if (parent.right !== node) {
                                throw new Error("Nodes must be equal");
                            }
                            return true;
                        }

                    default:
                        return false;
                }

            case "SequenceExpression":
                switch (parent.type) {
                    case "ForStatement":
                        // Although parentheses wouldn't hurt around sequence
                        // expressions in the head of for loops, traditional style
                        // dictates that e.g. i++, j++ should not be wrapped with
                        // parentheses.
                        return false;

                    case "ExpressionStatement":
                        return this.name !== "expression";

                    default:
                        // Otherwise err on the side of overparenthesization, adding
                        // explicit exceptions above if this proves overzealous.
                        return true;
                }

            case "YieldExpression":
                switch (parent.type) {
                    case "BinaryExpression":
                    case "LogicalExpression":
                    case "UnaryExpression":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "CallExpression":
                    case "MemberExpression":
                    case "NewExpression":
                    case "ConditionalExpression":
                    case "YieldExpression":
                        return true;

                    default:
                        return false;
                }

            case "Literal":
                return parent.type === "MemberExpression"
                  && isNumber.check(node.value)
                  && this.name === "object"
                  && parent.object === node;

            case "AssignmentExpression":
            case "ConditionalExpression":
                switch (parent.type) {
                    case "UnaryExpression":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "BinaryExpression":
                    case "LogicalExpression":
                        return true;

                    case "CallExpression":
                        return this.name === "callee"
                          && parent.callee === node;

                    case "ConditionalExpression":
                        return this.name === "test"
                          && parent.test === node;

                    case "MemberExpression":
                        return this.name === "object"
                          && parent.object === node;

                    default:
                        return false;
                }

            default:
                if (parent.type === "NewExpression" &&
                  this.name === "callee" &&
                  parent.callee === node) {
                    return containsCallExpression(node);
                }
        }

        if (assumeExpressionContext !== true &&
          !this.canBeFirstInStatement() &&
          this.firstInStatement())
            return true;

        return false;
    };

    function isBinary(node) {
        return n.BinaryExpression.check(node)
          || n.LogicalExpression.check(node);
    }

    function isUnaryLike(node) {
        return n.UnaryExpression.check(node)
          // I considered making SpreadElement and SpreadProperty subtypes
          // of UnaryExpression, but they're not really Expression nodes.
          || (n.SpreadElement && n.SpreadElement.check(node))
          || (n.SpreadProperty && n.SpreadProperty.check(node));
    }

    var PRECEDENCE = {};
    [["||"],
        ["&&"],
        ["|"],
        ["^"],
        ["&"],
        ["==", "===", "!=", "!=="],
        ["<", ">", "<=", ">=", "in", "instanceof"],
        [">>", "<<", ">>>"],
        ["+", "-"],
        ["*", "/", "%"]
    ].forEach(function (tier, i) {
        tier.forEach(function (op) {
            PRECEDENCE[op] = i;
        });
    });

    function containsCallExpression(node) {
        if (n.CallExpression.check(node)) {
            return true;
        }

        if (isArray.check(node)) {
            return node.some(containsCallExpression);
        }

        if (n.Node.check(node)) {
            return types.someField(node, function (name, child) {
                return containsCallExpression(child);
            });
        }

        return false;
    }

    NPp.canBeFirstInStatement = function () {
        var node = this.node;
        return !n.FunctionExpression.check(node)
          && !n.ObjectExpression.check(node);
    };

    NPp.firstInStatement = function () {
        return firstInStatement(this);
    };

    function firstInStatement(path) {
        for (var node, parent; path.parent; path = path.parent) {
            node = path.node;
            parent = path.parent.node;

            if (n.BlockStatement.check(parent) &&
              path.parent.name === "body" &&
              path.name === 0) {
                if (parent.body[0] !== node) {
                    throw new Error("Nodes must be equal");
                }
                return true;
            }

            if (n.ExpressionStatement.check(parent) &&
              path.name === "expression") {
                if (parent.expression !== node) {
                    throw new Error("Nodes must be equal");
                }
                return true;
            }

            if (n.SequenceExpression.check(parent) &&
              path.parent.name === "expressions" &&
              path.name === 0) {
                if (parent.expressions[0] !== node) {
                    throw new Error("Nodes must be equal");
                }
                continue;
            }

            if (n.CallExpression.check(parent) &&
              path.name === "callee") {
                if (parent.callee !== node) {
                    throw new Error("Nodes must be equal");
                }
                continue;
            }

            if (n.MemberExpression.check(parent) &&
              path.name === "object") {
                if (parent.object !== node) {
                    throw new Error("Nodes must be equal");
                }
                continue;
            }

            if (n.ConditionalExpression.check(parent) &&
              path.name === "test") {
                if (parent.test !== node) {
                    throw new Error("Nodes must be equal");
                }
                continue;
            }

            if (isBinary(parent) &&
              path.name === "left") {
                if (parent.left !== node) {
                    throw new Error("Nodes must be equal");
                }
                continue;
            }

            if (n.UnaryExpression.check(parent) &&
              !parent.prefix &&
              path.name === "argument") {
                if (parent.argument !== node) {
                    throw new Error("Nodes must be equal");
                }
                continue;
            }

            return false;
        }

        return true;
    }

    /**
     * Pruning certain nodes will result in empty or incomplete nodes, here we clean those nodes up.
     */
    function cleanUpNodesAfterPrune(remainingNodePath) {
        if (n.VariableDeclaration.check(remainingNodePath.node)) {
            var declarations = remainingNodePath.get('declarations').value;
            if (!declarations || declarations.length === 0) {
                return remainingNodePath.prune();
            }
        } else if (n.ExpressionStatement.check(remainingNodePath.node)) {
            if (!remainingNodePath.get('expression').value) {
                return remainingNodePath.prune();
            }
        } else if (n.IfStatement.check(remainingNodePath.node)) {
            cleanUpIfStatementAfterPrune(remainingNodePath);
        }

        return remainingNodePath;
    }

    function cleanUpIfStatementAfterPrune(ifStatement) {
        var testExpression = ifStatement.get('test').value;
        var alternate = ifStatement.get('alternate').value;
        var consequent = ifStatement.get('consequent').value;

        if (!consequent && !alternate) {
            var testExpressionStatement = b.expressionStatement(testExpression);

            ifStatement.replace(testExpressionStatement);
        } else if (!consequent && alternate) {
            var negatedTestExpression = b.unaryExpression('!', testExpression, true);

            if (n.UnaryExpression.check(testExpression) && testExpression.operator === '!') {
                negatedTestExpression = testExpression.argument;
            }

            ifStatement.get("test").replace(negatedTestExpression);
            ifStatement.get("consequent").replace(alternate);
            ifStatement.get("alternate").replace();
        }
    }

    return NodePath;
};

},{"./path":18,"./scope":19,"./types":21}],17:[function(require,module,exports){
var hasOwn = Object.prototype.hasOwnProperty;

module.exports = function (fork) {
    var types = fork.use(require("./types"));
    var NodePath = fork.use(require("./node-path"));
    var Printable = types.namedTypes.Printable;
    var isArray = types.builtInTypes.array;
    var isObject = types.builtInTypes.object;
    var isFunction = types.builtInTypes.function;
    var undefined;

    function PathVisitor() {
        if (!(this instanceof PathVisitor)) {
            throw new Error(
              "PathVisitor constructor cannot be invoked without 'new'"
            );
        }

        // Permanent state.
        this._reusableContextStack = [];

        this._methodNameTable = computeMethodNameTable(this);
        this._shouldVisitComments =
          hasOwn.call(this._methodNameTable, "Block") ||
          hasOwn.call(this._methodNameTable, "Line");

        this.Context = makeContextConstructor(this);

        // State reset every time PathVisitor.prototype.visit is called.
        this._visiting = false;
        this._changeReported = false;
    }

    function computeMethodNameTable(visitor) {
        var typeNames = Object.create(null);

        for (var methodName in visitor) {
            if (/^visit[A-Z]/.test(methodName)) {
                var type = methodName.slice("visit".length);

                if (!(type in types.namedTypes)) {
                    console.warn(
                            "\033[33m", // yellow
                            "Are you sure you meant [" + methodName + "]?",
                            "\033[0m" // reset
                    );
                } else {
                    typeNames[type] = true;
                }
            }
        }

        var supertypeTable = types.computeSupertypeLookupTable(typeNames);
        var methodNameTable = Object.create(null);

        var typeNames = Object.keys(supertypeTable);
        var typeNameCount = typeNames.length;
        for (var i = 0; i < typeNameCount; ++i) {
            var typeName = typeNames[i];
            methodName = "visit" + supertypeTable[typeName];
            if (isFunction.check(visitor[methodName])) {
                methodNameTable[typeName] = methodName;
            }
        }

        return methodNameTable;
    }

    PathVisitor.fromMethodsObject = function fromMethodsObject(methods) {
        if (methods instanceof PathVisitor) {
            return methods;
        }

        if (!isObject.check(methods)) {
            // An empty visitor?
            return new PathVisitor;
        }

        function Visitor() {
            if (!(this instanceof Visitor)) {
                throw new Error(
                  "Visitor constructor cannot be invoked without 'new'"
                );
            }
            PathVisitor.call(this);
        }

        var Vp = Visitor.prototype = Object.create(PVp);
        Vp.constructor = Visitor;

        extend(Vp, methods);
        extend(Visitor, PathVisitor);

        isFunction.assert(Visitor.fromMethodsObject);
        isFunction.assert(Visitor.visit);

        return new Visitor;
    };

    function extend(target, source) {
        for (var property in source) {
            if (hasOwn.call(source, property)) {
                target[property] = source[property];
            }
        }

        return target;
    }

    PathVisitor.visit = function visit(node, methods) {
        return PathVisitor.fromMethodsObject(methods).visit(node);
    };

    var PVp = PathVisitor.prototype;

    PVp.visit = function () {
        if (this._visiting) {
            throw new Error(
              "Recursively calling visitor.visit(path) resets visitor state. " +
              "Try this.visit(path) or this.traverse(path) instead."
            );
        }

        // Private state that needs to be reset before every traversal.
        this._visiting = true;
        this._changeReported = false;
        this._abortRequested = false;

        var argc = arguments.length;
        var args = new Array(argc)
        for (var i = 0; i < argc; ++i) {
            args[i] = arguments[i];
        }

        if (!(args[0] instanceof NodePath)) {
            args[0] = new NodePath({root: args[0]}).get("root");
        }

        // Called with the same arguments as .visit.
        this.reset.apply(this, args);

        try {
            var root = this.visitWithoutReset(args[0]);
            var didNotThrow = true;
        } finally {
            this._visiting = false;

            if (!didNotThrow && this._abortRequested) {
                // If this.visitWithoutReset threw an exception and
                // this._abortRequested was set to true, return the root of
                // the AST instead of letting the exception propagate, so that
                // client code does not have to provide a try-catch block to
                // intercept the AbortRequest exception.  Other kinds of
                // exceptions will propagate without being intercepted and
                // rethrown by a catch block, so their stacks will accurately
                // reflect the original throwing context.
                return args[0].value;
            }
        }

        return root;
    };

    PVp.AbortRequest = function AbortRequest() {};
    PVp.abort = function () {
        var visitor = this;
        visitor._abortRequested = true;
        var request = new visitor.AbortRequest();

        // If you decide to catch this exception and stop it from propagating,
        // make sure to call its cancel method to avoid silencing other
        // exceptions that might be thrown later in the traversal.
        request.cancel = function () {
            visitor._abortRequested = false;
        };

        throw request;
    };

    PVp.reset = function (path/*, additional arguments */) {
        // Empty stub; may be reassigned or overridden by subclasses.
    };

    PVp.visitWithoutReset = function (path) {
        if (this instanceof this.Context) {
            // Since this.Context.prototype === this, there's a chance we
            // might accidentally call context.visitWithoutReset. If that
            // happens, re-invoke the method against context.visitor.
            return this.visitor.visitWithoutReset(path);
        }

        if (!(path instanceof NodePath)) {
            throw new Error("");
        }

        var value = path.value;

        var methodName = value &&
          typeof value === "object" &&
          typeof value.type === "string" &&
          this._methodNameTable[value.type];

        if (methodName) {
            var context = this.acquireContext(path);
            try {
                return context.invokeVisitorMethod(methodName);
            } finally {
                this.releaseContext(context);
            }

        } else {
            // If there was no visitor method to call, visit the children of
            // this node generically.
            return visitChildren(path, this);
        }
    };

    function visitChildren(path, visitor) {
        if (!(path instanceof NodePath)) {
            throw new Error("");
        }
        if (!(visitor instanceof PathVisitor)) {
            throw new Error("");
        }

        var value = path.value;

        if (isArray.check(value)) {
            path.each(visitor.visitWithoutReset, visitor);
        } else if (!isObject.check(value)) {
            // No children to visit.
        } else {
            var childNames = types.getFieldNames(value);

            // The .comments field of the Node type is hidden, so we only
            // visit it if the visitor defines visitBlock or visitLine, and
            // value.comments is defined.
            if (visitor._shouldVisitComments &&
              value.comments &&
              childNames.indexOf("comments") < 0) {
                childNames.push("comments");
            }

            var childCount = childNames.length;
            var childPaths = [];

            for (var i = 0; i < childCount; ++i) {
                var childName = childNames[i];
                if (!hasOwn.call(value, childName)) {
                    value[childName] = types.getFieldValue(value, childName);
                }
                childPaths.push(path.get(childName));
            }

            for (var i = 0; i < childCount; ++i) {
                visitor.visitWithoutReset(childPaths[i]);
            }
        }

        return path.value;
    }

    PVp.acquireContext = function (path) {
        if (this._reusableContextStack.length === 0) {
            return new this.Context(path);
        }
        return this._reusableContextStack.pop().reset(path);
    };

    PVp.releaseContext = function (context) {
        if (!(context instanceof this.Context)) {
            throw new Error("");
        }
        this._reusableContextStack.push(context);
        context.currentPath = null;
    };

    PVp.reportChanged = function () {
        this._changeReported = true;
    };

    PVp.wasChangeReported = function () {
        return this._changeReported;
    };

    function makeContextConstructor(visitor) {
        function Context(path) {
            if (!(this instanceof Context)) {
                throw new Error("");
            }
            if (!(this instanceof PathVisitor)) {
                throw new Error("");
            }
            if (!(path instanceof NodePath)) {
                throw new Error("");
            }

            Object.defineProperty(this, "visitor", {
                value: visitor,
                writable: false,
                enumerable: true,
                configurable: false
            });

            this.currentPath = path;
            this.needToCallTraverse = true;

            Object.seal(this);
        }

        if (!(visitor instanceof PathVisitor)) {
            throw new Error("");
        }

        // Note that the visitor object is the prototype of Context.prototype,
        // so all visitor methods are inherited by context objects.
        var Cp = Context.prototype = Object.create(visitor);

        Cp.constructor = Context;
        extend(Cp, sharedContextProtoMethods);

        return Context;
    }

// Every PathVisitor has a different this.Context constructor and
// this.Context.prototype object, but those prototypes can all use the
// same reset, invokeVisitorMethod, and traverse function objects.
    var sharedContextProtoMethods = Object.create(null);

    sharedContextProtoMethods.reset =
      function reset(path) {
          if (!(this instanceof this.Context)) {
              throw new Error("");
          }
          if (!(path instanceof NodePath)) {
              throw new Error("");
          }

          this.currentPath = path;
          this.needToCallTraverse = true;

          return this;
      };

    sharedContextProtoMethods.invokeVisitorMethod =
      function invokeVisitorMethod(methodName) {
          if (!(this instanceof this.Context)) {
              throw new Error("");
          }
          if (!(this.currentPath instanceof NodePath)) {
              throw new Error("");
          }

          var result = this.visitor[methodName].call(this, this.currentPath);

          if (result === false) {
              // Visitor methods return false to indicate that they have handled
              // their own traversal needs, and we should not complain if
              // this.needToCallTraverse is still true.
              this.needToCallTraverse = false;

          } else if (result !== undefined) {
              // Any other non-undefined value returned from the visitor method
              // is interpreted as a replacement value.
              this.currentPath = this.currentPath.replace(result)[0];

              if (this.needToCallTraverse) {
                  // If this.traverse still hasn't been called, visit the
                  // children of the replacement node.
                  this.traverse(this.currentPath);
              }
          }

          if (this.needToCallTraverse !== false) {
              throw new Error(
                "Must either call this.traverse or return false in " + methodName
              );
          }

          var path = this.currentPath;
          return path && path.value;
      };

    sharedContextProtoMethods.traverse =
      function traverse(path, newVisitor) {
          if (!(this instanceof this.Context)) {
              throw new Error("");
          }
          if (!(path instanceof NodePath)) {
              throw new Error("");
          }
          if (!(this.currentPath instanceof NodePath)) {
              throw new Error("");
          }

          this.needToCallTraverse = false;

          return visitChildren(path, PathVisitor.fromMethodsObject(
            newVisitor || this.visitor
          ));
      };

    sharedContextProtoMethods.visit =
      function visit(path, newVisitor) {
          if (!(this instanceof this.Context)) {
              throw new Error("");
          }
          if (!(path instanceof NodePath)) {
              throw new Error("");
          }
          if (!(this.currentPath instanceof NodePath)) {
              throw new Error("");
          }

          this.needToCallTraverse = false;

          return PathVisitor.fromMethodsObject(
            newVisitor || this.visitor
          ).visitWithoutReset(path);
      };

    sharedContextProtoMethods.reportChanged = function reportChanged() {
        this.visitor.reportChanged();
    };

    sharedContextProtoMethods.abort = function abort() {
        this.needToCallTraverse = false;
        this.visitor.abort();
    };

    return PathVisitor;
};

},{"./node-path":16,"./types":21}],18:[function(require,module,exports){
var Ap = Array.prototype;
var slice = Ap.slice;
var map = Ap.map;
var Op = Object.prototype;
var hasOwn = Op.hasOwnProperty;

module.exports = function (fork) {
    var types = fork.use(require("./types"));
    var isArray = types.builtInTypes.array;
    var isNumber = types.builtInTypes.number;

    function Path(value, parentPath, name) {
        if (!(this instanceof Path)) {
            throw new Error("Path constructor cannot be invoked without 'new'");
        }

        if (parentPath) {
            if (!(parentPath instanceof Path)) {
                throw new Error("");
            }
        } else {
            parentPath = null;
            name = null;
        }

        // The value encapsulated by this Path, generally equal to
        // parentPath.value[name] if we have a parentPath.
        this.value = value;

        // The immediate parent Path of this Path.
        this.parentPath = parentPath;

        // The name of the property of parentPath.value through which this
        // Path's value was reached.
        this.name = name;

        // Calling path.get("child") multiple times always returns the same
        // child Path object, for both performance and consistency reasons.
        this.__childCache = null;
    }

    var Pp = Path.prototype;

    function getChildCache(path) {
        // Lazily create the child cache. This also cheapens cache
        // invalidation, since you can just reset path.__childCache to null.
        return path.__childCache || (path.__childCache = Object.create(null));
    }

    function getChildPath(path, name) {
        var cache = getChildCache(path);
        var actualChildValue = path.getValueProperty(name);
        var childPath = cache[name];
        if (!hasOwn.call(cache, name) ||
          // Ensure consistency between cache and reality.
          childPath.value !== actualChildValue) {
            childPath = cache[name] = new path.constructor(
              actualChildValue, path, name
            );
        }
        return childPath;
    }

// This method is designed to be overridden by subclasses that need to
// handle missing properties, etc.
    Pp.getValueProperty = function getValueProperty(name) {
        return this.value[name];
    };

    Pp.get = function get(name) {
        var path = this;
        var names = arguments;
        var count = names.length;

        for (var i = 0; i < count; ++i) {
            path = getChildPath(path, names[i]);
        }

        return path;
    };

    Pp.each = function each(callback, context) {
        var childPaths = [];
        var len = this.value.length;
        var i = 0;

        // Collect all the original child paths before invoking the callback.
        for (var i = 0; i < len; ++i) {
            if (hasOwn.call(this.value, i)) {
                childPaths[i] = this.get(i);
            }
        }

        // Invoke the callback on just the original child paths, regardless of
        // any modifications made to the array by the callback. I chose these
        // semantics over cleverly invoking the callback on new elements because
        // this way is much easier to reason about.
        context = context || this;
        for (i = 0; i < len; ++i) {
            if (hasOwn.call(childPaths, i)) {
                callback.call(context, childPaths[i]);
            }
        }
    };

    Pp.map = function map(callback, context) {
        var result = [];

        this.each(function (childPath) {
            result.push(callback.call(this, childPath));
        }, context);

        return result;
    };

    Pp.filter = function filter(callback, context) {
        var result = [];

        this.each(function (childPath) {
            if (callback.call(this, childPath)) {
                result.push(childPath);
            }
        }, context);

        return result;
    };

    function emptyMoves() {}
    function getMoves(path, offset, start, end) {
        isArray.assert(path.value);

        if (offset === 0) {
            return emptyMoves;
        }

        var length = path.value.length;
        if (length < 1) {
            return emptyMoves;
        }

        var argc = arguments.length;
        if (argc === 2) {
            start = 0;
            end = length;
        } else if (argc === 3) {
            start = Math.max(start, 0);
            end = length;
        } else {
            start = Math.max(start, 0);
            end = Math.min(end, length);
        }

        isNumber.assert(start);
        isNumber.assert(end);

        var moves = Object.create(null);
        var cache = getChildCache(path);

        for (var i = start; i < end; ++i) {
            if (hasOwn.call(path.value, i)) {
                var childPath = path.get(i);
                if (childPath.name !== i) {
                    throw new Error("");
                }
                var newIndex = i + offset;
                childPath.name = newIndex;
                moves[newIndex] = childPath;
                delete cache[i];
            }
        }

        delete cache.length;

        return function () {
            for (var newIndex in moves) {
                var childPath = moves[newIndex];
                if (childPath.name !== +newIndex) {
                    throw new Error("");
                }
                cache[newIndex] = childPath;
                path.value[newIndex] = childPath.value;
            }
        };
    }

    Pp.shift = function shift() {
        var move = getMoves(this, -1);
        var result = this.value.shift();
        move();
        return result;
    };

    Pp.unshift = function unshift(node) {
        var move = getMoves(this, arguments.length);
        var result = this.value.unshift.apply(this.value, arguments);
        move();
        return result;
    };

    Pp.push = function push(node) {
        isArray.assert(this.value);
        delete getChildCache(this).length
        return this.value.push.apply(this.value, arguments);
    };

    Pp.pop = function pop() {
        isArray.assert(this.value);
        var cache = getChildCache(this);
        delete cache[this.value.length - 1];
        delete cache.length;
        return this.value.pop();
    };

    Pp.insertAt = function insertAt(index, node) {
        var argc = arguments.length;
        var move = getMoves(this, argc - 1, index);
        if (move === emptyMoves) {
            return this;
        }

        index = Math.max(index, 0);

        for (var i = 1; i < argc; ++i) {
            this.value[index + i - 1] = arguments[i];
        }

        move();

        return this;
    };

    Pp.insertBefore = function insertBefore(node) {
        var pp = this.parentPath;
        var argc = arguments.length;
        var insertAtArgs = [this.name];
        for (var i = 0; i < argc; ++i) {
            insertAtArgs.push(arguments[i]);
        }
        return pp.insertAt.apply(pp, insertAtArgs);
    };

    Pp.insertAfter = function insertAfter(node) {
        var pp = this.parentPath;
        var argc = arguments.length;
        var insertAtArgs = [this.name + 1];
        for (var i = 0; i < argc; ++i) {
            insertAtArgs.push(arguments[i]);
        }
        return pp.insertAt.apply(pp, insertAtArgs);
    };

    function repairRelationshipWithParent(path) {
        if (!(path instanceof Path)) {
            throw new Error("");
        }

        var pp = path.parentPath;
        if (!pp) {
            // Orphan paths have no relationship to repair.
            return path;
        }

        var parentValue = pp.value;
        var parentCache = getChildCache(pp);

        // Make sure parentCache[path.name] is populated.
        if (parentValue[path.name] === path.value) {
            parentCache[path.name] = path;
        } else if (isArray.check(parentValue)) {
            // Something caused path.name to become out of date, so attempt to
            // recover by searching for path.value in parentValue.
            var i = parentValue.indexOf(path.value);
            if (i >= 0) {
                parentCache[path.name = i] = path;
            }
        } else {
            // If path.value disagrees with parentValue[path.name], and
            // path.name is not an array index, let path.value become the new
            // parentValue[path.name] and update parentCache accordingly.
            parentValue[path.name] = path.value;
            parentCache[path.name] = path;
        }

        if (parentValue[path.name] !== path.value) {
            throw new Error("");
        }
        if (path.parentPath.get(path.name) !== path) {
            throw new Error("");
        }

        return path;
    }

    Pp.replace = function replace(replacement) {
        var results = [];
        var parentValue = this.parentPath.value;
        var parentCache = getChildCache(this.parentPath);
        var count = arguments.length;

        repairRelationshipWithParent(this);

        if (isArray.check(parentValue)) {
            var originalLength = parentValue.length;
            var move = getMoves(this.parentPath, count - 1, this.name + 1);

            var spliceArgs = [this.name, 1];
            for (var i = 0; i < count; ++i) {
                spliceArgs.push(arguments[i]);
            }

            var splicedOut = parentValue.splice.apply(parentValue, spliceArgs);

            if (splicedOut[0] !== this.value) {
                throw new Error("");
            }
            if (parentValue.length !== (originalLength - 1 + count)) {
                throw new Error("");
            }

            move();

            if (count === 0) {
                delete this.value;
                delete parentCache[this.name];
                this.__childCache = null;

            } else {
                if (parentValue[this.name] !== replacement) {
                    throw new Error("");
                }

                if (this.value !== replacement) {
                    this.value = replacement;
                    this.__childCache = null;
                }

                for (i = 0; i < count; ++i) {
                    results.push(this.parentPath.get(this.name + i));
                }

                if (results[0] !== this) {
                    throw new Error("");
                }
            }

        } else if (count === 1) {
            if (this.value !== replacement) {
                this.__childCache = null;
            }
            this.value = parentValue[this.name] = replacement;
            results.push(this);

        } else if (count === 0) {
            delete parentValue[this.name];
            delete this.value;
            this.__childCache = null;

            // Leave this path cached as parentCache[this.name], even though
            // it no longer has a value defined.

        } else {
            throw new Error("Could not replace path");
        }

        return results;
    };

    return Path;
};

},{"./types":21}],19:[function(require,module,exports){
var hasOwn = Object.prototype.hasOwnProperty;

module.exports = function (fork) {
    var types = fork.use(require("./types"));
    var Type = types.Type;
    var namedTypes = types.namedTypes;
    var Node = namedTypes.Node;
    var Expression = namedTypes.Expression;
    var isArray = types.builtInTypes.array;
    var b = types.builders;

    function Scope(path, parentScope) {
        if (!(this instanceof Scope)) {
            throw new Error("Scope constructor cannot be invoked without 'new'");
        }
        if (!(path instanceof fork.use(require("./node-path")))) {
            throw new Error("");
        }
        ScopeType.assert(path.value);

        var depth;

        if (parentScope) {
            if (!(parentScope instanceof Scope)) {
                throw new Error("");
            }
            depth = parentScope.depth + 1;
        } else {
            parentScope = null;
            depth = 0;
        }

        Object.defineProperties(this, {
            path: { value: path },
            node: { value: path.value },
            isGlobal: { value: !parentScope, enumerable: true },
            depth: { value: depth },
            parent: { value: parentScope },
            bindings: { value: {} },
            types: { value: {} },
        });
    }

    var scopeTypes = [
        // Program nodes introduce global scopes.
        namedTypes.Program,

        // Function is the supertype of FunctionExpression,
        // FunctionDeclaration, ArrowExpression, etc.
        namedTypes.Function,

        // In case you didn't know, the caught parameter shadows any variable
        // of the same name in an outer scope.
        namedTypes.CatchClause
    ];

    var ScopeType = Type.or.apply(Type, scopeTypes);

    Scope.isEstablishedBy = function(node) {
        return ScopeType.check(node);
    };

    var Sp = Scope.prototype;

// Will be overridden after an instance lazily calls scanScope.
    Sp.didScan = false;

    Sp.declares = function(name) {
        this.scan();
        return hasOwn.call(this.bindings, name);
    };

    Sp.declaresType = function(name) {
        this.scan();
        return hasOwn.call(this.types, name);
    };

    Sp.declareTemporary = function(prefix) {
        if (prefix) {
            if (!/^[a-z$_]/i.test(prefix)) {
                throw new Error("");
            }
        } else {
            prefix = "t$";
        }

        // Include this.depth in the name to make sure the name does not
        // collide with any variables in nested/enclosing scopes.
        prefix += this.depth.toString(36) + "$";

        this.scan();

        var index = 0;
        while (this.declares(prefix + index)) {
            ++index;
        }

        var name = prefix + index;
        return this.bindings[name] = types.builders.identifier(name);
    };

    Sp.injectTemporary = function(identifier, init) {
        identifier || (identifier = this.declareTemporary());

        var bodyPath = this.path.get("body");
        if (namedTypes.BlockStatement.check(bodyPath.value)) {
            bodyPath = bodyPath.get("body");
        }

        bodyPath.unshift(
          b.variableDeclaration(
            "var",
            [b.variableDeclarator(identifier, init || null)]
          )
        );

        return identifier;
    };

    Sp.scan = function(force) {
        if (force || !this.didScan) {
            for (var name in this.bindings) {
                // Empty out this.bindings, just in cases.
                delete this.bindings[name];
            }
            scanScope(this.path, this.bindings, this.types);
            this.didScan = true;
        }
    };

    Sp.getBindings = function () {
        this.scan();
        return this.bindings;
    };

    Sp.getTypes = function () {
        this.scan();
        return this.types;
    };

    function scanScope(path, bindings, scopeTypes) {
        var node = path.value;
        ScopeType.assert(node);

        if (namedTypes.CatchClause.check(node)) {
            // A catch clause establishes a new scope but the only variable
            // bound in that scope is the catch parameter. Any other
            // declarations create bindings in the outer scope.
            addPattern(path.get("param"), bindings);

        } else {
            recursiveScanScope(path, bindings, scopeTypes);
        }
    }

    function recursiveScanScope(path, bindings, scopeTypes) {
        var node = path.value;

        if (path.parent &&
          namedTypes.FunctionExpression.check(path.parent.node) &&
          path.parent.node.id) {
            addPattern(path.parent.get("id"), bindings);
        }

        if (!node) {
            // None of the remaining cases matter if node is falsy.

        } else if (isArray.check(node)) {
            path.each(function(childPath) {
                recursiveScanChild(childPath, bindings, scopeTypes);
            });

        } else if (namedTypes.Function.check(node)) {
            path.get("params").each(function(paramPath) {
                addPattern(paramPath, bindings);
            });

            recursiveScanChild(path.get("body"), bindings, scopeTypes);

        } else if (namedTypes.TypeAlias && namedTypes.TypeAlias.check(node)) {
            addTypePattern(path.get("id"), scopeTypes);

        } else if (namedTypes.VariableDeclarator.check(node)) {
            addPattern(path.get("id"), bindings);
            recursiveScanChild(path.get("init"), bindings, scopeTypes);

        } else if (node.type === "ImportSpecifier" ||
          node.type === "ImportNamespaceSpecifier" ||
          node.type === "ImportDefaultSpecifier") {
            addPattern(
              // Esprima used to use the .name field to refer to the local
              // binding identifier for ImportSpecifier nodes, but .id for
              // ImportNamespaceSpecifier and ImportDefaultSpecifier nodes.
              // ESTree/Acorn/ESpree use .local for all three node types.
              path.get(node.local ? "local" :
                node.name ? "name" : "id"),
              bindings
            );

        } else if (Node.check(node) && !Expression.check(node)) {
            types.eachField(node, function(name, child) {
                var childPath = path.get(name);
                if (!pathHasValue(childPath, child)) {
                    throw new Error("");
                }
                recursiveScanChild(childPath, bindings, scopeTypes);
            });
        }
    }

    function pathHasValue(path, value) {
        if (path.value === value) {
            return true;
        }

        // Empty arrays are probably produced by defaults.emptyArray, in which
        // case is makes sense to regard them as equivalent, if not ===.
        if (Array.isArray(path.value) &&
          path.value.length === 0 &&
          Array.isArray(value) &&
          value.length === 0) {
            return true;
        }

        return false;
    }

    function recursiveScanChild(path, bindings, scopeTypes) {
        var node = path.value;

        if (!node || Expression.check(node)) {
            // Ignore falsy values and Expressions.

        } else if (namedTypes.FunctionDeclaration.check(node) &&
                   node.id !== null) {
            addPattern(path.get("id"), bindings);

        } else if (namedTypes.ClassDeclaration &&
          namedTypes.ClassDeclaration.check(node)) {
            addPattern(path.get("id"), bindings);

        } else if (ScopeType.check(node)) {
            if (namedTypes.CatchClause.check(node)) {
                var catchParamName = node.param.name;
                var hadBinding = hasOwn.call(bindings, catchParamName);

                // Any declarations that occur inside the catch body that do
                // not have the same name as the catch parameter should count
                // as bindings in the outer scope.
                recursiveScanScope(path.get("body"), bindings, scopeTypes);

                // If a new binding matching the catch parameter name was
                // created while scanning the catch body, ignore it because it
                // actually refers to the catch parameter and not the outer
                // scope that we're currently scanning.
                if (!hadBinding) {
                    delete bindings[catchParamName];
                }
            }

        } else {
            recursiveScanScope(path, bindings, scopeTypes);
        }
    }

    function addPattern(patternPath, bindings) {
        var pattern = patternPath.value;
        namedTypes.Pattern.assert(pattern);

        if (namedTypes.Identifier.check(pattern)) {
            if (hasOwn.call(bindings, pattern.name)) {
                bindings[pattern.name].push(patternPath);
            } else {
                bindings[pattern.name] = [patternPath];
            }

        } else if (namedTypes.ObjectPattern &&
          namedTypes.ObjectPattern.check(pattern)) {
            patternPath.get('properties').each(function(propertyPath) {
                var property = propertyPath.value;
                if (namedTypes.Pattern.check(property)) {
                    addPattern(propertyPath, bindings);
                } else  if (namedTypes.Property.check(property)) {
                    addPattern(propertyPath.get('value'), bindings);
                } else if (namedTypes.SpreadProperty &&
                  namedTypes.SpreadProperty.check(property)) {
                    addPattern(propertyPath.get('argument'), bindings);
                }
            });

        } else if (namedTypes.ArrayPattern &&
          namedTypes.ArrayPattern.check(pattern)) {
            patternPath.get('elements').each(function(elementPath) {
                var element = elementPath.value;
                if (namedTypes.Pattern.check(element)) {
                    addPattern(elementPath, bindings);
                } else if (namedTypes.SpreadElement &&
                  namedTypes.SpreadElement.check(element)) {
                    addPattern(elementPath.get("argument"), bindings);
                }
            });

        } else if (namedTypes.PropertyPattern &&
          namedTypes.PropertyPattern.check(pattern)) {
            addPattern(patternPath.get('pattern'), bindings);

        } else if ((namedTypes.SpreadElementPattern &&
          namedTypes.SpreadElementPattern.check(pattern)) ||
          (namedTypes.SpreadPropertyPattern &&
          namedTypes.SpreadPropertyPattern.check(pattern))) {
            addPattern(patternPath.get('argument'), bindings);
        }
    }

    function addTypePattern(patternPath, types) {
        var pattern = patternPath.value;
        namedTypes.Pattern.assert(pattern);

        if (namedTypes.Identifier.check(pattern)) {
            if (hasOwn.call(types, pattern.name)) {
                types[pattern.name].push(patternPath);
            } else {
                types[pattern.name] = [patternPath];
            }

        }
    }

    Sp.lookup = function(name) {
        for (var scope = this; scope; scope = scope.parent)
            if (scope.declares(name))
                break;
        return scope;
    };

    Sp.lookupType = function(name) {
        for (var scope = this; scope; scope = scope.parent)
            if (scope.declaresType(name))
                break;
        return scope;
    };

    Sp.getGlobalScope = function() {
        var scope = this;
        while (!scope.isGlobal)
            scope = scope.parent;
        return scope;
    };

    return Scope;
};

},{"./node-path":16,"./types":21}],20:[function(require,module,exports){
module.exports = function (fork) {
    var exports = {};
    var types = fork.use(require("../lib/types"));
    var Type = types.Type;
    var builtin = types.builtInTypes;
    var isNumber = builtin.number;

    // An example of constructing a new type with arbitrary constraints from
    // an existing type.
    exports.geq = function (than) {
        return new Type(function (value) {
            return isNumber.check(value) && value >= than;
        }, isNumber + " >= " + than);
    };

    // Default value-returning functions that may optionally be passed as a
    // third argument to Def.prototype.field.
    exports.defaults = {
        // Functions were used because (among other reasons) that's the most
        // elegant way to allow for the emptyArray one always to give a new
        // array instance.
        "null": function () { return null },
        "emptyArray": function () { return [] },
        "false": function () { return false },
        "true": function () { return true },
        "undefined": function () {}
    };

    var naiveIsPrimitive = Type.or(
      builtin.string,
      builtin.number,
      builtin.boolean,
      builtin.null,
      builtin.undefined
    );

    exports.isPrimitive = new Type(function (value) {
        if (value === null)
            return true;
        var type = typeof value;
        return !(type === "object" ||
        type === "function");
    }, naiveIsPrimitive.toString());

    return exports;
};
},{"../lib/types":21}],21:[function(require,module,exports){
var Ap = Array.prototype;
var slice = Ap.slice;
var map = Ap.map;
var each = Ap.forEach;
var Op = Object.prototype;
var objToStr = Op.toString;
var funObjStr = objToStr.call(function(){});
var strObjStr = objToStr.call("");
var hasOwn = Op.hasOwnProperty;

module.exports = function () {

    var exports = {};

    // A type is an object with a .check method that takes a value and returns
    // true or false according to whether the value matches the type.

    function Type(check, name) {
        var self = this;
        if (!(self instanceof Type)) {
            throw new Error("Type constructor cannot be invoked without 'new'");
        }

        // Unfortunately we can't elegantly reuse isFunction and isString,
        // here, because this code is executed while defining those types.
        if (objToStr.call(check) !== funObjStr) {
            throw new Error(check + " is not a function");
        }

        // The `name` parameter can be either a function or a string.
        var nameObjStr = objToStr.call(name);
        if (!(nameObjStr === funObjStr ||
          nameObjStr === strObjStr)) {
            throw new Error(name + " is neither a function nor a string");
        }

        Object.defineProperties(self, {
            name: {value: name},
            check: {
                value: function (value, deep) {
                    var result = check.call(self, value, deep);
                    if (!result && deep && objToStr.call(deep) === funObjStr)
                        deep(self, value);
                    return result;
                }
            }
        });
    }

    var Tp = Type.prototype;

    // Throughout this file we use Object.defineProperty to prevent
    // redefinition of exported properties.
    exports.Type = Type;

    // Like .check, except that failure triggers an AssertionError.
    Tp.assert = function (value, deep) {
        if (!this.check(value, deep)) {
            var str = shallowStringify(value);
            throw new Error(str + " does not match type " + this);
        }
        return true;
    };

    function shallowStringify(value) {
        if (isObject.check(value))
            return "{" + Object.keys(value).map(function (key) {
                  return key + ": " + value[key];
              }).join(", ") + "}";

        if (isArray.check(value))
            return "[" + value.map(shallowStringify).join(", ") + "]";

        return JSON.stringify(value);
    }

    Tp.toString = function () {
        var name = this.name;

        if (isString.check(name))
            return name;

        if (isFunction.check(name))
            return name.call(this) + "";

        return name + " type";
    };

    var builtInCtorFns = [];
    var builtInCtorTypes = [];
    var builtInTypes = {};
    exports.builtInTypes = builtInTypes;

    function defBuiltInType(example, name) {
        var objStr = objToStr.call(example);

        var type = new Type(function (value) {
            return objToStr.call(value) === objStr;
        }, name);

        builtInTypes[name] = type;

        if (example && typeof example.constructor === "function") {
            builtInCtorFns.push(example.constructor);
            builtInCtorTypes.push(type);
        }

        return type;
    }

    // These types check the underlying [[Class]] attribute of the given
    // value, rather than using the problematic typeof operator. Note however
    // that no subtyping is considered; so, for instance, isObject.check
    // returns false for [], /./, new Date, and null.
    var isString = defBuiltInType("truthy", "string");
    var isFunction = defBuiltInType(function () {}, "function");
    var isArray = defBuiltInType([], "array");
    var isObject = defBuiltInType({}, "object");
    var isRegExp = defBuiltInType(/./, "RegExp");
    var isDate = defBuiltInType(new Date, "Date");
    var isNumber = defBuiltInType(3, "number");
    var isBoolean = defBuiltInType(true, "boolean");
    var isNull = defBuiltInType(null, "null");
    var isUndefined = defBuiltInType(void 0, "undefined");

    // There are a number of idiomatic ways of expressing types, so this
    // function serves to coerce them all to actual Type objects. Note that
    // providing the name argument is not necessary in most cases.
    function toType(from, name) {
        // The toType function should of course be idempotent.
        if (from instanceof Type)
            return from;

        // The Def type is used as a helper for constructing compound
        // interface types for AST nodes.
        if (from instanceof Def)
            return from.type;

        // Support [ElemType] syntax.
        if (isArray.check(from))
            return Type.fromArray(from);

        // Support { someField: FieldType, ... } syntax.
        if (isObject.check(from))
            return Type.fromObject(from);

        if (isFunction.check(from)) {
            var bicfIndex = builtInCtorFns.indexOf(from);
            if (bicfIndex >= 0) {
                return builtInCtorTypes[bicfIndex];
            }

            // If isFunction.check(from), and from is not a built-in
            // constructor, assume from is a binary predicate function we can
            // use to define the type.
            return new Type(from, name);
        }

        // As a last resort, toType returns a type that matches any value that
        // is === from. This is primarily useful for literal values like
        // toType(null), but it has the additional advantage of allowing
        // toType to be a total function.
        return new Type(function (value) {
            return value === from;
        }, isUndefined.check(name) ? function () {
            return from + "";
        } : name);
    }

    // Returns a type that matches the given value iff any of type1, type2,
    // etc. match the value.
    Type.or = function (/* type1, type2, ... */) {
        var types = [];
        var len = arguments.length;
        for (var i = 0; i < len; ++i)
            types.push(toType(arguments[i]));

        return new Type(function (value, deep) {
            for (var i = 0; i < len; ++i)
                if (types[i].check(value, deep))
                    return true;
            return false;
        }, function () {
            return types.join(" | ");
        });
    };

    Type.fromArray = function (arr) {
        if (!isArray.check(arr)) {
            throw new Error("");
        }
        if (arr.length !== 1) {
            throw new Error("only one element type is permitted for typed arrays");
        }
        return toType(arr[0]).arrayOf();
    };

    Tp.arrayOf = function () {
        var elemType = this;
        return new Type(function (value, deep) {
            return isArray.check(value) && value.every(function (elem) {
                  return elemType.check(elem, deep);
              });
        }, function () {
            return "[" + elemType + "]";
        });
    };

    Type.fromObject = function (obj) {
        var fields = Object.keys(obj).map(function (name) {
            return new Field(name, obj[name]);
        });

        return new Type(function (value, deep) {
            return isObject.check(value) && fields.every(function (field) {
                  return field.type.check(value[field.name], deep);
              });
        }, function () {
            return "{ " + fields.join(", ") + " }";
        });
    };

    function Field(name, type, defaultFn, hidden) {
        var self = this;

        if (!(self instanceof Field)) {
            throw new Error("Field constructor cannot be invoked without 'new'");
        }
        isString.assert(name);

        type = toType(type);

        var properties = {
            name: {value: name},
            type: {value: type},
            hidden: {value: !!hidden}
        };

        if (isFunction.check(defaultFn)) {
            properties.defaultFn = {value: defaultFn};
        }

        Object.defineProperties(self, properties);
    }

    var Fp = Field.prototype;

    Fp.toString = function () {
        return JSON.stringify(this.name) + ": " + this.type;
    };

    Fp.getValue = function (obj) {
        var value = obj[this.name];

        if (!isUndefined.check(value))
            return value;

        if (this.defaultFn)
            value = this.defaultFn.call(obj);

        return value;
    };

    // Define a type whose name is registered in a namespace (the defCache) so
    // that future definitions will return the same type given the same name.
    // In particular, this system allows for circular and forward definitions.
    // The Def object d returned from Type.def may be used to configure the
    // type d.type by calling methods such as d.bases, d.build, and d.field.
    Type.def = function (typeName) {
        isString.assert(typeName);
        return hasOwn.call(defCache, typeName)
          ? defCache[typeName]
          : defCache[typeName] = new Def(typeName);
    };

    // In order to return the same Def instance every time Type.def is called
    // with a particular name, those instances need to be stored in a cache.
    var defCache = Object.create(null);

    function Def(typeName) {
        var self = this;
        if (!(self instanceof Def)) {
            throw new Error("Def constructor cannot be invoked without 'new'");
        }

        Object.defineProperties(self, {
            typeName: {value: typeName},
            baseNames: {value: []},
            ownFields: {value: Object.create(null)},

            // These two are populated during finalization.
            allSupertypes: {value: Object.create(null)}, // Includes own typeName.
            supertypeList: {value: []}, // Linear inheritance hierarchy.
            allFields: {value: Object.create(null)}, // Includes inherited fields.
            fieldNames: {value: []}, // Non-hidden keys of allFields.

            type: {
                value: new Type(function (value, deep) {
                    return self.check(value, deep);
                }, typeName)
            }
        });
    }

    Def.fromValue = function (value) {
        if (value && typeof value === "object") {
            var type = value.type;
            if (typeof type === "string" &&
              hasOwn.call(defCache, type)) {
                var d = defCache[type];
                if (d.finalized) {
                    return d;
                }
            }
        }

        return null;
    };

    var Dp = Def.prototype;

    Dp.isSupertypeOf = function (that) {
        if (that instanceof Def) {
            if (this.finalized !== true ||
              that.finalized !== true) {
                throw new Error("");
            }
            return hasOwn.call(that.allSupertypes, this.typeName);
        } else {
            throw new Error(that + " is not a Def");
        }
    };

    // Note that the list returned by this function is a copy of the internal
    // supertypeList, *without* the typeName itself as the first element.
    exports.getSupertypeNames = function (typeName) {
        if (!hasOwn.call(defCache, typeName)) {
            throw new Error("");
        }
        var d = defCache[typeName];
        if (d.finalized !== true) {
            throw new Error("");
        }
        return d.supertypeList.slice(1);
    };

    // Returns an object mapping from every known type in the defCache to the
    // most specific supertype whose name is an own property of the candidates
    // object.
    exports.computeSupertypeLookupTable = function (candidates) {
        var table = {};
        var typeNames = Object.keys(defCache);
        var typeNameCount = typeNames.length;

        for (var i = 0; i < typeNameCount; ++i) {
            var typeName = typeNames[i];
            var d = defCache[typeName];
            if (d.finalized !== true) {
                throw new Error("" + typeName);
            }
            for (var j = 0; j < d.supertypeList.length; ++j) {
                var superTypeName = d.supertypeList[j];
                if (hasOwn.call(candidates, superTypeName)) {
                    table[typeName] = superTypeName;
                    break;
                }
            }
        }

        return table;
    };

    Dp.checkAllFields = function (value, deep) {
        var allFields = this.allFields;
        if (this.finalized !== true) {
            throw new Error("" + this.typeName);
        }

        function checkFieldByName(name) {
            var field = allFields[name];
            var type = field.type;
            var child = field.getValue(value);
            return type.check(child, deep);
        }

        return isObject.check(value)
          && Object.keys(allFields).every(checkFieldByName);
    };

    Dp.check = function (value, deep) {
        if (this.finalized !== true) {
            throw new Error(
              "prematurely checking unfinalized type " + this.typeName
            );
        }

        // A Def type can only match an object value.
        if (!isObject.check(value))
            return false;

        var vDef = Def.fromValue(value);
        if (!vDef) {
            // If we couldn't infer the Def associated with the given value,
            // and we expected it to be a SourceLocation or a Position, it was
            // probably just missing a "type" field (because Esprima does not
            // assign a type property to such nodes). Be optimistic and let
            // this.checkAllFields make the final decision.
            if (this.typeName === "SourceLocation" ||
              this.typeName === "Position") {
                return this.checkAllFields(value, deep);
            }

            // Calling this.checkAllFields for any other type of node is both
            // bad for performance and way too forgiving.
            return false;
        }

        // If checking deeply and vDef === this, then we only need to call
        // checkAllFields once. Calling checkAllFields is too strict when deep
        // is false, because then we only care about this.isSupertypeOf(vDef).
        if (deep && vDef === this)
            return this.checkAllFields(value, deep);

        // In most cases we rely exclusively on isSupertypeOf to make O(1)
        // subtyping determinations. This suffices in most situations outside
        // of unit tests, since interface conformance is checked whenever new
        // instances are created using builder functions.
        if (!this.isSupertypeOf(vDef))
            return false;

        // The exception is when deep is true; then, we recursively check all
        // fields.
        if (!deep)
            return true;

        // Use the more specific Def (vDef) to perform the deep check, but
        // shallow-check fields defined by the less specific Def (this).
        return vDef.checkAllFields(value, deep)
          && this.checkAllFields(value, false);
    };

    Dp.bases = function () {
        var args = slice.call(arguments);
        var bases = this.baseNames;

        if (this.finalized) {
            if (args.length !== bases.length) {
                throw new Error("");
            }
            for (var i = 0; i < args.length; i++) {
                if (args[i] !== bases[i]) {
                    throw new Error("");
                }
            }
            return this;
        }

        args.forEach(function (baseName) {
            isString.assert(baseName);

            // This indexOf lookup may be O(n), but the typical number of base
            // names is very small, and indexOf is a native Array method.
            if (bases.indexOf(baseName) < 0)
                bases.push(baseName);
        });

        return this; // For chaining.
    };

    // False by default until .build(...) is called on an instance.
    Object.defineProperty(Dp, "buildable", {value: false});

    var builders = {};
    exports.builders = builders;

    // This object is used as prototype for any node created by a builder.
    var nodePrototype = {};

    // Call this function to define a new method to be shared by all AST
     // nodes. The replaced method (if any) is returned for easy wrapping.
    exports.defineMethod = function (name, func) {
        var old = nodePrototype[name];

        // Pass undefined as func to delete nodePrototype[name].
        if (isUndefined.check(func)) {
            delete nodePrototype[name];

        } else {
            isFunction.assert(func);

            Object.defineProperty(nodePrototype, name, {
                enumerable: true, // For discoverability.
                configurable: true, // For delete proto[name].
                value: func
            });
        }

        return old;
    };

    var isArrayOfString = isString.arrayOf();

    // Calling the .build method of a Def simultaneously marks the type as
    // buildable (by defining builders[getBuilderName(typeName)]) and
    // specifies the order of arguments that should be passed to the builder
    // function to create an instance of the type.
    Dp.build = function (/* param1, param2, ... */) {
        var self = this;

        var newBuildParams = slice.call(arguments);
        isArrayOfString.assert(newBuildParams);

        // Calling Def.prototype.build multiple times has the effect of merely
        // redefining this property.
        Object.defineProperty(self, "buildParams", {
            value: newBuildParams,
            writable: false,
            enumerable: false,
            configurable: true
        });

        if (self.buildable) {
            // If this Def is already buildable, update self.buildParams and
            // continue using the old builder function.
            return self;
        }

        // Every buildable type will have its "type" field filled in
        // automatically. This includes types that are not subtypes of Node,
        // like SourceLocation, but that seems harmless (TODO?).
        self.field("type", String, function () { return self.typeName });

        // Override Dp.buildable for this Def instance.
        Object.defineProperty(self, "buildable", {value: true});

        Object.defineProperty(builders, getBuilderName(self.typeName), {
            enumerable: true,

            value: function () {
                var args = arguments;
                var argc = args.length;
                var built = Object.create(nodePrototype);

                if (!self.finalized) {
                    throw new Error(
                      "attempting to instantiate unfinalized type " +
                      self.typeName
                    );
                }

                function add(param, i) {
                    if (hasOwn.call(built, param))
                        return;

                    var all = self.allFields;
                    if (!hasOwn.call(all, param)) {
                        throw new Error("" + param);
                    }

                    var field = all[param];
                    var type = field.type;
                    var value;

                    if (isNumber.check(i) && i < argc) {
                        value = args[i];
                    } else if (field.defaultFn) {
                        // Expose the partially-built object to the default
                        // function as its `this` object.
                        value = field.defaultFn.call(built);
                    } else {
                        var message = "no value or default function given for field " +
                          JSON.stringify(param) + " of " + self.typeName + "(" +
                          self.buildParams.map(function (name) {
                              return all[name];
                          }).join(", ") + ")";
                        throw new Error(message);
                    }

                    if (!type.check(value)) {
                        throw new Error(
                          shallowStringify(value) +
                          " does not match field " + field +
                          " of type " + self.typeName
                        );
                    }

                    // TODO Could attach getters and setters here to enforce
                    // dynamic type safety.
                    built[param] = value;
                }

                self.buildParams.forEach(function (param, i) {
                    add(param, i);
                });

                Object.keys(self.allFields).forEach(function (param) {
                    add(param); // Use the default value.
                });

                // Make sure that the "type" field was filled automatically.
                if (built.type !== self.typeName) {
                    throw new Error("");
                }

                return built;
            }
        });

        return self; // For chaining.
    };

    function getBuilderName(typeName) {
        return typeName.replace(/^[A-Z]+/, function (upperCasePrefix) {
            var len = upperCasePrefix.length;
            switch (len) {
                case 0: return "";
                // If there's only one initial capital letter, just lower-case it.
                case 1: return upperCasePrefix.toLowerCase();
                default:
                    // If there's more than one initial capital letter, lower-case
                    // all but the last one, so that XMLDefaultDeclaration (for
                    // example) becomes xmlDefaultDeclaration.
                    return upperCasePrefix.slice(
                        0, len - 1).toLowerCase() +
                      upperCasePrefix.charAt(len - 1);
            }
        });
    }
    exports.getBuilderName = getBuilderName;

    function getStatementBuilderName(typeName) {
        typeName = getBuilderName(typeName);
        return typeName.replace(/(Expression)?$/, "Statement");
    }
    exports.getStatementBuilderName = getStatementBuilderName;

    // The reason fields are specified using .field(...) instead of an object
    // literal syntax is somewhat subtle: the object literal syntax would
    // support only one key and one value, but with .field(...) we can pass
    // any number of arguments to specify the field.
    Dp.field = function (name, type, defaultFn, hidden) {
        if (this.finalized) {
            console.error("Ignoring attempt to redefine field " +
              JSON.stringify(name) + " of finalized type " +
              JSON.stringify(this.typeName));
            return this;
        }
        this.ownFields[name] = new Field(name, type, defaultFn, hidden);
        return this; // For chaining.
    };

    var namedTypes = {};
    exports.namedTypes = namedTypes;

    // Like Object.keys, but aware of what fields each AST type should have.
    function getFieldNames(object) {
        var d = Def.fromValue(object);
        if (d) {
            return d.fieldNames.slice(0);
        }

        if ("type" in object) {
            throw new Error(
              "did not recognize object of type " +
              JSON.stringify(object.type)
            );
        }

        return Object.keys(object);
    }
    exports.getFieldNames = getFieldNames;

    // Get the value of an object property, taking object.type and default
    // functions into account.
    function getFieldValue(object, fieldName) {
        var d = Def.fromValue(object);
        if (d) {
            var field = d.allFields[fieldName];
            if (field) {
                return field.getValue(object);
            }
        }

        return object && object[fieldName];
    }
    exports.getFieldValue = getFieldValue;

    // Iterate over all defined fields of an object, including those missing
    // or undefined, passing each field name and effective value (as returned
    // by getFieldValue) to the callback. If the object has no corresponding
    // Def, the callback will never be called.
    exports.eachField = function (object, callback, context) {
        getFieldNames(object).forEach(function (name) {
            callback.call(this, name, getFieldValue(object, name));
        }, context);
    };

    // Similar to eachField, except that iteration stops as soon as the
    // callback returns a truthy value. Like Array.prototype.some, the final
    // result is either true or false to indicates whether the callback
    // returned true for any element or not.
    exports.someField = function (object, callback, context) {
        return getFieldNames(object).some(function (name) {
            return callback.call(this, name, getFieldValue(object, name));
        }, context);
    };

    // This property will be overridden as true by individual Def instances
    // when they are finalized.
    Object.defineProperty(Dp, "finalized", {value: false});

    Dp.finalize = function () {
        var self = this;

        // It's not an error to finalize a type more than once, but only the
        // first call to .finalize does anything.
        if (!self.finalized) {
            var allFields = self.allFields;
            var allSupertypes = self.allSupertypes;

            self.baseNames.forEach(function (name) {
                var def = defCache[name];
                if (def instanceof Def) {
                    def.finalize();
                    extend(allFields, def.allFields);
                    extend(allSupertypes, def.allSupertypes);
                } else {
                    var message = "unknown supertype name " +
                      JSON.stringify(name) +
                      " for subtype " +
                      JSON.stringify(self.typeName);
                    throw new Error(message);
                }
            });

            // TODO Warn if fields are overridden with incompatible types.
            extend(allFields, self.ownFields);
            allSupertypes[self.typeName] = self;

            self.fieldNames.length = 0;
            for (var fieldName in allFields) {
                if (hasOwn.call(allFields, fieldName) &&
                    !allFields[fieldName].hidden) {
                        self.fieldNames.push(fieldName);
                }
            }

            // Types are exported only once they have been finalized.
            Object.defineProperty(namedTypes, self.typeName, {
                enumerable: true,
                value: self.type
            });

            Object.defineProperty(self, "finalized", {value: true});

            // A linearization of the inheritance hierarchy.
            populateSupertypeList(self.typeName, self.supertypeList);

            if (self.buildable && self.supertypeList.lastIndexOf("Expression") >= 0) {
                wrapExpressionBuilderWithStatement(self.typeName);
            }
        }
    };

    // Adds an additional builder for Expression subtypes
    // that wraps the built Expression in an ExpressionStatements.
    function wrapExpressionBuilderWithStatement(typeName) {
        var wrapperName = getStatementBuilderName(typeName);

        // skip if the builder already exists
        if (builders[wrapperName]) return;

        // the builder function to wrap with builders.ExpressionStatement
        var wrapped = builders[getBuilderName(typeName)];

        // skip if there is nothing to wrap
        if (!wrapped) return;

        builders[wrapperName] = function () {
            return builders.expressionStatement(wrapped.apply(builders, arguments));
        };
    }

    function populateSupertypeList(typeName, list) {
        list.length = 0;
        list.push(typeName);

        var lastSeen = Object.create(null);

        for (var pos = 0; pos < list.length; ++pos) {
            typeName = list[pos];
            var d = defCache[typeName];
            if (d.finalized !== true) {
                throw new Error("");
            }

            // If we saw typeName earlier in the breadth-first traversal,
            // delete the last-seen occurrence.
            if (hasOwn.call(lastSeen, typeName)) {
                delete list[lastSeen[typeName]];
            }

            // Record the new index of the last-seen occurrence of typeName.
            lastSeen[typeName] = pos;

            // Enqueue the base names of this type.
            list.push.apply(list, d.baseNames);
        }

        // Compaction loop to remove array holes.
        for (var to = 0, from = to, len = list.length; from < len; ++from) {
            if (hasOwn.call(list, from)) {
                list[to++] = list[from];
            }
        }

        list.length = to;
    }

    function extend(into, from) {
        Object.keys(from).forEach(function (name) {
            into[name] = from[name];
        });

        return into;
    };

    exports.finalize = function () {
        Object.keys(defCache).forEach(function (name) {
            defCache[name].finalize();
        });
    };

    return exports;
};

},{}],22:[function(require,module,exports){
module.exports = require('./fork')([
    // This core module of AST types captures ES5 as it is parsed today by
    // git://github.com/ariya/esprima.git#master.
    require("./def/core"),

    // Feel free to add to or remove from this list of extension modules to
    // configure the precise type hierarchy that you need.
    require("./def/es6"),
    require("./def/es7"),
    require("./def/mozilla"),
    require("./def/e4x"),
    require("./def/jsx"),
    require("./def/flow"),
    require("./def/esprima"),
    require("./def/babel"),
    require("./def/babel6")
]);

},{"./def/babel":3,"./def/babel6":5,"./def/core":6,"./def/e4x":7,"./def/es6":8,"./def/es7":9,"./def/esprima":10,"./def/flow":11,"./def/jsx":12,"./def/mozilla":13,"./fork":14}],23:[function(require,module,exports){
var b = require('@gerhobbelt/ast-types').builders;
module.exports = function(scope) {
  return b.functionExpression(
  b.identifier('get'),
  [
    b.identifier('object'),
    b.identifier('property'),
    b.identifier('receiver')
  ],
  b.blockStatement([
    b.variableDeclaration(
      'var',
      [
        b.variableDeclarator(
          b.identifier('desc'),
          b.callExpression(
            b.memberExpression(
              b.identifier('Object'),
              b.identifier('getOwnPropertyDescriptor'),
              false
            ),
            [
              b.identifier('object'),
              b.identifier('property')
            ]
          )
        )
      ]
    ),
    b.ifStatement(
      b.binaryExpression(
        '===',
        b.identifier('desc'),
        b.unaryExpression(
          'void',
          b.literal(0),
          true
        )
      ),
      b.blockStatement([
        b.variableDeclaration(
          'var',
          [
            b.variableDeclarator(
              b.identifier('parent'),
              b.callExpression(
                b.memberExpression(
                  b.identifier('Object'),
                  b.identifier('getPrototypeOf'),
                  false
                ),
                [b.identifier('object')]
              )
            )
          ]
        ),
        b.ifStatement(
          b.binaryExpression(
            '===',
            b.identifier('parent'),
            b.literal(null)
          ),
          b.blockStatement([
            b.returnStatement(
              b.unaryExpression(
                'void',
                b.literal(0),
                true
              )
            )
          ]),
          b.blockStatement([
            b.returnStatement(
              b.callExpression(
                b.identifier('get'),
                [
                  b.identifier('parent'),
                  b.identifier('property'),
                  b.identifier('receiver')
                ]
              )
            )
          ])
        )
      ]),
      b.ifStatement(
        b.logicalExpression(
          '&&',
          b.binaryExpression(
            'in',
            b.literal('value'),
            b.identifier('desc')
          ),
          b.binaryExpression(
            'in',
            b.literal('writable'),
            b.identifier('desc')
          )
        ),
        b.blockStatement([
          b.returnStatement(
            b.memberExpression(
              b.identifier('desc'),
              b.identifier('value'),
              false
            )
          )
        ]),
        b.blockStatement([
          b.variableDeclaration(
            'var',
            [
              b.variableDeclarator(
                b.identifier('getter'),
                b.memberExpression(
                  b.identifier('desc'),
                  b.identifier('get'),
                  false
                )
              )
            ]
          ),
          b.ifStatement(
            b.binaryExpression(
              '===',
              b.identifier('getter'),
              b.unaryExpression(
                'void',
                b.literal(0),
                true
              )
            ),
            b.blockStatement([
              b.returnStatement(
                b.unaryExpression(
                  'void',
                  b.literal(0),
                  true
                )
              )
            ]),
            null
          ),
          b.returnStatement(
            b.callExpression(
              b.memberExpression(
                b.identifier('getter'),
                b.identifier('call'),
                false
              ),
              [b.identifier('receiver')]
            )
          )
        ])
      )
    )
  ]),
  false,
  false
)};

},{"@gerhobbelt/ast-types":22}],24:[function(require,module,exports){
var b = require('@gerhobbelt/ast-types').builders;
module.exports = function(scope) {
  return b.functionExpression(
  null,
  [b.identifier('array')],
  b.blockStatement([
    b.variableDeclaration(
      'var',
      [
        b.variableDeclarator(
          b.identifier('index'),
          b.literal(0)
        )
      ]
    ),
    b.returnStatement(
      b.objectExpression([
        b.property(
          'init',
          b.identifier('next'),
          b.functionExpression(
            null,
            [],
            b.blockStatement([
              b.ifStatement(
                b.binaryExpression(
                  '<',
                  b.identifier('index'),
                  b.memberExpression(
                    b.identifier('array'),
                    b.identifier('length'),
                    false
                  )
                ),
                b.blockStatement([
                  b.returnStatement(
                    b.objectExpression([
                      b.property(
                        'init',
                        b.identifier('done'),
                        b.literal(false)
                      ),
                      b.property(
                        'init',
                        b.identifier('value'),
                        b.memberExpression(
                          b.identifier('array'),
                          b.updateExpression(
                            '++',
                            b.identifier('index'),
                            false
                          ),
                          true
                        )
                      )
                    ])
                  )
                ]),
                b.blockStatement([
                  b.returnStatement(
                    b.objectExpression([
                      b.property(
                        'init',
                        b.identifier('done'),
                        b.literal(true)
                      ),
                      b.property(
                        'init',
                        b.identifier('value'),
                        b.unaryExpression(
                          'void',
                          b.literal(0),
                          true
                        )
                      )
                    ])
                  )
                ])
              )
            ]),
            false,
            false
          )
        )
      ])
    )
  ]),
  false,
  false
)};

},{"@gerhobbelt/ast-types":22}],25:[function(require,module,exports){
var b = require('@gerhobbelt/ast-types').builders;
module.exports = function(scope) {
  var getArrayIterator = require('..').getArrayIterator;

  return b.functionExpression(
  null,
  [b.identifier('iterable')],
  b.blockStatement([
    b.variableDeclaration(
      'var',
      [
        b.variableDeclarator(
          b.identifier('sym'),
          b.logicalExpression(
            '||',
            b.logicalExpression(
              '&&',
              b.binaryExpression(
                '===',
                b.unaryExpression(
                  'typeof',
                  b.identifier('Symbol'),
                  true
                ),
                b.literal('function')
              ),
              b.memberExpression(
                b.identifier('Symbol'),
                b.identifier('iterator'),
                false
              )
            ),
            b.literal('@@iterator')
          )
        )
      ]
    ),
    b.ifStatement(
      b.binaryExpression(
        '===',
        b.unaryExpression(
          'typeof',
          b.memberExpression(
            b.identifier('iterable'),
            b.identifier('sym'),
            true
          ),
          true
        ),
        b.literal('function')
      ),
      b.blockStatement([
        b.returnStatement(
          b.callExpression(
            b.memberExpression(
              b.identifier('iterable'),
              b.identifier('sym'),
              true
            ),
            []
          )
        )
      ]),
      b.ifStatement(
        b.logicalExpression(
          '||',
          b.binaryExpression(
            '===',
            b.unaryExpression(
              'typeof',
              b.identifier('iterable'),
              true
            ),
            b.literal('object')
          ),
          b.binaryExpression(
            '===',
            b.unaryExpression(
              'typeof',
              b.identifier('iterable'),
              true
            ),
            b.literal('function')
          )
        ),
        b.blockStatement([
          b.returnStatement(
            b.callExpression(
              getArrayIterator(scope),
              [b.identifier('iterable')]
            )
          )
        ]),
        b.blockStatement([
          b.throwStatement(
            b.newExpression(
              b.identifier('TypeError'),
              []
            )
          )
        ])
      )
    )
  ]),
  false,
  false
)};

},{"..":27,"@gerhobbelt/ast-types":22}],26:[function(require,module,exports){
var b = require('@gerhobbelt/ast-types').builders;
module.exports = function(scope) {
  return b.functionExpression(
  null,
  [
    b.identifier('iterator'),
    b.identifier('index'),
    b.identifier('begin'),
    b.identifier('len')
  ],
  b.blockStatement([
    b.ifStatement(
      b.binaryExpression(
        '>',
        b.identifier('index'),
        b.identifier('begin')
      ),
      b.blockStatement([
        b.throwStatement(
          b.newExpression(
            b.identifier('RangeError'),
            []
          )
        )
      ]),
      null
    ),
    b.ifStatement(
      b.binaryExpression(
        '===',
        b.unaryExpression(
          'typeof',
          b.identifier('len'),
          true
        ),
        b.literal('undefined')
      ),
      b.blockStatement([
        b.expressionStatement(
          b.assignmentExpression(
            '=',
            b.identifier('len'),
            b.identifier('Infinity')
          )
        )
      ]),
      null
    ),
    b.variableDeclaration(
      'var',
      [
        b.variableDeclarator(
          b.identifier('range'),
          b.arrayExpression([])
        ),
        b.variableDeclarator(
          b.identifier('end'),
          b.binaryExpression(
            '+',
            b.identifier('begin'),
            b.identifier('len')
          )
        )
      ]
    ),
    b.whileStatement(
      b.binaryExpression(
        '<',
        b.identifier('index'),
        b.identifier('end')
      ),
      b.blockStatement([
        b.variableDeclaration(
          'var',
          [
            b.variableDeclarator(
              b.identifier('next'),
              b.callExpression(
                b.memberExpression(
                  b.identifier('iterator'),
                  b.identifier('next'),
                  false
                ),
                []
              )
            )
          ]
        ),
        b.ifStatement(
          b.memberExpression(
            b.identifier('next'),
            b.identifier('done'),
            false
          ),
          b.blockStatement([b.breakStatement()]),
          null
        ),
        b.ifStatement(
          b.binaryExpression(
            '>=',
            b.identifier('index'),
            b.identifier('begin')
          ),
          b.blockStatement([
            b.expressionStatement(
              b.callExpression(
                b.memberExpression(
                  b.identifier('range'),
                  b.identifier('push'),
                  false
                ),
                [
                  b.memberExpression(
                    b.identifier('next'),
                    b.identifier('value'),
                    false
                  )
                ]
              )
            )
          ]),
          null
        ),
        b.expressionStatement(
          b.updateExpression(
            '++',
            b.identifier('index'),
            false
          )
        )
      ])
    ),
    b.returnStatement(
      b.objectExpression([
        b.property(
          'init',
          b.identifier('range'),
          b.identifier('range')
        ),
        b.property(
          'init',
          b.identifier('index'),
          b.identifier('index')
        )
      ])
    )
  ]),
  false,
  false
)};

},{"@gerhobbelt/ast-types":22}],27:[function(require,module,exports){
/* jshint node:true, undef:true, unused:true */

var types = require('@gerhobbelt/ast-types');
var b = types.builders;
var n = types.namedTypes;
var NodePath = types.NodePath;

var getSecret = require('private').makeAccessor();
var hasOwnProp = Object.prototype.hasOwnProperty;

var assert = require('assert');

/**
 * Re-export ast-types for ease of our users.
 */
exports.types = types;

/**
 * Export the Replacement helper for anything that needs to delay replacement.
 */
exports.Replacement = require('./replacement');

/**
 * Returns a call to `Array.prototype.slice` with `node` as the context and
 * `begin` and `end` as the arguments to `slice`.
 *
 * @param {Scope} scope
 * @param {Expression} node
 * @param {Expression|number=} begin
 * @param {Expression|number=} end
 * @return {CallExpression}
 */
function callArraySlice(scope, node, begin, end) {
  if (typeof begin === 'number') {
    begin = b.literal(begin);
  }

  if (typeof end === 'number') {
    end = b.literal(end);
  }

  var args = [];
  if (begin) { args.push(begin); }
  if (end) { args.push(end); }

  return callSharedMethodWithContext(
    scope,
    'Array.prototype.slice',
    node,
    args
  );
}
exports.callArraySlice = callArraySlice;

/**
 * Returns a call to `Function.prototype.bind` using either `call` or `apply`
 * depending on what the value of `args` is. If `args` is an expression then
 * `apply` is used. If `args` is an array of expressions, then `call`.
 *
 * @param {Scope} scope
 * @param {Expression} fn
 * @param {Expression} context
 * @param {Expression|Array.<Expression>} args
 * @return {CallExpression}
 */
function callFunctionBind(scope, fn, context, args) {
  var bind = sharedFor(scope, 'Function.prototype.bind');

  if (n.Expression.check(args)) {
    return b.callExpression(
      b.memberExpression(bind, b.identifier('apply'), false),
      [fn, b.callExpression(
        b.memberExpression(
          b.arrayExpression([context]),
          b.identifier('concat'),
          false
        ),
        [args]
      )]
    );
  } else {
    return b.callExpression(
      b.memberExpression(bind, b.identifier('call'), false),
      [fn, context].concat(args || [])
    );
  }
}
exports.callFunctionBind = callFunctionBind;

/**
 * Gets an iterator for the value representing the given expression.
 *
 * @param {Scope} scope
 * @param {Expression} expression
 * @return {CallExpression}
 */
function callGetIterator(scope, expression) {
  var getIterator = injectGetIteratorHelper(scope.getGlobalScope());
  return b.callExpression(getIterator, [expression]);
}
exports.callGetIterator = callGetIterator;

/**
 * Returns a reference to a shared function that implements the default
 * `@@iterator` for arrays.
 *
 * @private
 * @param {Scope} scope
 * @return {CallExpression}
 */
function getArrayIterator(scope) {
  return injectGetArrayIteratorHelper(scope.getGlobalScope());
}
exports.getArrayIterator = getArrayIterator;

/**
 * return a range of value from an iterator
 *
 * @param {Scope} scope
 * @param {Expression} iterator
 * @param {Literal} index
 * @param {Literal} begin
 * @param {Literal} len
 * @return {CallExpression}
 */
function callGetIteratorRange(scope, iterator, index, begin, len) {
  var getIteratorRange = injectGetIteratorRangeHelper(scope.getGlobalScope());
  return b.callExpression(getIteratorRange, [iterator, index, begin, len]);
}
exports.callGetIteratorRange = callGetIteratorRange;

/**
 * The [[Get]] internal method on objects.
 *
 * @param {Scope} scope
 * @param {Expression} object
 * @param {Expression} property
 * @param {Expression} receiver
 * @return {CallExpression}
 */
function callGet(scope, object, property, receiver) {
  var get = injectGetHelper(scope.getGlobalScope());
  return b.callExpression(get, [object, property, receiver]);
}
exports.callGet = callGet;

/**
 * Returns a call to `Object.getOwnPropertyDescriptor` with the given `object`
 * and `property`.
 *
 * @param {Scope} scope
 * @param {Expression} object
 * @param {Expression|string} property
 * @return {CallExpression}
 */
function callGetOwnPropertyDescriptor(scope, object, property) {
  if (typeof property === 'string') {
    property = b.literal(property);
  }

  return callSharedMethod(
    scope,
    'Object.getOwnPropertyDescriptor',
    [object, property]
  );
}
exports.callGetOwnPropertyDescriptor = callGetOwnPropertyDescriptor;

/**
 * Returns a call to `Object.getPrototypeOf` with the given `object`.
 *
 * @param {Scope} scope
 * @param {Expression} object
 * @return {CallExpression}
 */
function callGetPrototypeOf(scope, object) {
  return callSharedMethod(scope, 'Object.getPrototypeOf', [object]);
}
exports.callGetPrototypeOf = callGetPrototypeOf;

/**
 * Returns a call to `hasOwnProperty` with `node` as the context and `property`
 * as the property to check.
 *
 * @param {Scope} scope
 * @param {Expression} node
 * @param {Expression|string} property
 * @return {CallExpression}
 */
function callHasOwnProperty(scope, node, property) {
  if (typeof property === 'string') {
    property = b.literal(property);
  }

  return callSharedMethodWithContext(
    scope,
    'Object.prototype.hasOwnProperty',
    node,
    [property]
  );
}
exports.callHasOwnProperty = callHasOwnProperty;

/**
 * Returns a call to the given `callee` with `args` as the arguments. If
 * `callee` is a string then it is treated as a globally-accessible function
 * such as `Object.defineProperty` which will be stored in a unique temporary
 * variable. Subsequent calls to this function will re-use the same temporary
 * variable.
 *
 * @param {Scope} scope
 * @param {Expression|string} callee
 * @param {Array.<Expression>} args
 * @return {CallExpression}
 */
function callSharedMethod(scope, callee, args) {
  if (typeof callee === 'string') {
    callee = sharedFor(scope, callee);
  }

  return b.callExpression(callee, args);
}
exports.callSharedMethod = callSharedMethod;

/**
 * Returns a call to the given `callee` with `context` as the method context
 * and `args` as the arguments. If `callee` is a string then it is treated as a
 * globally-accessible function such as `Array.prototype.slice` which will be
 * stored in a unique temporary variable. Subsequent calls to this function
 * will re-use the same temporary variable.
 *
 * @param {Scope} scope
 * @param {Expression|string} callee
 * @param {Expression} context
 * @param {Array.<Expression>} args
 * @return {CallExpression}
 */
function callSharedMethodWithContext(scope, callee, context, args) {
  if (typeof callee === 'string') {
    callee = sharedFor(scope, callee);
  }

  return b.callExpression(
    b.memberExpression(callee, b.identifier('call'), false),
    [context].concat(args)
  );
}
exports.callSharedMethodWithContext = callSharedMethodWithContext;

/**
 * Gets a list of identifiers referencing global variables anywhere within the
 * given `ast`. Assuming the ast is for this code:
 *
 *   var a;
 *   function b(){ return c; }
 *   b(d);
 *
 * Then `getGlobals` will return two identifiers, `c` and `d`.
 *
 * @param {Node} ast
 * @return {Array.<Identifier>}
 */
function getGlobals(ast) {
  var globals = [];
  var seen = Object.create(null);

  types.visit(ast, {
    visitNode: function(path) {
      this.traverse(path);
      var node = path.value;

      if (isReference(path) && !path.scope.lookup(node.name)) {
        if (!(node.name in seen)) {
          seen[node.name] = true;
          globals.push(node);
        }
      }
    }
  });

  return globals;
}
exports.getGlobals = getGlobals;

/**
 * Generate a safe JavaScript identifier for the given string.
 *
 * @param {string} string
 * @return {string}
 * @private
 */
function identifierForString(string) {
  // TODO: Verify this regex.
  return string.replace(/[^\w\d\$_]/g, '$');
}

/**
 * Injects the 'get' pre-built helper.
 *
 * @param {Scope} scope
 * @return {Identifier}
 */
function injectGetHelper(scope) {
  return injectShared(
    scope,
    'get',
    function() {
      return require('./helpers/get')(scope);
    }
  );
}

/**
 * Injects the 'getArrayIterator' pre-built helper.
 *
 * @param {Scope} scope
 * @return {Identifier}
 */
function injectGetArrayIteratorHelper(scope) {
  return injectShared(
    scope,
    'getArrayIterator',
    function() {
      return require('./helpers/getArrayIterator')(scope);
    }
  );
}

/**
 * Injects the 'getIterator' pre-built helper.
 *
 * @param {Scope} scope
 * @return {Identifier}
 */
function injectGetIteratorHelper(scope) {
  return injectShared(
    scope,
    'getIterator',
    function() {
      return require('./helpers/getIterator')(scope);
    }
  );
}

/**
 * Injects the 'getIteratorRange' pre-built helper.
 *
 * @param {Scope} scope
 * @return {Identifier}
 */
function injectGetIteratorRangeHelper(scope) {
  return injectShared(
    scope,
    'getIteratorRange',
    function() {
      return require('./helpers/getIteratorRange')(scope);
    }
  );
}

/**
 * Injects a shared variable with a unique identifier. Only the first call with
 * the same `scope` and `name` will result in a variable declaration being
 * created. The `expression` passed in can either be an AST node or a function
 * to generate one. This function is generally used to inject repeatedly-used
 * values and prevent repeated execution.
 *
 * @param {Scope} scope
 * @param {string} name
 * @param {Expression|function(): Expression} expression
 * @return {Identifier}
 */
function injectShared(scope, name, expression) {
  var scopeSecret = getSecret(scope);

  if (!(name in scopeSecret)) {
    scopeSecret[name] = injectVariable(
      scope,
      uniqueIdentifier(scope, name),
      typeof expression === 'function' ?
        expression() :
        expression
    );
  }

  return scopeSecret[name];
}
exports.injectShared = injectShared;

/**
 * Injects a variable with the given `identifier` into the given `scope` as a
 * `var` declaration with an optional initial value.
 *
 * @param {Scope} scope
 * @param {Identifier} identifier
 * @param {Expression=} init
 * @return {Identifier} Returns the given `identifier`.
 */
function injectVariable(scope, identifier, init) {
  var bodyPath = scope.path.get('body');

  if (n.BlockStatement.check(bodyPath.value)) {
    bodyPath = bodyPath.get('body');
  }

  var declarationIndex;
  var bodyStatements = bodyPath.node.body;

  for (declarationIndex = 0; declarationIndex < bodyStatements.length; declarationIndex++) {
    var statement = bodyStatements[declarationIndex];
    if (!isDirectivePrologue(statement)) {
      break;
    }
  }

  bodyPath.insertAt(
    declarationIndex,
    b.variableDeclaration(
      'var',
      [b.variableDeclarator(identifier, init || null)]
    )
  );

  // Ensure this identifier counts as used in this scope.
  var name = identifier.name;
  var bindings = scope.getBindings();
  if (!hasOwnProp.call(bindings, name)) {
    bindings[name] = [];
  }
  bindings[name].push(new NodePath(identifier));

  return identifier;
}
exports.injectVariable = injectVariable;

/**
 * Determines whether the given statement is a directive prologue, e.g.
 * "use strict".
 *
 * @param {Statement} statement
 * @returns {boolean}
 */
function isDirectivePrologue(statement) {
  if (n.ExpressionStatement.check(statement)) {
    var expression = statement.expression;
    if (n.Literal.check(expression)) {
      return typeof expression.value === 'string';
    }
  }

  return false;
}

/**
 * Determines whether the given `path` is a value reference. For example, `a`
 * and `b` are references, but `c` is not:
 *
 *    a(b.c);
 *
 * Only identifiers count as references.
 *
 * @param {NodePath} path
 * @param {string=} name
 * @return {boolean}
 */
function isReference(path, name) {
  var node = path.value;
  assert.ok(n.Node.check(node));

  if (n.Identifier.check(node)) {
    if (name && node.name !== name) { return false; }

    var parent = path.parent.value;
    if (n.VariableDeclarator.check(parent)) {
      return parent.init === node;
    } else if (n.MemberExpression.check(parent)) {
      return parent.object === node || (
        parent.computed && parent.property === node
      );
    } else if (n.Function.check(parent)) {
      return parent.id !== node && !parent.params.some(function(param) {
        return param === node;
      });
    } else if (n.ClassDeclaration.check(parent) || n.ClassExpression.check(parent)) {
      return parent.id !== node;
    } else if (n.CatchClause.check(parent)) {
      return parent.param !== node;
    } else if (n.Property.check(parent)) {
      return parent.key !== node;
    } else if (n.MethodDefinition.check(parent)) {
      return parent.key !== node;
    } else if (n.ImportSpecifier.check(parent)) {
      return false;
    } else if (n.ImportDefaultSpecifier.check(parent)) {
      return false;
    } else if (n.ImportNamespaceSpecifier.check(parent)) {
      return false;
    } else if (n.LabeledStatement.check(parent)) {
      return false;
    } else {
      return true;
    }
  }

  return false;
}
exports.isReference = isReference;

/**
 * Determines whether the given `name` should be considered "used" in the given
 * `scope`. For a name to be used, it should either:
 *
 *   1. Be declared in this scope or a parent scope.
 *   2. Be referenced in this scope, a parent scope, or any child scopes.
 *
 * For example, `a`, `b`, and `d` are used in the global scope of this example
 * while `c` is not:
 *
 *   var a;
 *   function b() {}
 *
 *   try {
 *     a = b(d);
 *   } catch (c) {
 *   }
 *
 * @param {Scope} scope
 * @param {string} name
 * @return {boolean}
 */
function isUsed(scope, name) {
  if (scope.lookup(name)) {
    return true;
  }

  var globalScope = scope.getGlobalScope();
  var globalScopeSecret = getSecret(globalScope);

  if (!globalScopeSecret.globals) {
    globalScopeSecret.globals = getGlobals(globalScope.node);
  }

  return globalScopeSecret.globals.some(function(global) {
    return global.name === name;
  });
}
exports.isUsed = isUsed;

/**
 * Injects a shared variable by getting the named value from a dotted path. For
 * example, this will return an identifier that can be used in place of the
 * named expression:
 *
 *    sharedFor(scope, 'Object.defineProperty')
 *
 * Subsequent calls to `sharedFor` in the same scope will return the same
 * identifier.
 *
 * @param {Scope} scope
 * @param {string} name
 * @return {Identifier}
 */
function sharedFor(scope, name) {
  return injectShared(
    scope,
    name,
    function() {
      var parts = name.split('.');
      var result = b.identifier(parts[0]);

      for (var i = 1, length = parts.length; i < length; i++) {
        result = b.memberExpression(
          result,
          b.identifier(parts[i]),
          false
        );
      }

      return result;
    }
  );
}
exports.sharedFor = sharedFor;

/**
 * Generates an identifier guaranteed not to collide with any others in the
 * given `scope`. This function will also never generate the same identifier
 * twice for any `scope` whose global scope already got that identifier.
 *
 * Called in a scope with no global references and no variables, the first time
 * this function is called it will return an identifier named `$__0`.
 *
 * When called with a name that name will be used with a prefix, "$__", if
 * possible. If that name is already used then it will append incrementing
 * numbers until it finds a name that isn't used.
 *
 * @param {Scope} scope
 * @param {string=} name
 * @return {Identifier}
 * @see isUsed
 */
function uniqueIdentifier(scope, name) {
  var prefix = '$__' + identifierForString(name ? name : '');
  var globalScopeSecret = getSecret(scope.getGlobalScope());
  var n = globalScopeSecret.nextId || 0;
  var identifier = name ? prefix : null;

  while (!identifier || isUsed(scope, identifier)) {
    identifier = prefix + n;
    n++;
  }

  globalScopeSecret.nextId = n;

  return b.identifier(identifier);
}
exports.uniqueIdentifier = uniqueIdentifier;

},{"./helpers/get":23,"./helpers/getArrayIterator":24,"./helpers/getIterator":25,"./helpers/getIteratorRange":26,"./replacement":28,"@gerhobbelt/ast-types":22,"assert":72,"private":145}],28:[function(require,module,exports){
/* jshint node:true, undef:true, unused:true */

/**
 * Represents a replacement of a node path with zero or more nodes.
 *
 * @constructor
 * @param {NodePath} nodePath
 * @param {Array.<Node>} nodes
 */
function Replacement(nodePath, nodes) {
  this.queue = [];
  if (nodePath && nodes) {
    this.queue.push([nodePath, nodes]);
  }
}

/**
 * Performs the replacement.
 */
Replacement.prototype.replace = function() {
  for (var i = 0, length = this.queue.length; i < length; i++) {
    var item = this.queue[i];
    item[0].replace.apply(item[0], item[1]);
  }
};

/**
 * Incorporates the replacements from the given Replacement into this one.
 *
 * @param {Replacement} anotherReplacement
 */
Replacement.prototype.and = function(anotherReplacement) {
  this.queue.push.apply(this.queue, anotherReplacement.queue);
  return this;
};

/**
 * Constructs a Replacement that, when run, will remove the node from the AST.
 *
 * @param {NodePath} nodePath
 * @returns {Replacement}
 */
Replacement.removes = function(nodePath) {
  return new Replacement(nodePath, []);
};

/**
 * Constructs a Replacement that, when run, will insert the given nodes after
 * the one in nodePath.
 *
 * @param {NodePath} nodePath
 * @param {Array.<Node>} nodes
 * @returns {Replacement}
 */
Replacement.adds = function(nodePath, nodes) {
  return new Replacement(nodePath, [nodePath.node].concat(nodes));
};

/**
 * Constructs a Replacement that, when run, swaps the node in nodePath with the
 * given node or nodes.
 *
 * @param {NodePath} nodePath
 * @param {Node|Array.<Node>} nodes
 */
Replacement.swaps = function(nodePath, nodes) {
  if ({}.toString.call(nodes) !== '[object Array]') {
    nodes = [nodes];
  }
  return new Replacement(nodePath, nodes);
};

/**
 * Build replacements for each of the items in nodePaths by passing them to the
 * given callback. If the callback returns null for a given node path then no
 * replacement will be created for that node.
 *
 * @param {Array.<NodePath>} nodePaths
 * @param {function(NodePath): ?Replacement} callback
 * @returns {Replacement}
 */
Replacement.map = function(nodePaths, callback) {
  var result = new Replacement();

  nodePaths.each(function(nodePath) {
    var replacement = callback(nodePath);
    if (replacement) {
      result.and(replacement);
    }
  });

  return result;
};

module.exports = Replacement;

},{}],29:[function(require,module,exports){
(function webpackUniversalModuleDefinition(root, factory) {
/* istanbul ignore next */
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
/* istanbul ignore next */
	else if(typeof exports === 'object')
		exports["esprima"] = factory();
	else
		root["esprima"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/* istanbul ignore if */
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 10);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Syntax = {
    AssignmentExpression: 'AssignmentExpression',
    AssignmentPattern: 'AssignmentPattern',
    ArrayExpression: 'ArrayExpression',
    ArrayPattern: 'ArrayPattern',
    ArrowFunctionExpression: 'ArrowFunctionExpression',
    AwaitExpression: 'AwaitExpression',
    BlockStatement: 'BlockStatement',
    BinaryExpression: 'BinaryExpression',
    BreakStatement: 'BreakStatement',
    CallExpression: 'CallExpression',
    CatchClause: 'CatchClause',
    ClassBody: 'ClassBody',
    ClassDeclaration: 'ClassDeclaration',
    ClassExpression: 'ClassExpression',
    ConditionalExpression: 'ConditionalExpression',
    ContinueStatement: 'ContinueStatement',
    DoWhileStatement: 'DoWhileStatement',
    DebuggerStatement: 'DebuggerStatement',
    EmptyStatement: 'EmptyStatement',
    ExportAllDeclaration: 'ExportAllDeclaration',
    ExportDefaultDeclaration: 'ExportDefaultDeclaration',
    ExportNamedDeclaration: 'ExportNamedDeclaration',
    ExportSpecifier: 'ExportSpecifier',
    ExpressionStatement: 'ExpressionStatement',
    ForStatement: 'ForStatement',
    ForOfStatement: 'ForOfStatement',
    ForInStatement: 'ForInStatement',
    FunctionDeclaration: 'FunctionDeclaration',
    FunctionExpression: 'FunctionExpression',
    Identifier: 'Identifier',
    IfStatement: 'IfStatement',
    Import: 'Import',
    ImportDeclaration: 'ImportDeclaration',
    ImportDefaultSpecifier: 'ImportDefaultSpecifier',
    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
    ImportSpecifier: 'ImportSpecifier',
    Literal: 'Literal',
    LabeledStatement: 'LabeledStatement',
    LogicalExpression: 'LogicalExpression',
    MemberExpression: 'MemberExpression',
    MetaProperty: 'MetaProperty',
    MethodDefinition: 'MethodDefinition',
    NewExpression: 'NewExpression',
    ObjectExpression: 'ObjectExpression',
    ObjectPattern: 'ObjectPattern',
    Program: 'Program',
    Property: 'Property',
    RestElement: 'RestElement',
    ReturnStatement: 'ReturnStatement',
    SequenceExpression: 'SequenceExpression',
    SpreadElement: 'SpreadElement',
    Super: 'Super',
    SwitchCase: 'SwitchCase',
    SwitchStatement: 'SwitchStatement',
    TaggedTemplateExpression: 'TaggedTemplateExpression',
    TemplateElement: 'TemplateElement',
    TemplateLiteral: 'TemplateLiteral',
    ThisExpression: 'ThisExpression',
    ThrowStatement: 'ThrowStatement',
    TryStatement: 'TryStatement',
    UnaryExpression: 'UnaryExpression',
    UpdateExpression: 'UpdateExpression',
    VariableDeclaration: 'VariableDeclaration',
    VariableDeclarator: 'VariableDeclarator',
    WhileStatement: 'WhileStatement',
    WithStatement: 'WithStatement',
    YieldExpression: 'YieldExpression'
};


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenName = {};
exports.TokenName[1 /* BooleanLiteral */] = 'Boolean';
exports.TokenName[2 /* EOF */] = '<end>';
exports.TokenName[3 /* Identifier */] = 'Identifier';
exports.TokenName[4 /* Keyword */] = 'Keyword';
exports.TokenName[5 /* NullLiteral */] = 'Null';
exports.TokenName[6 /* NumericLiteral */] = 'Numeric';
exports.TokenName[7 /* Punctuator */] = 'Punctuator';
exports.TokenName[8 /* StringLiteral */] = 'String';
exports.TokenName[9 /* RegularExpression */] = 'RegularExpression';
exports.TokenName[10 /* Template */] = 'Template';


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// See also tools/generate-unicode-regex.js.
var Regex = {
    // ECMAScript 6/Unicode v8.0.0 NonAsciiIdentifierStart:
    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
    // ECMAScript 6/Unicode v8.0.0 NonAsciiIdentifierPart:
    NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/,
};
// See also tools/generate-unicode-regex.js:
// Appending snippet file: W:\Users\Ger\Projects\sites\library.visyond.gov\80\lib\js\esprima\tools\generate-indentifier-character.ts.snippet
exports.Character = {
    /* tslint:disable:no-bitwise */
    fromCodePoint: function (cp) {
        return (cp < 0x10000) ? String.fromCharCode(cp) :
            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +
                String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));
    },
    // https://tc39.github.io/ecma262/#sec-white-space
    isWhiteSpace: function (cp) {
        return (cp === 0x20) || (cp === 0x09) || (cp === 0x0B) || (cp === 0x0C) || (cp === 0xA0) ||
            (cp >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(cp) >= 0);
    },
    // https://tc39.github.io/ecma262/#sec-line-terminators
    isLineTerminator: function (cp) {
        return (cp === 0x0A) || (cp === 0x0D) || (cp === 0x2028) || (cp === 0x2029);
    },
    // https://tc39.github.io/ecma262/#sec-names-and-keywords
    isIdentifierStart: function (cp) {
        return (cp === 0x24) || (cp === 0x5F) || // $ (dollar) and _ (underscore)
            (cp >= 0x41 && cp <= 0x5A) || // A..Z
            (cp >= 0x61 && cp <= 0x7A) || // a..z
            (cp === 0x5C) || // \ (backslash)
            ((cp >= 0x80) && Regex.NonAsciiIdentifierStart.test(exports.Character.fromCodePoint(cp)));
    },
    isIdentifierPart: function (cp) {
        return (cp === 0x24) || (cp === 0x5F) || // $ (dollar) and _ (underscore)
            (cp >= 0x41 && cp <= 0x5A) || // A..Z
            (cp >= 0x61 && cp <= 0x7A) || // a..z
            (cp >= 0x30 && cp <= 0x39) || // 0..9
            (cp === 0x5C) || // \ (backslash)
            ((cp >= 0x80) && Regex.NonAsciiIdentifierPart.test(exports.Character.fromCodePoint(cp)));
    },
    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
    isDecimalDigit: function (cp) {
        return (cp >= 0x30 && cp <= 0x39); // 0..9
    },
    isHexDigit: function (cp) {
        return (cp >= 0x30 && cp <= 0x39) || // 0..9
            (cp >= 0x41 && cp <= 0x46) || // A..F
            (cp >= 0x61 && cp <= 0x66); // a..f
    },
    isOctalDigit: function (cp) {
        return (cp >= 0x30 && cp <= 0x37); // 0..7
    }
};


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.JSXSyntax = {
    JSXAttribute: 'JSXAttribute',
    JSXClosingElement: 'JSXClosingElement',
    JSXElement: 'JSXElement',
    JSXEmptyExpression: 'JSXEmptyExpression',
    JSXExpressionContainer: 'JSXExpressionContainer',
    JSXIdentifier: 'JSXIdentifier',
    JSXMemberExpression: 'JSXMemberExpression',
    JSXNamespacedName: 'JSXNamespacedName',
    JSXOpeningElement: 'JSXOpeningElement',
    JSXSpreadAttribute: 'JSXSpreadAttribute',
    JSXText: 'JSXText'
};


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var syntax_1 = __webpack_require__(0);
/* tslint:disable:max-classes-per-file */
var ArrayExpression = /** @class */ (function () {
    function ArrayExpression(elements) {
        this.type = syntax_1.Syntax.ArrayExpression;
        this.elements = elements;
    }
    return ArrayExpression;
}());
exports.ArrayExpression = ArrayExpression;
var ArrayPattern = /** @class */ (function () {
    function ArrayPattern(elements) {
        this.type = syntax_1.Syntax.ArrayPattern;
        this.elements = elements;
    }
    return ArrayPattern;
}());
exports.ArrayPattern = ArrayPattern;
var ArrowFunctionExpression = /** @class */ (function () {
    function ArrowFunctionExpression(params, body, expression) {
        this.type = syntax_1.Syntax.ArrowFunctionExpression;
        this.id = null;
        this.params = params;
        this.body = body;
        this.generator = false;
        this.expression = expression;
        this.async = false;
    }
    return ArrowFunctionExpression;
}());
exports.ArrowFunctionExpression = ArrowFunctionExpression;
var AssignmentExpression = /** @class */ (function () {
    function AssignmentExpression(operator, left, right) {
        this.type = syntax_1.Syntax.AssignmentExpression;
        this.operator = operator;
        this.left = left;
        this.right = right;
    }
    return AssignmentExpression;
}());
exports.AssignmentExpression = AssignmentExpression;
var AssignmentPattern = /** @class */ (function () {
    function AssignmentPattern(left, right) {
        this.type = syntax_1.Syntax.AssignmentPattern;
        this.left = left;
        this.right = right;
    }
    return AssignmentPattern;
}());
exports.AssignmentPattern = AssignmentPattern;
var AsyncArrowFunctionExpression = /** @class */ (function () {
    function AsyncArrowFunctionExpression(params, body, expression) {
        this.type = syntax_1.Syntax.ArrowFunctionExpression;
        this.id = null;
        this.params = params;
        this.body = body;
        this.generator = false;
        this.expression = expression;
        this.async = true;
    }
    return AsyncArrowFunctionExpression;
}());
exports.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
var AsyncFunctionDeclaration = /** @class */ (function () {
    function AsyncFunctionDeclaration(id, params, body) {
        this.type = syntax_1.Syntax.FunctionDeclaration;
        this.id = id;
        this.params = params;
        this.body = body;
        this.generator = false;
        this.expression = false;
        this.async = true;
    }
    return AsyncFunctionDeclaration;
}());
exports.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
var AsyncFunctionExpression = /** @class */ (function () {
    function AsyncFunctionExpression(id, params, body) {
        this.type = syntax_1.Syntax.FunctionExpression;
        this.id = id;
        this.params = params;
        this.body = body;
        this.generator = false;
        this.expression = false;
        this.async = true;
    }
    return AsyncFunctionExpression;
}());
exports.AsyncFunctionExpression = AsyncFunctionExpression;
var AwaitExpression = /** @class */ (function () {
    function AwaitExpression(argument) {
        this.type = syntax_1.Syntax.AwaitExpression;
        this.argument = argument;
    }
    return AwaitExpression;
}());
exports.AwaitExpression = AwaitExpression;
var BinaryExpression = /** @class */ (function () {
    function BinaryExpression(operator, left, right) {
        var logical = (operator === '||' || operator === '&&');
        this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
        this.operator = operator;
        this.left = left;
        this.right = right;
    }
    return BinaryExpression;
}());
exports.BinaryExpression = BinaryExpression;
var BlockStatement = /** @class */ (function () {
    function BlockStatement(body) {
        this.type = syntax_1.Syntax.BlockStatement;
        this.body = body;
    }
    return BlockStatement;
}());
exports.BlockStatement = BlockStatement;
var BreakStatement = /** @class */ (function () {
    function BreakStatement(label) {
        this.type = syntax_1.Syntax.BreakStatement;
        this.label = label;
    }
    return BreakStatement;
}());
exports.BreakStatement = BreakStatement;
var CallExpression = /** @class */ (function () {
    function CallExpression(callee, args) {
        this.type = syntax_1.Syntax.CallExpression;
        this.callee = callee;
        this.arguments = args;
    }
    return CallExpression;
}());
exports.CallExpression = CallExpression;
var CatchClause = /** @class */ (function () {
    function CatchClause(param, body) {
        this.type = syntax_1.Syntax.CatchClause;
        this.param = param;
        this.body = body;
    }
    return CatchClause;
}());
exports.CatchClause = CatchClause;
var ClassBody = /** @class */ (function () {
    function ClassBody(body) {
        this.type = syntax_1.Syntax.ClassBody;
        this.body = body;
    }
    return ClassBody;
}());
exports.ClassBody = ClassBody;
var ClassDeclaration = /** @class */ (function () {
    function ClassDeclaration(id, superClass, body) {
        this.type = syntax_1.Syntax.ClassDeclaration;
        this.id = id;
        this.superClass = superClass;
        this.body = body;
    }
    return ClassDeclaration;
}());
exports.ClassDeclaration = ClassDeclaration;
var ClassExpression = /** @class */ (function () {
    function ClassExpression(id, superClass, body) {
        this.type = syntax_1.Syntax.ClassExpression;
        this.id = id;
        this.superClass = superClass;
        this.body = body;
    }
    return ClassExpression;
}());
exports.ClassExpression = ClassExpression;
var ComputedMemberExpression = /** @class */ (function () {
    function ComputedMemberExpression(object, property) {
        this.type = syntax_1.Syntax.MemberExpression;
        this.computed = true;
        this.object = object;
        this.property = property;
    }
    return ComputedMemberExpression;
}());
exports.ComputedMemberExpression = ComputedMemberExpression;
var ConditionalExpression = /** @class */ (function () {
    function ConditionalExpression(test, consequent, alternate) {
        this.type = syntax_1.Syntax.ConditionalExpression;
        this.test = test;
        this.consequent = consequent;
        this.alternate = alternate;
    }
    return ConditionalExpression;
}());
exports.ConditionalExpression = ConditionalExpression;
var ContinueStatement = /** @class */ (function () {
    function ContinueStatement(label) {
        this.type = syntax_1.Syntax.ContinueStatement;
        this.label = label;
    }
    return ContinueStatement;
}());
exports.ContinueStatement = ContinueStatement;
var DebuggerStatement = /** @class */ (function () {
    function DebuggerStatement() {
        this.type = syntax_1.Syntax.DebuggerStatement;
    }
    return DebuggerStatement;
}());
exports.DebuggerStatement = DebuggerStatement;
var Directive = /** @class */ (function () {
    function Directive(expression, directive) {
        this.type = syntax_1.Syntax.ExpressionStatement;
        this.expression = expression;
        this.directive = directive;
    }
    return Directive;
}());
exports.Directive = Directive;
var DoWhileStatement = /** @class */ (function () {
    function DoWhileStatement(body, test) {
        this.type = syntax_1.Syntax.DoWhileStatement;
        this.body = body;
        this.test = test;
    }
    return DoWhileStatement;
}());
exports.DoWhileStatement = DoWhileStatement;
var EmptyStatement = /** @class */ (function () {
    function EmptyStatement() {
        this.type = syntax_1.Syntax.EmptyStatement;
    }
    return EmptyStatement;
}());
exports.EmptyStatement = EmptyStatement;
var ExportAllDeclaration = /** @class */ (function () {
    function ExportAllDeclaration(source) {
        this.type = syntax_1.Syntax.ExportAllDeclaration;
        this.source = source;
    }
    return ExportAllDeclaration;
}());
exports.ExportAllDeclaration = ExportAllDeclaration;
var ExportDefaultDeclaration = /** @class */ (function () {
    function ExportDefaultDeclaration(declaration) {
        this.type = syntax_1.Syntax.ExportDefaultDeclaration;
        this.declaration = declaration;
    }
    return ExportDefaultDeclaration;
}());
exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
var ExportNamedDeclaration = /** @class */ (function () {
    function ExportNamedDeclaration(declaration, specifiers, source) {
        this.type = syntax_1.Syntax.ExportNamedDeclaration;
        this.declaration = declaration;
        this.specifiers = specifiers;
        this.source = source;
    }
    return ExportNamedDeclaration;
}());
exports.ExportNamedDeclaration = ExportNamedDeclaration;
var ExportSpecifier = /** @class */ (function () {
    function ExportSpecifier(local, exported) {
        this.type = syntax_1.Syntax.ExportSpecifier;
        this.exported = exported;
        this.local = local;
    }
    return ExportSpecifier;
}());
exports.ExportSpecifier = ExportSpecifier;
var ExpressionStatement = /** @class */ (function () {
    function ExpressionStatement(expression) {
        this.type = syntax_1.Syntax.ExpressionStatement;
        this.expression = expression;
    }
    return ExpressionStatement;
}());
exports.ExpressionStatement = ExpressionStatement;
var ForInStatement = /** @class */ (function () {
    function ForInStatement(left, right, body) {
        this.type = syntax_1.Syntax.ForInStatement;
        this.left = left;
        this.right = right;
        this.body = body;
        this.each = false;
    }
    return ForInStatement;
}());
exports.ForInStatement = ForInStatement;
var ForOfStatement = /** @class */ (function () {
    function ForOfStatement(left, right, body) {
        this.type = syntax_1.Syntax.ForOfStatement;
        this.left = left;
        this.right = right;
        this.body = body;
    }
    return ForOfStatement;
}());
exports.ForOfStatement = ForOfStatement;
var ForStatement = /** @class */ (function () {
    function ForStatement(init, test, update, body) {
        this.type = syntax_1.Syntax.ForStatement;
        this.init = init;
        this.test = test;
        this.update = update;
        this.body = body;
    }
    return ForStatement;
}());
exports.ForStatement = ForStatement;
var FunctionDeclaration = /** @class */ (function () {
    function FunctionDeclaration(id, params, body, generator) {
        this.type = syntax_1.Syntax.FunctionDeclaration;
        this.id = id;
        this.params = params;
        this.body = body;
        this.generator = generator;
        this.expression = false;
        this.async = false;
    }
    return FunctionDeclaration;
}());
exports.FunctionDeclaration = FunctionDeclaration;
var FunctionExpression = /** @class */ (function () {
    function FunctionExpression(id, params, body, generator) {
        this.type = syntax_1.Syntax.FunctionExpression;
        this.id = id;
        this.params = params;
        this.body = body;
        this.generator = generator;
        this.expression = false;
        this.async = false;
    }
    return FunctionExpression;
}());
exports.FunctionExpression = FunctionExpression;
var Identifier = /** @class */ (function () {
    function Identifier(name) {
        this.type = syntax_1.Syntax.Identifier;
        this.name = name;
    }
    return Identifier;
}());
exports.Identifier = Identifier;
var IfStatement = /** @class */ (function () {
    function IfStatement(test, consequent, alternate) {
        this.type = syntax_1.Syntax.IfStatement;
        this.test = test;
        this.consequent = consequent;
        this.alternate = alternate;
    }
    return IfStatement;
}());
exports.IfStatement = IfStatement;
var Import = /** @class */ (function () {
    function Import() {
        this.type = syntax_1.Syntax.Import;
    }
    return Import;
}());
exports.Import = Import;
var ImportDeclaration = /** @class */ (function () {
    function ImportDeclaration(specifiers, source) {
        this.type = syntax_1.Syntax.ImportDeclaration;
        this.specifiers = specifiers;
        this.source = source;
    }
    return ImportDeclaration;
}());
exports.ImportDeclaration = ImportDeclaration;
var ImportDefaultSpecifier = /** @class */ (function () {
    function ImportDefaultSpecifier(local) {
        this.type = syntax_1.Syntax.ImportDefaultSpecifier;
        this.local = local;
    }
    return ImportDefaultSpecifier;
}());
exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
var ImportNamespaceSpecifier = /** @class */ (function () {
    function ImportNamespaceSpecifier(local) {
        this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
        this.local = local;
    }
    return ImportNamespaceSpecifier;
}());
exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
var ImportSpecifier = /** @class */ (function () {
    function ImportSpecifier(local, imported) {
        this.type = syntax_1.Syntax.ImportSpecifier;
        this.local = local;
        this.imported = imported;
    }
    return ImportSpecifier;
}());
exports.ImportSpecifier = ImportSpecifier;
var LabeledStatement = /** @class */ (function () {
    function LabeledStatement(label, body) {
        this.type = syntax_1.Syntax.LabeledStatement;
        this.label = label;
        this.body = body;
    }
    return LabeledStatement;
}());
exports.LabeledStatement = LabeledStatement;
var Literal = /** @class */ (function () {
    function Literal(value, raw) {
        this.type = syntax_1.Syntax.Literal;
        this.value = value;
        this.raw = raw;
    }
    return Literal;
}());
exports.Literal = Literal;
var MetaProperty = /** @class */ (function () {
    function MetaProperty(meta, property) {
        this.type = syntax_1.Syntax.MetaProperty;
        this.meta = meta;
        this.property = property;
    }
    return MetaProperty;
}());
exports.MetaProperty = MetaProperty;
var MethodDefinition = /** @class */ (function () {
    function MethodDefinition(key, computed, value, kind, isStatic) {
        this.type = syntax_1.Syntax.MethodDefinition;
        this.key = key;
        this.computed = computed;
        this.value = value;
        this.kind = kind;
        this.static = isStatic;
    }
    return MethodDefinition;
}());
exports.MethodDefinition = MethodDefinition;
var Module = /** @class */ (function () {
    function Module(body) {
        this.type = syntax_1.Syntax.Program;
        this.body = body;
        this.sourceType = 'module';
    }
    return Module;
}());
exports.Module = Module;
var NewExpression = /** @class */ (function () {
    function NewExpression(callee, args) {
        this.type = syntax_1.Syntax.NewExpression;
        this.callee = callee;
        this.arguments = args;
    }
    return NewExpression;
}());
exports.NewExpression = NewExpression;
var ObjectExpression = /** @class */ (function () {
    function ObjectExpression(properties) {
        this.type = syntax_1.Syntax.ObjectExpression;
        this.properties = properties;
    }
    return ObjectExpression;
}());
exports.ObjectExpression = ObjectExpression;
var ObjectPattern = /** @class */ (function () {
    function ObjectPattern(properties) {
        this.type = syntax_1.Syntax.ObjectPattern;
        this.properties = properties;
    }
    return ObjectPattern;
}());
exports.ObjectPattern = ObjectPattern;
var Property = /** @class */ (function () {
    function Property(kind, key, computed, value, method, shorthand) {
        this.type = syntax_1.Syntax.Property;
        this.key = key;
        this.computed = computed;
        this.value = value;
        this.kind = kind;
        this.method = method;
        this.shorthand = shorthand;
    }
    return Property;
}());
exports.Property = Property;
var RegexLiteral = /** @class */ (function () {
    function RegexLiteral(value, raw, pattern, flags) {
        this.type = syntax_1.Syntax.Literal;
        this.value = value;
        this.raw = raw;
        this.regex = { pattern: pattern, flags: flags };
    }
    return RegexLiteral;
}());
exports.RegexLiteral = RegexLiteral;
var RestElement = /** @class */ (function () {
    function RestElement(argument) {
        this.type = syntax_1.Syntax.RestElement;
        this.argument = argument;
    }
    return RestElement;
}());
exports.RestElement = RestElement;
var ReturnStatement = /** @class */ (function () {
    function ReturnStatement(argument) {
        this.type = syntax_1.Syntax.ReturnStatement;
        this.argument = argument;
    }
    return ReturnStatement;
}());
exports.ReturnStatement = ReturnStatement;
var Script = /** @class */ (function () {
    function Script(body) {
        this.type = syntax_1.Syntax.Program;
        this.body = body;
        this.sourceType = 'script';
    }
    return Script;
}());
exports.Script = Script;
var SequenceExpression = /** @class */ (function () {
    function SequenceExpression(expressions) {
        this.type = syntax_1.Syntax.SequenceExpression;
        this.expressions = expressions;
    }
    return SequenceExpression;
}());
exports.SequenceExpression = SequenceExpression;
var SpreadElement = /** @class */ (function () {
    function SpreadElement(argument) {
        this.type = syntax_1.Syntax.SpreadElement;
        this.argument = argument;
    }
    return SpreadElement;
}());
exports.SpreadElement = SpreadElement;
var StaticMemberExpression = /** @class */ (function () {
    function StaticMemberExpression(object, property) {
        this.type = syntax_1.Syntax.MemberExpression;
        this.computed = false;
        this.object = object;
        this.property = property;
    }
    return StaticMemberExpression;
}());
exports.StaticMemberExpression = StaticMemberExpression;
var Super = /** @class */ (function () {
    function Super() {
        this.type = syntax_1.Syntax.Super;
    }
    return Super;
}());
exports.Super = Super;
var SwitchCase = /** @class */ (function () {
    function SwitchCase(test, consequent) {
        this.type = syntax_1.Syntax.SwitchCase;
        this.test = test;
        this.consequent = consequent;
    }
    return SwitchCase;
}());
exports.SwitchCase = SwitchCase;
var SwitchStatement = /** @class */ (function () {
    function SwitchStatement(discriminant, cases) {
        this.type = syntax_1.Syntax.SwitchStatement;
        this.discriminant = discriminant;
        this.cases = cases;
    }
    return SwitchStatement;
}());
exports.SwitchStatement = SwitchStatement;
var TaggedTemplateExpression = /** @class */ (function () {
    function TaggedTemplateExpression(tag, quasi) {
        this.type = syntax_1.Syntax.TaggedTemplateExpression;
        this.tag = tag;
        this.quasi = quasi;
    }
    return TaggedTemplateExpression;
}());
exports.TaggedTemplateExpression = TaggedTemplateExpression;
var TemplateElement = /** @class */ (function () {
    function TemplateElement(value, tail) {
        this.type = syntax_1.Syntax.TemplateElement;
        this.value = value;
        this.tail = tail;
    }
    return TemplateElement;
}());
exports.TemplateElement = TemplateElement;
var TemplateLiteral = /** @class */ (function () {
    function TemplateLiteral(quasis, expressions) {
        this.type = syntax_1.Syntax.TemplateLiteral;
        this.quasis = quasis;
        this.expressions = expressions;
    }
    return TemplateLiteral;
}());
exports.TemplateLiteral = TemplateLiteral;
var ThisExpression = /** @class */ (function () {
    function ThisExpression() {
        this.type = syntax_1.Syntax.ThisExpression;
    }
    return ThisExpression;
}());
exports.ThisExpression = ThisExpression;
var ThrowStatement = /** @class */ (function () {
    function ThrowStatement(argument) {
        this.type = syntax_1.Syntax.ThrowStatement;
        this.argument = argument;
    }
    return ThrowStatement;
}());
exports.ThrowStatement = ThrowStatement;
var TryStatement = /** @class */ (function () {
    function TryStatement(block, handler, finalizer) {
        this.type = syntax_1.Syntax.TryStatement;
        this.block = block;
        this.handler = handler;
        this.finalizer = finalizer;
    }
    return TryStatement;
}());
exports.TryStatement = TryStatement;
var UnaryExpression = /** @class */ (function () {
    function UnaryExpression(operator, argument) {
        this.type = syntax_1.Syntax.UnaryExpression;
        this.operator = operator;
        this.argument = argument;
        this.prefix = true;
    }
    return UnaryExpression;
}());
exports.UnaryExpression = UnaryExpression;
var UpdateExpression = /** @class */ (function () {
    function UpdateExpression(operator, argument, prefix) {
        this.type = syntax_1.Syntax.UpdateExpression;
        this.operator = operator;
        this.argument = argument;
        this.prefix = prefix;
    }
    return UpdateExpression;
}());
exports.UpdateExpression = UpdateExpression;
var VariableDeclaration = /** @class */ (function () {
    function VariableDeclaration(declarations, kind) {
        this.type = syntax_1.Syntax.VariableDeclaration;
        this.declarations = declarations;
        this.kind = kind;
    }
    return VariableDeclaration;
}());
exports.VariableDeclaration = VariableDeclaration;
var VariableDeclarator = /** @class */ (function () {
    function VariableDeclarator(id, init) {
        this.type = syntax_1.Syntax.VariableDeclarator;
        this.id = id;
        this.init = init;
    }
    return VariableDeclarator;
}());
exports.VariableDeclarator = VariableDeclarator;
var WhileStatement = /** @class */ (function () {
    function WhileStatement(test, body) {
        this.type = syntax_1.Syntax.WhileStatement;
        this.test = test;
        this.body = body;
    }
    return WhileStatement;
}());
exports.WhileStatement = WhileStatement;
var WithStatement = /** @class */ (function () {
    function WithStatement(object, body) {
        this.type = syntax_1.Syntax.WithStatement;
        this.object = object;
        this.body = body;
    }
    return WithStatement;
}());
exports.WithStatement = WithStatement;
var YieldExpression = /** @class */ (function () {
    function YieldExpression(argument, delegate) {
        this.type = syntax_1.Syntax.YieldExpression;
        this.argument = argument;
        this.delegate = delegate;
    }
    return YieldExpression;
}());
exports.YieldExpression = YieldExpression;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var assert_1 = __webpack_require__(6);
var error_handler_1 = __webpack_require__(7);
var messages_1 = __webpack_require__(8);
var Node = __webpack_require__(4);
var scanner_1 = __webpack_require__(9);
var syntax_1 = __webpack_require__(0);
var token_1 = __webpack_require__(1);
var ArrowParameterPlaceHolder = 'ArrowParameterPlaceHolder';
var Parser = /** @class */ (function () {
    function Parser(code, options, delegate) {
        if (options === void 0) { options = {}; }
        this.config = {
            range: (typeof options.range === 'boolean') && options.range,
            loc: (typeof options.loc === 'boolean') && options.loc,
            source: null,
            tokens: (typeof options.tokens === 'boolean') && options.tokens,
            comment: (typeof options.comment === 'boolean') && options.comment,
            tolerant: (typeof options.tolerant === 'boolean') && options.tolerant
        };
        if (this.config.loc && options.source && options.source !== null) {
            this.config.source = String(options.source);
        }
        this.delegate = delegate;
        this.errorHandler = new error_handler_1.ErrorHandler();
        this.errorHandler.tolerant = this.config.tolerant;
        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
        this.scanner.trackComment = this.config.comment;
        this.operatorPrecedence = {
            ')': 0,
            ';': 0,
            ',': 0,
            '=': 0,
            ']': 0,
            '||': 1,
            '&&': 2,
            '|': 3,
            '^': 4,
            '&': 5,
            '==': 6,
            '!=': 6,
            '===': 6,
            '!==': 6,
            '<': 7,
            '>': 7,
            '<=': 7,
            '>=': 7,
            '<<': 8,
            '>>': 8,
            '>>>': 8,
            '+': 9,
            '-': 9,
            '*': 11,
            '/': 11,
            '%': 11
        };
        this.lookahead = {
            type: 2 /* EOF */,
            value: '',
            lineNumber: this.scanner.lineNumber,
            lineStart: 0,
            start: 0,
            end: 0
        };
        this.hasLineTerminator = false;
        this.context = {
            isModule: false,
            await: false,
            allowIn: true,
            allowStrictDirective: true,
            allowYield: true,
            firstCoverInitializedNameError: null,
            isAssignmentTarget: false,
            isBindingElement: false,
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            labelSet: {},
            strict: false
        };
        this.tokens = [];
        this.startMarker = {
            index: 0,
            line: this.scanner.lineNumber,
            column: 0
        };
        this.lastMarker = {
            index: 0,
            line: this.scanner.lineNumber,
            column: 0
        };
        this.nextToken();
        this.lastMarker = {
            index: this.scanner.index,
            line: this.scanner.lineNumber,
            column: this.scanner.index - this.scanner.lineStart
        };
    }
    Parser.prototype.throwError = function (messageFormat) {
        var values = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            values[_i - 1] = arguments[_i];
        }
        var args = Array.prototype.slice.call(arguments, 1);
        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
            assert_1.assert(idx < args.length, 'Message reference must be in range');
            return args[idx];
        });
        var index = this.lastMarker.index;
        var line = this.lastMarker.line;
        var column = this.lastMarker.column + 1;
        throw this.errorHandler.createError(index, line, column, msg);
    };
    Parser.prototype.tolerateError = function (messageFormat) {
        var values = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            values[_i - 1] = arguments[_i];
        }
        var args = Array.prototype.slice.call(arguments, 1);
        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
            assert_1.assert(idx < args.length, 'Message reference must be in range');
            return args[idx];
        });
        var index = this.lastMarker.index;
        var line = this.scanner.lineNumber;
        var column = this.lastMarker.column + 1;
        this.errorHandler.tolerateError(index, line, column, msg);
    };
    // Throw an exception because of the token.
    Parser.prototype.unexpectedTokenError = function (token, message) {
        var msg = message || messages_1.Messages.UnexpectedToken;
        var value;
        if (token) {
            if (!message) {
                msg = (token.type === 2 /* EOF */) ? messages_1.Messages.UnexpectedEOS :
                    (token.type === 3 /* Identifier */) ? messages_1.Messages.UnexpectedIdentifier :
                        (token.type === 6 /* NumericLiteral */) ? messages_1.Messages.UnexpectedNumber :
                            (token.type === 8 /* StringLiteral */) ? messages_1.Messages.UnexpectedString :
                                (token.type === 10 /* Template */) ? messages_1.Messages.UnexpectedTemplate :
                                    messages_1.Messages.UnexpectedToken;
                if (token.type === 4 /* Keyword */) {
                    if (this.scanner.isFutureReservedWord(token.value)) {
                        msg = messages_1.Messages.UnexpectedReserved;
                    }
                    else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
                        msg = messages_1.Messages.StrictReservedWord;
                    }
                }
            }
            value = token.value;
        }
        else {
            value = 'ILLEGAL';
        }
        msg = msg.replace('%0', value);
        if (token && typeof token.lineNumber === 'number') {
            var index = token.start;
            var line = token.lineNumber;
            var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
            var column = token.start - lastMarkerLineStart + 1;
            return this.errorHandler.createError(index, line, column, msg);
        }
        else {
            var index = this.lastMarker.index;
            var line = this.lastMarker.line;
            var column = this.lastMarker.column + 1;
            return this.errorHandler.createError(index, line, column, msg);
        }
    };
    Parser.prototype.throwUnexpectedToken = function (token, message) {
        throw this.unexpectedTokenError(token, message);
    };
    Parser.prototype.tolerateUnexpectedToken = function (token, message) {
        this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
    };
    Parser.prototype.collectComments = function () {
        if (!this.config.comment) {
            this.scanner.scanComments();
        }
        else {
            var comments = this.scanner.scanComments();
            if (comments.length > 0 && this.delegate) {
                for (var i = 0; i < comments.length; ++i) {
                    var e = comments[i];
                    var node = void 0;
                    node = {
                        type: e.multiLine ? 'BlockComment' : 'LineComment',
                        value: this.scanner.source.slice(e.slice[0], e.slice[1])
                    };
                    if (this.config.range) {
                        node.range = e.range;
                    }
                    if (this.config.loc) {
                        node.loc = e.loc;
                    }
                    var metadata = {
                        start: {
                            line: e.loc.start.line,
                            column: e.loc.start.column,
                            offset: e.range[0]
                        },
                        end: {
                            line: e.loc.end.line,
                            column: e.loc.end.column,
                            offset: e.range[1]
                        }
                    };
                    this.delegate(node, metadata);
                }
            }
        }
    };
    // From internal representation to an external structure
    Parser.prototype.getTokenRaw = function (token) {
        return this.scanner.source.slice(token.start, token.end);
    };
    Parser.prototype.convertToken = function (token) {
        var t = {
            type: token_1.TokenName[token.type],
            value: this.getTokenRaw(token)
        };
        if (this.config.range) {
            t.range = [token.start, token.end];
        }
        if (this.config.loc) {
            t.loc = {
                start: {
                    line: this.startMarker.line,
                    column: this.startMarker.column
                },
                end: {
                    line: this.scanner.lineNumber,
                    column: this.scanner.index - this.scanner.lineStart
                }
            };
        }
        if (token.type === 9 /* RegularExpression */) {
            var pattern = token.pattern;
            var flags = token.flags;
            t.regex = { pattern: pattern, flags: flags };
        }
        return t;
    };
    Parser.prototype.nextToken = function () {
        var token = this.lookahead;
        this.lastMarker.index = this.scanner.index;
        this.lastMarker.line = this.scanner.lineNumber;
        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
        this.collectComments();
        if (this.scanner.index !== this.startMarker.index) {
            this.startMarker.index = this.scanner.index;
            this.startMarker.line = this.scanner.lineNumber;
            this.startMarker.column = this.scanner.index - this.scanner.lineStart;
        }
        var next = this.scanner.lex();
        this.hasLineTerminator = (token.lineNumber !== next.lineNumber);
        if (next && this.context.strict && next.type === 3 /* Identifier */) {
            if (this.scanner.isStrictModeReservedWord(next.value)) {
                next.type = 4 /* Keyword */;
            }
        }
        this.lookahead = next;
        if (this.config.tokens && next.type !== 2 /* EOF */) {
            this.tokens.push(this.convertToken(next));
        }
        return token;
    };
    Parser.prototype.nextRegexToken = function () {
        this.collectComments();
        var token = this.scanner.scanRegExp();
        if (this.config.tokens) {
            // Pop the previous token, '/' or '/='
            // This is added from the lookahead token.
            this.tokens.pop();
            this.tokens.push(this.convertToken(token));
        }
        // Prime the next lookahead.
        this.lookahead = token;
        this.nextToken();
        return token;
    };
    Parser.prototype.createNode = function () {
        return {
            index: this.startMarker.index,
            line: this.startMarker.line,
            column: this.startMarker.column
        };
    };
    Parser.prototype.startNode = function (token, lastLineStart) {
        if (lastLineStart === void 0) { lastLineStart = 0; }
        var column = token.start - token.lineStart;
        var line = token.lineNumber;
        if (column < 0) {
            column += lastLineStart;
            line--;
        }
        return {
            index: token.start,
            line: line,
            column: column
        };
    };
    Parser.prototype.finalize = function (marker, node) {
        if (this.config.range) {
            node.range = [marker.index, this.lastMarker.index];
        }
        if (this.config.loc) {
            node.loc = {
                start: {
                    line: marker.line,
                    column: marker.column,
                },
                end: {
                    line: this.lastMarker.line,
                    column: this.lastMarker.column
                }
            };
            if (this.config.source) {
                node.loc.source = this.config.source;
            }
        }
        if (this.delegate) {
            var metadata = {
                start: {
                    line: marker.line,
                    column: marker.column,
                    offset: marker.index
                },
                end: {
                    line: this.lastMarker.line,
                    column: this.lastMarker.column,
                    offset: this.lastMarker.index
                }
            };
            this.delegate(node, metadata);
        }
        return node;
    };
    // Expect the next token to match the specified punctuator.
    // If not, an exception will be thrown.
    Parser.prototype.expect = function (value) {
        var token = this.nextToken();
        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
            this.throwUnexpectedToken(token);
        }
    };
    // Quietly expect a comma when in tolerant mode, otherwise delegates to expect().
    Parser.prototype.expectCommaSeparator = function () {
        if (this.config.tolerant) {
            var token = this.lookahead;
            if (token.type === 7 /* Punctuator */ && token.value === ',') {
                this.nextToken();
            }
            else if (token.type === 7 /* Punctuator */ && token.value === ';') {
                this.nextToken();
                this.tolerateUnexpectedToken(token);
            }
            else {
                this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
            }
        }
        else {
            this.expect(',');
        }
    };
    // Expect the next token to match the specified keyword.
    // If not, an exception will be thrown.
    Parser.prototype.expectKeyword = function (keyword) {
        var token = this.nextToken();
        if (token.type !== 4 /* Keyword */ || token.value !== keyword) {
            this.throwUnexpectedToken(token);
        }
    };
    // Return true if the next token matches the specified punctuator.
    Parser.prototype.match = function (value) {
        return this.lookahead.type === 7 /* Punctuator */ && this.lookahead.value === value;
    };
    // Return true if the next token matches the specified keyword
    Parser.prototype.matchKeyword = function (keyword) {
        return this.lookahead.type === 4 /* Keyword */ && this.lookahead.value === keyword;
    };
    // Return true if the next token matches the specified contextual keyword
    // (where an identifier is sometimes a keyword depending on the context)
    Parser.prototype.matchContextualKeyword = function (keyword) {
        return this.lookahead.type === 3 /* Identifier */ && this.lookahead.value === keyword;
    };
    // Return true if the next token is an assignment operator
    Parser.prototype.matchAssign = function () {
        if (this.lookahead.type !== 7 /* Punctuator */) {
            return false;
        }
        var op = this.lookahead.value;
        return op === '=' ||
            op === '*=' ||
            op === '**=' ||
            op === '/=' ||
            op === '%=' ||
            op === '+=' ||
            op === '-=' ||
            op === '<<=' ||
            op === '>>=' ||
            op === '>>>=' ||
            op === '&=' ||
            op === '^=' ||
            op === '|=';
    };
    // Cover grammar support.
    //
    // When an assignment expression position starts with an left parenthesis, the determination of the type
    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
    //
    // There are three productions that can be parsed in a parentheses pair that needs to be determined
    // after the outermost pair is closed. They are:
    //
    //   1. AssignmentExpression
    //   2. BindingElements
    //   3. AssignmentTargets
    //
    // In order to avoid exponential backtracking, we use two flags to denote if the production can be
    // binding element or assignment target.
    //
    // The three productions have the relationship:
    //
    //   BindingElements  AssignmentTargets  AssignmentExpression
    //
    // with a single exception that CoverInitializedName when used directly in an Expression, generates
    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
    //
    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
    // the CoverInitializedName check is conducted.
    //
    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
    // pattern. The CoverInitializedName check is deferred.
    Parser.prototype.isolateCoverGrammar = function (parseFunction) {
        var previousIsBindingElement = this.context.isBindingElement;
        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
        this.context.isBindingElement = true;
        this.context.isAssignmentTarget = true;
        this.context.firstCoverInitializedNameError = null;
        var result = parseFunction.call(this);
        if (this.context.firstCoverInitializedNameError !== null) {
            this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
        }
        this.context.isBindingElement = previousIsBindingElement;
        this.context.isAssignmentTarget = previousIsAssignmentTarget;
        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
        return result;
    };
    Parser.prototype.inheritCoverGrammar = function (parseFunction) {
        var previousIsBindingElement = this.context.isBindingElement;
        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
        this.context.isBindingElement = true;
        this.context.isAssignmentTarget = true;
        this.context.firstCoverInitializedNameError = null;
        var result = parseFunction.call(this);
        this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
        this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
        return result;
    };
    Parser.prototype.consumeSemicolon = function () {
        if (this.match(';')) {
            this.nextToken();
        }
        else if (!this.hasLineTerminator) {
            if (this.lookahead.type !== 2 /* EOF */ && !this.match('}')) {
                this.throwUnexpectedToken(this.lookahead);
            }
            this.lastMarker.index = this.startMarker.index;
            this.lastMarker.line = this.startMarker.line;
            this.lastMarker.column = this.startMarker.column;
        }
    };
    // https://tc39.github.io/ecma262/#sec-primary-expression
    Parser.prototype.parsePrimaryExpression = function () {
        var node = this.createNode();
        var expr;
        var token, raw;
        switch (this.lookahead.type) {
            case 3 /* Identifier */:
                if ((this.context.isModule || this.context.await) && this.lookahead.value === 'await') {
                    this.tolerateUnexpectedToken(this.lookahead);
                }
                expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
                break;
            case 6 /* NumericLiteral */:
            case 8 /* StringLiteral */:
                if (this.context.strict && this.lookahead.octal) {
                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
                }
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                token = this.nextToken();
                raw = this.getTokenRaw(token);
                expr = this.finalize(node, new Node.Literal(token.value, raw));
                break;
            case 1 /* BooleanLiteral */:
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                token = this.nextToken();
                raw = this.getTokenRaw(token);
                expr = this.finalize(node, new Node.Literal(token.value === 'true', raw));
                break;
            case 5 /* NullLiteral */:
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                token = this.nextToken();
                raw = this.getTokenRaw(token);
                expr = this.finalize(node, new Node.Literal(null, raw));
                break;
            case 10 /* Template */:
                expr = this.parseTemplateLiteral();
                break;
            case 7 /* Punctuator */:
                switch (this.lookahead.value) {
                    case '(':
                        this.context.isBindingElement = false;
                        expr = this.inheritCoverGrammar(this.parseGroupExpression);
                        break;
                    case '[':
                        expr = this.inheritCoverGrammar(this.parseArrayInitializer);
                        break;
                    case '{':
                        expr = this.inheritCoverGrammar(this.parseObjectInitializer);
                        break;
                    case '/':
                    case '/=':
                        this.context.isAssignmentTarget = false;
                        this.context.isBindingElement = false;
                        this.scanner.index = this.startMarker.index;
                        token = this.nextRegexToken();
                        raw = this.getTokenRaw(token);
                        expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
                        break;
                    default:
                        expr = this.throwUnexpectedToken(this.nextToken());
                }
                break;
            case 4 /* Keyword */:
                if (!this.context.strict && this.context.allowYield && this.matchKeyword('yield')) {
                    expr = this.parseIdentifierName();
                }
                else if (!this.context.strict && this.matchKeyword('let')) {
                    expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
                }
                else {
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    if (this.matchKeyword('function')) {
                        expr = this.parseFunctionExpression();
                    }
                    else if (this.matchKeyword('this')) {
                        this.nextToken();
                        expr = this.finalize(node, new Node.ThisExpression());
                    }
                    else if (this.matchKeyword('class')) {
                        expr = this.parseClassExpression();
                    }
                    else if (this.matchImportCall()) {
                        expr = this.parseImportCall();
                    }
                    else {
                        expr = this.throwUnexpectedToken(this.nextToken());
                    }
                }
                break;
            default:
                expr = this.throwUnexpectedToken(this.nextToken());
        }
        return expr;
    };
    // https://tc39.github.io/ecma262/#sec-array-initializer
    Parser.prototype.parseSpreadElement = function () {
        var node = this.createNode();
        this.expect('...');
        var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
        return this.finalize(node, new Node.SpreadElement(arg));
    };
    Parser.prototype.parseArrayInitializer = function () {
        var node = this.createNode();
        var elements = [];
        this.expect('[');
        while (!this.match(']')) {
            if (this.match(',')) {
                this.nextToken();
                elements.push(null);
            }
            else if (this.match('...')) {
                var element = this.parseSpreadElement();
                if (!this.match(']')) {
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    this.expect(',');
                }
                elements.push(element);
            }
            else {
                elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                if (!this.match(']')) {
                    this.expect(',');
                }
            }
        }
        this.expect(']');
        return this.finalize(node, new Node.ArrayExpression(elements));
    };
    // https://tc39.github.io/ecma262/#sec-object-initializer
    Parser.prototype.parsePropertyMethod = function (params) {
        this.context.isAssignmentTarget = false;
        this.context.isBindingElement = false;
        var previousStrict = this.context.strict;
        var previousAllowStrictDirective = this.context.allowStrictDirective;
        this.context.allowStrictDirective = params.simple;
        var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
        if (this.context.strict && params.firstRestricted) {
            this.tolerateUnexpectedToken(params.firstRestricted, params.message);
        }
        if (this.context.strict && params.stricted) {
            this.tolerateUnexpectedToken(params.stricted, params.message);
        }
        this.context.strict = previousStrict;
        this.context.allowStrictDirective = previousAllowStrictDirective;
        return body;
    };
    Parser.prototype.parsePropertyMethodFunction = function () {
        var isGenerator = false;
        var node = this.createNode();
        var previousAllowYield = this.context.allowYield;
        this.context.allowYield = true;
        var params = this.parseFormalParameters();
        var method = this.parsePropertyMethod(params);
        this.context.allowYield = previousAllowYield;
        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
    };
    Parser.prototype.parsePropertyMethodAsyncFunction = function () {
        var node = this.createNode();
        var previousAllowYield = this.context.allowYield;
        var previousAwait = this.context.await;
        this.context.allowYield = false;
        this.context.await = true;
        var params = this.parseFormalParameters();
        var method = this.parsePropertyMethod(params);
        this.context.allowYield = previousAllowYield;
        this.context.await = previousAwait;
        return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
    };
    Parser.prototype.parseObjectPropertyKey = function () {
        var node = this.createNode();
        var token = this.nextToken();
        var key;
        switch (token.type) {
            case 8 /* StringLiteral */:
            case 6 /* NumericLiteral */:
                if (this.context.strict && token.octal) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
                }
                var raw = this.getTokenRaw(token);
                key = this.finalize(node, new Node.Literal(token.value, raw));
                break;
            case 3 /* Identifier */:
            case 1 /* BooleanLiteral */:
            case 5 /* NullLiteral */:
            case 4 /* Keyword */:
                key = this.finalize(node, new Node.Identifier(token.value));
                break;
            case 7 /* Punctuator */:
                if (token.value === '[') {
                    key = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    this.expect(']');
                }
                else {
                    key = this.throwUnexpectedToken(token);
                }
                break;
            default:
                key = this.throwUnexpectedToken(token);
        }
        return key;
    };
    Parser.prototype.isPropertyKey = function (key, value) {
        return (key.type === syntax_1.Syntax.Identifier && key.name === value) ||
            (key.type === syntax_1.Syntax.Literal && key.value === value);
    };
    Parser.prototype.parseObjectProperty = function (hasProto) {
        var node = this.createNode();
        var token = this.lookahead;
        var kind;
        var key = null;
        var value = null;
        var computed = false;
        var method = false;
        var shorthand = false;
        var isAsync = false;
        if (token.type === 3 /* Identifier */) {
            var id = token.value;
            this.nextToken();
            computed = this.match('[');
            isAsync = !this.hasLineTerminator && (id === 'async') &&
                !this.match(':') && !this.match('(') && !this.match('*') && !this.match(',');
            key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
        }
        else if (this.match('*')) {
            this.nextToken();
        }
        else {
            computed = this.match('[');
            key = this.parseObjectPropertyKey();
        }
        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
        if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'get' && lookaheadPropertyKey) {
            kind = 'get';
            computed = this.match('[');
            key = this.parseObjectPropertyKey();
            this.context.allowYield = false;
            value = this.parseGetterMethod();
        }
        else if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'set' && lookaheadPropertyKey) {
            kind = 'set';
            computed = this.match('[');
            key = this.parseObjectPropertyKey();
            value = this.parseSetterMethod();
        }
        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
            kind = 'init';
            computed = this.match('[');
            key = this.parseObjectPropertyKey();
            value = this.parseGeneratorMethod();
            method = true;
        }
        else {
            if (!key) {
                this.throwUnexpectedToken(this.lookahead);
            }
            kind = 'init';
            if (this.match(':') && !isAsync) {
                if (!computed && this.isPropertyKey(key, '__proto__')) {
                    if (hasProto.value) {
                        this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
                    }
                    hasProto.value = true;
                }
                this.nextToken();
                value = this.inheritCoverGrammar(this.parseAssignmentExpression);
            }
            else if (this.match('(')) {
                value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                method = true;
            }
            else if (token.type === 3 /* Identifier */) {
                var id = this.finalize(node, new Node.Identifier(token.value));
                if (this.match('=')) {
                    this.context.firstCoverInitializedNameError = this.lookahead;
                    this.nextToken();
                    shorthand = true;
                    var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    value = this.finalize(node, new Node.AssignmentPattern(id, init));
                }
                else {
                    shorthand = true;
                    value = id;
                }
            }
            else {
                this.throwUnexpectedToken(this.nextToken());
            }
        }
        return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
    };
    Parser.prototype.parseObjectInitializer = function () {
        var node = this.createNode();
        this.expect('{');
        var properties = [];
        var hasProto = { value: false };
        while (!this.match('}')) {
            properties.push(this.match('...') ? this.parseSpreadElement() : this.parseObjectProperty(hasProto));
            if (!this.match('}')) {
                this.expectCommaSeparator();
            }
        }
        this.expect('}');
        return this.finalize(node, new Node.ObjectExpression(properties));
    };
    // https://tc39.github.io/ecma262/#sec-template-literals
    Parser.prototype.parseTemplateHead = function () {
        assert_1.assert(this.lookahead.head, 'Template literal must start with a template head');
        var node = this.createNode();
        var token = this.nextToken();
        var raw = token.value;
        var cooked = token.cooked;
        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
    };
    Parser.prototype.parseTemplateElement = function () {
        if (this.lookahead.type !== 10 /* Template */) {
            this.throwUnexpectedToken();
        }
        var node = this.createNode();
        var token = this.nextToken();
        var raw = token.value;
        var cooked = token.cooked;
        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
    };
    Parser.prototype.parseTemplateLiteral = function () {
        var node = this.createNode();
        var expressions = [];
        var quasis = [];
        var quasi = this.parseTemplateHead();
        quasis.push(quasi);
        while (!quasi.tail) {
            expressions.push(this.parseExpression());
            quasi = this.parseTemplateElement();
            quasis.push(quasi);
        }
        return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
    };
    // https://tc39.github.io/ecma262/#sec-grouping-operator
    Parser.prototype.reinterpretExpressionAsPattern = function (expr) {
        switch (expr.type) {
            case syntax_1.Syntax.Identifier:
            case syntax_1.Syntax.MemberExpression:
            case syntax_1.Syntax.RestElement:
            case syntax_1.Syntax.AssignmentPattern:
                break;
            case syntax_1.Syntax.SpreadElement:
                expr.type = syntax_1.Syntax.RestElement;
                this.reinterpretExpressionAsPattern(expr.argument);
                break;
            case syntax_1.Syntax.ArrayExpression:
                expr.type = syntax_1.Syntax.ArrayPattern;
                for (var i = 0; i < expr.elements.length; i++) {
                    if (expr.elements[i] !== null) {
                        this.reinterpretExpressionAsPattern(expr.elements[i]);
                    }
                }
                break;
            case syntax_1.Syntax.ObjectExpression:
                expr.type = syntax_1.Syntax.ObjectPattern;
                for (var i = 0; i < expr.properties.length; i++) {
                    var property = expr.properties[i];
                    this.reinterpretExpressionAsPattern(property.type === syntax_1.Syntax.SpreadElement ? property : property.value);
                }
                break;
            case syntax_1.Syntax.AssignmentExpression:
                expr.type = syntax_1.Syntax.AssignmentPattern;
                delete expr.operator;
                this.reinterpretExpressionAsPattern(expr.left);
                break;
            default:
                // Allow other node type for tolerant parsing.
                break;
        }
    };
    Parser.prototype.parseGroupExpression = function () {
        var expr;
        this.expect('(');
        if (this.match(')')) {
            this.nextToken();
            if (!this.match('=>')) {
                this.expect('=>');
            }
            expr = {
                type: ArrowParameterPlaceHolder,
                params: [],
                async: false
            };
        }
        else {
            var startToken = this.lookahead;
            var params = [];
            if (this.match('...')) {
                expr = this.parseRestElement(params);
                this.expect(')');
                if (!this.match('=>')) {
                    this.expect('=>');
                }
                expr = {
                    type: ArrowParameterPlaceHolder,
                    params: [expr],
                    async: false
                };
            }
            else {
                var arrow = false;
                this.context.isBindingElement = true;
                expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
                if (this.match(',')) {
                    var expressions = [];
                    this.context.isAssignmentTarget = false;
                    expressions.push(expr);
                    while (this.lookahead.type !== 2 /* EOF */) {
                        if (!this.match(',')) {
                            break;
                        }
                        this.nextToken();
                        if (this.match(')')) {
                            this.nextToken();
                            for (var i = 0; i < expressions.length; i++) {
                                this.reinterpretExpressionAsPattern(expressions[i]);
                            }
                            arrow = true;
                            expr = {
                                type: ArrowParameterPlaceHolder,
                                params: expressions,
                                async: false
                            };
                        }
                        else if (this.match('...')) {
                            if (!this.context.isBindingElement) {
                                this.throwUnexpectedToken(this.lookahead);
                            }
                            expressions.push(this.parseRestElement(params));
                            this.expect(')');
                            if (!this.match('=>')) {
                                this.expect('=>');
                            }
                            this.context.isBindingElement = false;
                            for (var i = 0; i < expressions.length; i++) {
                                this.reinterpretExpressionAsPattern(expressions[i]);
                            }
                            arrow = true;
                            expr = {
                                type: ArrowParameterPlaceHolder,
                                params: expressions,
                                async: false
                            };
                        }
                        else {
                            expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                        }
                        if (arrow) {
                            break;
                        }
                    }
                    if (!arrow) {
                        expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
                    }
                }
                if (!arrow) {
                    this.expect(')');
                    if (this.match('=>')) {
                        if (expr.type === syntax_1.Syntax.Identifier && expr.name === 'yield') {
                            arrow = true;
                            expr = {
                                type: ArrowParameterPlaceHolder,
                                params: [expr],
                                async: false
                            };
                        }
                        if (!arrow) {
                            if (!this.context.isBindingElement) {
                                this.throwUnexpectedToken(this.lookahead);
                            }
                            if (expr.type === syntax_1.Syntax.SequenceExpression) {
                                for (var i = 0; i < expr.expressions.length; i++) {
                                    this.reinterpretExpressionAsPattern(expr.expressions[i]);
                                }
                            }
                            else {
                                this.reinterpretExpressionAsPattern(expr);
                            }
                            var parameters = (expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr]);
                            expr = {
                                type: ArrowParameterPlaceHolder,
                                params: parameters,
                                async: false
                            };
                        }
                    }
                    this.context.isBindingElement = false;
                }
            }
        }
        return expr;
    };
    // https://tc39.github.io/ecma262/#sec-left-hand-side-expressions
    Parser.prototype.parseArguments = function () {
        this.expect('(');
        var args = [];
        if (!this.match(')')) {
            while (true) {
                var expr = this.match('...') ? this.parseSpreadElement() :
                    this.isolateCoverGrammar(this.parseAssignmentExpression);
                args.push(expr);
                if (this.match(')')) {
                    break;
                }
                this.expectCommaSeparator();
                if (this.match(')')) {
                    break;
                }
            }
        }
        this.expect(')');
        return args;
    };
    Parser.prototype.isIdentifierName = function (token) {
        return token.type === 3 /* Identifier */ ||
            token.type === 4 /* Keyword */ ||
            token.type === 1 /* BooleanLiteral */ ||
            token.type === 5 /* NullLiteral */;
    };
    Parser.prototype.parseIdentifierName = function () {
        var node = this.createNode();
        var token = this.nextToken();
        if (!this.isIdentifierName(token)) {
            this.throwUnexpectedToken(token);
        }
        return this.finalize(node, new Node.Identifier(token.value));
    };
    Parser.prototype.parseNewExpression = function () {
        var node = this.createNode();
        var id = this.parseIdentifierName();
        assert_1.assert(id.name === 'new', 'New expression must start with `new`');
        var expr;
        if (this.match('.')) {
            this.nextToken();
            if (this.lookahead.type === 3 /* Identifier */ && this.context.inFunctionBody && this.lookahead.value === 'target') {
                var property = this.parseIdentifierName();
                expr = new Node.MetaProperty(id, property);
            }
            else {
                this.throwUnexpectedToken(this.lookahead);
            }
        }
        else if (this.matchKeyword('import')) {
            this.throwUnexpectedToken(this.lookahead);
        }
        else {
            var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
            var args = this.match('(') ? this.parseArguments() : [];
            expr = new Node.NewExpression(callee, args);
            this.context.isAssignmentTarget = false;
            this.context.isBindingElement = false;
        }
        return this.finalize(node, expr);
    };
    Parser.prototype.parseAsyncArgument = function () {
        var arg = this.parseAssignmentExpression();
        this.context.firstCoverInitializedNameError = null;
        return arg;
    };
    Parser.prototype.parseAsyncArguments = function () {
        this.expect('(');
        var args = [];
        if (!this.match(')')) {
            while (true) {
                var expr = this.match('...') ? this.parseSpreadElement() :
                    this.isolateCoverGrammar(this.parseAsyncArgument);
                args.push(expr);
                if (this.match(')')) {
                    break;
                }
                this.expectCommaSeparator();
                if (this.match(')')) {
                    break;
                }
            }
        }
        this.expect(')');
        return args;
    };
    Parser.prototype.matchImportCall = function () {
        var match = this.matchKeyword('import');
        if (match) {
            var state = this.scanner.saveState();
            this.scanner.scanComments();
            var next = this.scanner.lex();
            this.scanner.restoreState(state);
            match = (next.type === 7 /* Punctuator */) && (next.value === '(');
        }
        return match;
    };
    Parser.prototype.parseImportCall = function () {
        var node = this.createNode();
        this.expectKeyword('import');
        return this.finalize(node, new Node.Import());
    };
    Parser.prototype.parseLeftHandSideExpressionAllowCall = function () {
        var startToken = this.lookahead;
        var maybeAsync = this.matchContextualKeyword('async');
        var previousAllowIn = this.context.allowIn;
        this.context.allowIn = true;
        var expr;
        if (this.matchKeyword('super') && this.context.inFunctionBody) {
            expr = this.createNode();
            this.nextToken();
            expr = this.finalize(expr, new Node.Super());
            if (!this.match('(') && !this.match('.') && !this.match('[')) {
                this.throwUnexpectedToken(this.lookahead);
            }
        }
        else {
            expr = this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
        }
        while (true) {
            if (this.match('.')) {
                this.context.isBindingElement = false;
                this.context.isAssignmentTarget = true;
                this.expect('.');
                var property = this.parseIdentifierName();
                expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
            }
            else if (this.match('(')) {
                var asyncArrow = maybeAsync && (startToken.lineNumber === this.lookahead.lineNumber);
                this.context.isBindingElement = false;
                this.context.isAssignmentTarget = false;
                var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
                if (expr.type === syntax_1.Syntax.Import && args.length !== 1) {
                    this.tolerateError(messages_1.Messages.BadImportCallArity);
                }
                expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
                if (asyncArrow && this.match('=>')) {
                    for (var i = 0; i < args.length; ++i) {
                        this.reinterpretExpressionAsPattern(args[i]);
                    }
                    expr = {
                        type: ArrowParameterPlaceHolder,
                        params: args,
                        async: true
                    };
                }
            }
            else if (this.match('[')) {
                this.context.isBindingElement = false;
                this.context.isAssignmentTarget = true;
                this.expect('[');
                var property = this.isolateCoverGrammar(this.parseExpression);
                this.expect(']');
                expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
            }
            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
                var quasi = this.parseTemplateLiteral();
                expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
            }
            else {
                break;
            }
        }
        this.context.allowIn = previousAllowIn;
        return expr;
    };
    Parser.prototype.parseSuper = function () {
        var node = this.createNode();
        this.expectKeyword('super');
        if (!this.match('[') && !this.match('.')) {
            this.throwUnexpectedToken(this.lookahead);
        }
        return this.finalize(node, new Node.Super());
    };
    Parser.prototype.parseLeftHandSideExpression = function () {
        assert_1.assert(this.context.allowIn, 'callee of new expression always allow in keyword.');
        var node = this.startNode(this.lookahead);
        var expr = (this.matchKeyword('super') && this.context.inFunctionBody) ? this.parseSuper() :
            this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
        while (true) {
            if (this.match('[')) {
                this.context.isBindingElement = false;
                this.context.isAssignmentTarget = true;
                this.expect('[');
                var property = this.isolateCoverGrammar(this.parseExpression);
                this.expect(']');
                expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
            }
            else if (this.match('.')) {
                this.context.isBindingElement = false;
                this.context.isAssignmentTarget = true;
                this.expect('.');
                var property = this.parseIdentifierName();
                expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
            }
            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
                var quasi = this.parseTemplateLiteral();
                expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
            }
            else {
                break;
            }
        }
        return expr;
    };
    // https://tc39.github.io/ecma262/#sec-update-expressions
    Parser.prototype.parseUpdateExpression = function () {
        var expr;
        var startToken = this.lookahead;
        if (this.match('++') || this.match('--')) {
            var node = this.startNode(startToken);
            var token = this.nextToken();
            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
            if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                this.tolerateError(messages_1.Messages.StrictLHSPrefix);
            }
            if (!this.context.isAssignmentTarget) {
                this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
            }
            var prefix = true;
            expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
            this.context.isAssignmentTarget = false;
            this.context.isBindingElement = false;
        }
        else {
            expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
            if (!this.hasLineTerminator && this.lookahead.type === 7 /* Punctuator */) {
                if (this.match('++') || this.match('--')) {
                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                        this.tolerateError(messages_1.Messages.StrictLHSPostfix);
                    }
                    if (!this.context.isAssignmentTarget) {
                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                    }
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    var operator = this.nextToken().value;
                    var prefix = false;
                    expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
                }
            }
        }
        return expr;
    };
    // https://tc39.github.io/ecma262/#sec-unary-operators
    Parser.prototype.parseAwaitExpression = function () {
        var node = this.createNode();
        this.nextToken();
        var argument = this.parseUnaryExpression();
        return this.finalize(node, new Node.AwaitExpression(argument));
    };
    Parser.prototype.parseUnaryExpression = function () {
        var expr;
        if (this.match('+') || this.match('-') || this.match('~') || this.match('!') ||
            this.matchKeyword('delete') || this.matchKeyword('void') || this.matchKeyword('typeof')) {
            var node = this.startNode(this.lookahead);
            var token = this.nextToken();
            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
            expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
            if (this.context.strict && expr.operator === 'delete' && expr.argument.type === syntax_1.Syntax.Identifier) {
                this.tolerateError(messages_1.Messages.StrictDelete);
            }
            this.context.isAssignmentTarget = false;
            this.context.isBindingElement = false;
        }
        else if (this.context.await && this.matchContextualKeyword('await')) {
            expr = this.parseAwaitExpression();
        }
        else {
            expr = this.parseUpdateExpression();
        }
        return expr;
    };
    Parser.prototype.parseExponentiationExpression = function () {
        var startToken = this.lookahead;
        var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
        if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match('**')) {
            this.nextToken();
            this.context.isAssignmentTarget = false;
            this.context.isBindingElement = false;
            var left = expr;
            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
            expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression('**', left, right));
        }
        return expr;
    };
    // https://tc39.github.io/ecma262/#sec-exp-operator
    // https://tc39.github.io/ecma262/#sec-multiplicative-operators
    // https://tc39.github.io/ecma262/#sec-additive-operators
    // https://tc39.github.io/ecma262/#sec-bitwise-shift-operators
    // https://tc39.github.io/ecma262/#sec-relational-operators
    // https://tc39.github.io/ecma262/#sec-equality-operators
    // https://tc39.github.io/ecma262/#sec-binary-bitwise-operators
    // https://tc39.github.io/ecma262/#sec-binary-logical-operators
    Parser.prototype.binaryPrecedence = function (token) {
        var op = token.value;
        var precedence;
        if (token.type === 7 /* Punctuator */) {
            precedence = this.operatorPrecedence[op] || 0;
        }
        else if (token.type === 4 /* Keyword */) {
            precedence = (op === 'instanceof' || (this.context.allowIn && op === 'in')) ? 7 : 0;
        }
        else {
            precedence = 0;
        }
        return precedence;
    };
    Parser.prototype.parseBinaryExpression = function () {
        var startToken = this.lookahead;
        var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
        var token = this.lookahead;
        var prec = this.binaryPrecedence(token);
        if (prec > 0) {
            this.nextToken();
            this.context.isAssignmentTarget = false;
            this.context.isBindingElement = false;
            var markers = [startToken, this.lookahead];
            var left = expr;
            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
            var stack = [left, token.value, right];
            var precedences = [prec];
            while (true) {
                prec = this.binaryPrecedence(this.lookahead);
                if (prec <= 0) {
                    break;
                }
                // Reduce: make a binary expression from the three topmost entries.
                while ((stack.length > 2) && (prec <= precedences[precedences.length - 1])) {
                    right = stack.pop();
                    var operator = stack.pop();
                    precedences.pop();
                    left = stack.pop();
                    markers.pop();
                    var node = this.startNode(markers[markers.length - 1]);
                    stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
                }
                // Shift.
                stack.push(this.nextToken().value);
                precedences.push(prec);
                markers.push(this.lookahead);
                stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
            }
            // Final reduce to clean-up the stack.
            var i = stack.length - 1;
            expr = stack[i];
            var lastMarker = markers.pop();
            while (i > 1) {
                var marker = markers.pop();
                var lastLineStart = lastMarker && lastMarker.lineStart;
                var node = this.startNode(marker, lastLineStart);
                var operator = stack[i - 1];
                expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));
                i -= 2;
                lastMarker = marker;
            }
        }
        return expr;
    };
    // https://tc39.github.io/ecma262/#sec-conditional-operator
    Parser.prototype.parseConditionalExpression = function () {
        var startToken = this.lookahead;
        var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
        if (this.match('?')) {
            this.nextToken();
            var previousAllowIn = this.context.allowIn;
            this.context.allowIn = true;
            var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
            this.context.allowIn = previousAllowIn;
            this.expect(':');
            var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
            expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
            this.context.isAssignmentTarget = false;
            this.context.isBindingElement = false;
        }
        return expr;
    };
    // https://tc39.github.io/ecma262/#sec-assignment-operators
    Parser.prototype.checkPatternParam = function (options, param) {
        switch (param.type) {
            case syntax_1.Syntax.Identifier:
                this.validateParam(options, param, param.name);
                break;
            case syntax_1.Syntax.RestElement:
                this.checkPatternParam(options, param.argument);
                break;
            case syntax_1.Syntax.AssignmentPattern:
                this.checkPatternParam(options, param.left);
                break;
            case syntax_1.Syntax.ArrayPattern:
                for (var i = 0; i < param.elements.length; i++) {
                    if (param.elements[i] !== null) {
                        this.checkPatternParam(options, param.elements[i]);
                    }
                }
                break;
            case syntax_1.Syntax.ObjectPattern:
                for (var i = 0; i < param.properties.length; i++) {
                    var property = param.properties[i];
                    this.checkPatternParam(options, (property.type === syntax_1.Syntax.RestElement) ? property : property.value);
                }
                break;
            default:
                break;
        }
        options.simple = options.simple && (param instanceof Node.Identifier);
    };
    Parser.prototype.reinterpretAsCoverFormalsList = function (expr) {
        var params = [expr];
        var options;
        var asyncArrow = false;
        switch (expr.type) {
            case syntax_1.Syntax.Identifier:
                break;
            case ArrowParameterPlaceHolder:
                params = expr.params;
                asyncArrow = expr.async;
                break;
            default:
                return null;
        }
        options = {
            simple: true,
            paramSet: {}
        };
        for (var i = 0; i < params.length; ++i) {
            var param = params[i];
            if (param.type === syntax_1.Syntax.AssignmentPattern) {
                if (param.right.type === syntax_1.Syntax.YieldExpression) {
                    if (param.right.argument) {
                        this.throwUnexpectedToken(this.lookahead);
                    }
                    param.right.type = syntax_1.Syntax.Identifier;
                    param.right.name = 'yield';
                    delete param.right.argument;
                    delete param.right.delegate;
                }
            }
            else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === 'await') {
                this.throwUnexpectedToken(this.lookahead);
            }
            this.checkPatternParam(options, param);
            params[i] = param;
        }
        if (this.context.strict || !this.context.allowYield) {
            for (var i = 0; i < params.length; ++i) {
                var param = params[i];
                if (param.type === syntax_1.Syntax.YieldExpression) {
                    this.throwUnexpectedToken(this.lookahead);
                }
            }
        }
        if (options.message === messages_1.Messages.StrictParamDupe) {
            var token = this.context.strict ? options.stricted : options.firstRestricted;
            this.throwUnexpectedToken(token, options.message);
        }
        return {
            simple: options.simple,
            params: params,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
        };
    };
    Parser.prototype.parseAssignmentExpression = function () {
        var expr;
        if (!this.context.allowYield && this.matchKeyword('yield')) {
            expr = this.parseYieldExpression();
        }
        else {
            var startToken = this.lookahead;
            var token = startToken;
            expr = this.parseConditionalExpression();
            if (token.type === 3 /* Identifier */ && (token.lineNumber === this.lookahead.lineNumber) && token.value === 'async') {
                if (this.lookahead.type === 3 /* Identifier */ || this.matchKeyword('yield')) {
                    var arg = this.parsePrimaryExpression();
                    this.reinterpretExpressionAsPattern(arg);
                    expr = {
                        type: ArrowParameterPlaceHolder,
                        params: [arg],
                        async: true
                    };
                }
            }
            if (expr.type === ArrowParameterPlaceHolder || this.match('=>')) {
                // https://tc39.github.io/ecma262/#sec-arrow-function-definitions
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                var isAsync = expr.async;
                var list = this.reinterpretAsCoverFormalsList(expr);
                if (list) {
                    if (this.hasLineTerminator) {
                        this.tolerateUnexpectedToken(this.lookahead);
                    }
                    this.context.firstCoverInitializedNameError = null;
                    var previousStrict = this.context.strict;
                    var previousAllowStrictDirective = this.context.allowStrictDirective;
                    this.context.allowStrictDirective = list.simple;
                    var previousAllowYield = this.context.allowYield;
                    var previousAwait = this.context.await;
                    this.context.allowYield = true;
                    this.context.await = isAsync;
                    var node = this.startNode(startToken);
                    this.expect('=>');
                    var body = void 0;
                    if (this.match('{')) {
                        var previousAllowIn = this.context.allowIn;
                        this.context.allowIn = true;
                        body = this.parseFunctionSourceElements();
                        this.context.allowIn = previousAllowIn;
                    }
                    else {
                        body = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    }
                    var expression = body.type !== syntax_1.Syntax.BlockStatement;
                    if (this.context.strict && list.firstRestricted) {
                        this.throwUnexpectedToken(list.firstRestricted, list.message);
                    }
                    if (this.context.strict && list.stricted) {
                        this.tolerateUnexpectedToken(list.stricted, list.message);
                    }
                    expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) :
                        this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
                    this.context.strict = previousStrict;
                    this.context.allowStrictDirective = previousAllowStrictDirective;
                    this.context.allowYield = previousAllowYield;
                    this.context.await = previousAwait;
                }
            }
            else {
                if (this.matchAssign()) {
                    if (!this.context.isAssignmentTarget) {
                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                    }
                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
                        var id = expr;
                        if (this.scanner.isRestrictedWord(id.name)) {
                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
                        }
                        if (this.scanner.isStrictModeReservedWord(id.name)) {
                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                        }
                    }
                    if (!this.match('=')) {
                        this.context.isAssignmentTarget = false;
                        this.context.isBindingElement = false;
                    }
                    else {
                        this.reinterpretExpressionAsPattern(expr);
                    }
                    token = this.nextToken();
                    var operator = token.value;
                    var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
                    this.context.firstCoverInitializedNameError = null;
                }
            }
        }
        return expr;
    };
    // https://tc39.github.io/ecma262/#sec-comma-operator
    Parser.prototype.parseExpression = function () {
        var startToken = this.lookahead;
        var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
        if (this.match(',')) {
            var expressions = [];
            expressions.push(expr);
            while (this.lookahead.type !== 2 /* EOF */) {
                if (!this.match(',')) {
                    break;
                }
                this.nextToken();
                expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
            }
            expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
        }
        return expr;
    };
    // https://tc39.github.io/ecma262/#sec-block
    Parser.prototype.parseStatementListItem = function () {
        var statement;
        this.context.isAssignmentTarget = true;
        this.context.isBindingElement = true;
        if (this.lookahead.type === 4 /* Keyword */) {
            switch (this.lookahead.value) {
                case 'export':
                    if (!this.context.isModule) {
                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
                    }
                    statement = this.parseExportDeclaration();
                    break;
                case 'import':
                    if (this.matchImportCall()) {
                        statement = this.parseExpressionStatement();
                    }
                    else {
                        if (!this.context.isModule) {
                            this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
                        }
                        statement = this.parseImportDeclaration();
                    }
                    break;
                case 'const':
                    statement = this.parseLexicalDeclaration({ inFor: false });
                    break;
                case 'function':
                    statement = this.parseFunctionDeclaration();
                    break;
                case 'class':
                    statement = this.parseClassDeclaration();
                    break;
                case 'let':
                    statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
                    break;
                default:
                    statement = this.parseStatement();
                    break;
            }
        }
        else {
            statement = this.parseStatement();
        }
        return statement;
    };
    Parser.prototype.parseBlock = function () {
        var node = this.createNode();
        this.expect('{');
        var block = [];
        while (true) {
            if (this.match('}')) {
                break;
            }
            block.push(this.parseStatementListItem());
        }
        this.expect('}');
        return this.finalize(node, new Node.BlockStatement(block));
    };
    // https://tc39.github.io/ecma262/#sec-let-and-const-declarations
    Parser.prototype.parseLexicalBinding = function (kind, options) {
        var node = this.createNode();
        var params = [];
        var id = this.parsePattern(params, kind);
        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
            if (this.scanner.isRestrictedWord(id.name)) {
                this.tolerateError(messages_1.Messages.StrictVarName);
            }
        }
        var init = null;
        if (kind === 'const') {
            if (!this.matchKeyword('in') && !this.matchContextualKeyword('of')) {
                if (this.match('=')) {
                    this.nextToken();
                    init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                }
                else {
                    this.throwError(messages_1.Messages.DeclarationMissingInitializer, 'const');
                }
            }
        }
        else if ((!options.inFor && id.type !== syntax_1.Syntax.Identifier) || this.match('=')) {
            this.expect('=');
            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
        }
        return this.finalize(node, new Node.VariableDeclarator(id, init));
    };
    Parser.prototype.parseBindingList = function (kind, options) {
        var list = [this.parseLexicalBinding(kind, options)];
        while (this.match(',')) {
            this.nextToken();
            list.push(this.parseLexicalBinding(kind, options));
        }
        return list;
    };
    Parser.prototype.isLexicalDeclaration = function () {
        var state = this.scanner.saveState();
        this.scanner.scanComments();
        var next = this.scanner.lex();
        this.scanner.restoreState(state);
        return (next.type === 3 /* Identifier */) ||
            (next.type === 7 /* Punctuator */ && next.value === '[') ||
            (next.type === 7 /* Punctuator */ && next.value === '{') ||
            (next.type === 4 /* Keyword */ && next.value === 'let') ||
            (next.type === 4 /* Keyword */ && next.value === 'yield');
    };
    Parser.prototype.parseLexicalDeclaration = function (options) {
        var node = this.createNode();
        var kind = this.nextToken().value;
        assert_1.assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');
        var declarations = this.parseBindingList(kind, options);
        this.consumeSemicolon();
        return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
    };
    // https://tc39.github.io/ecma262/#sec-destructuring-binding-patterns
    Parser.prototype.parseBindingRestElement = function (params, kind) {
        var node = this.createNode();
        this.expect('...');
        var arg = this.parsePattern(params, kind);
        return this.finalize(node, new Node.RestElement(arg));
    };
    Parser.prototype.parseArrayPattern = function (params, kind) {
        var node = this.createNode();
        this.expect('[');
        var elements = [];
        while (!this.match(']')) {
            if (this.match(',')) {
                this.nextToken();
                elements.push(null);
            }
            else {
                if (this.match('...')) {
                    elements.push(this.parseBindingRestElement(params, kind));
                    break;
                }
                else {
                    elements.push(this.parsePatternWithDefault(params, kind));
                }
                if (!this.match(']')) {
                    this.expect(',');
                }
            }
        }
        this.expect(']');
        return this.finalize(node, new Node.ArrayPattern(elements));
    };
    Parser.prototype.parsePropertyPattern = function (params, kind) {
        var node = this.createNode();
        var computed = false;
        var shorthand = false;
        var method = false;
        var key;
        var value;
        if (this.lookahead.type === 3 /* Identifier */) {
            var keyToken = this.lookahead;
            key = this.parseVariableIdentifier();
            var init = this.finalize(node, new Node.Identifier(keyToken.value));
            if (this.match('=')) {
                params.push(keyToken);
                shorthand = true;
                this.nextToken();
                var expr = this.parseAssignmentExpression();
                value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
            }
            else if (!this.match(':')) {
                params.push(keyToken);
                shorthand = true;
                value = init;
            }
            else {
                this.expect(':');
                value = this.parsePatternWithDefault(params, kind);
            }
        }
        else {
            computed = this.match('[');
            key = this.parseObjectPropertyKey();
            this.expect(':');
            value = this.parsePatternWithDefault(params, kind);
        }
        return this.finalize(node, new Node.Property('init', key, computed, value, method, shorthand));
    };
    Parser.prototype.parseRestProperty = function (params, kind) {
        var node = this.createNode();
        this.expect('...');
        var arg = this.parsePattern(params);
        if (this.match('=')) {
            this.throwError(messages_1.Messages.DefaultRestProperty);
        }
        if (!this.match('}')) {
            this.throwError(messages_1.Messages.PropertyAfterRestProperty);
        }
        return this.finalize(node, new Node.RestElement(arg));
    };
    Parser.prototype.parseObjectPattern = function (params, kind) {
        var node = this.createNode();
        var properties = [];
        this.expect('{');
        while (!this.match('}')) {
            properties.push(this.match('...') ? this.parseRestProperty(params, kind) : this.parsePropertyPattern(params, kind));
            if (!this.match('}')) {
                this.expect(',');
            }
        }
        this.expect('}');
        return this.finalize(node, new Node.ObjectPattern(properties));
    };
    Parser.prototype.parsePattern = function (params, kind) {
        var pattern;
        if (this.match('[')) {
            pattern = this.parseArrayPattern(params, kind);
        }
        else if (this.match('{')) {
            pattern = this.parseObjectPattern(params, kind);
        }
        else {
            if (this.matchKeyword('let') && (kind === 'const' || kind === 'let')) {
                this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
            }
            params.push(this.lookahead);
            pattern = this.parseVariableIdentifier(kind);
        }
        return pattern;
    };
    Parser.prototype.parsePatternWithDefault = function (params, kind) {
        var startToken = this.lookahead;
        var pattern = this.parsePattern(params, kind);
        if (this.match('=')) {
            this.nextToken();
            var previousAllowYield = this.context.allowYield;
            this.context.allowYield = true;
            var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
            this.context.allowYield = previousAllowYield;
            pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
        }
        return pattern;
    };
    // https://tc39.github.io/ecma262/#sec-variable-statement
    Parser.prototype.parseVariableIdentifier = function (kind) {
        var node = this.createNode();
        var token = this.nextToken();
        if (token.type === 4 /* Keyword */ && token.value === 'yield') {
            if (this.context.strict) {
                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
            }
            else if (!this.context.allowYield) {
                this.throwUnexpectedToken(token);
            }
        }
        else if (token.type !== 3 /* Identifier */) {
            if (this.context.strict && token.type === 4 /* Keyword */ && this.scanner.isStrictModeReservedWord(token.value)) {
                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
            }
            else {
                if (this.context.strict || token.value !== 'let' || kind !== 'var') {
                    this.throwUnexpectedToken(token);
                }
            }
        }
        else if ((this.context.isModule || this.context.await) && token.type === 3 /* Identifier */ && token.value === 'await') {
            this.tolerateUnexpectedToken(token);
        }
        return this.finalize(node, new Node.Identifier(token.value));
    };
    Parser.prototype.parseVariableDeclaration = function (options) {
        var node = this.createNode();
        var params = [];
        var id = this.parsePattern(params, 'var');
        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
            if (this.scanner.isRestrictedWord(id.name)) {
                this.tolerateError(messages_1.Messages.StrictVarName);
            }
        }
        var init = null;
        if (this.match('=')) {
            this.nextToken();
            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
        }
        else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
            this.expect('=');
        }
        return this.finalize(node, new Node.VariableDeclarator(id, init));
    };
    Parser.prototype.parseVariableDeclarationList = function (options) {
        var opt = { inFor: options.inFor };
        var list = [];
        list.push(this.parseVariableDeclaration(opt));
        while (this.match(',')) {
            this.nextToken();
            list.push(this.parseVariableDeclaration(opt));
        }
        return list;
    };
    Parser.prototype.parseVariableStatement = function () {
        var node = this.createNode();
        this.expectKeyword('var');
        var declarations = this.parseVariableDeclarationList({ inFor: false });
        this.consumeSemicolon();
        return this.finalize(node, new Node.VariableDeclaration(declarations, 'var'));
    };
    // https://tc39.github.io/ecma262/#sec-empty-statement
    Parser.prototype.parseEmptyStatement = function () {
        var node = this.createNode();
        this.expect(';');
        return this.finalize(node, new Node.EmptyStatement());
    };
    // https://tc39.github.io/ecma262/#sec-expression-statement
    Parser.prototype.parseExpressionStatement = function () {
        var node = this.createNode();
        var expr = this.parseExpression();
        this.consumeSemicolon();
        return this.finalize(node, new Node.ExpressionStatement(expr));
    };
    // https://tc39.github.io/ecma262/#sec-if-statement
    Parser.prototype.parseIfClause = function () {
        if (this.context.strict && this.matchKeyword('function')) {
            this.tolerateError(messages_1.Messages.StrictFunction);
        }
        return this.parseStatement();
    };
    Parser.prototype.parseIfStatement = function () {
        var node = this.createNode();
        var consequent;
        var alternate = null;
        this.expectKeyword('if');
        this.expect('(');
        var test = this.parseExpression();
        if (!this.match(')') && this.config.tolerant) {
            this.tolerateUnexpectedToken(this.nextToken());
            consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
        }
        else {
            this.expect(')');
            consequent = this.parseIfClause();
            if (this.matchKeyword('else')) {
                this.nextToken();
                alternate = this.parseIfClause();
            }
        }
        return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
    };
    // https://tc39.github.io/ecma262/#sec-do-while-statement
    Parser.prototype.parseDoWhileStatement = function () {
        var node = this.createNode();
        this.expectKeyword('do');
        var previousInIteration = this.context.inIteration;
        this.context.inIteration = true;
        var body = this.parseStatement();
        this.context.inIteration = previousInIteration;
        this.expectKeyword('while');
        this.expect('(');
        var test = this.parseExpression();
        if (!this.match(')') && this.config.tolerant) {
            this.tolerateUnexpectedToken(this.nextToken());
        }
        else {
            this.expect(')');
            if (this.match(';')) {
                this.nextToken();
            }
        }
        return this.finalize(node, new Node.DoWhileStatement(body, test));
    };
    // https://tc39.github.io/ecma262/#sec-while-statement
    Parser.prototype.parseWhileStatement = function () {
        var node = this.createNode();
        var body;
        this.expectKeyword('while');
        this.expect('(');
        var test = this.parseExpression();
        if (!this.match(')') && this.config.tolerant) {
            this.tolerateUnexpectedToken(this.nextToken());
            body = this.finalize(this.createNode(), new Node.EmptyStatement());
        }
        else {
            this.expect(')');
            var previousInIteration = this.context.inIteration;
            this.context.inIteration = true;
            body = this.parseStatement();
            this.context.inIteration = previousInIteration;
        }
        return this.finalize(node, new Node.WhileStatement(test, body));
    };
    // https://tc39.github.io/ecma262/#sec-for-statement
    // https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements
    Parser.prototype.parseForStatement = function () {
        var init = null;
        var test = null;
        var update = null;
        var forIn = true;
        var left, right;
        var node = this.createNode();
        this.expectKeyword('for');
        this.expect('(');
        if (this.match(';')) {
            this.nextToken();
        }
        else {
            if (this.matchKeyword('var')) {
                init = this.createNode();
                this.nextToken();
                var previousAllowIn = this.context.allowIn;
                this.context.allowIn = false;
                var declarations = this.parseVariableDeclarationList({ inFor: true });
                this.context.allowIn = previousAllowIn;
                if (declarations.length === 1 && this.matchKeyword('in')) {
                    var decl = declarations[0];
                    if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
                        this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, 'for-in');
                    }
                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
                    this.nextToken();
                    left = init;
                    right = this.parseExpression();
                    init = null;
                }
                else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
                    this.nextToken();
                    left = init;
                    right = this.parseAssignmentExpression();
                    init = null;
                    forIn = false;
                }
                else {
                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
                    this.expect(';');
                }
            }
            else if (this.matchKeyword('const') || this.matchKeyword('let')) {
                init = this.createNode();
                var kind = this.nextToken().value;
                if (!this.context.strict && this.lookahead.value === 'in') {
                    init = this.finalize(init, new Node.Identifier(kind));
                    this.nextToken();
                    left = init;
                    right = this.parseExpression();
                    init = null;
                }
                else {
                    var previousAllowIn = this.context.allowIn;
                    this.context.allowIn = false;
                    var declarations = this.parseBindingList(kind, { inFor: true });
                    this.context.allowIn = previousAllowIn;
                    if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword('in')) {
                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                        this.nextToken();
                        left = init;
                        right = this.parseExpression();
                        init = null;
                    }
                    else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                        this.nextToken();
                        left = init;
                        right = this.parseAssignmentExpression();
                        init = null;
                        forIn = false;
                    }
                    else {
                        this.consumeSemicolon();
                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                    }
                }
            }
            else {
                var initStartToken = this.lookahead;
                var previousAllowIn = this.context.allowIn;
                this.context.allowIn = false;
                init = this.inheritCoverGrammar(this.parseAssignmentExpression);
                this.context.allowIn = previousAllowIn;
                if (this.matchKeyword('in')) {
                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
                        this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
                    }
                    this.nextToken();
                    this.reinterpretExpressionAsPattern(init);
                    left = init;
                    right = this.parseExpression();
                    init = null;
                }
                else if (this.matchContextualKeyword('of')) {
                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
                        this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
                    }
                    this.nextToken();
                    this.reinterpretExpressionAsPattern(init);
                    left = init;
                    right = this.parseAssignmentExpression();
                    init = null;
                    forIn = false;
                }
                else {
                    if (this.match(',')) {
                        var initSeq = [init];
                        while (this.match(',')) {
                            this.nextToken();
                            initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                        }
                        init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
                    }
                    this.expect(';');
                }
            }
        }
        if (typeof left === 'undefined') {
            if (!this.match(';')) {
                test = this.parseExpression();
            }
            this.expect(';');
            if (!this.match(')')) {
                update = this.parseExpression();
            }
        }
        var body;
        if (!this.match(')') && this.config.tolerant) {
            this.tolerateUnexpectedToken(this.nextToken());
            body = this.finalize(this.createNode(), new Node.EmptyStatement());
        }
        else {
            this.expect(')');
            var previousInIteration = this.context.inIteration;
            this.context.inIteration = true;
            body = this.isolateCoverGrammar(this.parseStatement);
            this.context.inIteration = previousInIteration;
        }
        return (typeof left === 'undefined') ?
            this.finalize(node, new Node.ForStatement(init, test, update, body)) :
            forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) :
                this.finalize(node, new Node.ForOfStatement(left, right, body));
    };
    // https://tc39.github.io/ecma262/#sec-continue-statement
    Parser.prototype.parseContinueStatement = function () {
        var node = this.createNode();
        this.expectKeyword('continue');
        var label = null;
        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
            var id = this.parseVariableIdentifier();
            label = id;
            var key = '$' + id.name;
            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                this.throwError(messages_1.Messages.UnknownLabel, id.name);
            }
        }
        this.consumeSemicolon();
        if (label === null && !this.context.inIteration) {
            this.throwError(messages_1.Messages.IllegalContinue);
        }
        return this.finalize(node, new Node.ContinueStatement(label));
    };
    // https://tc39.github.io/ecma262/#sec-break-statement
    Parser.prototype.parseBreakStatement = function () {
        var node = this.createNode();
        this.expectKeyword('break');
        var label = null;
        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
            var id = this.parseVariableIdentifier();
            var key = '$' + id.name;
            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                this.throwError(messages_1.Messages.UnknownLabel, id.name);
            }
            label = id;
        }
        this.consumeSemicolon();
        if (label === null && !this.context.inIteration && !this.context.inSwitch) {
            this.throwError(messages_1.Messages.IllegalBreak);
        }
        return this.finalize(node, new Node.BreakStatement(label));
    };
    // https://tc39.github.io/ecma262/#sec-return-statement
    Parser.prototype.parseReturnStatement = function () {
        if (!this.context.inFunctionBody) {
            this.tolerateError(messages_1.Messages.IllegalReturn);
        }
        var node = this.createNode();
        this.expectKeyword('return');
        var hasArgument = !this.match(';') && !this.match('}') &&
            (!this.hasLineTerminator || this.match('`')) &&
            this.lookahead.type !== 2 /* EOF */;
        var argument = hasArgument ? this.parseExpression() : null;
        this.consumeSemicolon();
        return this.finalize(node, new Node.ReturnStatement(argument));
    };
    // https://tc39.github.io/ecma262/#sec-with-statement
    Parser.prototype.parseWithStatement = function () {
        if (this.context.strict) {
            this.tolerateError(messages_1.Messages.StrictModeWith);
        }
        var node = this.createNode();
        var body;
        this.expectKeyword('with');
        this.expect('(');
        var object = this.parseExpression();
        if (!this.match(')') && this.config.tolerant) {
            this.tolerateUnexpectedToken(this.nextToken());
            body = this.finalize(this.createNode(), new Node.EmptyStatement());
        }
        else {
            this.expect(')');
            body = this.parseStatement();
        }
        return this.finalize(node, new Node.WithStatement(object, body));
    };
    // https://tc39.github.io/ecma262/#sec-switch-statement
    Parser.prototype.parseSwitchCase = function () {
        var node = this.createNode();
        var test;
        if (this.matchKeyword('default')) {
            this.nextToken();
            test = null;
        }
        else {
            this.expectKeyword('case');
            test = this.parseExpression();
        }
        this.expect(':');
        var consequent = [];
        while (true) {
            if (this.match('}') || this.matchKeyword('default') || this.matchKeyword('case')) {
                break;
            }
            consequent.push(this.parseStatementListItem());
        }
        return this.finalize(node, new Node.SwitchCase(test, consequent));
    };
    Parser.prototype.parseSwitchStatement = function () {
        var node = this.createNode();
        this.expectKeyword('switch');
        this.expect('(');
        var discriminant = this.parseExpression();
        this.expect(')');
        var previousInSwitch = this.context.inSwitch;
        this.context.inSwitch = true;
        var cases = [];
        var defaultFound = false;
        this.expect('{');
        while (true) {
            if (this.match('}')) {
                break;
            }
            var clause = this.parseSwitchCase();
            if (clause.test === null) {
                if (defaultFound) {
                    this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
                }
                defaultFound = true;
            }
            cases.push(clause);
        }
        this.expect('}');
        this.context.inSwitch = previousInSwitch;
        return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
    };
    // https://tc39.github.io/ecma262/#sec-labelled-statements
    Parser.prototype.parseLabelledStatement = function () {
        var node = this.createNode();
        var expr = this.parseExpression();
        var statement;
        if ((expr.type === syntax_1.Syntax.Identifier) && this.match(':')) {
            this.nextToken();
            var id = expr;
            var key = '$' + id.name;
            if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                this.throwError(messages_1.Messages.Redeclaration, 'Label', id.name);
            }
            this.context.labelSet[key] = true;
            var body = void 0;
            if (this.matchKeyword('class')) {
                this.tolerateUnexpectedToken(this.lookahead);
                body = this.parseClassDeclaration();
            }
            else if (this.matchKeyword('function')) {
                var token = this.lookahead;
                var declaration = this.parseFunctionDeclaration();
                if (this.context.strict) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
                }
                else if (declaration.generator) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
                }
                body = declaration;
            }
            else {
                body = this.parseStatement();
            }
            delete this.context.labelSet[key];
            statement = new Node.LabeledStatement(id, body);
        }
        else {
            this.consumeSemicolon();
            statement = new Node.ExpressionStatement(expr);
        }
        return this.finalize(node, statement);
    };
    // https://tc39.github.io/ecma262/#sec-throw-statement
    Parser.prototype.parseThrowStatement = function () {
        var node = this.createNode();
        this.expectKeyword('throw');
        var hasLineTerminator = this.hasLineTerminator;
        var source = this.scanner.source;
        var argument;
        try {
            argument = this.parseExpression();
        }
        catch (e) {
            if (!hasLineTerminator) {
                throw e;
            }
        }
        if (hasLineTerminator) {
            var isTemplateLiteral = argument && argument.type === 'TemplateLiteral';
            var hasLineTerminatorBeforeTemplate = isTemplateLiteral &&
                source.trim().indexOf('\n') < source.trim().indexOf('`');
            if (!argument ||
                !isTemplateLiteral ||
                hasLineTerminatorBeforeTemplate) {
                this.throwError(messages_1.Messages.NewlineAfterThrow);
            }
        }
        this.consumeSemicolon();
        return this.finalize(node, new Node.ThrowStatement(argument));
    };
    // https://tc39.github.io/ecma262/#sec-try-statement
    Parser.prototype.parseCatchClause = function () {
        var node = this.createNode();
        this.expectKeyword('catch');
        this.expect('(');
        if (this.match(')')) {
            this.throwUnexpectedToken(this.lookahead);
        }
        var params = [];
        var param = this.parsePattern(params);
        var paramMap = {};
        for (var i = 0; i < params.length; i++) {
            var key = '$' + params[i].value;
            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
                this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
            }
            paramMap[key] = true;
        }
        if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
            if (this.scanner.isRestrictedWord(param.name)) {
                this.tolerateError(messages_1.Messages.StrictCatchVariable);
            }
        }
        this.expect(')');
        var body = this.parseBlock();
        return this.finalize(node, new Node.CatchClause(param, body));
    };
    Parser.prototype.parseFinallyClause = function () {
        this.expectKeyword('finally');
        return this.parseBlock();
    };
    Parser.prototype.parseTryStatement = function () {
        var node = this.createNode();
        this.expectKeyword('try');
        var block = this.parseBlock();
        var handler = this.matchKeyword('catch') ? this.parseCatchClause() : null;
        var finalizer = this.matchKeyword('finally') ? this.parseFinallyClause() : null;
        if (!handler && !finalizer) {
            this.throwError(messages_1.Messages.NoCatchOrFinally);
        }
        return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
    };
    // https://tc39.github.io/ecma262/#sec-debugger-statement
    Parser.prototype.parseDebuggerStatement = function () {
        var node = this.createNode();
        this.expectKeyword('debugger');
        this.consumeSemicolon();
        return this.finalize(node, new Node.DebuggerStatement());
    };
    // https://tc39.github.io/ecma262/#sec-ecmascript-language-statements-and-declarations
    Parser.prototype.parseStatement = function () {
        var statement;
        switch (this.lookahead.type) {
            case 1 /* BooleanLiteral */:
            case 5 /* NullLiteral */:
            case 6 /* NumericLiteral */:
            case 8 /* StringLiteral */:
            case 10 /* Template */:
            case 9 /* RegularExpression */:
                statement = this.parseExpressionStatement();
                break;
            case 7 /* Punctuator */:
                var value = this.lookahead.value;
                if (value === '{') {
                    statement = this.parseBlock();
                }
                else if (value === '(') {
                    statement = this.parseExpressionStatement();
                }
                else if (value === ';') {
                    statement = this.parseEmptyStatement();
                }
                else {
                    statement = this.parseExpressionStatement();
                }
                break;
            case 3 /* Identifier */:
                statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
                break;
            case 4 /* Keyword */:
                switch (this.lookahead.value) {
                    case 'break':
                        statement = this.parseBreakStatement();
                        break;
                    case 'continue':
                        statement = this.parseContinueStatement();
                        break;
                    case 'debugger':
                        statement = this.parseDebuggerStatement();
                        break;
                    case 'do':
                        statement = this.parseDoWhileStatement();
                        break;
                    case 'for':
                        statement = this.parseForStatement();
                        break;
                    case 'function':
                        statement = this.parseFunctionDeclaration();
                        break;
                    case 'if':
                        statement = this.parseIfStatement();
                        break;
                    case 'return':
                        statement = this.parseReturnStatement();
                        break;
                    case 'switch':
                        statement = this.parseSwitchStatement();
                        break;
                    case 'throw':
                        statement = this.parseThrowStatement();
                        break;
                    case 'try':
                        statement = this.parseTryStatement();
                        break;
                    case 'var':
                        statement = this.parseVariableStatement();
                        break;
                    case 'while':
                        statement = this.parseWhileStatement();
                        break;
                    case 'with':
                        statement = this.parseWithStatement();
                        break;
                    default:
                        statement = this.parseExpressionStatement();
                        break;
                }
                break;
            default:
                statement = this.throwUnexpectedToken(this.lookahead);
        }
        return statement;
    };
    // https://tc39.github.io/ecma262/#sec-function-definitions
    Parser.prototype.parseFunctionSourceElements = function () {
        var node = this.createNode();
        this.expect('{');
        var body = this.parseDirectivePrologues();
        var previousLabelSet = this.context.labelSet;
        var previousInIteration = this.context.inIteration;
        var previousInSwitch = this.context.inSwitch;
        var previousInFunctionBody = this.context.inFunctionBody;
        this.context.labelSet = {};
        this.context.inIteration = false;
        this.context.inSwitch = false;
        this.context.inFunctionBody = true;
        while (this.lookahead.type !== 2 /* EOF */) {
            if (this.match('}')) {
                break;
            }
            body.push(this.parseStatementListItem());
        }
        this.expect('}');
        this.context.labelSet = previousLabelSet;
        this.context.inIteration = previousInIteration;
        this.context.inSwitch = previousInSwitch;
        this.context.inFunctionBody = previousInFunctionBody;
        return this.finalize(node, new Node.BlockStatement(body));
    };
    Parser.prototype.validateParam = function (options, param, name) {
        var key = '$' + name;
        if (this.context.strict) {
            if (this.scanner.isRestrictedWord(name)) {
                options.stricted = param;
                options.message = messages_1.Messages.StrictParamName;
            }
            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.stricted = param;
                options.message = messages_1.Messages.StrictParamDupe;
            }
        }
        else if (!options.firstRestricted) {
            if (this.scanner.isRestrictedWord(name)) {
                options.firstRestricted = param;
                options.message = messages_1.Messages.StrictParamName;
            }
            else if (this.scanner.isStrictModeReservedWord(name)) {
                options.firstRestricted = param;
                options.message = messages_1.Messages.StrictReservedWord;
            }
            else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.stricted = param;
                options.message = messages_1.Messages.StrictParamDupe;
            }
        }
        /* istanbul ignore next */
        if (typeof Object.defineProperty === 'function') {
            Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
        }
        else {
            options.paramSet[key] = true;
        }
    };
    Parser.prototype.parseRestElement = function (params) {
        var node = this.createNode();
        this.expect('...');
        var arg = this.parsePattern(params);
        if (this.match('=')) {
            this.throwError(messages_1.Messages.DefaultRestParameter);
        }
        if (!this.match(')')) {
            this.throwError(messages_1.Messages.ParameterAfterRestParameter);
        }
        return this.finalize(node, new Node.RestElement(arg));
    };
    Parser.prototype.parseFormalParameter = function (options) {
        var params = [];
        var param = this.match('...') ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
        for (var i = 0; i < params.length; i++) {
            this.validateParam(options, params[i], params[i].value);
        }
        options.simple = options.simple && (param instanceof Node.Identifier);
        options.params.push(param);
    };
    Parser.prototype.parseFormalParameters = function (firstRestricted) {
        var options;
        options = {
            simple: true,
            params: [],
            firstRestricted: firstRestricted
        };
        this.expect('(');
        if (!this.match(')')) {
            options.paramSet = {};
            while (this.lookahead.type !== 2 /* EOF */) {
                this.parseFormalParameter(options);
                if (this.match(')')) {
                    break;
                }
                this.expect(',');
                if (this.match(')')) {
                    break;
                }
            }
        }
        this.expect(')');
        return {
            simple: options.simple,
            params: options.params,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
        };
    };
    Parser.prototype.matchAsyncFunction = function () {
        var match = this.matchContextualKeyword('async');
        if (match) {
            var state = this.scanner.saveState();
            this.scanner.scanComments();
            var next = this.scanner.lex();
            this.scanner.restoreState(state);
            match = (state.lineNumber === next.lineNumber) && (next.type === 4 /* Keyword */) && (next.value === 'function');
        }
        return match;
    };
    Parser.prototype.parseFunctionDeclaration = function (identifierIsOptional) {
        var node = this.createNode();
        var isAsync = this.matchContextualKeyword('async');
        if (isAsync) {
            this.nextToken();
        }
        this.expectKeyword('function');
        var isGenerator = isAsync ? false : this.match('*');
        if (isGenerator) {
            this.nextToken();
        }
        var message;
        var id = null;
        var firstRestricted = null;
        if (!identifierIsOptional || !this.match('(')) {
            var token = this.lookahead;
            id = this.parseVariableIdentifier();
            if (this.context.strict) {
                if (this.scanner.isRestrictedWord(token.value)) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                }
            }
            else {
                if (this.scanner.isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = messages_1.Messages.StrictFunctionName;
                }
                else if (this.scanner.isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = messages_1.Messages.StrictReservedWord;
                }
            }
        }
        var previousAllowAwait = this.context.await;
        var previousAllowYield = this.context.allowYield;
        this.context.await = isAsync;
        this.context.allowYield = !isGenerator;
        var formalParameters = this.parseFormalParameters(firstRestricted);
        var params = formalParameters.params;
        var stricted = formalParameters.stricted;
        firstRestricted = formalParameters.firstRestricted;
        if (formalParameters.message) {
            message = formalParameters.message;
        }
        var previousStrict = this.context.strict;
        var previousAllowStrictDirective = this.context.allowStrictDirective;
        this.context.allowStrictDirective = formalParameters.simple;
        var body = this.parseFunctionSourceElements();
        if (this.context.strict && firstRestricted) {
            this.throwUnexpectedToken(firstRestricted, message);
        }
        if (this.context.strict && stricted) {
            this.tolerateUnexpectedToken(stricted, message);
        }
        this.context.strict = previousStrict;
        this.context.allowStrictDirective = previousAllowStrictDirective;
        this.context.await = previousAllowAwait;
        this.context.allowYield = previousAllowYield;
        return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) :
            this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
    };
    Parser.prototype.parseFunctionExpression = function () {
        var node = this.createNode();
        var isAsync = this.matchContextualKeyword('async');
        if (isAsync) {
            this.nextToken();
        }
        this.expectKeyword('function');
        var isGenerator = isAsync ? false : this.match('*');
        if (isGenerator) {
            this.nextToken();
        }
        var message;
        var id = null;
        var firstRestricted;
        var previousAllowAwait = this.context.await;
        var previousAllowYield = this.context.allowYield;
        this.context.await = isAsync;
        this.context.allowYield = !isGenerator;
        if (!this.match('(')) {
            var token = this.lookahead;
            id = (!this.context.strict && !isGenerator && this.matchKeyword('yield')) ? this.parseIdentifierName() : this.parseVariableIdentifier();
            if (this.context.strict) {
                if (this.scanner.isRestrictedWord(token.value)) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                }
            }
            else {
                if (this.scanner.isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = messages_1.Messages.StrictFunctionName;
                }
                else if (this.scanner.isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = messages_1.Messages.StrictReservedWord;
                }
            }
        }
        var formalParameters = this.parseFormalParameters(firstRestricted);
        var params = formalParameters.params;
        var stricted = formalParameters.stricted;
        firstRestricted = formalParameters.firstRestricted;
        if (formalParameters.message) {
            message = formalParameters.message;
        }
        var previousStrict = this.context.strict;
        var previousAllowStrictDirective = this.context.allowStrictDirective;
        this.context.allowStrictDirective = formalParameters.simple;
        var body = this.parseFunctionSourceElements();
        if (this.context.strict && firstRestricted) {
            this.throwUnexpectedToken(firstRestricted, message);
        }
        if (this.context.strict && stricted) {
            this.tolerateUnexpectedToken(stricted, message);
        }
        this.context.strict = previousStrict;
        this.context.allowStrictDirective = previousAllowStrictDirective;
        this.context.await = previousAllowAwait;
        this.context.allowYield = previousAllowYield;
        return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) :
            this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
    };
    // https://tc39.github.io/ecma262/#sec-directive-prologues-and-the-use-strict-directive
    Parser.prototype.parseDirective = function () {
        var token = this.lookahead;
        var node = this.createNode();
        var expr = this.parseExpression();
        var directive = (expr.type === syntax_1.Syntax.Literal) ? this.getTokenRaw(token).slice(1, -1) : null;
        this.consumeSemicolon();
        return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
    };
    Parser.prototype.parseDirectivePrologues = function () {
        var firstRestricted = null;
        var body = [];
        while (true) {
            var token = this.lookahead;
            if (token.type !== 8 /* StringLiteral */) {
                break;
            }
            var statement = this.parseDirective();
            body.push(statement);
            var directive = statement.directive;
            if (typeof directive !== 'string') {
                break;
            }
            if (directive === 'use strict') {
                this.context.strict = true;
                if (firstRestricted) {
                    this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
                }
                if (!this.context.allowStrictDirective) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
                }
            }
            else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }
        return body;
    };
    // https://tc39.github.io/ecma262/#sec-method-definitions
    Parser.prototype.qualifiedPropertyName = function (token) {
        switch (token.type) {
            case 3 /* Identifier */:
            case 8 /* StringLiteral */:
            case 1 /* BooleanLiteral */:
            case 5 /* NullLiteral */:
            case 6 /* NumericLiteral */:
            case 4 /* Keyword */:
                return true;
            case 7 /* Punctuator */:
                return token.value === '[';
            default:
                break;
        }
        return false;
    };
    Parser.prototype.parseGetterMethod = function () {
        var node = this.createNode();
        var isGenerator = false;
        var previousAllowYield = this.context.allowYield;
        this.context.allowYield = !isGenerator;
        var formalParameters = this.parseFormalParameters();
        if (formalParameters.params.length > 0) {
            this.tolerateError(messages_1.Messages.BadGetterArity);
        }
        var method = this.parsePropertyMethod(formalParameters);
        this.context.allowYield = previousAllowYield;
        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
    };
    Parser.prototype.parseSetterMethod = function () {
        var node = this.createNode();
        var isGenerator = false;
        var previousAllowYield = this.context.allowYield;
        this.context.allowYield = !isGenerator;
        var formalParameters = this.parseFormalParameters();
        if (formalParameters.params.length !== 1) {
            this.tolerateError(messages_1.Messages.BadSetterArity);
        }
        else if (formalParameters.params[0] instanceof Node.RestElement) {
            this.tolerateError(messages_1.Messages.BadSetterRestParameter);
        }
        var method = this.parsePropertyMethod(formalParameters);
        this.context.allowYield = previousAllowYield;
        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
    };
    Parser.prototype.parseGeneratorMethod = function () {
        var node = this.createNode();
        var isGenerator = true;
        var previousAllowYield = this.context.allowYield;
        this.context.allowYield = true;
        var params = this.parseFormalParameters();
        this.context.allowYield = false;
        var method = this.parsePropertyMethod(params);
        this.context.allowYield = previousAllowYield;
        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
    };
    // https://tc39.github.io/ecma262/#sec-generator-function-definitions
    Parser.prototype.isStartOfExpression = function () {
        var start = true;
        var value = this.lookahead.value;
        switch (this.lookahead.type) {
            case 7 /* Punctuator */:
                start = (value === '[') || (value === '(') || (value === '{') ||
                    (value === '+') || (value === '-') ||
                    (value === '!') || (value === '~') ||
                    (value === '++') || (value === '--') ||
                    (value === '/') || (value === '/='); // regular expression literal
                break;
            case 4 /* Keyword */:
                start = (value === 'class') || (value === 'delete') ||
                    (value === 'function') || (value === 'let') || (value === 'new') ||
                    (value === 'super') || (value === 'this') || (value === 'typeof') ||
                    (value === 'void') || (value === 'yield');
                break;
            default:
                break;
        }
        return start;
    };
    Parser.prototype.parseYieldExpression = function () {
        var node = this.createNode();
        this.expectKeyword('yield');
        var argument = null;
        var delegate = false;
        if (!this.hasLineTerminator) {
            var previousAllowYield = this.context.allowYield;
            this.context.allowYield = false;
            delegate = this.match('*');
            if (delegate) {
                this.nextToken();
                argument = this.parseAssignmentExpression();
            }
            else if (this.isStartOfExpression()) {
                argument = this.parseAssignmentExpression();
            }
            this.context.allowYield = previousAllowYield;
        }
        return this.finalize(node, new Node.YieldExpression(argument, delegate));
    };
    // https://tc39.github.io/ecma262/#sec-class-definitions
    Parser.prototype.parseClassElement = function (hasConstructor) {
        var token = this.lookahead;
        var node = this.createNode();
        var kind = '';
        var key = null;
        var value = null;
        var computed = false;
        var method = false;
        var isStatic = false;
        var isAsync = false;
        if (this.match('*')) {
            this.nextToken();
        }
        else {
            computed = this.match('[');
            key = this.parseObjectPropertyKey();
            var id = key;
            if (id.name === 'static' && (this.qualifiedPropertyName(this.lookahead) || this.match('*'))) {
                token = this.lookahead;
                isStatic = true;
                computed = this.match('[');
                if (this.match('*')) {
                    this.nextToken();
                }
                else {
                    key = this.parseObjectPropertyKey();
                }
            }
            if ((token.type === 3 /* Identifier */) && !this.hasLineTerminator && (token.value === 'async')) {
                var punctuator = this.lookahead.value;
                if (punctuator !== ':' && punctuator !== '(' && punctuator !== '*') {
                    isAsync = true;
                    token = this.lookahead;
                    key = this.parseObjectPropertyKey();
                    if (token.type === 3 /* Identifier */) {
                        if (token.value === 'get' || token.value === 'set') {
                            this.tolerateUnexpectedToken(token);
                        }
                        else if (token.value === 'constructor') {
                            this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
                        }
                    }
                }
            }
        }
        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
        if (token.type === 3 /* Identifier */) {
            if (token.value === 'get' && lookaheadPropertyKey) {
                kind = 'get';
                computed = this.match('[');
                key = this.parseObjectPropertyKey();
                this.context.allowYield = false;
                value = this.parseGetterMethod();
            }
            else if (token.value === 'set' && lookaheadPropertyKey) {
                kind = 'set';
                computed = this.match('[');
                key = this.parseObjectPropertyKey();
                value = this.parseSetterMethod();
            }
        }
        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
            kind = 'init';
            computed = this.match('[');
            key = this.parseObjectPropertyKey();
            value = this.parseGeneratorMethod();
            method = true;
        }
        if (!kind && key && this.match('(')) {
            kind = 'init';
            value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
            method = true;
        }
        if (!kind) {
            this.throwUnexpectedToken(this.lookahead);
        }
        if (kind === 'init') {
            kind = 'method';
        }
        if (!computed) {
            if (isStatic && this.isPropertyKey(key, 'prototype')) {
                this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
            }
            if (!isStatic && this.isPropertyKey(key, 'constructor')) {
                if (kind !== 'method' || !method || (value && value.generator)) {
                    this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
                }
                if (hasConstructor.value) {
                    this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
                }
                else {
                    hasConstructor.value = true;
                }
                kind = 'constructor';
            }
        }
        return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
    };
    Parser.prototype.parseClassElementList = function () {
        var body = [];
        var hasConstructor = { value: false };
        this.expect('{');
        while (!this.match('}')) {
            if (this.match(';')) {
                this.nextToken();
            }
            else {
                body.push(this.parseClassElement(hasConstructor));
            }
        }
        this.expect('}');
        return body;
    };
    Parser.prototype.parseClassBody = function () {
        var node = this.createNode();
        var elementList = this.parseClassElementList();
        return this.finalize(node, new Node.ClassBody(elementList));
    };
    Parser.prototype.parseClassDeclaration = function (identifierIsOptional) {
        var node = this.createNode();
        var previousStrict = this.context.strict;
        this.context.strict = true;
        this.expectKeyword('class');
        var id = (identifierIsOptional && (this.lookahead.type !== 3 /* Identifier */)) ? null : this.parseVariableIdentifier();
        var superClass = null;
        if (this.matchKeyword('extends')) {
            this.nextToken();
            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
        }
        var classBody = this.parseClassBody();
        this.context.strict = previousStrict;
        return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
    };
    Parser.prototype.parseClassExpression = function () {
        var node = this.createNode();
        var previousStrict = this.context.strict;
        this.context.strict = true;
        this.expectKeyword('class');
        var id = (this.lookahead.type === 3 /* Identifier */) ? this.parseVariableIdentifier() : null;
        var superClass = null;
        if (this.matchKeyword('extends')) {
            this.nextToken();
            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
        }
        var classBody = this.parseClassBody();
        this.context.strict = previousStrict;
        return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
    };
    // https://tc39.github.io/ecma262/#sec-scripts
    // https://tc39.github.io/ecma262/#sec-modules
    Parser.prototype.parseModule = function () {
        this.context.strict = true;
        this.context.isModule = true;
        var node = this.createNode();
        var body = this.parseDirectivePrologues();
        while (this.lookahead.type !== 2 /* EOF */) {
            body.push(this.parseStatementListItem());
        }
        return this.finalize(node, new Node.Module(body));
    };
    Parser.prototype.parseScript = function () {
        var node = this.createNode();
        var body = this.parseDirectivePrologues();
        while (this.lookahead.type !== 2 /* EOF */) {
            body.push(this.parseStatementListItem());
        }
        return this.finalize(node, new Node.Script(body));
    };
    // https://tc39.github.io/ecma262/#sec-imports
    Parser.prototype.parseModuleSpecifier = function () {
        var node = this.createNode();
        if (this.lookahead.type !== 8 /* StringLiteral */) {
            this.throwError(messages_1.Messages.InvalidModuleSpecifier);
        }
        var token = this.nextToken();
        var raw = this.getTokenRaw(token);
        return this.finalize(node, new Node.Literal(token.value, raw));
    };
    // import {<foo as bar>} ...;
    Parser.prototype.parseImportSpecifier = function () {
        var node = this.createNode();
        var imported;
        var local;
        if (this.lookahead.type === 3 /* Identifier */) {
            imported = this.parseVariableIdentifier();
            local = imported;
            if (this.matchContextualKeyword('as')) {
                this.nextToken();
                local = this.parseVariableIdentifier();
            }
        }
        else {
            imported = this.parseIdentifierName();
            local = imported;
            if (this.matchContextualKeyword('as')) {
                this.nextToken();
                local = this.parseVariableIdentifier();
            }
            else {
                this.throwUnexpectedToken(this.nextToken());
            }
        }
        return this.finalize(node, new Node.ImportSpecifier(local, imported));
    };
    // {foo, bar as bas}
    Parser.prototype.parseNamedImports = function () {
        this.expect('{');
        var specifiers = [];
        while (!this.match('}')) {
            specifiers.push(this.parseImportSpecifier());
            if (!this.match('}')) {
                this.expect(',');
            }
        }
        this.expect('}');
        return specifiers;
    };
    // import <foo> ...;
    Parser.prototype.parseImportDefaultSpecifier = function () {
        var node = this.createNode();
        var local = this.parseIdentifierName();
        return this.finalize(node, new Node.ImportDefaultSpecifier(local));
    };
    // import <* as foo> ...;
    Parser.prototype.parseImportNamespaceSpecifier = function () {
        var node = this.createNode();
        this.expect('*');
        if (!this.matchContextualKeyword('as')) {
            this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
        }
        this.nextToken();
        var local = this.parseIdentifierName();
        return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
    };
    Parser.prototype.parseImportDeclaration = function () {
        if (this.context.inFunctionBody) {
            this.throwError(messages_1.Messages.IllegalImportDeclaration);
        }
        var node = this.createNode();
        this.expectKeyword('import');
        var src;
        var specifiers = [];
        if (this.lookahead.type === 8 /* StringLiteral */) {
            // import 'foo';
            src = this.parseModuleSpecifier();
        }
        else {
            if (this.match('{')) {
                // import {bar}
                specifiers = specifiers.concat(this.parseNamedImports());
            }
            else if (this.match('*')) {
                // import * as foo
                specifiers.push(this.parseImportNamespaceSpecifier());
            }
            else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword('default')) {
                // import foo
                specifiers.push(this.parseImportDefaultSpecifier());
                if (this.match(',')) {
                    this.nextToken();
                    if (this.match('*')) {
                        // import foo, * as foo
                        specifiers.push(this.parseImportNamespaceSpecifier());
                    }
                    else if (this.match('{')) {
                        // import foo, {bar}
                        specifiers = specifiers.concat(this.parseNamedImports());
                    }
                    else {
                        this.throwUnexpectedToken(this.lookahead);
                    }
                }
            }
            else {
                this.throwUnexpectedToken(this.nextToken());
            }
            if (!this.matchContextualKeyword('from')) {
                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                this.throwError(message, this.lookahead.value);
            }
            this.nextToken();
            src = this.parseModuleSpecifier();
        }
        this.consumeSemicolon();
        return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
    };
    // https://tc39.github.io/ecma262/#sec-exports
    Parser.prototype.parseExportSpecifier = function () {
        var node = this.createNode();
        var local = this.parseIdentifierName();
        var exported = local;
        if (this.matchContextualKeyword('as')) {
            this.nextToken();
            exported = this.parseIdentifierName();
        }
        return this.finalize(node, new Node.ExportSpecifier(local, exported));
    };
    Parser.prototype.parseExportDeclaration = function () {
        if (this.context.inFunctionBody) {
            this.throwError(messages_1.Messages.IllegalExportDeclaration);
        }
        var node = this.createNode();
        this.expectKeyword('export');
        var exportDeclaration;
        if (this.matchKeyword('default')) {
            // export default ...
            this.nextToken();
            if (this.matchKeyword('function')) {
                // export default function foo () {}
                // export default function () {}
                var declaration = this.parseFunctionDeclaration(true);
                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
            }
            else if (this.matchKeyword('class')) {
                // export default class foo {}
                var declaration = this.parseClassDeclaration(true);
                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
            }
            else if (this.matchContextualKeyword('async')) {
                // export default async function f () {}
                // export default async function () {}
                // export default async x => x
                var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
            }
            else {
                if (this.matchContextualKeyword('from')) {
                    this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
                }
                // export default {};
                // export default [];
                // export default (1 + 2);
                var declaration = this.match('{') ? this.parseObjectInitializer() :
                    this.match('[') ? this.parseArrayInitializer() : this.parseAssignmentExpression();
                this.consumeSemicolon();
                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
            }
        }
        else if (this.match('*')) {
            // export * from 'foo';
            this.nextToken();
            if (!this.matchContextualKeyword('from')) {
                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                this.throwError(message, this.lookahead.value);
            }
            this.nextToken();
            var src = this.parseModuleSpecifier();
            this.consumeSemicolon();
            exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
        }
        else if (this.lookahead.type === 4 /* Keyword */) {
            // export var f = 1;
            var declaration = void 0;
            switch (this.lookahead.value) {
                case 'let':
                case 'const':
                    declaration = this.parseLexicalDeclaration({ inFor: false });
                    break;
                case 'var':
                case 'class':
                case 'function':
                    declaration = this.parseStatementListItem();
                    break;
                default:
                    this.throwUnexpectedToken(this.lookahead);
            }
            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
        }
        else if (this.matchAsyncFunction()) {
            var declaration = this.parseFunctionDeclaration();
            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
        }
        else {
            var specifiers = [];
            var source = null;
            var isExportFromIdentifier = false;
            this.expect('{');
            while (!this.match('}')) {
                isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword('default');
                specifiers.push(this.parseExportSpecifier());
                if (!this.match('}')) {
                    this.expect(',');
                }
            }
            this.expect('}');
            if (this.matchContextualKeyword('from')) {
                // export {default} from 'foo';
                // export {foo} from 'foo';
                this.nextToken();
                source = this.parseModuleSpecifier();
                this.consumeSemicolon();
            }
            else if (isExportFromIdentifier) {
                // export {default}; // missing fromClause
                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                this.throwError(message, this.lookahead.value);
            }
            else {
                // export {foo};
                this.consumeSemicolon();
            }
            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
        }
        return exportDeclaration;
    };
    return Parser;
}());
exports.Parser = Parser;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Ensure the condition is true, otherwise throw an error.
// This is only to have a better contract semantic, i.e. another safety net
// to catch a logic error. The condition shall be fulfilled in normal case.
// Do NOT use this to enforce a certain condition on any user input.
Object.defineProperty(exports, "__esModule", { value: true });
function assert(condition, message) {
    /* istanbul ignore if */
    if (!condition) {
        throw new Error('ASSERT: ' + message);
    }
}
exports.assert = assert;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* tslint:disable:max-classes-per-file */
Object.defineProperty(exports, "__esModule", { value: true });
var ErrorHandler = /** @class */ (function () {
    function ErrorHandler() {
        this.errors = [];
        this.tolerant = false;
    }
    ErrorHandler.prototype.recordError = function (error) {
        this.errors.push(error);
    };
    ErrorHandler.prototype.tolerate = function (error) {
        if (this.tolerant) {
            this.recordError(error);
        }
        else {
            throw error;
        }
    };
    ErrorHandler.prototype.constructError = function (msg, column) {
        var error = new Error(msg);
        try {
            throw error;
        }
        catch (base) {
            /* istanbul ignore else */
            if (Object.create && Object.defineProperty) {
                error = Object.create(base);
                Object.defineProperty(error, 'column', { value: column });
            }
        }
        /* istanbul ignore next */
        return error;
    };
    ErrorHandler.prototype.createError = function (index, line, col, description) {
        var msg = 'Line ' + line + ': ' + description;
        var error = this.constructError(msg, col);
        error.index = index;
        error.lineNumber = line;
        error.description = description;
        return error;
    };
    ErrorHandler.prototype.throwError = function (index, line, col, description) {
        throw this.createError(index, line, col, description);
    };
    ErrorHandler.prototype.tolerateError = function (index, line, col, description) {
        var error = this.createError(index, line, col, description);
        if (this.tolerant) {
            this.recordError(error);
        }
        else {
            throw error;
        }
    };
    return ErrorHandler;
}());
exports.ErrorHandler = ErrorHandler;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// Error messages should be identical to V8.
exports.Messages = {
    BadImportCallArity: 'Unexpected token',
    BadGetterArity: 'Getter must not have any formal parameters',
    BadSetterArity: 'Setter must have exactly one formal parameter',
    BadSetterRestParameter: 'Setter function argument must not be a rest parameter',
    ConstructorIsAsync: 'Class constructor may not be an async method',
    ConstructorSpecialMethod: 'Class constructor may not be an accessor',
    DeclarationMissingInitializer: 'Missing initializer in %0 declaration',
    DefaultRestParameter: 'Unexpected token =',
    DefaultRestProperty: 'Unexpected token =',
    DuplicateBinding: 'Duplicate binding %0',
    DuplicateConstructor: 'A class may only have one constructor',
    DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
    ForInOfLoopInitializer: '%0 loop variable declaration may not have an initializer',
    GeneratorInLegacyContext: 'Generator declarations are not allowed in legacy contexts',
    IllegalBreak: 'Illegal break statement',
    IllegalContinue: 'Illegal continue statement',
    IllegalExportDeclaration: 'Unexpected token',
    IllegalImportDeclaration: 'Unexpected token',
    IllegalLanguageModeDirective: 'Illegal \'use strict\' directive in function with non-simple parameter list',
    IllegalReturn: 'Illegal return statement',
    InvalidEscapedReservedWord: 'Keyword must not contain escaped characters',
    InvalidHexEscapeSequence: 'Invalid hexadecimal escape sequence',
    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
    InvalidLHSInForIn: 'Invalid left-hand side in for-in',
    InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
    InvalidModuleSpecifier: 'Unexpected token',
    InvalidRegExp: 'Invalid regular expression',
    LetInLexicalBinding: 'let is disallowed as a lexically bound name',
    MissingFromClause: 'Unexpected token',
    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
    NewlineAfterThrow: 'Illegal newline after throw',
    NoAsAfterImportNamespace: 'Unexpected token',
    NoCatchOrFinally: 'Missing catch or finally after try',
    ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
    PropertyAfterRestProperty: 'Unexpected token',
    Redeclaration: '%0 \'%1\' has already been declared',
    StaticPrototype: 'Classes may not have static property named prototype',
    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
    StrictDelete: 'Delete of an unqualified identifier in strict mode.',
    StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block',
    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
    StrictModeWith: 'Strict mode code may not include a with statement',
    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
    StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
    StrictReservedWord: 'Use of future reserved word in strict mode',
    StrictVarName: 'Variable name may not be eval or arguments in strict mode',
    TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
    UnexpectedEOS: 'Unexpected end of input',
    UnexpectedIdentifier: 'Unexpected identifier',
    UnexpectedNumber: 'Unexpected number',
    UnexpectedReserved: 'Unexpected reserved word',
    UnexpectedString: 'Unexpected string',
    UnexpectedTemplate: 'Unexpected quasi %0',
    UnexpectedToken: 'Unexpected token %0',
    UnexpectedTokenIllegal: 'Unexpected token ILLEGAL',
    UnknownLabel: 'Undefined label \'%0\'',
    UnterminatedRegExp: 'Invalid regular expression: missing /'
};


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var assert_1 = __webpack_require__(6);
var character_1 = __webpack_require__(2);
var messages_1 = __webpack_require__(8);
function hexValue(ch) {
    return '0123456789abcdef'.indexOf(ch.toLowerCase());
}
function octalValue(ch) {
    return '01234567'.indexOf(ch);
}
var Scanner = /** @class */ (function () {
    function Scanner(code, handler) {
        this.source = code;
        this.errorHandler = handler;
        this.trackComment = false;
        this.length = code.length;
        this.index = 0;
        this.lineNumber = (code.length > 0) ? 1 : 0;
        this.lineStart = 0;
        this.curlyStack = [];
    }
    Scanner.prototype.saveState = function () {
        return {
            index: this.index,
            lineNumber: this.lineNumber,
            lineStart: this.lineStart
        };
    };
    Scanner.prototype.restoreState = function (state) {
        this.index = state.index;
        this.lineNumber = state.lineNumber;
        this.lineStart = state.lineStart;
    };
    Scanner.prototype.eof = function () {
        return this.index >= this.length;
    };
    Scanner.prototype.throwUnexpectedToken = function (message) {
        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
        return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
    };
    Scanner.prototype.tolerateUnexpectedToken = function (message) {
        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
        this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
    };
    // https://tc39.github.io/ecma262/#sec-comments
    Scanner.prototype.skipSingleLineComment = function (offset) {
        var comments = [];
        var start, loc;
        if (this.trackComment) {
            comments = [];
            start = this.index - offset;
            loc = {
                start: {
                    line: this.lineNumber,
                    column: this.index - this.lineStart - offset
                },
                end: {}
            };
        }
        while (!this.eof()) {
            var ch = this.source.charCodeAt(this.index);
            ++this.index;
            if (character_1.Character.isLineTerminator(ch)) {
                if (this.trackComment) {
                    loc.end = {
                        line: this.lineNumber,
                        column: this.index - this.lineStart - 1
                    };
                    var entry = {
                        multiLine: false,
                        slice: [start + offset, this.index - 1],
                        range: [start, this.index - 1],
                        loc: loc
                    };
                    comments.push(entry);
                }
                if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                    ++this.index;
                }
                ++this.lineNumber;
                this.lineStart = this.index;
                return comments;
            }
        }
        if (this.trackComment) {
            loc.end = {
                line: this.lineNumber,
                column: this.index - this.lineStart
            };
            var entry = {
                multiLine: false,
                slice: [start + offset, this.index],
                range: [start, this.index],
                loc: loc
            };
            comments.push(entry);
        }
        return comments;
    };
    Scanner.prototype.skipMultiLineComment = function () {
        var comments = [];
        var start, loc;
        if (this.trackComment) {
            comments = [];
            start = this.index - 2;
            loc = {
                start: {
                    line: this.lineNumber,
                    column: this.index - this.lineStart - 2
                },
                end: {}
            };
        }
        while (!this.eof()) {
            var ch = this.source.charCodeAt(this.index);
            if (character_1.Character.isLineTerminator(ch)) {
                if (ch === 0x0D && this.source.charCodeAt(this.index + 1) === 0x0A) {
                    ++this.index;
                }
                ++this.lineNumber;
                ++this.index;
                this.lineStart = this.index;
            }
            else if (ch === 0x2A) {
                // Block comment ends with '*/'.
                if (this.source.charCodeAt(this.index + 1) === 0x2F) {
                    this.index += 2;
                    if (this.trackComment) {
                        loc.end = {
                            line: this.lineNumber,
                            column: this.index - this.lineStart
                        };
                        var entry = {
                            multiLine: true,
                            slice: [start + 2, this.index - 2],
                            range: [start, this.index],
                            loc: loc
                        };
                        comments.push(entry);
                    }
                    return comments;
                }
                ++this.index;
            }
            else {
                ++this.index;
            }
        }
        // Ran off the end of the file - the whole thing is a comment
        if (this.trackComment) {
            loc.end = {
                line: this.lineNumber,
                column: this.index - this.lineStart
            };
            var entry = {
                multiLine: true,
                slice: [start + 2, this.index],
                range: [start, this.index],
                loc: loc
            };
            comments.push(entry);
        }
        this.tolerateUnexpectedToken();
        return comments;
    };
    Scanner.prototype.scanComments = function () {
        var comments;
        if (this.trackComment) {
            comments = [];
        }
        var start = (this.index === 0);
        while (!this.eof()) {
            var ch = this.source.charCodeAt(this.index);
            if (character_1.Character.isWhiteSpace(ch)) {
                ++this.index;
            }
            else if (character_1.Character.isLineTerminator(ch)) {
                ++this.index;
                if (ch === 0x0D && this.source.charCodeAt(this.index) === 0x0A) {
                    ++this.index;
                }
                ++this.lineNumber;
                this.lineStart = this.index;
                start = true;
            }
            else if (ch === 0x2F) {
                ch = this.source.charCodeAt(this.index + 1);
                if (ch === 0x2F) {
                    this.index += 2;
                    var comment = this.skipSingleLineComment(2);
                    if (this.trackComment) {
                        comments = comments.concat(comment);
                    }
                    start = true;
                }
                else if (ch === 0x2A) {
                    this.index += 2;
                    var comment = this.skipMultiLineComment();
                    if (this.trackComment) {
                        comments = comments.concat(comment);
                    }
                }
                else {
                    break;
                }
            }
            else if (start && ch === 0x2D) {
                // U+003E is '>'
                if ((this.source.charCodeAt(this.index + 1) === 0x2D) && (this.source.charCodeAt(this.index + 2) === 0x3E)) {
                    // '-->' is a single-line comment
                    this.index += 3;
                    var comment = this.skipSingleLineComment(3);
                    if (this.trackComment) {
                        comments = comments.concat(comment);
                    }
                }
                else {
                    break;
                }
            }
            else if (ch === 0x3C) {
                if (this.source.slice(this.index + 1, this.index + 4) === '!--') {
                    this.index += 4; // `<!--`
                    var comment = this.skipSingleLineComment(4);
                    if (this.trackComment) {
                        comments = comments.concat(comment);
                    }
                }
                else {
                    break;
                }
            }
            else {
                break;
            }
        }
        return comments;
    };
    // https://tc39.github.io/ecma262/#sec-future-reserved-words
    Scanner.prototype.isFutureReservedWord = function (id) {
        switch (id) {
            case 'enum':
            case 'export':
            case 'import':
            case 'super':
                return true;
            default:
                return false;
        }
    };
    Scanner.prototype.isStrictModeReservedWord = function (id) {
        switch (id) {
            case 'implements':
            case 'interface':
            case 'package':
            case 'private':
            case 'protected':
            case 'public':
            case 'static':
            case 'yield':
            case 'let':
                return true;
            default:
                return false;
        }
    };
    Scanner.prototype.isRestrictedWord = function (id) {
        return id === 'eval' || id === 'arguments';
    };
    // https://tc39.github.io/ecma262/#sec-keywords
    Scanner.prototype.isKeyword = function (id) {
        switch (id.length) {
            case 2:
                return (id === 'if') || (id === 'in') || (id === 'do');
            case 3:
                return (id === 'var') || (id === 'for') || (id === 'new') ||
                    (id === 'try') || (id === 'let');
            case 4:
                return (id === 'this') || (id === 'else') || (id === 'case') ||
                    (id === 'void') || (id === 'with') || (id === 'enum');
            case 5:
                return (id === 'while') || (id === 'break') || (id === 'catch') ||
                    (id === 'throw') || (id === 'const') || (id === 'yield') ||
                    (id === 'class') || (id === 'super');
            case 6:
                return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                    (id === 'switch') || (id === 'export') || (id === 'import');
            case 7:
                return (id === 'default') || (id === 'finally') || (id === 'extends');
            case 8:
                return (id === 'function') || (id === 'continue') || (id === 'debugger');
            case 10:
                return (id === 'instanceof');
            default:
                return false;
        }
    };
    Scanner.prototype.codePointAt = function (i) {
        var cp = this.source.charCodeAt(i);
        if (cp >= 0xD800 && cp <= 0xDBFF) {
            var second = this.source.charCodeAt(i + 1);
            if (second >= 0xDC00 && second <= 0xDFFF) {
                var first = cp;
                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
            }
        }
        return cp;
    };
    Scanner.prototype.scanHexEscape = function (prefix) {
        var len = (prefix === 'u') ? 4 : 2;
        var code = 0;
        for (var i = 0; i < len; ++i) {
            if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                code = code * 16 + hexValue(this.source[this.index++]);
            }
            else {
                return null;
            }
        }
        return String.fromCharCode(code);
    };
    Scanner.prototype.scanUnicodeCodePointEscape = function () {
        var ch = this.source[this.index];
        var code = 0;
        // At least, one hex digit is required.
        if (ch === '}') {
            this.throwUnexpectedToken();
        }
        while (!this.eof()) {
            ch = this.source[this.index++];
            if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
                break;
            }
            code = code * 16 + hexValue(ch);
        }
        if (code > 0x10FFFF || ch !== '}') {
            this.throwUnexpectedToken();
        }
        return character_1.Character.fromCodePoint(code);
    };
    Scanner.prototype.getIdentifier = function () {
        var start = this.index;
        this.index++;
        while (!this.eof()) {
            var ch = this.source.charCodeAt(this.index);
            if (ch === 0x5C) {
                // Blackslash (U+005C) marks Unicode escape sequence.
                this.index = start;
                return this.getComplexIdentifier();
            }
            else if (ch >= 0xD800 && ch < 0xDFFF) {
                // Need to handle surrogate pairs.
                this.index = start;
                return this.getComplexIdentifier();
            }
            if (character_1.Character.isIdentifierPart(ch)) {
                ++this.index;
            }
            else if ((ch === 0x23 || ch === 0x40) &&
                character_1.Character.isIdentifierPart(this.source.charCodeAt(this.index - 1))) {
                // # and @ at end of identifier name  (JISON action variables contain these, e.g. `@1` or `#LABEL#`)
                //
                // Note that these characters may only occur at the START or END of an identifier
                // AND these cannot occur on their own but must be a prefix or postfix of a
                // larger identifier, e.g. `@1`, `@label1`, `#3`, `#loc`, `#id#`
                ++this.index;
                break;
            }
            else {
                break;
            }
        }
        return this.source.slice(start, this.index);
    };
    Scanner.prototype.getComplexIdentifier = function () {
        var cp = this.codePointAt(this.index);
        var id = character_1.Character.fromCodePoint(cp);
        this.index += id.length;
        // '\u' (U+005C, U+0075) denotes an escaped character.
        var ch;
        if (cp === 0x5C) {
            if (this.source.charCodeAt(this.index) !== 0x75) {
                this.throwUnexpectedToken();
            }
            ++this.index;
            if (this.source[this.index] === '{') {
                ++this.index;
                ch = this.scanUnicodeCodePointEscape();
            }
            else {
                ch = this.scanHexEscape('u');
                if (ch === null || ch === '\\' || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
                    this.throwUnexpectedToken();
                }
            }
            id = ch;
        }
        while (!this.eof()) {
            cp = this.codePointAt(this.index);
            if (!character_1.Character.isIdentifierPart(cp) &&
                // # and @  (JISON action variables contain these, e.g. `@1` or `#LABEL#`)
                cp !== 0x23 && cp !== 0x40) {
                break;
            }
            ch = character_1.Character.fromCodePoint(cp);
            id += ch;
            this.index += ch.length;
            // '\u' (U+005C, U+0075) denotes an escaped character.
            if (cp === 0x5C) {
                id = id.substr(0, id.length - 1);
                if (this.source.charCodeAt(this.index) !== 0x75) {
                    this.throwUnexpectedToken();
                }
                ++this.index;
                if (this.source[this.index] === '{') {
                    ++this.index;
                    ch = this.scanUnicodeCodePointEscape();
                }
                else {
                    ch = this.scanHexEscape('u');
                    if (ch === null || ch === '\\' || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                        this.throwUnexpectedToken();
                    }
                }
                id += ch;
            }
        }
        return id;
    };
    Scanner.prototype.octalToDecimal = function (ch) {
        // \0 is not octal escape sequence
        var octal = (ch !== '0');
        var code = octalValue(ch);
        if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
            octal = true;
            code = code * 8 + octalValue(this.source[this.index++]);
            // 3 digits are only allowed when string starts
            // with 0, 1, 2, 3
            if ('0123'.indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                code = code * 8 + octalValue(this.source[this.index++]);
            }
        }
        return {
            code: code,
            octal: octal
        };
    };
    // https://tc39.github.io/ecma262/#sec-names-and-keywords
    Scanner.prototype.scanIdentifier = function (start) {
        var type;
        var partStart = this.index;
        // Backslash (U+005C) starts an escaped character.
        var id = ((this.source.charCodeAt(partStart) === 0x5C) ? this.getComplexIdentifier() : this.getIdentifier());
        if (partStart > start) {
            id = this.source.slice(start, partStart) + id;
        }
        // There is no keyword or literal with only one character.
        // Thus, it must be an identifier.
        if (id.length === 1) {
            type = 3 /* Identifier */;
        }
        else if (this.isKeyword(id)) {
            type = 4 /* Keyword */;
        }
        else if (id === 'null') {
            type = 5 /* NullLiteral */;
        }
        else if (id === 'true' || id === 'false') {
            type = 1 /* BooleanLiteral */;
        }
        else {
            type = 3 /* Identifier */;
        }
        if (type !== 3 /* Identifier */ && (start + id.length !== this.index)) {
            var restore = this.index;
            this.index = start;
            this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
            this.index = restore;
        }
        return {
            type: type,
            value: id,
            lineNumber: this.lineNumber,
            lineStart: this.lineStart,
            start: start,
            end: this.index
        };
    };
    // https://tc39.github.io/ecma262/#sec-punctuators
    Scanner.prototype.scanPunctuator = function () {
        var start = this.index;
        // Check for most common single-character punctuators.
        var str = this.source[this.index];
        switch (str) {
            case '(':
            case '{':
                if (str === '{') {
                    this.curlyStack.push('{');
                }
                ++this.index;
                break;
            case '.':
                ++this.index;
                if (this.source[this.index] === '.' && this.source[this.index + 1] === '.') {
                    // Spread operator: ...
                    this.index += 2;
                    str = '...';
                }
                break;
            case '}':
                ++this.index;
                this.curlyStack.pop();
                break;
            case ')':
            case ';':
            case ',':
            case '[':
            case ']':
            case ':':
            case '?':
            case '~':
                ++this.index;
                break;
            default:
                // 4-character punctuator.
                str = this.source.substr(this.index, 4);
                if (str === '>>>=') {
                    this.index += 4;
                }
                else {
                    // 3-character punctuators.
                    str = str.substr(0, 3);
                    if (str === '===' || str === '!==' || str === '>>>' ||
                        str === '<<=' || str === '>>=' || str === '**=') {
                        this.index += 3;
                    }
                    else {
                        // 2-character punctuators.
                        str = str.substr(0, 2);
                        if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
                            str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
                            str === '++' || str === '--' || str === '<<' || str === '>>' ||
                            str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
                            str === '<=' || str === '>=' || str === '=>' || str === '**') {
                            this.index += 2;
                        }
                        else {
                            // 1-character punctuators.
                            str = this.source[this.index];
                            if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
                                ++this.index;
                            }
                        }
                    }
                }
        }
        if (this.index === start) {
            this.throwUnexpectedToken();
        }
        return {
            type: 7 /* Punctuator */,
            value: str,
            lineNumber: this.lineNumber,
            lineStart: this.lineStart,
            start: start,
            end: this.index
        };
    };
    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
    Scanner.prototype.scanHexLiteral = function (start) {
        var num = '';
        while (!this.eof()) {
            if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                break;
            }
            num += this.source[this.index++];
        }
        if (num.length === 0) {
            this.throwUnexpectedToken();
        }
        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
            this.throwUnexpectedToken();
        }
        return {
            type: 6 /* NumericLiteral */,
            value: parseInt('0x' + num, 16),
            lineNumber: this.lineNumber,
            lineStart: this.lineStart,
            start: start,
            end: this.index
        };
    };
    Scanner.prototype.scanBinaryLiteral = function (start) {
        var num = '';
        var ch;
        while (!this.eof()) {
            ch = this.source[this.index];
            if (ch !== '0' && ch !== '1') {
                break;
            }
            num += this.source[this.index++];
        }
        if (num.length === 0) {
            // only 0b or 0B
            this.throwUnexpectedToken();
        }
        if (!this.eof()) {
            ch = this.source.charCodeAt(this.index);
            /* istanbul ignore else */
            if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
                this.throwUnexpectedToken();
            }
        }
        return {
            type: 6 /* NumericLiteral */,
            value: parseInt(num, 2),
            lineNumber: this.lineNumber,
            lineStart: this.lineStart,
            start: start,
            end: this.index
        };
    };
    Scanner.prototype.scanOctalLiteral = function (prefix, start) {
        var num = '';
        var octal = false;
        if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
            octal = true;
            num = '0' + this.source[this.index++];
        }
        else {
            ++this.index;
        }
        while (!this.eof()) {
            if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                break;
            }
            num += this.source[this.index++];
        }
        if (!octal && num.length === 0) {
            // only 0o or 0O
            this.throwUnexpectedToken();
        }
        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
            this.throwUnexpectedToken();
        }
        return {
            type: 6 /* NumericLiteral */,
            value: parseInt(num, 8),
            octal: octal,
            lineNumber: this.lineNumber,
            lineStart: this.lineStart,
            start: start,
            end: this.index
        };
    };
    Scanner.prototype.isImplicitOctalLiteral = function () {
        // Implicit octal, unless there is a non-octal digit.
        // (Annex B.1.1 on Numeric Literals)
        for (var i = this.index + 1; i < this.length; ++i) {
            var ch = this.source[i];
            if (ch === '8' || ch === '9') {
                return false;
            }
            if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                return true;
            }
        }
        return true;
    };
    Scanner.prototype.scanNumericLiteral = function () {
        var start = this.index;
        var ch = this.source[start];
        assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'), 'Numeric literal must start with a decimal digit or a decimal point');
        var num = '';
        if (ch !== '.') {
            num = this.source[this.index++];
            ch = this.source[this.index];
            // Hex number starts with '0x'.
            // Octal number starts with '0'.
            // Octal number in ES6 starts with '0o'.
            // Binary number in ES6 starts with '0b'.
            if (num === '0') {
                if (ch === 'x' || ch === 'X') {
                    ++this.index;
                    return this.scanHexLiteral(start);
                }
                if (ch === 'b' || ch === 'B') {
                    ++this.index;
                    return this.scanBinaryLiteral(start);
                }
                if (ch === 'o' || ch === 'O') {
                    return this.scanOctalLiteral(ch, start);
                }
                if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                    if (this.isImplicitOctalLiteral()) {
                        return this.scanOctalLiteral(ch, start);
                    }
                }
            }
            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                num += this.source[this.index++];
            }
            ch = this.source[this.index];
        }
        if (ch === '.') {
            num += this.source[this.index++];
            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                num += this.source[this.index++];
            }
            ch = this.source[this.index];
        }
        if (ch === 'e' || ch === 'E') {
            num += this.source[this.index++];
            ch = this.source[this.index];
            if (ch === '+' || ch === '-') {
                num += this.source[this.index++];
            }
            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                    num += this.source[this.index++];
                }
            }
            else {
                this.throwUnexpectedToken();
            }
        }
        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
            this.throwUnexpectedToken();
        }
        return {
            type: 6 /* NumericLiteral */,
            value: parseFloat(num),
            lineNumber: this.lineNumber,
            lineStart: this.lineStart,
            start: start,
            end: this.index
        };
    };
    // https://tc39.github.io/ecma262/#sec-literals-string-literals
    Scanner.prototype.scanStringLiteral = function () {
        var start = this.index;
        var quote = this.source[start];
        assert_1.assert((quote === '\'' || quote === '"'), 'String literal must starts with a quote');
        ++this.index;
        var octal = false;
        var str = '';
        while (!this.eof()) {
            var ch = this.source[this.index++];
            if (ch === quote) {
                quote = '';
                break;
            }
            else if (ch === '\\') {
                ch = this.source[this.index++];
                if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                        case 'u':
                            if (this.source[this.index] === '{') {
                                ++this.index;
                                str += this.scanUnicodeCodePointEscape();
                            }
                            else {
                                var unescaped1 = this.scanHexEscape(ch);
                                if (unescaped1 === null) {
                                    this.throwUnexpectedToken();
                                }
                                str += unescaped1;
                            }
                            break;
                        case 'x':
                            var unescaped2 = this.scanHexEscape(ch);
                            if (unescaped2 === null) {
                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                            }
                            str += unescaped2;
                            break;
                        case 'n':
                            str += '\n';
                            break;
                        case 'r':
                            str += '\r';
                            break;
                        case 't':
                            str += '\t';
                            break;
                        case 'b':
                            str += '\b';
                            break;
                        case 'f':
                            str += '\f';
                            break;
                        case 'v':
                            str += '\x0B';
                            break;
                        case '8':
                        case '9':
                            str += ch;
                            this.tolerateUnexpectedToken();
                            break;
                        default:
                            if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                                var octToDec = this.octalToDecimal(ch);
                                octal = octToDec.octal || octal;
                                str += String.fromCharCode(octToDec.code);
                            }
                            else {
                                str += ch;
                            }
                            break;
                    }
                }
                else {
                    ++this.lineNumber;
                    if (ch === '\r' && this.source[this.index] === '\n') {
                        ++this.index;
                    }
                    this.lineStart = this.index;
                }
            }
            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                break;
            }
            else {
                str += ch;
            }
        }
        if (quote !== '') {
            this.index = start;
            this.throwUnexpectedToken();
        }
        return {
            type: 8 /* StringLiteral */,
            value: str,
            octal: octal,
            lineNumber: this.lineNumber,
            lineStart: this.lineStart,
            start: start,
            end: this.index
        };
    };
    // https://tc39.github.io/ecma262/#sec-template-literal-lexical-components
    Scanner.prototype.scanTemplate = function () {
        var cooked = '';
        var terminated = false;
        var start = this.index;
        var head = (this.source[start] === '`');
        var tail = false;
        var rawOffset = 2;
        ++this.index;
        while (!this.eof()) {
            var ch = this.source[this.index++];
            if (ch === '`') {
                rawOffset = 1;
                tail = true;
                terminated = true;
                break;
            }
            else if (ch === '$') {
                if (this.source[this.index] === '{') {
                    this.curlyStack.push('${');
                    ++this.index;
                    terminated = true;
                    break;
                }
                cooked += ch;
            }
            else if (ch === '\\') {
                ch = this.source[this.index++];
                if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                        case 'n':
                            cooked += '\n';
                            break;
                        case 'r':
                            cooked += '\r';
                            break;
                        case 't':
                            cooked += '\t';
                            break;
                        case 'u':
                            if (this.source[this.index] === '{') {
                                ++this.index;
                                cooked += this.scanUnicodeCodePointEscape();
                            }
                            else {
                                var restore = this.index;
                                var unescaped1 = this.scanHexEscape(ch);
                                if (unescaped1 !== null) {
                                    cooked += unescaped1;
                                }
                                else {
                                    this.index = restore;
                                    cooked += ch;
                                }
                            }
                            break;
                        case 'x':
                            var unescaped2 = this.scanHexEscape(ch);
                            if (unescaped2 === null) {
                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                            }
                            cooked += unescaped2;
                            break;
                        case 'b':
                            cooked += '\b';
                            break;
                        case 'f':
                            cooked += '\f';
                            break;
                        case 'v':
                            cooked += '\v';
                            break;
                        default:
                            if (ch === '0') {
                                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                                    // Illegal: \01 \02 and so on
                                    this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                                }
                                cooked += '\0';
                            }
                            else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                                // Illegal: \1 \2
                                this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                            }
                            else {
                                cooked += ch;
                            }
                            break;
                    }
                }
                else {
                    ++this.lineNumber;
                    if (ch === '\r' && this.source[this.index] === '\n') {
                        ++this.index;
                    }
                    this.lineStart = this.index;
                }
            }
            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                ++this.lineNumber;
                if (ch === '\r' && this.source[this.index] === '\n') {
                    ++this.index;
                }
                this.lineStart = this.index;
                cooked += '\n';
            }
            else {
                cooked += ch;
            }
        }
        if (!terminated) {
            this.throwUnexpectedToken();
        }
        if (!head) {
            this.curlyStack.pop();
        }
        return {
            type: 10 /* Template */,
            value: this.source.slice(start + 1, this.index - rawOffset),
            cooked: cooked,
            head: head,
            tail: tail,
            lineNumber: this.lineNumber,
            lineStart: this.lineStart,
            start: start,
            end: this.index
        };
    };
    // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
    Scanner.prototype.testRegExp = function (pattern, flags) {
        // The BMP character to use as a replacement for astral symbols when
        // translating an ES6 "u"-flagged pattern to an ES5-compatible
        // approximation.
        // Note: replacing with '\uFFFF' enables false positives in unlikely
        // scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
        // pattern that would not be detected by this substitution.
        var astralSubstitute = '\uFFFF';
        var tmp = pattern;
        var self = this;
        if (flags.indexOf('u') >= 0) {
            tmp = tmp
                .replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
                var codePoint = parseInt($1 || $2, 16);
                if (codePoint > 0x10FFFF) {
                    self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
                }
                if (codePoint <= 0xFFFF) {
                    return String.fromCharCode(codePoint);
                }
                return astralSubstitute;
            })
                .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
        }
        // First, detect invalid regular expressions.
        try {
            RegExp(tmp);
        }
        catch (e) {
            this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
        }
        // Return a regular expression object for this pattern-flag pair, or
        // `null` in case the current environment doesn't support the flags it
        // uses.
        try {
            return new RegExp(pattern, flags);
        }
        catch (exception) {
            /* istanbul ignore next */
            return null;
        }
    };
    Scanner.prototype.scanRegExpBody = function () {
        var ch = this.source[this.index];
        assert_1.assert(ch === '/', 'Regular expression literal must start with a slash');
        var str = this.source[this.index++];
        var classMarker = false;
        var terminated = false;
        while (!this.eof()) {
            ch = this.source[this.index++];
            str += ch;
            if (ch === '\\') {
                ch = this.source[this.index++];
                // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
                if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                }
                str += ch;
            }
            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
            }
            else if (classMarker) {
                if (ch === ']') {
                    classMarker = false;
                }
            }
            else {
                if (ch === '/') {
                    terminated = true;
                    break;
                }
                else if (ch === '[') {
                    classMarker = true;
                }
            }
        }
        if (!terminated) {
            this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
        }
        // Exclude leading and trailing slash.
        return str.substr(1, str.length - 2);
    };
    Scanner.prototype.scanRegExpFlags = function () {
        var str = '';
        var flags = '';
        while (!this.eof()) {
            var ch = this.source[this.index];
            if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                break;
            }
            ++this.index;
            if (ch === '\\' && !this.eof()) {
                ch = this.source[this.index];
                if (ch === 'u') {
                    ++this.index;
                    var restore = this.index;
                    var char = this.scanHexEscape('u');
                    if (char !== null) {
                        flags += char;
                        for (str += '\\u'; restore < this.index; ++restore) {
                            str += this.source[restore];
                        }
                    }
                    else {
                        this.index = restore;
                        flags += 'u';
                        str += '\\u';
                    }
                    this.tolerateUnexpectedToken();
                }
                else {
                    str += '\\';
                    this.tolerateUnexpectedToken();
                }
            }
            else {
                flags += ch;
                str += ch;
            }
        }
        return flags;
    };
    Scanner.prototype.scanRegExp = function () {
        var start = this.index;
        var pattern = this.scanRegExpBody();
        var flags = this.scanRegExpFlags();
        var value = this.testRegExp(pattern, flags);
        return {
            type: 9 /* RegularExpression */,
            value: '',
            pattern: pattern,
            flags: flags,
            regex: value,
            lineNumber: this.lineNumber,
            lineStart: this.lineStart,
            start: start,
            end: this.index
        };
    };
    Scanner.prototype.lex = function () {
        if (this.eof()) {
            return {
                type: 2 /* EOF */,
                value: '',
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start: this.index,
                end: this.index
            };
        }
        var cp = this.source.charCodeAt(this.index);
        if (character_1.Character.isIdentifierStart(cp)) {
            return this.scanIdentifier(this.index);
        }
        else if (cp === 0x23 || cp === 0x40) {
            //
            // # and @  (JISON action variables contain these, e.g. `@1` or `#LABEL#`)
            //
            // Note that these characters may only occur at the START or END of an identifier
            // AND these cannot occur on their own but must be a prefix or postfix of a
            // larger identifier, e.g. `@1`, `@label1`, `#3`, `#loc`, `#id#`
            //
            var start = this.index;
            var cpNext = this.source.charCodeAt(this.index + 1);
            if (character_1.Character.isIdentifierPart(cpNext)) {
                this.index += 1;
                return this.scanIdentifier(start);
            }
            else if (cpNext === 0x23 || cpNext === 0x40) {
                //
                // ## and @@  (JISON action variables contain these, e.g. `@@1` or `##INDEX`)
                //
                // Note that these characters may only occur at the START of an identifier
                // AND these cannot occur on their own but must be a prefix of a
                // larger identifier, e.g. `@@1`, `@@label1`, `##3`, `##loc`, `##id`
                //
                var cpNextNext = this.source.charCodeAt(this.index + 2);
                if (character_1.Character.isIdentifierPart(cpNextNext)) {
                    this.index += 2;
                    return this.scanIdentifier(start);
                }
                else if (cpNextNext === 0x2D) {
                    // negative reference index variable, e.g. `@@-1`:
                    var cpN3 = this.source.charCodeAt(this.index + 3);
                    if (character_1.Character.isDecimalDigit(cpN3)) {
                        this.index += 3;
                        return this.scanIdentifier(start);
                    }
                }
            }
            else if (cpNext === 0x2D) {
                // negative reference index variable, e.g. `@-1`:
                var cpN2 = this.source.charCodeAt(this.index + 2);
                if (character_1.Character.isDecimalDigit(cpN2)) {
                    this.index += 2;
                    return this.scanIdentifier(start);
                }
            }
        }
        // Very common: ( and ) and ;
        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
            return this.scanPunctuator();
        }
        // String literal starts with single quote (U+0027) or double quote (U+0022).
        if (cp === 0x27 || cp === 0x22) {
            return this.scanStringLiteral();
        }
        // Dot (.) U+002E can also start a floating-point number, hence the need
        // to check the next character.
        if (cp === 0x2E) {
            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
                return this.scanNumericLiteral();
            }
            return this.scanPunctuator();
        }
        if (character_1.Character.isDecimalDigit(cp)) {
            return this.scanNumericLiteral();
        }
        // Template literals start with ` (U+0060) for template head
        // or } (U+007D) for template middle or template tail.
        if (cp === 0x60 || (cp === 0x7D && this.curlyStack[this.curlyStack.length - 1] === '${')) {
            return this.scanTemplate();
        }
        // Possible identifier start in a surrogate pair.
        if (cp >= 0xD800 && cp < 0xDFFF) {
            if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
                return this.scanIdentifier(this.index);
            }
        }
        return this.scanPunctuator();
    };
    return Scanner;
}());
exports.Scanner = Scanner;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
  Copyright JS Foundation and other contributors, https://js.foundation/

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
Object.defineProperty(exports, "__esModule", { value: true });
var comment_handler_1 = __webpack_require__(11);
var jsx_parser_1 = __webpack_require__(12);
var parser_1 = __webpack_require__(5);
var tokenizer_1 = __webpack_require__(15);
function parse(code, options, delegate) {
    var commentHandler = null;
    var proxyDelegate = function (node, metadata) {
        if (delegate) {
            delegate(node, metadata);
        }
        if (commentHandler) {
            commentHandler.visit(node, metadata);
        }
    };
    var parserDelegate = (typeof delegate === 'function') ? proxyDelegate : null;
    var collectComment = false;
    if (options) {
        collectComment = (typeof options.comment === 'boolean' && options.comment);
        var attachComment = (typeof options.attachComment === 'boolean' && options.attachComment);
        if (collectComment || attachComment) {
            commentHandler = new comment_handler_1.CommentHandler();
            commentHandler.attach = attachComment;
            options.comment = true;
            parserDelegate = proxyDelegate;
        }
    }
    var isModule = false;
    if (options && typeof options.sourceType === 'string') {
        isModule = (options.sourceType === 'module');
    }
    var parser;
    if (options && typeof options.jsx === 'boolean' && options.jsx) {
        parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
    }
    else {
        parser = new parser_1.Parser(code, options, parserDelegate);
    }
    var program = isModule ? parser.parseModule() : parser.parseScript();
    var ast = program;
    if (collectComment && commentHandler) {
        ast.comments = commentHandler.comments;
    }
    if (parser.config.tokens) {
        ast.tokens = parser.tokens;
    }
    if (parser.config.tolerant) {
        ast.errors = parser.errorHandler.errors;
    }
    return ast;
}
exports.parse = parse;
function parseModule(code, options, delegate) {
    var parsingOptions = options || {};
    parsingOptions.sourceType = 'module';
    return parse(code, parsingOptions, delegate);
}
exports.parseModule = parseModule;
function parseScript(code, options, delegate) {
    var parsingOptions = options || {};
    parsingOptions.sourceType = 'script';
    return parse(code, parsingOptions, delegate);
}
exports.parseScript = parseScript;
function tokenize(code, options, delegate) {
    var tokenizer = new tokenizer_1.Tokenizer(code, options);
    var tokens;
    tokens = [];
    try {
        while (true) {
            var token = tokenizer.getNextToken();
            if (!token) {
                break;
            }
            if (delegate) {
                token = delegate(token);
            }
            tokens.push(token);
        }
    }
    catch (e) {
        tokenizer.errorHandler.tolerate(e);
    }
    if (tokenizer.errorHandler.tolerant) {
        tokens.errors = tokenizer.errors();
    }
    return tokens;
}
exports.tokenize = tokenize;
var syntax_1 = __webpack_require__(0);
exports.Syntax = syntax_1.Syntax;
// Sync with *.json manifests.
exports.version = '4.0.1-13';


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var syntax_1 = __webpack_require__(0);
var CommentHandler = /** @class */ (function () {
    function CommentHandler() {
        this.attach = false;
        this.comments = [];
        this.stack = [];
        this.leading = [];
        this.trailing = [];
    }
    CommentHandler.prototype.insertInnerComments = function (node, metadata) {
        //  innnerComments for properties empty block
        //  `function a() {/** comments **\/}`
        if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
            var innerComments = [];
            for (var i = this.leading.length - 1; i >= 0; --i) {
                var entry = this.leading[i];
                if (metadata.end.offset >= entry.start) {
                    innerComments.unshift(entry.comment);
                    this.leading.splice(i, 1);
                    this.trailing.splice(i, 1);
                }
            }
            if (innerComments.length) {
                node.innerComments = innerComments;
            }
        }
    };
    CommentHandler.prototype.findTrailingComments = function (metadata) {
        var trailingComments = [];
        if (this.trailing.length > 0) {
            for (var i = this.trailing.length - 1; i >= 0; --i) {
                var trailEntry = this.trailing[i];
                if (trailEntry.start >= metadata.end.offset) {
                    trailingComments.unshift(trailEntry.comment);
                }
            }
            this.trailing.length = 0;
            return trailingComments;
        }
        var entry = this.stack[this.stack.length - 1];
        if (entry && entry.node.trailingComments) {
            var firstComment = entry.node.trailingComments[0];
            if (firstComment && firstComment.range[0] >= metadata.end.offset) {
                trailingComments = entry.node.trailingComments;
                delete entry.node.trailingComments;
            }
        }
        return trailingComments;
    };
    CommentHandler.prototype.findLeadingComments = function (metadata) {
        var leadingComments = [];
        var target;
        while (this.stack.length > 0) {
            var entry = this.stack[this.stack.length - 1];
            if (entry && entry.start >= metadata.start.offset) {
                target = entry.node;
                this.stack.pop();
            }
            else {
                break;
            }
        }
        if (target) {
            var count = target.leadingComments ? target.leadingComments.length : 0;
            for (var i = count - 1; i >= 0; --i) {
                var comment = target.leadingComments[i];
                if (comment.range[1] <= metadata.start.offset) {
                    leadingComments.unshift(comment);
                    target.leadingComments.splice(i, 1);
                }
            }
            if (target.leadingComments && target.leadingComments.length === 0) {
                delete target.leadingComments;
            }
            return leadingComments;
        }
        for (var i = this.leading.length - 1; i >= 0; --i) {
            var leadEntry = this.leading[i];
            if (leadEntry.start <= metadata.start.offset) {
                leadingComments.unshift(leadEntry.comment);
                this.leading.splice(i, 1);
            }
        }
        return leadingComments;
    };
    CommentHandler.prototype.visitNode = function (node, metadata) {
        if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
            return;
        }
        this.insertInnerComments(node, metadata);
        var trailingComments = this.findTrailingComments(metadata);
        var leadingComments = this.findLeadingComments(metadata);
        if (leadingComments.length > 0) {
            node.leadingComments = leadingComments;
        }
        if (trailingComments.length > 0) {
            node.trailingComments = trailingComments;
        }
        this.stack.push({
            node: node,
            start: metadata.start.offset
        });
    };
    CommentHandler.prototype.visitComment = function (node, metadata) {
        var type = (node.type[0] === 'L') ? 'Line' : 'Block';
        var comment = {
            type: type,
            value: node.value
        };
        if (node.range) {
            comment.range = node.range;
        }
        if (node.loc) {
            comment.loc = node.loc;
        }
        this.comments.push(comment);
        if (this.attach) {
            var entry = {
                comment: {
                    type: type,
                    value: node.value,
                    range: [metadata.start.offset, metadata.end.offset]
                },
                start: metadata.start.offset
            };
            if (node.loc) {
                entry.comment.loc = node.loc;
            }
            node.type = type;
            this.leading.push(entry);
            this.trailing.push(entry);
        }
    };
    CommentHandler.prototype.visit = function (node, metadata) {
        if (node.type === 'LineComment') {
            this.visitComment(node, metadata);
        }
        else if (node.type === 'BlockComment') {
            this.visitComment(node, metadata);
        }
        else if (this.attach) {
            this.visitNode(node, metadata);
        }
    };
    return CommentHandler;
}());
exports.CommentHandler = CommentHandler;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* istanbul ignore next */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var character_1 = __webpack_require__(2);
var JSXNode = __webpack_require__(13);
var jsx_syntax_1 = __webpack_require__(3);
var Node = __webpack_require__(4);
var parser_1 = __webpack_require__(5);
var token_1 = __webpack_require__(1);
var xhtml_entities_1 = __webpack_require__(14);
token_1.TokenName[100 /* Identifier */] = 'JSXIdentifier';
token_1.TokenName[101 /* Text */] = 'JSXText';
// Fully qualified element name, e.g. <svg:path> returns "svg:path"
function getQualifiedElementName(elementName) {
    var qualifiedName;
    switch (elementName.type) {
        case jsx_syntax_1.JSXSyntax.JSXIdentifier:
            var id = elementName;
            qualifiedName = id.name;
            break;
        case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
            var ns = elementName;
            qualifiedName = getQualifiedElementName(ns.namespace) + ':' +
                getQualifiedElementName(ns.name);
            break;
        case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
            var expr = elementName;
            qualifiedName = getQualifiedElementName(expr.object) + '.' +
                getQualifiedElementName(expr.property);
            break;
        /* istanbul ignore next */
        default:
            break;
    }
    return qualifiedName;
}
var JSXParser = /** @class */ (function (_super) {
    __extends(JSXParser, _super);
    function JSXParser(code, options, delegate) {
        return _super.call(this, code, options, delegate) || this;
    }
    JSXParser.prototype.parsePrimaryExpression = function () {
        return this.match('<') ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
    };
    JSXParser.prototype.startJSX = function () {
        // Unwind the scanner before the lookahead token.
        this.scanner.index = this.startMarker.index;
        this.scanner.lineNumber = this.startMarker.line;
        this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
    };
    JSXParser.prototype.finishJSX = function () {
        // Prime the next lookahead.
        this.nextToken();
    };
    JSXParser.prototype.reenterJSX = function () {
        this.startJSX();
        this.expectJSX('}');
        // Pop the closing '}' added from the lookahead.
        if (this.config.tokens) {
            this.tokens.pop();
        }
    };
    JSXParser.prototype.createJSXNode = function () {
        this.collectComments();
        return {
            index: this.scanner.index,
            line: this.scanner.lineNumber,
            column: this.scanner.index - this.scanner.lineStart
        };
    };
    JSXParser.prototype.createJSXChildNode = function () {
        return {
            index: this.scanner.index,
            line: this.scanner.lineNumber,
            column: this.scanner.index - this.scanner.lineStart
        };
    };
    JSXParser.prototype.scanXHTMLEntity = function (quote) {
        var result = '&';
        var valid = true;
        var terminated = false;
        var numeric = false;
        var hex = false;
        while (!this.scanner.eof() && valid && !terminated) {
            var ch = this.scanner.source[this.scanner.index];
            if (ch === quote) {
                break;
            }
            terminated = (ch === ';');
            result += ch;
            ++this.scanner.index;
            if (!terminated) {
                switch (result.length) {
                    case 2:
                        // e.g. '&#123;'
                        numeric = (ch === '#');
                        break;
                    case 3:
                        if (numeric) {
                            // e.g. '&#x41;'
                            hex = (ch === 'x');
                            valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
                            numeric = numeric && !hex;
                        }
                        break;
                    default:
                        valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
                        valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
                        break;
                }
            }
        }
        if (valid && terminated && result.length > 2) {
            // e.g. '&#x41;' becomes just '#x41'
            var str = result.substr(1, result.length - 2);
            if (numeric && str.length > 1) {
                result = String.fromCharCode(parseInt(str.substr(1), 10));
            }
            else if (hex && str.length > 2) {
                result = String.fromCharCode(parseInt('0' + str.substr(1), 16));
            }
            else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
                result = xhtml_entities_1.XHTMLEntities[str];
            }
        }
        return result;
    };
    // Scan the next JSX token. This replaces Scanner#lex when in JSX mode.
    JSXParser.prototype.lexJSX = function () {
        var cp = this.scanner.source.charCodeAt(this.scanner.index);
        // < > / : = { }
        if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
            var value = this.scanner.source[this.scanner.index++];
            return {
                type: 7 /* Punctuator */,
                value: value,
                lineNumber: this.scanner.lineNumber,
                lineStart: this.scanner.lineStart,
                start: this.scanner.index - 1,
                end: this.scanner.index
            };
        }
        // " '
        if (cp === 34 || cp === 39) {
            var start = this.scanner.index;
            var quote = this.scanner.source[this.scanner.index++];
            var str = '';
            while (!this.scanner.eof()) {
                var ch = this.scanner.source[this.scanner.index++];
                if (ch === quote) {
                    break;
                }
                else if (ch === '&') {
                    str += this.scanXHTMLEntity(quote);
                }
                else {
                    str += ch;
                }
            }
            return {
                type: 8 /* StringLiteral */,
                value: str,
                lineNumber: this.scanner.lineNumber,
                lineStart: this.scanner.lineStart,
                start: start,
                end: this.scanner.index
            };
        }
        // ... or .
        if (cp === 46) {
            var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
            var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
            var value = (n1 === 46 && n2 === 46) ? '...' : '.';
            var start = this.scanner.index;
            this.scanner.index += value.length;
            return {
                type: 7 /* Punctuator */,
                value: value,
                lineNumber: this.scanner.lineNumber,
                lineStart: this.scanner.lineStart,
                start: start,
                end: this.scanner.index
            };
        }
        // `
        if (cp === 96) {
            // Only placeholder, since it will be rescanned as a real assignment expression.
            return {
                type: 10 /* Template */,
                value: '',
                lineNumber: this.scanner.lineNumber,
                lineStart: this.scanner.lineStart,
                start: this.scanner.index,
                end: this.scanner.index
            };
        }
        // Identifer can not contain backslash (char code 92).
        if (character_1.Character.isIdentifierStart(cp) && (cp !== 92)) {
            var start = this.scanner.index;
            ++this.scanner.index;
            while (!this.scanner.eof()) {
                var ch = this.scanner.source.charCodeAt(this.scanner.index);
                if (character_1.Character.isIdentifierPart(ch) && (ch !== 92)) {
                    ++this.scanner.index;
                }
                else if (ch === 45) {
                    // Hyphen (char code 45) can be part of an identifier.
                    ++this.scanner.index;
                }
                else {
                    break;
                }
            }
            var id = this.scanner.source.slice(start, this.scanner.index);
            return {
                type: 100 /* Identifier */,
                value: id,
                lineNumber: this.scanner.lineNumber,
                lineStart: this.scanner.lineStart,
                start: start,
                end: this.scanner.index
            };
        }
        return this.scanner.lex();
    };
    JSXParser.prototype.nextJSXToken = function () {
        this.collectComments();
        this.startMarker.index = this.scanner.index;
        this.startMarker.line = this.scanner.lineNumber;
        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
        var token = this.lexJSX();
        this.lastMarker.index = this.scanner.index;
        this.lastMarker.line = this.scanner.lineNumber;
        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
        if (this.config.tokens) {
            this.tokens.push(this.convertToken(token));
        }
        return token;
    };
    JSXParser.prototype.nextJSXText = function () {
        this.startMarker.index = this.scanner.index;
        this.startMarker.line = this.scanner.lineNumber;
        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
        var start = this.scanner.index;
        var text = '';
        while (!this.scanner.eof()) {
            var ch = this.scanner.source[this.scanner.index];
            if (ch === '{' || ch === '<') {
                break;
            }
            ++this.scanner.index;
            text += ch;
            if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                ++this.scanner.lineNumber;
                if (ch === '\r' && this.scanner.source[this.scanner.index] === '\n') {
                    ++this.scanner.index;
                }
                this.scanner.lineStart = this.scanner.index;
            }
        }
        this.lastMarker.index = this.scanner.index;
        this.lastMarker.line = this.scanner.lineNumber;
        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
        var token = {
            type: 101 /* Text */,
            value: text,
            lineNumber: this.scanner.lineNumber,
            lineStart: this.scanner.lineStart,
            start: start,
            end: this.scanner.index
        };
        if ((text.length > 0) && this.config.tokens) {
            this.tokens.push(this.convertToken(token));
        }
        return token;
    };
    JSXParser.prototype.peekJSXToken = function () {
        var state = this.scanner.saveState();
        this.scanner.scanComments();
        var next = this.lexJSX();
        this.scanner.restoreState(state);
        return next;
    };
    // Expect the next JSX token to match the specified punctuator.
    // If not, an exception will be thrown.
    JSXParser.prototype.expectJSX = function (value) {
        var token = this.nextJSXToken();
        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
            this.throwUnexpectedToken(token);
        }
    };
    // Return true if the next JSX token matches the specified punctuator.
    JSXParser.prototype.matchJSX = function (value) {
        var next = this.peekJSXToken();
        return next.type === 7 /* Punctuator */ && next.value === value;
    };
    JSXParser.prototype.parseJSXIdentifier = function () {
        var node = this.createJSXNode();
        var token = this.nextJSXToken();
        if (token.type !== 100 /* Identifier */) {
            this.throwUnexpectedToken(token);
        }
        return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
    };
    JSXParser.prototype.parseJSXElementName = function () {
        var node = this.createJSXNode();
        var elementName = this.parseJSXIdentifier();
        if (this.matchJSX(':')) {
            var namespace = elementName;
            this.expectJSX(':');
            var name_1 = this.parseJSXIdentifier();
            elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
        }
        else if (this.matchJSX('.')) {
            while (this.matchJSX('.')) {
                var object = elementName;
                this.expectJSX('.');
                var property = this.parseJSXIdentifier();
                elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
            }
        }
        return elementName;
    };
    JSXParser.prototype.parseJSXAttributeName = function () {
        var node = this.createJSXNode();
        var attributeName;
        var identifier = this.parseJSXIdentifier();
        if (this.matchJSX(':')) {
            var namespace = identifier;
            this.expectJSX(':');
            var name_2 = this.parseJSXIdentifier();
            attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
        }
        else {
            attributeName = identifier;
        }
        return attributeName;
    };
    JSXParser.prototype.parseJSXStringLiteralAttribute = function () {
        var node = this.createJSXNode();
        var token = this.nextJSXToken();
        if (token.type !== 8 /* StringLiteral */) {
            this.throwUnexpectedToken(token);
        }
        var raw = this.getTokenRaw(token);
        return this.finalize(node, new Node.Literal(token.value, raw));
    };
    JSXParser.prototype.parseJSXExpressionAttribute = function () {
        var node = this.createJSXNode();
        this.expectJSX('{');
        this.finishJSX();
        if (this.match('}')) {
            this.tolerateError('JSX attributes must only be assigned a non-empty expression');
        }
        var expression = this.parseAssignmentExpression();
        this.reenterJSX();
        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
    };
    JSXParser.prototype.parseJSXAttributeValue = function () {
        return this.matchJSX('{') ? this.parseJSXExpressionAttribute() :
            this.matchJSX('<') ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
    };
    JSXParser.prototype.parseJSXNameValueAttribute = function () {
        var node = this.createJSXNode();
        var name = this.parseJSXAttributeName();
        var value = null;
        if (this.matchJSX('=')) {
            this.expectJSX('=');
            value = this.parseJSXAttributeValue();
        }
        return this.finalize(node, new JSXNode.JSXAttribute(name, value));
    };
    JSXParser.prototype.parseJSXSpreadAttribute = function () {
        var node = this.createJSXNode();
        this.expectJSX('{');
        this.expectJSX('...');
        this.finishJSX();
        var argument = this.parseAssignmentExpression();
        this.reenterJSX();
        return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
    };
    JSXParser.prototype.parseJSXAttributes = function () {
        var attributes = [];
        while (!this.matchJSX('/') && !this.matchJSX('>')) {
            var attribute = this.matchJSX('{') ? this.parseJSXSpreadAttribute() :
                this.parseJSXNameValueAttribute();
            attributes.push(attribute);
        }
        return attributes;
    };
    JSXParser.prototype.parseJSXOpeningElement = function () {
        var node = this.createJSXNode();
        this.expectJSX('<');
        var name = this.parseJSXElementName();
        var attributes = this.parseJSXAttributes();
        var selfClosing = this.matchJSX('/');
        if (selfClosing) {
            this.expectJSX('/');
        }
        this.expectJSX('>');
        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
    };
    JSXParser.prototype.parseJSXBoundaryElement = function () {
        var node = this.createJSXNode();
        this.expectJSX('<');
        if (this.matchJSX('/')) {
            this.expectJSX('/');
            var name2 = this.parseJSXElementName();
            this.expectJSX('>');
            return this.finalize(node, new JSXNode.JSXClosingElement(name2));
        }
        var name = this.parseJSXElementName();
        var attributes = this.parseJSXAttributes();
        var selfClosing = this.matchJSX('/');
        if (selfClosing) {
            this.expectJSX('/');
        }
        this.expectJSX('>');
        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
    };
    JSXParser.prototype.parseJSXEmptyExpression = function () {
        var node = this.createJSXChildNode();
        this.collectComments();
        this.lastMarker.index = this.scanner.index;
        this.lastMarker.line = this.scanner.lineNumber;
        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
        return this.finalize(node, new JSXNode.JSXEmptyExpression());
    };
    JSXParser.prototype.parseJSXExpressionContainer = function () {
        var node = this.createJSXNode();
        this.expectJSX('{');
        var expression;
        if (this.matchJSX('}')) {
            expression = this.parseJSXEmptyExpression();
            this.expectJSX('}');
        }
        else {
            this.finishJSX();
            expression = this.parseAssignmentExpression();
            this.reenterJSX();
        }
        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
    };
    JSXParser.prototype.parseJSXChildren = function () {
        var children = [];
        while (!this.scanner.eof()) {
            var node = this.createJSXChildNode();
            var token = this.nextJSXText();
            if (token.start < token.end) {
                var raw = this.getTokenRaw(token);
                var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
                children.push(child);
            }
            if (this.scanner.source[this.scanner.index] === '{') {
                var container = this.parseJSXExpressionContainer();
                children.push(container);
            }
            else {
                break;
            }
        }
        return children;
    };
    JSXParser.prototype.parseComplexJSXElement = function (el) {
        var stack = [];
        while (!this.scanner.eof()) {
            el.children = el.children.concat(this.parseJSXChildren());
            var node = this.createJSXChildNode();
            var element = this.parseJSXBoundaryElement();
            if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
                var opening = element;
                if (opening.selfClosing) {
                    var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
                    el.children.push(child);
                }
                else {
                    stack.push(el);
                    el = { node: node, opening: opening, closing: null, children: [] };
                }
            }
            if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
                el.closing = element;
                var open_1 = getQualifiedElementName(el.opening.name);
                var close_1 = getQualifiedElementName(el.closing.name);
                if (open_1 !== close_1) {
                    this.tolerateError('Expected corresponding JSX closing tag for %0', open_1);
                }
                if (stack.length > 0) {
                    var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
                    el = stack[stack.length - 1];
                    el.children.push(child);
                    stack.pop();
                }
                else {
                    break;
                }
            }
        }
        return el;
    };
    JSXParser.prototype.parseJSXElement = function () {
        var node = this.createJSXNode();
        var opening = this.parseJSXOpeningElement();
        var children = [];
        var closing = null;
        if (!opening.selfClosing) {
            var el = this.parseComplexJSXElement({ node: node, opening: opening, closing: closing, children: children });
            children = el.children;
            closing = el.closing;
        }
        return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
    };
    JSXParser.prototype.parseJSXRoot = function () {
        // Pop the opening '<' added from the lookahead.
        if (this.config.tokens) {
            this.tokens.pop();
        }
        this.startJSX();
        var element = this.parseJSXElement();
        this.finishJSX();
        return element;
    };
    JSXParser.prototype.isStartOfExpression = function () {
        return _super.prototype.isStartOfExpression.call(this) || this.match('<');
    };
    return JSXParser;
}(parser_1.Parser));
exports.JSXParser = JSXParser;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var jsx_syntax_1 = __webpack_require__(3);
/* tslint:disable:max-classes-per-file */
var JSXClosingElement = /** @class */ (function () {
    function JSXClosingElement(name) {
        this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
        this.name = name;
    }
    return JSXClosingElement;
}());
exports.JSXClosingElement = JSXClosingElement;
var JSXElement = /** @class */ (function () {
    function JSXElement(openingElement, children, closingElement) {
        this.type = jsx_syntax_1.JSXSyntax.JSXElement;
        this.openingElement = openingElement;
        this.children = children;
        this.closingElement = closingElement;
    }
    return JSXElement;
}());
exports.JSXElement = JSXElement;
var JSXEmptyExpression = /** @class */ (function () {
    function JSXEmptyExpression() {
        this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
    }
    return JSXEmptyExpression;
}());
exports.JSXEmptyExpression = JSXEmptyExpression;
var JSXExpressionContainer = /** @class */ (function () {
    function JSXExpressionContainer(expression) {
        this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
        this.expression = expression;
    }
    return JSXExpressionContainer;
}());
exports.JSXExpressionContainer = JSXExpressionContainer;
var JSXIdentifier = /** @class */ (function () {
    function JSXIdentifier(name) {
        this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
        this.name = name;
    }
    return JSXIdentifier;
}());
exports.JSXIdentifier = JSXIdentifier;
var JSXMemberExpression = /** @class */ (function () {
    function JSXMemberExpression(object, property) {
        this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
        this.object = object;
        this.property = property;
    }
    return JSXMemberExpression;
}());
exports.JSXMemberExpression = JSXMemberExpression;
var JSXAttribute = /** @class */ (function () {
    function JSXAttribute(name, value) {
        this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
        this.name = name;
        this.value = value;
    }
    return JSXAttribute;
}());
exports.JSXAttribute = JSXAttribute;
var JSXNamespacedName = /** @class */ (function () {
    function JSXNamespacedName(namespace, name) {
        this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
        this.namespace = namespace;
        this.name = name;
    }
    return JSXNamespacedName;
}());
exports.JSXNamespacedName = JSXNamespacedName;
var JSXOpeningElement = /** @class */ (function () {
    function JSXOpeningElement(name, selfClosing, attributes) {
        this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
        this.name = name;
        this.selfClosing = selfClosing;
        this.attributes = attributes;
    }
    return JSXOpeningElement;
}());
exports.JSXOpeningElement = JSXOpeningElement;
var JSXSpreadAttribute = /** @class */ (function () {
    function JSXSpreadAttribute(argument) {
        this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
        this.argument = argument;
    }
    return JSXSpreadAttribute;
}());
exports.JSXSpreadAttribute = JSXSpreadAttribute;
var JSXText = /** @class */ (function () {
    function JSXText(value, raw) {
        this.type = jsx_syntax_1.JSXSyntax.JSXText;
        this.value = value;
        this.raw = raw;
    }
    return JSXText;
}());
exports.JSXText = JSXText;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Generated by generate-xhtml-entities.js. DO NOT MODIFY!
Object.defineProperty(exports, "__esModule", { value: true });
exports.XHTMLEntities = {
    quot: '\u0022',
    amp: '\u0026',
    apos: '\u0027',
    gt: '\u003E',
    nbsp: '\u00A0',
    iexcl: '\u00A1',
    cent: '\u00A2',
    pound: '\u00A3',
    curren: '\u00A4',
    yen: '\u00A5',
    brvbar: '\u00A6',
    sect: '\u00A7',
    uml: '\u00A8',
    copy: '\u00A9',
    ordf: '\u00AA',
    laquo: '\u00AB',
    not: '\u00AC',
    shy: '\u00AD',
    reg: '\u00AE',
    macr: '\u00AF',
    deg: '\u00B0',
    plusmn: '\u00B1',
    sup2: '\u00B2',
    sup3: '\u00B3',
    acute: '\u00B4',
    micro: '\u00B5',
    para: '\u00B6',
    middot: '\u00B7',
    cedil: '\u00B8',
    sup1: '\u00B9',
    ordm: '\u00BA',
    raquo: '\u00BB',
    frac14: '\u00BC',
    frac12: '\u00BD',
    frac34: '\u00BE',
    iquest: '\u00BF',
    Agrave: '\u00C0',
    Aacute: '\u00C1',
    Acirc: '\u00C2',
    Atilde: '\u00C3',
    Auml: '\u00C4',
    Aring: '\u00C5',
    AElig: '\u00C6',
    Ccedil: '\u00C7',
    Egrave: '\u00C8',
    Eacute: '\u00C9',
    Ecirc: '\u00CA',
    Euml: '\u00CB',
    Igrave: '\u00CC',
    Iacute: '\u00CD',
    Icirc: '\u00CE',
    Iuml: '\u00CF',
    ETH: '\u00D0',
    Ntilde: '\u00D1',
    Ograve: '\u00D2',
    Oacute: '\u00D3',
    Ocirc: '\u00D4',
    Otilde: '\u00D5',
    Ouml: '\u00D6',
    times: '\u00D7',
    Oslash: '\u00D8',
    Ugrave: '\u00D9',
    Uacute: '\u00DA',
    Ucirc: '\u00DB',
    Uuml: '\u00DC',
    Yacute: '\u00DD',
    THORN: '\u00DE',
    szlig: '\u00DF',
    agrave: '\u00E0',
    aacute: '\u00E1',
    acirc: '\u00E2',
    atilde: '\u00E3',
    auml: '\u00E4',
    aring: '\u00E5',
    aelig: '\u00E6',
    ccedil: '\u00E7',
    egrave: '\u00E8',
    eacute: '\u00E9',
    ecirc: '\u00EA',
    euml: '\u00EB',
    igrave: '\u00EC',
    iacute: '\u00ED',
    icirc: '\u00EE',
    iuml: '\u00EF',
    eth: '\u00F0',
    ntilde: '\u00F1',
    ograve: '\u00F2',
    oacute: '\u00F3',
    ocirc: '\u00F4',
    otilde: '\u00F5',
    ouml: '\u00F6',
    divide: '\u00F7',
    oslash: '\u00F8',
    ugrave: '\u00F9',
    uacute: '\u00FA',
    ucirc: '\u00FB',
    uuml: '\u00FC',
    yacute: '\u00FD',
    thorn: '\u00FE',
    yuml: '\u00FF',
    OElig: '\u0152',
    oelig: '\u0153',
    Scaron: '\u0160',
    scaron: '\u0161',
    Yuml: '\u0178',
    fnof: '\u0192',
    circ: '\u02C6',
    tilde: '\u02DC',
    Alpha: '\u0391',
    Beta: '\u0392',
    Gamma: '\u0393',
    Delta: '\u0394',
    Epsilon: '\u0395',
    Zeta: '\u0396',
    Eta: '\u0397',
    Theta: '\u0398',
    Iota: '\u0399',
    Kappa: '\u039A',
    Lambda: '\u039B',
    Mu: '\u039C',
    Nu: '\u039D',
    Xi: '\u039E',
    Omicron: '\u039F',
    Pi: '\u03A0',
    Rho: '\u03A1',
    Sigma: '\u03A3',
    Tau: '\u03A4',
    Upsilon: '\u03A5',
    Phi: '\u03A6',
    Chi: '\u03A7',
    Psi: '\u03A8',
    Omega: '\u03A9',
    alpha: '\u03B1',
    beta: '\u03B2',
    gamma: '\u03B3',
    delta: '\u03B4',
    epsilon: '\u03B5',
    zeta: '\u03B6',
    eta: '\u03B7',
    theta: '\u03B8',
    iota: '\u03B9',
    kappa: '\u03BA',
    lambda: '\u03BB',
    mu: '\u03BC',
    nu: '\u03BD',
    xi: '\u03BE',
    omicron: '\u03BF',
    pi: '\u03C0',
    rho: '\u03C1',
    sigmaf: '\u03C2',
    sigma: '\u03C3',
    tau: '\u03C4',
    upsilon: '\u03C5',
    phi: '\u03C6',
    chi: '\u03C7',
    psi: '\u03C8',
    omega: '\u03C9',
    thetasym: '\u03D1',
    upsih: '\u03D2',
    piv: '\u03D6',
    ensp: '\u2002',
    emsp: '\u2003',
    thinsp: '\u2009',
    zwnj: '\u200C',
    zwj: '\u200D',
    lrm: '\u200E',
    rlm: '\u200F',
    ndash: '\u2013',
    mdash: '\u2014',
    lsquo: '\u2018',
    rsquo: '\u2019',
    sbquo: '\u201A',
    ldquo: '\u201C',
    rdquo: '\u201D',
    bdquo: '\u201E',
    dagger: '\u2020',
    Dagger: '\u2021',
    bull: '\u2022',
    hellip: '\u2026',
    permil: '\u2030',
    prime: '\u2032',
    Prime: '\u2033',
    lsaquo: '\u2039',
    rsaquo: '\u203A',
    oline: '\u203E',
    frasl: '\u2044',
    euro: '\u20AC',
    image: '\u2111',
    weierp: '\u2118',
    real: '\u211C',
    trade: '\u2122',
    alefsym: '\u2135',
    larr: '\u2190',
    uarr: '\u2191',
    rarr: '\u2192',
    darr: '\u2193',
    harr: '\u2194',
    crarr: '\u21B5',
    lArr: '\u21D0',
    uArr: '\u21D1',
    rArr: '\u21D2',
    dArr: '\u21D3',
    hArr: '\u21D4',
    forall: '\u2200',
    part: '\u2202',
    exist: '\u2203',
    empty: '\u2205',
    nabla: '\u2207',
    isin: '\u2208',
    notin: '\u2209',
    ni: '\u220B',
    prod: '\u220F',
    sum: '\u2211',
    minus: '\u2212',
    lowast: '\u2217',
    radic: '\u221A',
    prop: '\u221D',
    infin: '\u221E',
    ang: '\u2220',
    and: '\u2227',
    or: '\u2228',
    cap: '\u2229',
    cup: '\u222A',
    int: '\u222B',
    there4: '\u2234',
    sim: '\u223C',
    cong: '\u2245',
    asymp: '\u2248',
    ne: '\u2260',
    equiv: '\u2261',
    le: '\u2264',
    ge: '\u2265',
    sub: '\u2282',
    sup: '\u2283',
    nsub: '\u2284',
    sube: '\u2286',
    supe: '\u2287',
    oplus: '\u2295',
    otimes: '\u2297',
    perp: '\u22A5',
    sdot: '\u22C5',
    lceil: '\u2308',
    rceil: '\u2309',
    lfloor: '\u230A',
    rfloor: '\u230B',
    loz: '\u25CA',
    spades: '\u2660',
    clubs: '\u2663',
    hearts: '\u2665',
    diams: '\u2666',
    lang: '\u27E8',
    rang: '\u27E9'
};


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var error_handler_1 = __webpack_require__(7);
var scanner_1 = __webpack_require__(9);
var token_1 = __webpack_require__(1);
var Reader = /** @class */ (function () {
    function Reader() {
        this.values = [];
        this.curly = this.paren = -1;
    }
    // A function following one of those tokens is an expression.
    Reader.prototype.beforeFunctionExpression = function (t) {
        return ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
            'return', 'case', 'delete', 'throw', 'void',
            // assignment operators
            '=', '+=', '-=', '*=', '**=', '/=', '%=', '<<=', '>>=', '>>>=',
            '&=', '|=', '^=', ',',
            // binary/unary operators
            '+', '-', '*', '**', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
            '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
            '<=', '<', '>', '!=', '!=='].indexOf(t) >= 0;
    };
    // Determine if forward slash (/) is an operator or part of a regular expression
    // https://github.com/mozilla/sweet.js/wiki/design
    Reader.prototype.isRegexStart = function () {
        var previous = this.values[this.values.length - 1];
        var regex = (previous !== null);
        switch (previous) {
            case 'this':
            case ']':
                regex = false;
                break;
            case ')':
                var keyword = this.values[this.paren - 1];
                regex = (keyword === 'if' || keyword === 'while' || keyword === 'for' || keyword === 'with');
                break;
            case '}':
                // Dividing a function by anything makes little sense,
                // but we have to check for that.
                regex = false;
                if (this.values[this.curly - 3] === 'function') {
                    // Anonymous function, e.g. function(){} /42
                    var check = this.values[this.curly - 4];
                    regex = check ? !this.beforeFunctionExpression(check) : false;
                }
                else if (this.values[this.curly - 4] === 'function') {
                    // Named function, e.g. function f(){} /42/
                    var check = this.values[this.curly - 5];
                    regex = check ? !this.beforeFunctionExpression(check) : true;
                }
                break;
            default:
                break;
        }
        return regex;
    };
    Reader.prototype.push = function (token) {
        if (token.type === 7 /* Punctuator */ || token.type === 4 /* Keyword */) {
            if (token.value === '{') {
                this.curly = this.values.length;
            }
            else if (token.value === '(') {
                this.paren = this.values.length;
            }
            this.values.push(token.value);
        }
        else {
            this.values.push(null);
        }
    };
    return Reader;
}());
var Tokenizer = /** @class */ (function () {
    function Tokenizer(code, config) {
        this.errorHandler = new error_handler_1.ErrorHandler();
        this.errorHandler.tolerant = config ? (typeof config.tolerant === 'boolean' && config.tolerant) : false;
        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
        this.scanner.trackComment = config ? (typeof config.comment === 'boolean' && config.comment) : false;
        this.trackRange = config ? (typeof config.range === 'boolean' && config.range) : false;
        this.trackLoc = config ? (typeof config.loc === 'boolean' && config.loc) : false;
        this.buffer = [];
        this.reader = new Reader();
    }
    Tokenizer.prototype.errors = function () {
        return this.errorHandler.errors;
    };
    Tokenizer.prototype.getNextToken = function () {
        if (this.buffer.length === 0) {
            var comments = this.scanner.scanComments();
            if (this.scanner.trackComment) {
                for (var i = 0; i < comments.length; ++i) {
                    var e = comments[i];
                    var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
                    var comment = {
                        type: e.multiLine ? 'BlockComment' : 'LineComment',
                        value: value
                    };
                    if (this.trackRange) {
                        comment.range = e.range;
                    }
                    if (this.trackLoc) {
                        comment.loc = e.loc;
                    }
                    this.buffer.push(comment);
                }
            }
            if (!this.scanner.eof()) {
                var loc = void 0;
                if (this.trackLoc) {
                    loc = {
                        start: {
                            line: this.scanner.lineNumber,
                            column: this.scanner.index - this.scanner.lineStart
                        },
                        end: {}
                    };
                }
                var startRegex = (this.scanner.source[this.scanner.index] === '/') && this.reader.isRegexStart();
                var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
                this.reader.push(token);
                var entry = {
                    type: token_1.TokenName[token.type],
                    value: this.scanner.source.slice(token.start, token.end)
                };
                if (this.trackRange) {
                    entry.range = [token.start, token.end];
                }
                if (this.trackLoc) {
                    loc.end = {
                        line: this.scanner.lineNumber,
                        column: this.scanner.index - this.scanner.lineStart
                    };
                    entry.loc = loc;
                }
                if (token.type === 9 /* RegularExpression */) {
                    var pattern = token.pattern;
                    var flags = token.flags;
                    entry.regex = { pattern: pattern, flags: flags };
                }
                this.buffer.push(entry);
            }
        }
        return this.buffer.shift();
    };
    return Tokenizer;
}());
exports.Tokenizer = Tokenizer;


/***/ })
/******/ ]);
});
},{}],30:[function(require,module,exports){
// json5.js
// JSON for Humans. See README.md for details.
//
// This file is based directly off of Douglas Crockford's json_parse.js:
// https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js

var JSON5 = (typeof exports === 'object' ? exports : {});

JSON5.parse = (function () {
    "use strict";

// This is a function that can parse a JSON5 text, producing a JavaScript
// data structure. It is a simple, recursive descent parser. It does not use
// eval or regular expressions, so it can be used as a model for implementing
// a JSON5 parser in other languages.

// We are defining the function inside of another function to avoid creating
// global variables.

    var at,           // The index of the current character
        lineNumber,   // The current line number
        columnNumber, // The current column number
        ch,           // The current character
        escapee = {
            "'":  "'",
            '"':  '"',
            '\\': '\\',
            '/':  '/',
            '\n': '',       // Replace escaped newlines in strings w/ empty string
            0:    '\0',
            b:    '\b',
            f:    '\f',
            n:    '\n',
            r:    '\r',
            t:    '\t',
            v:    '\v'
        },
        escapee_4_multiline = {
            '`':  '`',
            '\\': '\\'
        },
        ws = [
            ' ',
            '\t',
            '\r',
            '\n',
            '\v',
            '\f',
            '\xA0',
            '\uFEFF'
        ],
        text,

        renderChar = function (chr) {
            return chr === '' ? 'EOF' : "'" + chr + "'";
        },

        error = function (m) {

// Call error when something is wrong.

            var error = new SyntaxError();
            // beginning of message suffix to agree with that provided by Gecko - see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse
            error.message = m + " at line " + lineNumber + " column " + columnNumber + " of the JSON5 data. Still to read: " + JSON.stringify(text.substring(at - 1, at + 19));
            error.at = at;
            // These two property names have been chosen to agree with the ones in Gecko, the only popular
            // environment which seems to supply this info on JSON.parse
            error.lineNumber = lineNumber;
            error.columnNumber = columnNumber;
            throw error;
        },

        next = function (c) {

// If a c parameter is provided, verify that it matches the current character.

            if (c && c !== ch) {
                error("Expected " + renderChar(c) + " instead of " + renderChar(ch));
            }

// Get the next character. When there are no more characters,
// return the empty string.

            ch = text.charAt(at);
            at++;
            columnNumber++;
            if (ch === '\n' || ch === '\r' && peek() !== '\n') {
                lineNumber++;
                columnNumber = 0;
            }
            return ch;
        },

        peek = function () {

// Get the next character without consuming it or
// assigning it to the ch varaible.

            return text.charAt(at);
        },

        identifier = function () {

// Parse an identifier. Normally, reserved words are disallowed here, but we
// only use this for unquoted object keys, where reserved words are allowed,
// so we don't check for those here. References:
// - http://es5.github.com/#x7.6
// - https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Core_Language_Features#Variables
// - http://docstore.mik.ua/orelly/webprog/jscript/ch02_07.htm
// TODO Identifiers can have Unicode "letters" in them; add support for those.

            var key = ch;

            // Identifiers must start with a letter, _ or $.
            if ((ch !== '_' && ch !== '$') &&
                    (ch < 'a' || ch > 'z') &&
                    (ch < 'A' || ch > 'Z')) {
                error("Bad identifier as unquoted key");
            }

            // Subsequent characters can contain digits.
            while (next() && (
                    ch === '_' || ch === '$' ||
                    (ch >= 'a' && ch <= 'z') ||
                    (ch >= 'A' && ch <= 'Z') ||
                    (ch >= '0' && ch <= '9'))) {
                key += ch;
            }

            return key;
        },

        number = function () {

// Parse a number value.

            var number,
                sign = '',
                string = '',
                base = 10;

            if (ch === '-' || ch === '+') {
                sign = ch;
                next(ch);
            }

            // support for Infinity (could tweak to allow other words):
            if (ch === 'I') {
                number = word();
                if (typeof number !== 'number' || isNaN(number)) {
                    error('Unexpected word for number');
                }
                return (sign === '-') ? -number : number;
            }

            // support for NaN
            if (ch === 'N' ) {
              number = word();
              if (!isNaN(number)) {
                error('expected word to be NaN');
              }
              // ignore sign as -NaN also is NaN
              return number;
            }

            if (ch === '0') {
                string += ch;
                next();
                if (ch === 'x' || ch === 'X') {
                    string += ch;
                    next();
                    base = 16;
                } else if (ch >= '0' && ch <= '9') {
                    error('Octal literal');
                }
            }

            switch (base) {
            case 10:
                while (ch >= '0' && ch <= '9' ) {
                    string += ch;
                    next();
                }
                if (ch === '.') {
                    string += '.';
                    while (next() && ch >= '0' && ch <= '9') {
                        string += ch;
                    }
                }
                if (ch === 'e' || ch === 'E') {
                    string += ch;
                    next();
                    if (ch === '-' || ch === '+') {
                        string += ch;
                        next();
                    }
                    while (ch >= '0' && ch <= '9') {
                        string += ch;
                        next();
                    }
                }
                break;
            case 16:
                while (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') {
                    string += ch;
                    next();
                }
                break;
            }

            if(sign === '-') {
                number = -string;
            } else {
                number = +string;
            }

            if (!isFinite(number)) {
                error("Bad number");
            } else {
                return number;
            }
        },

        string = function () {

// Parse a string value.

            var hex,
                i,
                string = '',
                delim,      // double quote or single quote
                uffff,
                xff,
                is_basic_str,
                escapes;

// When parsing for string values, we must look for ', ", ` and \ characters.

            is_basic_str = (ch === '"' || ch === "'"); 
            if (is_basic_str || ch === '`') {
                escapes = (is_basic_str ? escapee : escapee_4_multiline);
                delim = ch;
                while (next()) {
                    if (ch === delim) {
                        next();
                        return string;
                    } else if (ch === '\\') {
                        next();
                        if (ch === 'u') {
                            uffff = 0;
                            for (i = 0; i < 4; i += 1) {
                                hex = parseInt(next(), 16);
                                if (!isFinite(hex)) {
                                    break;
                                }
                                uffff = uffff * 16 + hex;
                            }
                            string += String.fromCharCode(uffff);
                            // TODO: add \u{fffff} support for *Unicode Code Points* as per ES2017
                        } else if (ch === 'x') {
                            xff = 0;
                            for (i = 0; i < 2; i += 1) {
                                hex = parseInt(next(), 16);
                                if (!isFinite(hex)) {
                                    break;
                                }
                                xff = xff * 16 + hex;
                            }
                            string += String.fromCharCode(xff);
                        } else if (ch === '\r') {
                            if (peek() === '\n') {
                                next();
                            }
                            // CR and CRLF get transformed to LF when the string being parsed is a `string template` type.
                            // We also keep the `\\` at the end of line as it's an unrecognized escape in that mode.
                            if (!is_basic_str) {
                                string += '\\\n';
                            }
                        } else if (ch >= '1' && ch <= '7') {
                            // since octal literals are not supported,
                            // octal escapes in strings are not either.
                            //
                            // While https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals
                            // says otherwise, we still DO NOT support octal escapes in JSON5 '`'-delimited multiline
                            // strings, as these ARE NOT identical to JavaScript 'template strings' as we DO NOT
                            // intend to support the `${...}` template variable expansion feature either!
                            break;
                        } else if (typeof escapes[ch] === 'string') {
                            string += escapes[ch];
                        } else if (is_basic_str) {
                            // javascript treats the '\' char as an escape for any character in a classic string
                            string += ch;
                        } else {
                            // in '`'-delimited strings, we only accept \u, \x, \` and \\ escapes;
                            // everyhing else is copied verbatim
                            string += '\\' + ch;
                        }
                    } else if (is_basic_str && ch === '\n') {
                        // unescaped newlines are invalid; see:
                        // https://github.com/json5/json5/issues/24
                        //
                        // TODO: this feels special-cased; are there other
                        // invalid unescaped chars?
                        break;
                    } else if (ch === '\r') {
                        if (peek() === '\n') {
                            next();
                        }
                        // CR and CRLF get transformed to LF when the string being parsed is a `string template` type.
                        if (!is_basic_str) {
                            string += '\n';
                        } else {
                            // unescaped newlines are invalid; see:
                            // https://github.com/json5/json5/issues/24
                            //
                            // TODO: this feels special-cased; are there other
                            // invalid unescaped chars?
                            break;
                        }
                    } else {
                        string += ch;
                    }
                }
            }
            error("Bad string");
        },

        heredoc = function () {

// Parse a heredoc (string) value.

            var i,
                string,
                delim,
                input,
                m,
                l,
                offset,
                chkstr_e,
                chkstr_s;

// When parsing for heredoc values, we must extract the EOT marker before anything else.
// Once we've done that, we skip the first newline and start scanning/consuming heredoc
// content until we hit the EOT marker on a line by itself, sans whitespace.
//
// By convention we do not accept 'formatting whitespace/indentation' before the EOT
// marker on the same line.

            input = text.substring(at);
            // we accept 2 or more(!) `<` characters to mark the start of a heredoc chunk:
            m = /(<+)([^\s\r\n<>,"'\/\[\]\{\}]+)(\r?\n|\r\n?)/.exec(input);
            if (!m) {
                error("Expected heredoc starting EOT marker to immediately follow the initial << or <<<");
            }
            //offset = m[1].length;
            delim = m[2];

            // strip off start marker including CRLF:
            l = m[0].length;
            input = input.substring(l);

            at += l;
            columnNumber = 0;

            // scan for first occurrence of the lone EOT marker (which can really be ANYTHING 
            // as long as the ANYTHING isn't whitespace!):
            for (i = 0, l = delim.length; ; i = offset + 1) {
                offset = input.indexOf(delim, i);
                if (offset < 0) {
                    error("Expected heredoc terminating EOT marker \"" + delim + "\" on a line by itself (sans whitespace)");
                }
                // now check if located EOT delimiter is on a line by its lonesome:
                if (offset < 1) continue;
                chkstr_e = input.substring(offset + l);
                if (chkstr_e.length && chkstr_e[0] !== '\r' && chkstr_e[0] !== '\n') {
                    // we don't tolerate any whitespace trailing the EOT marker: 
                    // it must be the only item on the line!
                    //
                    // Note: however, we DO TOLERATE a comma field separator following 
                    // on the same line  la BASH, while we also accept any trailing
                    // whitespace as per the JSON5 spec for all other field formats
                    // in an object/array:
                    if (!chkstr_e.match(/^\s*,\s*(?:\r?\n|\r\n?)/)) {
                        continue;
                    } else {
                        // trailing comma found: bump skip length accordingly
                    }
                }
                chkstr_s = input.substr(offset - 2, 2);
                if (chkstr_s[1] !== '\r' && chkstr_s[1] !== '\n') {
                    // we don't tolerate any whitespace leading the EOT marker: 
                    // it must be at the start of a new line!
                    continue;
                } else if (chkstr_s[1] === '\n' && chkstr_s[0] === '\r') {
                    // found leading CRLF: ignore it entirely
                    i = offset - 2;
                } else {
                    // found leading CR or LF: ignore it
                    i = offset - 1;
                }

                // found a legal EOT marker! `i` is now index of first non-content character.
                //
                // Hence we now may extract the heredoc'ed content as a string,
                // ignoring the preceding CR/LF/CRLF:
                string = input.substring(0, i);

                // and we jump over the EOT marker:
                offset += l;
                // we DO NOT jump over the trailing optional comma and/or trailing CR/LF/CRLF
                // as those are expected to be parsed by the outer call: when parsing a heredoc
                // string in an array or object specifically, the outer call EXPECTS to see
                // that trailing comma in global `ch` or it will barf a hairball on the next
                // element!

                at += offset;
                columnNumber = l;

                // count the number of lines in the extracted string:
                var lines = (string.match(/\r?\n|\r\n?/g) || []);
                lineNumber += lines.length + 2;    // add the skipped newlines at start and end of heredoc: 1 at start, 1 at the end, not counting the trailing EOL as that one isn't skipped yet!

                // also make sure `ch` is primed a la `next()` API:
                ch = text.charAt(at);
                next();
                break;
            }

            return string;
        },

        inlineComment = function () {

// Skip an inline comment, assuming this is one. The current character should
// be the second / character in the // pair that begins this inline comment.
// To finish the inline comment, we look for a newline or the end of the text.

            if (ch !== '/') {
                error("Not an inline comment");
            }

            do {
                next();
                if (ch === '\n' || ch === '\r') {
                    next();
                    return;
                }
            } while (ch);
        },

        blockComment = function () {

// Skip a block comment, assuming this is one. The current character should be
// the * character in the /* pair that begins this block comment.
// To finish the block comment, we look for an ending */ pair of characters,
// but we also watch for the end of text before the comment is terminated.

            if (ch !== '*') {
                error("Not a block comment");
            }

            do {
                next();
                while (ch === '*') {
                    next('*');
                    if (ch === '/') {
                        next('/');
                        return;
                    }
                }
            } while (ch);

            error("Unterminated block comment");
        },

        comment = function () {

// Skip a comment, whether inline or block-level, assuming this is one.
// Comments always begin with a / character.

            if (ch !== '/') {
                error("Not a comment");
            }

            next('/');

            if (ch === '/') {
                inlineComment();
            } else if (ch === '*') {
                blockComment();
            } else {
                error("Unrecognized comment");
            }
        },

        white = function () {

// Skip whitespace and comments.
// Note that we're detecting comments by only a single / character.
// This works since regular expressions are not valid JSON(5), but this will
// break if there are other valid values that begin with a / character!

            while (ch) {
                if (ch === '/') {
                    comment();
                } else if (ws.indexOf(ch) >= 0) {
                    next();
                } else {
                    return;
                }
            }
        },

        word = function () {

// true, false, or null.

            switch (ch) {
            case 't':
                next('t');
                next('r');
                next('u');
                next('e');
                return true;
            case 'f':
                next('f');
                next('a');
                next('l');
                next('s');
                next('e');
                return false;
            case 'n':
                next('n');
                next('u');
                next('l');
                next('l');
                return null;
            case 'I':
                next('I');
                next('n');
                next('f');
                next('i');
                next('n');
                next('i');
                next('t');
                next('y');
                return Infinity;
            case 'N':
              next( 'N' );
              next( 'a' );
              next( 'N' );
              return NaN;
            }
            error("Unexpected " + renderChar(ch));
        },

        value,  // Place holder for the value function.

        array = function () {

// Parse an array value.

            var array = [];

            if (ch === '[') {
                next('[');
                white();
                while (ch) {
                    if (ch === ']') {
                        next(']');
                        return array;   // Potentially empty array
                    }
                    // ES5 allows omitting elements in arrays, e.g. [,] and
                    // [,null]. We don't allow this in JSON5.
                    if (ch === ',') {
                        error("Missing array element");
                    } else {
                        array.push(value());
                    }
                    white();
                    // If there's no comma after this value, this needs to
                    // be the end of the array.
                    if (ch !== ',') {
                        next(']');
                        return array;
                    }
                    next(',');
                    white();
                }
            }
            error("Bad array");
        },

        object = function () {

// Parse an object value.

            var key,
                object = {};

            if (ch === '{') {
                next('{');
                white();
                while (ch) {
                    if (ch === '}') {
                        next('}');
                        return object;   // Potentially empty object
                    }

                    // Keys can be unquoted. If they are, they need to be
                    // valid JS identifiers.
                    if (ch === '"' || ch === "'") {
                        key = string();
                    } else {
                        key = identifier();
                    }

                    white();
                    next(':');
                    object[key] = value();
                    white();
                    // If there's no comma after this pair, this needs to be
                    // the end of the object.
                    if (ch !== ',') {
                        next('}');
                        return object;
                    }
                    next(',');
                    white();
                }
            }
            error("Bad object");
        };

    value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

        white();
        switch (ch) {
        case '{':
            return object();
        case '[':
            return array();
        case '"':
        case "'":
        case "`":
            return string();
        case "<":
            return heredoc();
        case '-':
        case '+':
        case '.':
            return number();
        default:
            return ch >= '0' && ch <= '9' ? number() : word();
        }
    };

// Return the json_parse function. It will have access to all of the above
// functions and variables.

    return function json_parse(source, reviver) {
        var result;

        text = String(source);
        at = 0;
        lineNumber = 1;
        columnNumber = 1;
        ch = ' ';
        result = value();
        white();
        if (ch) {
            error("Syntax error");
        }

// If there is a reviver function, we recursively walk the new structure,
// passing each name/value pair to the reviver function for possible
// transformation, starting with a temporary root object that holds the result
// in an empty key. If there is not a reviver function, we simply return the
// result.

        return typeof reviver === 'function' ? (function walk(holder, key) {
            var k, v, value = holder[key];
            if (value && typeof value === 'object') {
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = walk(value, k);
                        if (v !== undefined) {
                            value[k] = v;
                        } else {
                            delete value[k];
                        }
                    }
                }
            }
            return reviver.call(holder, key, value);
        }({'': result}, '')) : result;
    };
}());

// JSON5 stringify will not quote keys where appropriate
JSON5.stringify = function (obj, replacer, space) {
    if (replacer && (typeof(replacer) !== "function" && !isArray(replacer))) {
        throw new Error('Replacer must be a function or an array');
    }
    var getReplacedValueOrUndefined = function(holder, key, isTopLevel) {
        var value = holder[key];

        // Replace the value with its toJSON value first, if possible
        if (value && value.toJSON && typeof value.toJSON === "function") {
            value = value.toJSON();
        }

        // If the user-supplied replacer if a function, call it. If it's an array, check objects' string keys for
        // presence in the array (removing the key/value pair from the resulting JSON if the key is missing).
        if (typeof(replacer) === "function") {
            return replacer.call(holder, key, value);
        } else if(replacer) {
            if (isTopLevel || isArray(holder) || replacer.indexOf(key) >= 0) {
                return value;
            } else {
                return undefined;
            }
        } else {
            return value;
        }
    };

    function isWordChar(c) {
        return (c >= 'a' && c <= 'z') ||
            (c >= 'A' && c <= 'Z') ||
            (c >= '0' && c <= '9') ||
            c === '_' || c === '$';
    }

    function isWordStart(c) {
        return (c >= 'a' && c <= 'z') ||
            (c >= 'A' && c <= 'Z') ||
            c === '_' || c === '$';
    }

    function isWord(key) {
        if (typeof key !== 'string') {
            return false;
        }
        if (!isWordStart(key[0])) {
            return false;
        }
        var i = 1, length = key.length;
        while (i < length) {
            if (!isWordChar(key[i])) {
                return false;
            }
            i++;
        }
        return true;
    }

    // export for use in tests
    JSON5.isWord = isWord;

    // polyfills
    function isArray(obj) {
        if (Array.isArray) {
            return Array.isArray(obj);
        } else {
            return Object.prototype.toString.call(obj) === '[object Array]';
        }
    }

    function isDate(obj) {
        return Object.prototype.toString.call(obj) === '[object Date]';
    }

    var objStack = [];
    function checkForCircular(obj) {
        for (var i = 0; i < objStack.length; i++) {
            if (objStack[i] === obj) {
                throw new TypeError("Converting circular structure to JSON");
            }
        }
    }

    function makeIndent(str, num, noNewLine) {
        if (!str) {
            return "";
        }
        // indentation no more than 10 chars
        if (str.length > 10) {
            str = str.substring(0, 10);
        }

        var indent = noNewLine ? "" : "\n";
        for (var i = 0; i < num; i++) {
            indent += str;
        }

        return indent;
    }

    var indentStr;
    if (space) {
        if (typeof space === "string") {
            indentStr = space;
        } else if (typeof space === "number" && space >= 0) {
            indentStr = makeIndent(" ", space, true);
        } else {
            // ignore space parameter
        }
    }

    // Copied from Crokford's implementation of JSON
    // See https://github.com/douglascrockford/JSON-js/blob/e39db4b7e6249f04a195e7dd0840e610cc9e941e/json2.js#L195
    // Begin
    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        meta = { // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    };

    function escapeString(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.
        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string' ?
                c :
                '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }
    // End

    function internalStringify(holder, key, isTopLevel) {
        var buffer, res;

        // Replace the value, if necessary
        var obj_part = getReplacedValueOrUndefined(holder, key, isTopLevel);

        if (obj_part && !isDate(obj_part)) {
            // unbox objects
            // don't unbox dates, since will turn it into number
            obj_part = obj_part.valueOf();
        }
        switch(typeof obj_part) {
            case "boolean":
                return obj_part.toString();

            case "number":
                if (isNaN(obj_part) || !isFinite(obj_part)) {
                    return "null";
                }
                return obj_part.toString();

            case "string":
                return escapeString(obj_part.toString());

            case "object":
                if (obj_part === null) {
                    return "null";
                } else if (isArray(obj_part)) {
                    checkForCircular(obj_part);
                    buffer = "[";
                    objStack.push(obj_part);

                    for (var i = 0; i < obj_part.length; i++) {
                        res = internalStringify(obj_part, i, false);
                        buffer += makeIndent(indentStr, objStack.length);
                        if (res === null || typeof res === "undefined") {
                            buffer += "null";
                        } else {
                            buffer += res;
                        }
                        if (i < obj_part.length-1) {
                            buffer += ",";
                        } else if (indentStr) {
                            buffer += "\n";
                        }
                    }
                    objStack.pop();
                    if (obj_part.length) {
                        buffer += makeIndent(indentStr, objStack.length, true)
                    }
                    buffer += "]";
                } else {
                    checkForCircular(obj_part);
                    buffer = "{";
                    var nonEmpty = false;
                    objStack.push(obj_part);
                    for (var prop in obj_part) {
                        if (obj_part.hasOwnProperty(prop)) {
                            var value = internalStringify(obj_part, prop, false);
                            isTopLevel = false;
                            if (typeof value !== "undefined" && value !== null) {
                                buffer += makeIndent(indentStr, objStack.length);
                                nonEmpty = true;
                                key = isWord(prop) ? prop : escapeString(prop);
                                buffer += key + ":" + (indentStr ? ' ' : '') + value + ",";
                            }
                        }
                    }
                    objStack.pop();
                    if (nonEmpty) {
                        buffer = buffer.substring(0, buffer.length-1) + makeIndent(indentStr, objStack.length) + "}";
                    } else {
                        buffer = '{}';
                    }
                }
                return buffer;
            default:
                // functions and undefined should be ignored
                return undefined;
        }
    }

    // special case...when undefined is used inside of
    // a compound object/array, return null.
    // but when top-level, return undefined
    var topLevelHolder = {"":obj};
    if (obj === undefined) {
        return getReplacedValueOrUndefined(topLevelHolder, '', true);
    }
    return internalStringify(topLevelHolder, '', true);
};

},{}],31:[function(require,module,exports){
var assert = require("assert");
var types = require("./types");
var n = types.namedTypes;
var isArray = types.builtInTypes.array;
var isObject = types.builtInTypes.object;
var linesModule = require("./lines");
var fromString = linesModule.fromString;
var Lines = linesModule.Lines;
var concat = linesModule.concat;
var util = require("./util");
var comparePos = util.comparePos;
var childNodesCacheKey = require("private").makeUniqueKey();

// TODO Move a non-caching implementation of this function into ast-types,
// and implement a caching wrapper function here.
function getSortedChildNodes(node, lines, resultArray) {
    if (!node) {
        return;
    }

    // The .loc checks below are sensitive to some of the problems that
    // are fixed by this utility function. Specifically, if it decides to
    // set node.loc to null, indicating that the node's .loc information
    // is unreliable, then we don't want to add node to the resultArray.
    util.fixFaultyLocations(node, lines);

    if (resultArray) {
        if (n.Node.check(node) &&
            n.SourceLocation.check(node.loc)) {
            // This reverse insertion sort almost always takes constant
            // time because we almost always (maybe always?) append the
            // nodes in order anyway.
            for (var i = resultArray.length - 1; i >= 0; --i) {
                if (comparePos(resultArray[i].loc.end,
                               node.loc.start) <= 0) {
                    break;
                }
            }
            resultArray.splice(i + 1, 0, node);
            return;
        }
    } else if (node[childNodesCacheKey]) {
        return node[childNodesCacheKey];
    }

    var names;
    if (isArray.check(node)) {
        names = Object.keys(node);
    } else if (isObject.check(node)) {
        names = types.getFieldNames(node);
    } else {
        return;
    }

    if (!resultArray) {
        Object.defineProperty(node, childNodesCacheKey, {
            value: resultArray = [],
            enumerable: false
        });
    }

    for (var i = 0, nameCount = names.length; i < nameCount; ++i) {
        getSortedChildNodes(node[names[i]], lines, resultArray);
    }

    return resultArray;
}

// As efficiently as possible, decorate the comment object with
// .precedingNode, .enclosingNode, and/or .followingNode properties, at
// least one of which is guaranteed to be defined.
function decorateComment(node, comment, lines) {
    var childNodes = getSortedChildNodes(node, lines);

    // Time to dust off the old binary search robes and wizard hat.
    var left = 0, right = childNodes.length;
    while (left < right) {
        var middle = (left + right) >> 1;
        var child = childNodes[middle];

        if (comparePos(child.loc.start, comment.loc.start) <= 0 &&
            comparePos(comment.loc.end, child.loc.end) <= 0) {
            // The comment is completely contained by this child node.
            decorateComment(comment.enclosingNode = child, comment, lines);
            return; // Abandon the binary search at this level.
        }

        if (comparePos(child.loc.end, comment.loc.start) <= 0) {
            // This child node falls completely before the comment.
            // Because we will never consider this node or any nodes
            // before it again, this node must be the closest preceding
            // node we have encountered so far.
            var precedingNode = child;
            left = middle + 1;
            continue;
        }

        if (comparePos(comment.loc.end, child.loc.start) <= 0) {
            // This child node falls completely after the comment.
            // Because we will never consider this node or any nodes after
            // it again, this node must be the closest following node we
            // have encountered so far.
            var followingNode = child;
            right = middle;
            continue;
        }

        return;
        throw new Error("Comment location overlaps with node location");
    }

    if (precedingNode) {
        comment.precedingNode = precedingNode;
    }

    if (followingNode) {
        comment.followingNode = followingNode;
    }
}

exports.attach = function(comments, ast, lines) {
    if (!isArray.check(comments)) {
        return;
    }

    var tiesToBreak = [];

    comments.forEach(function(comment) {
        comment.loc.lines = lines;
        decorateComment(ast, comment, lines);

        var pn = comment.precedingNode;
        var en = comment.enclosingNode;
        var fn = comment.followingNode;

        if (pn && fn) {
            var tieCount = tiesToBreak.length;
            if (tieCount > 0) {
                var lastTie = tiesToBreak[tieCount - 1];

                assert.strictEqual(
                    lastTie.precedingNode === comment.precedingNode,
                    lastTie.followingNode === comment.followingNode
                );

                if (lastTie.followingNode !== comment.followingNode) {
                    breakTies(tiesToBreak, lines);
                }
            }

            tiesToBreak.push(comment);

        } else if (pn) {
            // No contest: we have a trailing comment.
            breakTies(tiesToBreak, lines);
            addTrailingComment(pn, comment);

        } else if (fn) {
            // No contest: we have a leading comment.
            breakTies(tiesToBreak, lines);
            addLeadingComment(fn, comment);

        } else if (en) {
            // The enclosing node has no child nodes at all, so what we
            // have here is a dangling comment, e.g. [/* crickets */].
            breakTies(tiesToBreak, lines);
            addDanglingComment(en, comment);

        } else if (0) {
            throw new Error("AST contains no nodes at all?");
        }
    });

    breakTies(tiesToBreak, lines);

    comments.forEach(function(comment) {
        // These node references were useful for breaking ties, but we
        // don't need them anymore, and they create cycles in the AST that
        // may lead to infinite recursion if we don't delete them here.
        delete comment.precedingNode;
        delete comment.enclosingNode;
        delete comment.followingNode;
    });
};

function breakTies(tiesToBreak, lines) {
    var tieCount = tiesToBreak.length;
    if (tieCount === 0) {
        return;
    }

    var pn = tiesToBreak[0].precedingNode;
    var fn = tiesToBreak[0].followingNode;
    var gapEndPos = fn.loc.start;

    // Iterate backwards through tiesToBreak, examining the gaps
    // between the tied comments. In order to qualify as leading, a
    // comment must be separated from fn by an unbroken series of
    // whitespace-only gaps (or other comments).
    for (var indexOfFirstLeadingComment = tieCount;
         indexOfFirstLeadingComment > 0;
         --indexOfFirstLeadingComment) {
        var comment = tiesToBreak[indexOfFirstLeadingComment - 1];
        assert.strictEqual(comment.precedingNode, pn);
        assert.strictEqual(comment.followingNode, fn);

        var gap = lines.sliceString(comment.loc.end, gapEndPos);
        if (/\S/.test(gap)) {
            // The gap string contained something other than whitespace.
            break;
        }

        gapEndPos = comment.loc.start;
    }

    while (indexOfFirstLeadingComment <= tieCount &&
           (comment = tiesToBreak[indexOfFirstLeadingComment]) &&
           // If the comment is a //-style comment and indented more
           // deeply than the node itself, reconsider it as trailing.
           (comment.type === "Line" || comment.type === "CommentLine") &&
           comment.loc.start.column > fn.loc.start.column) {
        ++indexOfFirstLeadingComment;
    }

    tiesToBreak.forEach(function(comment, i) {
        if (i < indexOfFirstLeadingComment) {
            addTrailingComment(pn, comment);
        } else {
            addLeadingComment(fn, comment);
        }
    });

    tiesToBreak.length = 0;
}

function addCommentHelper(node, comment) {
    var comments = node.comments || (node.comments = []);
    comments.push(comment);
}

function addLeadingComment(node, comment) {
    comment.leading = true;
    comment.trailing = false;
    addCommentHelper(node, comment);
}

function addDanglingComment(node, comment) {
    comment.leading = false;
    comment.trailing = false;
    addCommentHelper(node, comment);
}

function addTrailingComment(node, comment) {
    comment.leading = false;
    comment.trailing = true;
    addCommentHelper(node, comment);
}

function printLeadingComment(commentPath, print) {
    var comment = commentPath.getValue();
    n.Comment.assert(comment);

    var loc = comment.loc;
    var lines = loc && loc.lines;
    var parts = [print(commentPath)];

    if (comment.trailing) {
        // When we print trailing comments as leading comments, we don't
        // want to bring any trailing spaces along.
        parts.push("\n");

    } else if (lines instanceof Lines) {
        var trailingSpace = lines.slice(
            loc.end,
            lines.skipSpaces(loc.end)
        );

        if (trailingSpace.length === 1) {
            // If the trailing space contains no newlines, then we want to
            // preserve it exactly as we found it.
            parts.push(trailingSpace);
        } else {
            // If the trailing space contains newlines, then replace it
            // with just that many newlines, with all other spaces removed.
            parts.push(new Array(trailingSpace.length).join("\n"));
        }
    } else {
        parts.push("\n");
    }

    return parts;
}

function printTrailingComment(commentPath, print) {
    var comment = commentPath.getValue(commentPath);
    n.Comment.assert(comment);

    var loc = comment.loc;
    var lines = loc && loc.lines;
    var parts = [];

    if (lines instanceof Lines) {
        var fromPos = lines.skipSpaces(loc.start, true) || lines.firstPos();
        var leadingSpace = lines.slice(fromPos, loc.start);

        if (leadingSpace.length === 1) {
            // If the leading space contains no newlines, then we want to
            // preserve it exactly as we found it.
            parts.push(leadingSpace);
        } else {
            // If the leading space contains newlines, then replace it
            // with just that many newlines, sans all other spaces.
            parts.push(new Array(leadingSpace.length).join("\n"));
        }
    }

    parts.push(print(commentPath));

    return parts;
}

exports.printComments = function(path, options, print) {
    var value = path.getValue();
    var innerLines = print(path);
    var comments = n.Node.check(value) &&
        types.getFieldValue(value, "comments");

    if (!comments || comments.length === 0) {
        return innerLines;
    }

    var leadingParts = [];
    var trailingParts = [];

    /*
     * HOTFIX 1: repair comment within an otherwise empty BlockStatement.
     * Example:
     *     { 
     *       // TODO
     *     }
     * Would otherwise print the 'trailing comment' "TODO" *after* the closing '}' brace.
     */
    var hotfixCommentInEmptyBlock = 0;
    if (innerLines.length === 1) {
        var str = innerLines.toString();
        if (str === "{}") {
            hotfixCommentInEmptyBlock = 1;
        }
    }

    path.each(function(commentPath) {
        var comment = commentPath.getValue();
        var leading = types.getFieldValue(comment, "leading");
        var trailing = types.getFieldValue(comment, "trailing");

        if (leading || (trailing && !(n.Statement.check(value) ||
                                      comment.type === "Line" ||
                                      comment.type === "Block" ||
                                      comment.type === "CommentBlock"))) {
            leadingParts.push(concat(printLeadingComment(commentPath, print)));
        } else /* if (trailing) */ {
            if (hotfixCommentInEmptyBlock === 1) {
                trailingParts.push("{");
                hotfixCommentInEmptyBlock = 2;
            }
            var cmt = printTrailingComment(commentPath, print);
            if (!hotfixCommentInEmptyBlock && comment.type === "Line") {
                // HOTFIX 2: Part One
                //
                // Mark up the start and end of LINE-comments,
                // so the caller can detect one dangling and thus obscuring
                // a comma, semicolon or other character being appended
                // at the end of the CODE LINE then.
                cmt.unshift(options.STX);
                cmt.push(options.ETX);
            }
            cmt = concat(cmt);
            if (hotfixCommentInEmptyBlock) {
                cmt = cmt.indent(options.tabWidth);
            }
            trailingParts.push(cmt);
        }
    }, "comments");

    if (hotfixCommentInEmptyBlock === 2) {
        trailingParts.push("\n}");
    } else {
        trailingParts.unshift(innerLines);
    }
    leadingParts.push.apply(leadingParts, trailingParts);
    return concat(leadingParts);
};

},{"./lines":33,"./types":39,"./util":40,"assert":72,"private":62}],32:[function(require,module,exports){
var assert = require("assert");
var types = require("./types");
var n = types.namedTypes;
var Node = n.Node;
var isArray = types.builtInTypes.array;
var isNumber = types.builtInTypes.number;

function FastPath(value) {
  assert.ok(this instanceof FastPath);
  this.stack = [value];
}

var FPp = FastPath.prototype;
module.exports = FastPath;

// Static convenience function for coercing a value to a FastPath.
FastPath.from = function(obj) {
  if (obj instanceof FastPath) {
    // Return a defensive copy of any existing FastPath instances.
    return obj.copy();
  }

  if (obj instanceof types.NodePath) {
    // For backwards compatibility, unroll NodePath instances into
    // lightweight FastPath [..., name, value] stacks.
    var copy = Object.create(FastPath.prototype);
    var stack = [obj.value];
    for (var pp; (pp = obj.parentPath); obj = pp)
      stack.push(obj.name, pp.value);
    copy.stack = stack.reverse();
    return copy;
  }

  // Otherwise use obj as the value of the new FastPath instance.
  return new FastPath(obj);
};

FPp.copy = function copy() {
  var copy = Object.create(FastPath.prototype);
  copy.stack = this.stack.slice(0);
  return copy;
};

// The name of the current property is always the penultimate element of
// this.stack, and always a String.
FPp.getName = function getName() {
  var s = this.stack;
  var len = s.length;
  if (len > 1) {
    return s[len - 2];
  }
  // Since the name is always a string, null is a safe sentinel value to
  // return if we do not know the name of the (root) value.
  return null;
};

// The value of the current property is always the final element of
// this.stack.
FPp.getValue = function getValue() {
  var s = this.stack;
  return s[s.length - 1];
};

FPp.valueIsDuplicate = function () {
  var s = this.stack;
  var valueIndex = s.length - 1;
  return s.lastIndexOf(s[valueIndex], valueIndex - 1) >= 0;
};

function getNodeHelper(path, count) {
  var s = path.stack;

  for (var i = s.length - 1; i >= 0; i -= 2) {
    var value = s[i];
    if (n.Node.check(value) && --count < 0) {
      return value;
    }
  }

  return null;
}

FPp.getNode = function getNode(count) {
  return getNodeHelper(this, ~~count);
};

FPp.getParentNode = function getParentNode(count) {
  return getNodeHelper(this, ~~count + 1);
};

// The length of the stack can be either even or odd, depending on whether
// or not we have a name for the root value. The difference between the
// index of the root value and the index of the final value is always
// even, though, which allows us to return the root value in constant time
// (i.e. without iterating backwards through the stack).
FPp.getRootValue = function getRootValue() {
  var s = this.stack;
  if (s.length % 2 === 0) {
    return s[1];
  }
  return s[0];
};

// Temporarily push properties named by string arguments given after the
// callback function onto this.stack, then call the callback with a
// reference to this (modified) FastPath object. Note that the stack will
// be restored to its original state after the callback is finished, so it
// is probably a mistake to retain a reference to the path.
FPp.call = function call(callback/*, name1, name2, ... */) {
  var s = this.stack;
  var origLen = s.length;
  var value = s[origLen - 1];
  var argc = arguments.length;
  for (var i = 1; i < argc; ++i) {
    var name = arguments[i];
    value = value[name];
    s.push(name, value);
  }
  var result = callback(this);
  s.length = origLen;
  return result;
};

// Similar to FastPath.prototype.call, except that the value obtained by
// accessing this.getValue()[name1][name2]... should be array-like. The
// callback will be called with a reference to this path object for each
// element of the array.
FPp.each = function each(callback/*, name1, name2, ... */) {
  var s = this.stack;
  var origLen = s.length;
  var value = s[origLen - 1];
  var argc = arguments.length;

  for (var i = 1; i < argc; ++i) {
    var name = arguments[i];
    value = value[name];
    s.push(name, value);
  }

  for (var i = 0; i < value.length; ++i) {
    if (i in value) {
      s.push(i, value[i]);
      // If the callback needs to know the value of i, call
      // path.getName(), assuming path is the parameter name.
      callback(this);
      s.length -= 2;
    }
  }

  s.length = origLen;
};

// Similar to FastPath.prototype.each, except that the results of the
// callback function invocations are stored in an array and returned at
// the end of the iteration.
FPp.map = function map(callback/*, name1, name2, ... */) {
  var s = this.stack;
  var origLen = s.length;
  var value = s[origLen - 1];
  var argc = arguments.length;

  for (var i = 1; i < argc; ++i) {
    var name = arguments[i];
    value = value[name];
    s.push(name, value);
  }

  var result = new Array(value.length);

  for (var i = 0; i < value.length; ++i) {
    if (i in value) {
      s.push(i, value[i]);
      result[i] = callback(this, i);
      s.length -= 2;
    }
  }

  s.length = origLen;

  return result;
};

// Inspired by require("ast-types").NodePath.prototype.needsParens, but
// more efficient because we're iterating backwards through a stack.
FPp.needsParens = function(assumeExpressionContext) {
  var node = this.getNode();

  // This needs to come before `if (!parent) { return false }` because
  // an object destructuring assignment requires parens for
  // correctness even when it's the topmost expression.
  if (node.type === "AssignmentExpression" && node.left.type === 'ObjectPattern') {
    return true;
  }

  var parent = this.getParentNode();
  if (!parent) {
    return false;
  }

  var name = this.getName();

  // If the value of this path is some child of a Node and not a Node
  // itself, then it doesn't need parentheses. Only Node objects (in fact,
  // only Expression nodes) need parentheses.
  if (this.getValue() !== node) {
    return false;
  }

  // Only statements don't need parentheses.
  if (n.Statement.check(node)) {
    return false;
  }

  // Identifiers never need parentheses.
  if (node.type === "Identifier") {
    return false;
  }

  if (parent.type === "ParenthesizedExpression") {
    return false;
  }

  switch (node.type) {
  case "UnaryExpression":
  case "SpreadElement":
  case "SpreadProperty":
    return parent.type === "MemberExpression"
      && name === "object"
      && parent.object === node;

  case "BinaryExpression":
  case "LogicalExpression":
    switch (parent.type) {
    case "CallExpression":
      return name === "callee"
        && parent.callee === node;

    case "UnaryExpression":
    case "SpreadElement":
    case "SpreadProperty":
      return true;

    case "MemberExpression":
      return name === "object"
        && parent.object === node;

    case "BinaryExpression":
    case "LogicalExpression":
      var po = parent.operator;
      var pp = PRECEDENCE[po];
      var no = node.operator;
      var np = PRECEDENCE[no];

      if (pp > np) {
        return true;
      }

      if (pp === np && name === "right") {
        assert.strictEqual(parent.right, node);
        return true;
      }

    default:
      return false;
    }

  case "SequenceExpression":
    switch (parent.type) {
    case "ReturnStatement":
      return false;

    case "ForStatement":
      // Although parentheses wouldn't hurt around sequence expressions in
      // the head of for loops, traditional style dictates that e.g. i++,
      // j++ should not be wrapped with parentheses.
      return false;

    case "ExpressionStatement":
      return name !== "expression";

    default:
      // Otherwise err on the side of overparenthesization, adding
      // explicit exceptions above if this proves overzealous.
      return true;
    }

  case "YieldExpression":
    switch (parent.type) {
    case "BinaryExpression":
    case "LogicalExpression":
    case "UnaryExpression":
    case "SpreadElement":
    case "SpreadProperty":
    case "CallExpression":
    case "MemberExpression":
    case "NewExpression":
    case "ConditionalExpression":
    case "YieldExpression":
      return true;

    default:
      return false;
    }

  case "IntersectionTypeAnnotation":
  case "UnionTypeAnnotation":
    return parent.type === "NullableTypeAnnotation";

  case "Literal":
    return parent.type === "MemberExpression"
      && isNumber.check(node.value)
      && name === "object"
      && parent.object === node;

  // Babel 6 Literal split
  case "NumericLiteral":
    return parent.type === "MemberExpression"
      && name === "object"
      && parent.object === node;

  case "AssignmentExpression":
  case "ConditionalExpression":
    switch (parent.type) {
    case "UnaryExpression":
    case "SpreadElement":
    case "SpreadProperty":
    case "BinaryExpression":
    case "LogicalExpression":
      return true;

    case "CallExpression":
      return name === "callee"
        && parent.callee === node;

    case "ConditionalExpression":
      return name === "test"
        && parent.test === node;

    case "MemberExpression":
      return name === "object"
        && parent.object === node;

    default:
      return false;
    }

  case "ArrowFunctionExpression":
    if(n.CallExpression.check(parent) && name === 'callee') {
      return true;
    }
    if(n.MemberExpression.check(parent) && name === 'object') {
      return true;
    }

    return isBinary(parent);

  case "ObjectExpression":
    if (parent.type === "ArrowFunctionExpression" &&
        name === "body") {
      return true;
    }

  default:
    if (parent.type === "NewExpression" &&
        name === "callee" &&
        parent.callee === node) {
      return containsCallExpression(node);
    }
  }

  if (assumeExpressionContext !== true &&
      !this.canBeFirstInStatement() &&
      this.firstInStatement())
    return true;

  return false;
};

function isBinary(node) {
  return n.BinaryExpression.check(node)
    || n.LogicalExpression.check(node);
}

function isUnaryLike(node) {
  return n.UnaryExpression.check(node)
  // I considered making SpreadElement and SpreadProperty subtypes of
  // UnaryExpression, but they're not really Expression nodes.
    || (n.SpreadElement && n.SpreadElement.check(node))
    || (n.SpreadProperty && n.SpreadProperty.check(node));
}

var PRECEDENCE = {};
[
  ["||"],
  ["&&"],
  ["|"],
  ["^"],
  ["&"],
  ["==", "===", "!=", "!=="],
  ["<", ">", "<=", ">=", "in", "instanceof"],
  [">>", "<<", ">>>"],
  ["+", "-"],
  ["*", "/", "%"],
  ["**"]
].forEach(function(tier, i) {
  tier.forEach(function(op) {
    PRECEDENCE[op] = i;
  });
});

function containsCallExpression(node) {
  if (n.CallExpression.check(node)) {
    return true;
  }

  if (isArray.check(node)) {
    return node.some(containsCallExpression);
  }

  if (n.Node.check(node)) {
    return types.someField(node, function(name, child) {
      return containsCallExpression(child);
    });
  }

  return false;
}

FPp.canBeFirstInStatement = function() {
  var node = this.getNode();
  return !n.FunctionExpression.check(node)
    && !n.ObjectExpression.check(node);
};

FPp.firstInStatement = function() {
  var s = this.stack;
  var parentName, parent;
  var childName, child;

  for (var i = s.length - 1; i >= 0; i -= 2) {
    if (n.Node.check(s[i])) {
      childName = parentName;
      child = parent;
      parentName = s[i - 1];
      parent = s[i];
    }

    if (!parent || !child) {
      continue;
    }

    if (n.BlockStatement.check(parent) &&
        parentName === "body" &&
        childName === 0) {
      assert.strictEqual(parent.body[0], child);
      return true;
    }

    if (n.ExpressionStatement.check(parent) &&
        childName === "expression") {
      assert.strictEqual(parent.expression, child);
      return true;
    }

    if (n.SequenceExpression.check(parent) &&
        parentName === "expressions" &&
        childName === 0) {
      assert.strictEqual(parent.expressions[0], child);
      continue;
    }

    if (n.CallExpression.check(parent) &&
        childName === "callee") {
      assert.strictEqual(parent.callee, child);
      continue;
    }

    if (n.MemberExpression.check(parent) &&
        childName === "object") {
      assert.strictEqual(parent.object, child);
      continue;
    }

    if (n.ConditionalExpression.check(parent) &&
        childName === "test") {
      assert.strictEqual(parent.test, child);
      continue;
    }

    if (isBinary(parent) &&
        childName === "left") {
      assert.strictEqual(parent.left, child);
      continue;
    }

    if (n.UnaryExpression.check(parent) &&
        !parent.prefix &&
        childName === "argument") {
      assert.strictEqual(parent.argument, child);
      continue;
    }

    return false;
  }

  return true;
};

},{"./types":39,"assert":72}],33:[function(require,module,exports){
var assert = require("assert");
var sourceMap = require("source-map");
var normalizeOptions = require("./options").normalize;
var secretKey = require("private").makeUniqueKey();
var types = require("./types");
var isString = types.builtInTypes.string;
var comparePos = require("./util").comparePos;
var Mapping = require("./mapping");

// Goals:
// 1. Minimize new string creation.
// 2. Keep (de)identation O(lines) time.
// 3. Permit negative indentations.
// 4. Enforce immutability.
// 5. No newline characters.

var useSymbol = typeof Symbol === "function";
var secretKey = "recastLinesSecret";
if (useSymbol) {
  secretKey = Symbol.for(secretKey);
}

function getSecret(lines) {
  return lines[secretKey];
}

function Lines(infos, sourceFileName) {
  assert.ok(this instanceof Lines);
  assert.ok(infos.length > 0);

  if (sourceFileName) {
    isString.assert(sourceFileName);
  } else {
    sourceFileName = null;
  }

  setSymbolOrKey(this, secretKey, {
    infos: infos,
    mappings: [],
    name: sourceFileName,
    cachedSourceMap: null
  });

  this.length = infos.length;
  this.name = sourceFileName;

  if (sourceFileName) {
    getSecret(this).mappings.push(new Mapping(this, {
      start: this.firstPos(),
      end: this.lastPos()
    }));
  }
}

function setSymbolOrKey(obj, key, value) {
  if (useSymbol) {
    return obj[key] = value;
  }

  Object.defineProperty(obj, key, {
    value: value,
    enumerable: false,
    writable: false,
    configurable: true
  });

  return value;
}

// Exposed for instanceof checks. The fromString function should be used
// to create new Lines objects.
exports.Lines = Lines;
var Lp = Lines.prototype;

function copyLineInfo(info) {
  return {
    line: info.line,
    indent: info.indent,
    locked: info.locked,
    sliceStart: info.sliceStart,
    sliceEnd: info.sliceEnd
  };
}

var fromStringCache = {};
var hasOwn = fromStringCache.hasOwnProperty;
var maxCacheKeyLen = 10;

function countSpaces(spaces, tabWidth) {
  var count = 0;
  var len = spaces.length;

  for (var i = 0; i < len; ++i) {
    switch (spaces.charCodeAt(i)) {
    case 9: // '\t'
      assert.strictEqual(typeof tabWidth, "number");
      assert.ok(tabWidth > 0);

      var next = Math.ceil(count / tabWidth) * tabWidth;
      if (next === count) {
        count += tabWidth;
      } else {
        count = next;
      }

      break;

    case 11: // '\v'
    case 12: // '\f'
    case 13: // '\r'
    case 0xfeff: // zero-width non-breaking space
      // These characters contribute nothing to indentation.
      break;

    case 32: // ' '
    default: // Treat all other whitespace like ' '.
      count += 1;
      break;
    }
  }

  return count;
}
exports.countSpaces = countSpaces;

var leadingSpaceExp = /^\s*/;

// As specified here: http://www.ecma-international.org/ecma-262/6.0/#sec-line-terminators
var lineTerminatorSeqExp =
  /\u000D\u000A|\u000D(?!\u000A)|\u000A|\u2028|\u2029/;

/**
 * @param {Object} options - Options object that configures printing.
 */
function fromString(string, options) {
  if (string instanceof Lines)
    return string;

  string += "";

  var tabWidth = options && options.tabWidth;
  var tabless = string.indexOf("\t") < 0;
  var locked = !! (options && options.locked);
  var cacheable = !options && tabless && (string.length <= maxCacheKeyLen);
  var nukeMultiIndent = options && options.nukeMultiIndent;

  assert.ok(tabWidth || tabless, "No tab width specified but encountered tabs in string\n" + string);

  if (cacheable && hasOwn.call(fromStringCache, string))
    return fromStringCache[string];

  var ls = string.split(lineTerminatorSeqExp);
  ls = ls.map(function(line, index) {
    var spaces = leadingSpaceExp.exec(line)[0];
    return {
      line: line,
      carriesContent: line.length - spaces.length,
      indent: countSpaces(spaces, tabWidth),
      // Boolean indicating whether this line can be reindented.
      locked: locked,
      sliceStart: spaces.length,
      sliceEnd: line.length
    };
  });
  var line1_indent = 0;
  var common_lead = 0;
  if (nukeMultiIndent && ls.length >= 2) {
    // now strip off the common leading spaces' width:
    common_lead = ls[1].indent;

    var c = ls[1].line[common_lead];
    /*
     * detect 'boxed' comments like this one, i.e. multi-line comments which have
     * their every line prefixed with the same 'box character'.
     * We don't hardcode this prefix to be "*" but assume the entire 'box' has
     * the same prefix character, whatever it is. This approach is at least
     * good enough to detect and properly format JSDoc/etc. 'API documentation'
     * comment chunks and comments like the one you're reading right now.
     */
    var is_box_format = c;

    // detect the common leading length:    
    ls.forEach(function (line, index) {
      if (index === 0 && line.carriesContent) {
        line1_indent = line.indent; 
      }
      if (index > 0) {
        if (line.carriesContent) {
          common_lead = Math.min(common_lead, line.indent);
          var c = line.line[common_lead];
          if (is_box_format && is_box_format !== c) {
            is_box_format = false;
          }
        } else if (index < ls.length - 1) {
          // tolerate only a 'content-less line' as the last one: 
          // that one is very probably the end-of-comment marker on a line alone!
          is_box_format = false;
        }
      }
    });
    
    if (is_box_format && line1_indent === 0) {
      line1_indent = 1;
    }

    // and apply it:
    ls.forEach(function (line, index) {
      if (index > 0) {
        line.indent = Math.max(line1_indent, line.indent - common_lead);
      }
    });
  }

  var lines = new Lines(ls, normalizeOptions(options).sourceFileName);

  if (cacheable)
    fromStringCache[string] = lines;

  return lines;
}
exports.fromString = fromString;

function isOnlyWhitespace(string) {
  return !/\S/.test(string);
}

Lp.toString = function(options) {
  return this.sliceString(this.firstPos(), this.lastPos(), options);
};

Lp.getSourceMap = function(sourceMapName, sourceRoot) {
  if (!sourceMapName) {
    // Although we could make up a name or generate an anonymous
    // source map, instead we assume that any consumer who does not
    // provide a name does not actually want a source map.
    return null;
  }

  var targetLines = this;

  function updateJSON(json) {
    json = json || {};

    isString.assert(sourceMapName);
    json.file = sourceMapName;

    if (sourceRoot) {
      isString.assert(sourceRoot);
      json.sourceRoot = sourceRoot;
    }

    return json;
  }

  var secret = getSecret(targetLines);
  if (secret.cachedSourceMap) {
    // Since Lines objects are immutable, we can reuse any source map
    // that was previously generated. Nevertheless, we return a new
    // JSON object here to protect the cached source map from outside
    // modification.
    return updateJSON(secret.cachedSourceMap.toJSON());
  }

  var smg = new sourceMap.SourceMapGenerator(updateJSON());
  var sourcesToContents = {};

  secret.mappings.forEach(function(mapping) {
    var sourceCursor = mapping.sourceLines.skipSpaces(
      mapping.sourceLoc.start
    ) || mapping.sourceLines.lastPos();

    var targetCursor = targetLines.skipSpaces(
      mapping.targetLoc.start
    ) || targetLines.lastPos();

    while (comparePos(sourceCursor, mapping.sourceLoc.end) < 0 &&
           comparePos(targetCursor, mapping.targetLoc.end) < 0) {

      var sourceChar = mapping.sourceLines.charAt(sourceCursor);
      var targetChar = targetLines.charAt(targetCursor);
      assert.strictEqual(sourceChar, targetChar);

      var sourceName = mapping.sourceLines.name;

      // Add mappings one character at a time for maximum resolution.
      smg.addMapping({
        source: sourceName,
        original: { line: sourceCursor.line,
                    column: sourceCursor.column },
        generated: { line: targetCursor.line,
                     column: targetCursor.column }
      });

      if (!hasOwn.call(sourcesToContents, sourceName)) {
        var sourceContent = mapping.sourceLines.toString();
        smg.setSourceContent(sourceName, sourceContent);
        sourcesToContents[sourceName] = sourceContent;
      }

      targetLines.nextPos(targetCursor, true);
      mapping.sourceLines.nextPos(sourceCursor, true);
    }
  });

  secret.cachedSourceMap = smg;

  return smg.toJSON();
};

Lp.bootstrapCharAt = function(pos) {
  assert.strictEqual(typeof pos, "object");
  assert.strictEqual(typeof pos.line, "number");
  assert.strictEqual(typeof pos.column, "number");

  var line = pos.line,
  column = pos.column,
  strings = this.toString().split(lineTerminatorSeqExp),
  string = strings[line - 1];

  if (typeof string === "undefined")
    return "";

  if (column === string.length &&
      line < strings.length)
    return "\n";

  if (column >= string.length)
    return "";

  return string.charAt(column);
};

Lp.charAt = function(pos) {
  assert.strictEqual(typeof pos, "object");
  assert.strictEqual(typeof pos.line, "number");
  assert.strictEqual(typeof pos.column, "number");

  var line = pos.line,
  column = pos.column,
  secret = getSecret(this),
  infos = secret.infos,
  info = infos[line - 1],
  c = column;

  if (typeof info === "undefined" || c < 0)
    return "";

  var indent = this.getIndentAt(line);
  if (c < indent)
    return " ";

  c += info.sliceStart - indent;

  if (c === info.sliceEnd &&
      line < this.length)
    return "\n";

  if (c >= info.sliceEnd)
    return "";

  return info.line.charAt(c);
};

Lp.stripMargin = function(width, skipFirstLine) {
  if (width === 0)
    return this;

  assert.ok(width > 0, "negative margin: " + width);

  if (skipFirstLine && this.length === 1)
    return this;

  var secret = getSecret(this);

  var lines = new Lines(secret.infos.map(function(info, i) {
    if (info.line && (i > 0 || !skipFirstLine)) {
      info = copyLineInfo(info);
      info.indent = Math.max(0, info.indent - width);
    }
    return info;
  }));

  if (secret.mappings.length > 0) {
    var newMappings = getSecret(lines).mappings;
    assert.strictEqual(newMappings.length, 0);
    secret.mappings.forEach(function(mapping) {
      newMappings.push(mapping.indent(width, skipFirstLine, true));
    });
  }

  return lines;
};

Lp.indent = function(by) {
  if (by === 0)
    return this;

  var secret = getSecret(this);

  var lines = new Lines(secret.infos.map(function(info) {
    if (info.line && ! info.locked) {
      info = copyLineInfo(info);
      info.indent += by;
    }
    return info
  }));

  if (secret.mappings.length > 0) {
    var newMappings = getSecret(lines).mappings;
    assert.strictEqual(newMappings.length, 0);
    secret.mappings.forEach(function(mapping) {
      newMappings.push(mapping.indent(by));
    });
  }

  return lines;
};

Lp.indentTail = function(by) {
  if (by === 0)
    return this;

  if (this.length < 2)
    return this;

  var secret = getSecret(this);

  var lines = new Lines(secret.infos.map(function(info, i) {
    if (i > 0 && info.line && ! info.locked) {
      info = copyLineInfo(info);
      info.indent += by;
    }

    return info;
  }));

  if (secret.mappings.length > 0) {
    var newMappings = getSecret(lines).mappings;
    assert.strictEqual(newMappings.length, 0);
    secret.mappings.forEach(function(mapping) {
      newMappings.push(mapping.indent(by, true));
    });
  }

  return lines;
};

Lp.lockIndentTail = function () {
  if (this.length < 2) {
    return this;
  }

  var infos = getSecret(this).infos;

  return new Lines(infos.map(function (info, i) {
    info = copyLineInfo(info);
    info.locked = i > 0;
    return info;
  }));
};

Lp.getIndentAt = function(line) {
  assert.ok(line >= 1, "no line " + line + " (line numbers start from 1)");
  var secret = getSecret(this),
  info = secret.infos[line - 1];
  return Math.max(info.indent, 0);
};

Lp.guessTabWidth = function() {
  var secret = getSecret(this);
  if (hasOwn.call(secret, "cachedTabWidth")) {
    return secret.cachedTabWidth;
  }

  var counts = []; // Sparse array.
  var lastIndent = 0;

  for (var line = 1, last = this.length; line <= last; ++line) {
    var info = secret.infos[line - 1];
    var sliced = info.line.slice(info.sliceStart, info.sliceEnd);

    // Whitespace-only lines don't tell us much about the likely tab
    // width of this code.
    if (isOnlyWhitespace(sliced)) {
      continue;
    }

    var diff = Math.abs(info.indent - lastIndent);
    counts[diff] = ~~counts[diff] + 1;
    lastIndent = info.indent;
  }

  var maxCount = -1;
  var result = 2;

  for (var tabWidth = 1;
       tabWidth < counts.length;
       tabWidth += 1) {
    if (hasOwn.call(counts, tabWidth) &&
        counts[tabWidth] > maxCount) {
      maxCount = counts[tabWidth];
      result = tabWidth;
    }
  }

  return secret.cachedTabWidth = result;
};

// Determine if the list of lines has a first line that starts with a //
// or /* comment. If this is the case, the code may need to be wrapped in
// parens to avoid ASI issues.
Lp.startsWithComment = function () {
  var secret = getSecret(this);
  if (secret.infos.length === 0) {
    return false;
  }
  var firstLineInfo = secret.infos[0],
  sliceStart = firstLineInfo.sliceStart,
  sliceEnd = firstLineInfo.sliceEnd,
  firstLine = firstLineInfo.line.slice(sliceStart, sliceEnd).trim();
  return firstLine.length === 0 ||
    firstLine.slice(0, 2) === "//" ||
    firstLine.slice(0, 2) === "/*";
};

Lp.isOnlyWhitespace = function() {
  return isOnlyWhitespace(this.toString());
};

Lp.isPrecededOnlyByWhitespace = function(pos) {
  var secret = getSecret(this);
  var info = secret.infos[pos.line - 1];
  var indent = Math.max(info.indent, 0);

  var diff = pos.column - indent;
  if (diff <= 0) {
    // If pos.column does not exceed the indentation amount, then
    // there must be only whitespace before it.
    return true;
  }

  var start = info.sliceStart;
  var end = Math.min(start + diff, info.sliceEnd);
  var prefix = info.line.slice(start, end);

  return isOnlyWhitespace(prefix);
};

Lp.getLineLength = function(line) {
  var secret = getSecret(this),
  info = secret.infos[line - 1];
  return this.getIndentAt(line) + info.sliceEnd - info.sliceStart;
};

Lp.nextPos = function(pos, skipSpaces) {
  var l = Math.max(pos.line, 0),
  c = Math.max(pos.column, 0);

  if (c < this.getLineLength(l)) {
    pos.column += 1;

    return skipSpaces
      ? !!this.skipSpaces(pos, false, true)
      : true;
  }

  if (l < this.length) {
    pos.line += 1;
    pos.column = 0;

    return skipSpaces
      ? !!this.skipSpaces(pos, false, true)
      : true;
  }

  return false;
};

Lp.prevPos = function(pos, skipSpaces) {
  var l = pos.line,
  c = pos.column;

  if (c < 1) {
    l -= 1;

    if (l < 1)
      return false;

    c = this.getLineLength(l);

  } else {
    c = Math.min(c - 1, this.getLineLength(l));
  }

  pos.line = l;
  pos.column = c;

  return skipSpaces
    ? !!this.skipSpaces(pos, true, true)
    : true;
};

Lp.firstPos = function() {
  // Trivial, but provided for completeness.
  return { line: 1, column: 0 };
};

Lp.lastPos = function() {
  return {
    line: this.length,
    column: this.getLineLength(this.length)
  };
};

Lp.skipSpaces = function(pos, backward, modifyInPlace) {
  if (pos) {
    pos = modifyInPlace ? pos : {
      line: pos.line,
      column: pos.column
    };
  } else if (backward) {
    pos = this.lastPos();
  } else {
    pos = this.firstPos();
  }

  if (backward) {
    while (this.prevPos(pos)) {
      if (!isOnlyWhitespace(this.charAt(pos)) &&
          this.nextPos(pos)) {
        return pos;
      }
    }

    return null;
  } else {
    while (isOnlyWhitespace(this.charAt(pos))) {
      if (!this.nextPos(pos)) {
        return null;
      }
    }

    return pos;
  }
};

Lp.trimLeft = function() {
  var pos = this.skipSpaces(this.firstPos(), false, true);
  return pos ? this.slice(pos) : emptyLines;
};

Lp.trimRight = function() {
  var pos = this.skipSpaces(this.lastPos(), true, true);
  return pos ? this.slice(this.firstPos(), pos) : emptyLines;
};

Lp.trim = function() {
  var start = this.skipSpaces(this.firstPos(), false, true);
  if (start === null)
    return emptyLines;

  var end = this.skipSpaces(this.lastPos(), true, true);
  assert.notStrictEqual(end, null);

  return this.slice(start, end);
};

Lp.eachPos = function(callback, startPos, skipSpaces) {
  var pos = this.firstPos();

  if (startPos) {
    pos.line = startPos.line,
    pos.column = startPos.column
  }

  if (skipSpaces && !this.skipSpaces(pos, false, true)) {
    return; // Encountered nothing but spaces.
  }

  do callback.call(this, pos);
  while (this.nextPos(pos, skipSpaces));
};

Lp.bootstrapSlice = function(start, end) {
  var strings = this.toString().split(
    lineTerminatorSeqExp
  ).slice(
    start.line - 1,
    end.line
  );

  strings.push(strings.pop().slice(0, end.column));
  strings[0] = strings[0].slice(start.column);

  return fromString(strings.join("\n"));
};

Lp.slice = function(start, end) {
  if (!end) {
    if (!start) {
      // The client seems to want a copy of this Lines object, but
      // Lines objects are immutable, so it's perfectly adequate to
      // return the same object.
      return this;
    }

    // Slice to the end if no end position was provided.
    end = this.lastPos();
  }

  var secret = getSecret(this);
  var sliced = secret.infos.slice(start.line - 1, end.line);

  if (start.line === end.line) {
    sliced[0] = sliceInfo(sliced[0], start.column, end.column);
  } else {
    assert.ok(start.line < end.line);
    sliced[0] = sliceInfo(sliced[0], start.column);
    sliced.push(sliceInfo(sliced.pop(), 0, end.column));
  }

  var lines = new Lines(sliced);

  if (secret.mappings.length > 0) {
    var newMappings = getSecret(lines).mappings;
    assert.strictEqual(newMappings.length, 0);
    secret.mappings.forEach(function(mapping) {
      var sliced = mapping.slice(this, start, end);
      if (sliced) {
        newMappings.push(sliced);
      }
    }, this);
  }

  return lines;
};

function sliceInfo(info, startCol, endCol) {
  var sliceStart = info.sliceStart;
  var sliceEnd = info.sliceEnd;
  var indent = Math.max(info.indent, 0);
  var lineLength = indent + sliceEnd - sliceStart;

  if (typeof endCol === "undefined") {
    endCol = lineLength;
  }

  startCol = Math.max(startCol, 0);
  endCol = Math.min(endCol, lineLength);
  endCol = Math.max(endCol, startCol);

  if (endCol < indent) {
    indent = endCol;
    sliceEnd = sliceStart;
  } else {
    sliceEnd -= lineLength - endCol;
  }

  lineLength = endCol;
  lineLength -= startCol;

  if (startCol < indent) {
    indent -= startCol;
  } else {
    startCol -= indent;
    indent = 0;
    sliceStart += startCol;
  }

  assert.ok(indent >= 0);
  assert.ok(sliceStart <= sliceEnd);
  assert.strictEqual(lineLength, indent + sliceEnd - sliceStart);

  if (info.indent === indent &&
      info.sliceStart === sliceStart &&
      info.sliceEnd === sliceEnd) {
    return info;
  }

  return {
    line: info.line,
    indent: indent,
    // A destructive slice always unlocks indentation.
    locked: false,
    sliceStart: sliceStart,
    sliceEnd: sliceEnd
  };
}

Lp.bootstrapSliceString = function(start, end, options) {
  return this.slice(start, end).toString(options);
};

Lp.sliceString = function(start, end, options) {
  if (!end) {
    if (!start) {
      // The client seems to want a copy of this Lines object, but
      // Lines objects are immutable, so it's perfectly adequate to
      // return the same object.
      return this;
    }

    // Slice to the end if no end position was provided.
    end = this.lastPos();
  }

  options = normalizeOptions(options);

  var infos = getSecret(this).infos;
  var parts = [];
  var tabWidth = options.tabWidth;

  for (var line = start.line; line <= end.line; ++line) {
    var info = infos[line - 1];

    if (line === start.line) {
      if (line === end.line) {
        info = sliceInfo(info, start.column, end.column);
      } else {
        info = sliceInfo(info, start.column);
      }
    } else if (line === end.line) {
      info = sliceInfo(info, 0, end.column);
    }

    var indent = Math.max(info.indent, 0);

    var before = info.line.slice(0, info.sliceStart);
    if (options.reuseWhitespace &&
        isOnlyWhitespace(before) &&
        countSpaces(before, options.tabWidth) === indent) {
      // Reuse original spaces if the indentation is correct.
      parts.push(info.line.slice(0, info.sliceEnd));
      continue;
    }

    var tabs = 0;
    var spaces = indent;

    if (options.useTabs) {
      tabs = Math.floor(indent / tabWidth);
      spaces -= tabs * tabWidth;
    }

    var result = "";

    if (tabs > 0) {
      result += new Array(tabs + 1).join("\t");
    }

    if (spaces > 0) {
      result += new Array(spaces + 1).join(" ");
    }

    result += info.line.slice(info.sliceStart, info.sliceEnd);

    parts.push(result);
  }

  return parts.join(options.lineTerminator);
};

Lp.isEmpty = function() {
  return this.length < 2 && this.getLineLength(1) < 1;
};

Lp.join = function(elements) {
  var separator = this;
  var separatorSecret = getSecret(separator);
  var infos = [];
  var mappings = [];
  var prevInfo;

  function appendSecret(secret) {
    if (secret === null)
      return;

    if (prevInfo) {
      var info = secret.infos[0];
      var indent = new Array(info.indent + 1).join(" ");
      var prevLine = infos.length;
      var prevColumn = Math.max(prevInfo.indent, 0) +
        prevInfo.sliceEnd - prevInfo.sliceStart;

      prevInfo.line = prevInfo.line.slice(
        0, prevInfo.sliceEnd) + indent + info.line.slice(
          info.sliceStart, info.sliceEnd);

      // If any part of a line is indentation-locked, the whole line
      // will be indentation-locked.
      prevInfo.locked = prevInfo.locked || info.locked;

      prevInfo.sliceEnd = prevInfo.line.length;

      if (secret.mappings.length > 0) {
        secret.mappings.forEach(function(mapping) {
          mappings.push(mapping.add(prevLine, prevColumn));
        });
      }

    } else if (secret.mappings.length > 0) {
      mappings.push.apply(mappings, secret.mappings);
    }

    secret.infos.forEach(function(info, i) {
      if (!prevInfo || i > 0) {
        prevInfo = copyLineInfo(info);
        infos.push(prevInfo);
      }
    });
  }

  function appendWithSeparator(secret, i) {
    if (i > 0)
      appendSecret(separatorSecret);
    appendSecret(secret);
  }

  elements.map(function(elem) {
    var lines = fromString(elem);
    if (lines.isEmpty())
      return null;
    return getSecret(lines);
  }).forEach(separator.isEmpty()
             ? appendSecret
             : appendWithSeparator);

  if (infos.length < 1)
    return emptyLines;

  var lines = new Lines(infos);

  getSecret(lines).mappings = mappings;

  return lines;
};

exports.concat = function(elements) {
  return emptyLines.join(elements);
};

Lp.concat = function(other) {
  var args = arguments,
  list = [this];
  list.push.apply(list, args);
  assert.strictEqual(list.length, args.length + 1);
  return emptyLines.join(list);
};

// The emptyLines object needs to be created all the way down here so that
// Lines.prototype will be fully populated.
var emptyLines = fromString("");

},{"./mapping":34,"./options":35,"./types":39,"./util":40,"assert":72,"private":62,"source-map":157}],34:[function(require,module,exports){
var assert = require("assert");
var types = require("./types");
var isString = types.builtInTypes.string;
var isNumber = types.builtInTypes.number;
var SourceLocation = types.namedTypes.SourceLocation;
var Position = types.namedTypes.Position;
var linesModule = require("./lines");
var comparePos = require("./util").comparePos;

function Mapping(sourceLines, sourceLoc, targetLoc) {
    assert.ok(this instanceof Mapping);
    assert.ok(sourceLines instanceof linesModule.Lines);
    SourceLocation.assert(sourceLoc);

    if (targetLoc) {
        // In certain cases it's possible for targetLoc.{start,end}.column
        // values to be negative, which technically makes them no longer
        // valid SourceLocation nodes, so we need to be more forgiving.
        assert.ok(
            isNumber.check(targetLoc.start.line) &&
            isNumber.check(targetLoc.start.column) &&
            isNumber.check(targetLoc.end.line) &&
            isNumber.check(targetLoc.end.column)
        );
    } else {
        // Assume identity mapping if no targetLoc specified.
        targetLoc = sourceLoc;
    }

    Object.defineProperties(this, {
        sourceLines: { value: sourceLines },
        sourceLoc: { value: sourceLoc },
        targetLoc: { value: targetLoc }
    });
}

var Mp = Mapping.prototype;
module.exports = Mapping;

Mp.slice = function(lines, start, end) {
    assert.ok(lines instanceof linesModule.Lines);
    Position.assert(start);

    if (end) {
        Position.assert(end);
    } else {
        end = lines.lastPos();
    }

    var sourceLines = this.sourceLines;
    var sourceLoc = this.sourceLoc;
    var targetLoc = this.targetLoc;

    function skip(name) {
        var sourceFromPos = sourceLoc[name];
        var targetFromPos = targetLoc[name];
        var targetToPos = start;

        if (name === "end") {
            targetToPos = end;
        } else {
            assert.strictEqual(name, "start");
        }

        return skipChars(
            sourceLines, sourceFromPos,
            lines, targetFromPos, targetToPos
        );
    }

    if (comparePos(start, targetLoc.start) <= 0) {
        if (comparePos(targetLoc.end, end) <= 0) {
            targetLoc = {
                start: subtractPos(targetLoc.start, start.line, start.column),
                end: subtractPos(targetLoc.end, start.line, start.column)
            };

            // The sourceLoc can stay the same because the contents of the
            // targetLoc have not changed.

        } else if (comparePos(end, targetLoc.start) <= 0) {
            return null;

        } else {
            sourceLoc = {
                start: sourceLoc.start,
                end: skip("end")
            };

            targetLoc = {
                start: subtractPos(targetLoc.start, start.line, start.column),
                end: subtractPos(end, start.line, start.column)
            };
        }

    } else {
        if (comparePos(targetLoc.end, start) <= 0) {
            return null;
        }

        if (comparePos(targetLoc.end, end) <= 0) {
            sourceLoc = {
                start: skip("start"),
                end: sourceLoc.end
            };

            targetLoc = {
                // Same as subtractPos(start, start.line, start.column):
                start: { line: 1, column: 0 },
                end: subtractPos(targetLoc.end, start.line, start.column)
            };

        } else {
            sourceLoc = {
                start: skip("start"),
                end: skip("end")
            };

            targetLoc = {
                // Same as subtractPos(start, start.line, start.column):
                start: { line: 1, column: 0 },
                end: subtractPos(end, start.line, start.column)
            };
        }
    }

    return new Mapping(this.sourceLines, sourceLoc, targetLoc);
};

Mp.add = function(line, column) {
    return new Mapping(this.sourceLines, this.sourceLoc, {
        start: addPos(this.targetLoc.start, line, column),
        end: addPos(this.targetLoc.end, line, column)
    });
};

function addPos(toPos, line, column) {
    return {
        line: toPos.line + line - 1,
        column: (toPos.line === 1)
            ? toPos.column + column
            : toPos.column
    };
}

Mp.subtract = function(line, column) {
    return new Mapping(this.sourceLines, this.sourceLoc, {
        start: subtractPos(this.targetLoc.start, line, column),
        end: subtractPos(this.targetLoc.end, line, column)
    });
};

function subtractPos(fromPos, line, column) {
    return {
        line: fromPos.line - line + 1,
        column: (fromPos.line === line)
            ? fromPos.column - column
            : fromPos.column
    };
}

Mp.indent = function(by, skipFirstLine, noNegativeColumns) {
    if (by === 0) {
        return this;
    }

    var targetLoc = this.targetLoc;
    var startLine = targetLoc.start.line;
    var endLine = targetLoc.end.line;

    if (skipFirstLine && startLine === 1 && endLine === 1) {
        return this;
    }

    targetLoc = {
        start: targetLoc.start,
        end: targetLoc.end
    };

    if (!skipFirstLine || startLine > 1) {
        var startColumn = targetLoc.start.column + by;
        targetLoc.start = {
            line: startLine,
            column: noNegativeColumns
                ? Math.max(0, startColumn)
                : startColumn
        };
    }

    if (!skipFirstLine || endLine > 1) {
        var endColumn = targetLoc.end.column + by;
        targetLoc.end = {
            line: endLine,
            column: noNegativeColumns
                ? Math.max(0, endColumn)
                : endColumn
        };
    }

    return new Mapping(this.sourceLines, this.sourceLoc, targetLoc);
};

function skipChars(
    sourceLines, sourceFromPos,
    targetLines, targetFromPos, targetToPos
) {
    assert.ok(sourceLines instanceof linesModule.Lines);
    assert.ok(targetLines instanceof linesModule.Lines);
    Position.assert(sourceFromPos);
    Position.assert(targetFromPos);
    Position.assert(targetToPos);

    var targetComparison = comparePos(targetFromPos, targetToPos);
    if (targetComparison === 0) {
        // Trivial case: no characters to skip.
        return sourceFromPos;
    }

    if (targetComparison < 0) {
        // Skipping forward.

        var sourceCursor = sourceLines.skipSpaces(sourceFromPos);
        var targetCursor = targetLines.skipSpaces(targetFromPos);

        var lineDiff = targetToPos.line - targetCursor.line;
        sourceCursor.line += lineDiff;
        targetCursor.line += lineDiff;

        if (lineDiff > 0) {
            // If jumping to later lines, reset columns to the beginnings
            // of those lines.
            sourceCursor.column = 0;
            targetCursor.column = 0;
        } else {
            assert.strictEqual(lineDiff, 0);
        }

        while (comparePos(targetCursor, targetToPos) < 0 &&
               targetLines.nextPos(targetCursor, true)) {
            assert.ok(sourceLines.nextPos(sourceCursor, true));
            assert.strictEqual(
                sourceLines.charAt(sourceCursor),
                targetLines.charAt(targetCursor)
            );
        }

    } else {
        // Skipping backward.

        var sourceCursor = sourceLines.skipSpaces(sourceFromPos, true);
        var targetCursor = targetLines.skipSpaces(targetFromPos, true);

        var lineDiff = targetToPos.line - targetCursor.line;
        sourceCursor.line += lineDiff;
        targetCursor.line += lineDiff;

        if (lineDiff < 0) {
            // If jumping to earlier lines, reset columns to the ends of
            // those lines.
            sourceCursor.column = sourceLines.getLineLength(sourceCursor.line);
            targetCursor.column = targetLines.getLineLength(targetCursor.line);
        } else {
            assert.strictEqual(lineDiff, 0);
        }

        while (comparePos(targetToPos, targetCursor) < 0 &&
               targetLines.prevPos(targetCursor, true)) {
            assert.ok(sourceLines.prevPos(sourceCursor, true));
            assert.strictEqual(
                sourceLines.charAt(sourceCursor),
                targetLines.charAt(targetCursor)
            );
        }
    }

    return sourceCursor;
}

},{"./lines":33,"./types":39,"./util":40,"assert":72}],35:[function(require,module,exports){
var defaults = {
    // If you want to use a different branch of esprima, or any other
    // module that supports a .parse function, pass that module object to
    // recast.parse as options.parser (legacy synonym: options.esprima).
    parser: require("@gerhobbelt/esprima"),

    // Number of spaces the pretty-printer should use per tab for
    // indentation. If you do not pass this option explicitly, it will be
    // (quite reliably!) inferred from the original code.
    tabWidth: 4,

    // If you really want the pretty-printer to use tabs instead of
    // spaces, make this option true.
    useTabs: false,

    // The reprinting code leaves leading whitespace untouched unless it
    // has to reindent a line, or you pass false for this option.
    reuseWhitespace: true,

    // Override this option to use a different line terminator, e.g. \r\n.
    lineTerminator: require("os").EOL,

    // Some of the pretty-printer code (such as that for printing function
    // parameter lists) makes a valiant attempt to prevent really long
    // lines. You can adjust the limit by changing this option; however,
    // there is no guarantee that line length will fit inside this limit.
    wrapColumn: 74, // Aspirational for now.

    // Pass a string as options.sourceFileName to recast.parse to tell the
    // reprinter to keep track of reused code so that it can construct a
    // source map automatically.
    sourceFileName: null,

    // Pass a string as options.sourceMapName to recast.print, and
    // (provided you passed options.sourceFileName earlier) the
    // PrintResult of recast.print will have a .map property for the
    // generated source map.
    sourceMapName: null,

    // If provided, this option will be passed along to the source map
    // generator as a root directory for relative source file paths.
    sourceRoot: null,

    // If you provide a source map that was generated from a previous call
    // to recast.print as options.inputSourceMap, the old source map will
    // be composed with the new source map.
    inputSourceMap: null,

    // If you want esprima to generate .range information (recast only
    // uses .loc internally), pass true for this option.
    range: false,

    // If you want esprima not to throw exceptions when it encounters
    // non-fatal errors, keep this option true.
    tolerant: true,

    // If you want to override the quotes used in string literals, specify
    // either "single", "double", or "auto" here ("auto" will select the one
    // which results in the shorter literal)
    // Otherwise, double quotes are used.
    quote: null,

    // Controls the printing of trailing commas in object literals,
    // array expressions and function parameters.
    //
    // This option could either be:
    // * Boolean - enable/disable in all contexts (objects, arrays and function params).
    // * Object - enable/disable per context.
    //
    // Example:
    // trailingComma: {
    //   objects: true,
    //   arrays: true,
    //   parameters: false,
    // }
    trailingComma: false,

    // Controls the printing of spaces inside array brackets.
    // See: http://eslint.org/docs/rules/array-bracket-spacing
    arrayBracketSpacing: false,

    // Controls the printing of spaces inside object literals,
    // destructuring assignments, and import/export specifiers.
    // See: http://eslint.org/docs/rules/object-curly-spacing
    objectCurlySpacing: true,

    // If you want parenthesis to wrap single-argument arrow function parameter
    // lists, pass true for this option.
    arrowParensAlways: false,

    // There are 2 supported syntaxes (`,` and `;`) in Flow Object Types;
    // The use of commas is in line with the more popular style and matches
    // how objects are defined in JS, making it a bit more natural to write.
    flowObjectCommas: true,

    // Controls adding extra line breaks before and after multiline property.
    extraLineBreaksForMultilineProperty: true,

    // Used internally to mark the start and end of trailing comment chunks
    // which must be patched after the initial code generation. (RTFC: "HOTFIX 2")
    // 
    // The crux is that both these characters DO NOT OCCUR ANYWHERE in the
    // parsed source code (AST), not even in a string (at least not literally:
    // you can always have these in there in escaped form, just as they are
    // specified below).
    STX: "\x02",
    ETX: "\x03",
}, hasOwn = defaults.hasOwnProperty;

// Copy options and fill in default values.
exports.normalize = function(options) {
    options = options || defaults;

    function get(key) {
        return hasOwn.call(options, key)
            ? options[key]
            : defaults[key];
    }

    return {
        tabWidth: +get("tabWidth"),
        useTabs: !!get("useTabs"),
        reuseWhitespace: !!get("reuseWhitespace"),
        lineTerminator: get("lineTerminator"),
        wrapColumn: Math.max(get("wrapColumn"), 0),
        sourceFileName: get("sourceFileName"),
        sourceMapName: get("sourceMapName"),
        sourceRoot: get("sourceRoot"),
        inputSourceMap: get("inputSourceMap"),
        parser: get("esprima") || get("parser"),
        range: get("range"),
        tolerant: get("tolerant"),
        quote: get("quote"),
        trailingComma: get("trailingComma"),
        arrayBracketSpacing: get("arrayBracketSpacing"),
        objectCurlySpacing: get("objectCurlySpacing"),
        arrowParensAlways: get("arrowParensAlways"),
        flowObjectCommas: get("flowObjectCommas"),
        extraLineBreaksForMultilineProperty: get("extraLineBreaksForMultilineProperty"),
        STX: get("STX"),
        ETX: get("ETX"),
    };
};

},{"@gerhobbelt/esprima":29,"os":143}],36:[function(require,module,exports){
(function (global){
var assert = require("assert");
var types = require("./types");
var n = types.namedTypes;
var b = types.builders;
var isObject = types.builtInTypes.object;
var isArray = types.builtInTypes.array;
var isFunction = types.builtInTypes.function;
var Patcher = require("./patcher").Patcher;
var normalizeOptions = require("./options").normalize;
var fromString = require("./lines").fromString;
var attachComments = require("./comments").attach;
var util = require("./util");
var Map = global.Map || require("core-js/es6/map");

exports.parse = function parse(source, options) {
  options = normalizeOptions(options);

  var lines = fromString(source, options);

  var sourceWithoutTabs = lines.toString({
    tabWidth: options.tabWidth,
    reuseWhitespace: false,
    useTabs: false
  });

  var comments = [];
  var program = options.parser.parse(sourceWithoutTabs, {
    jsx: true,
    loc: true,
    locations: true,
    range: options.range,
    comment: true,
    onComment: comments,
    tolerant: options.tolerant,
    ecmaVersion: 6,
    sourceType: 'module'
  });

  // If the source was empty, some parsers give loc.{start,end}.line
  // values of 0, instead of the minimum of 1.
  util.fixFaultyLocations(program, lines);

  program.loc = program.loc || {
    start: lines.firstPos(),
    end: lines.lastPos()
  };

  program.loc.lines = lines;
  program.loc.indent = 0;

  // Expand the Program node's .loc to include all comments, since
  // typically its .loc.start and .loc.end will coincide with those of the
  // first and last statements, respectively, excluding any comments that
  // fall outside that region.
  var trueProgramLoc = util.getTrueLoc(program, lines);
  program.loc.start = trueProgramLoc.start;
  program.loc.end = trueProgramLoc.end;

  if (program.comments) {
    comments = program.comments;
    delete program.comments;
  }

  // In order to ensure we reprint leading and trailing program comments,
  // wrap the original Program node with a File node.
  var file = program;
  if (file.type === "Program") {
    var file = b.file(program, options.sourceFileName || null);
    file.loc = {
      lines: lines,
      indent: 0,
      start: lines.firstPos(),
      end: lines.lastPos()
    };
  } else if (file.type === "File") {
    program = file.program;
  }

  // Passing file.program here instead of just file means that initial
  // comments will be attached to program.body[0] instead of program.
  attachComments(
    comments,
    program.body.length ? file.program : file,
    lines
  );

  // Return a copy of the original AST so that any changes made may be
  // compared to the original.
  return new TreeCopier(lines).copy(file);
};

function TreeCopier(lines) {
  assert.ok(this instanceof TreeCopier);
  this.lines = lines;
  this.indent = 0;
  this.seen = new Map;
}

var TCp = TreeCopier.prototype;

TCp.copy = function(node) {
  if (this.seen.has(node)) {
    return this.seen.get(node);
  }

  if (isArray.check(node)) {
    var copy = new Array(node.length);
    this.seen.set(node, copy);
    node.forEach(function (item, i) {
      copy[i] = this.copy(item);
    }, this);
    return copy;
  }

  if (!isObject.check(node)) {
    return node;
  }

  util.fixFaultyLocations(node, this.lines);

  var copy = Object.create(Object.getPrototypeOf(node), {
    original: { // Provide a link from the copy to the original.
      value: node,
      configurable: false,
      enumerable: false,
      writable: true
    }
  });

  this.seen.set(node, copy);

  var loc = node.loc;
  var oldIndent = this.indent;
  var newIndent = oldIndent;

  if (loc) {
    // When node is a comment, we set node.loc.indent to
    // node.loc.start.column so that, when/if we print the comment by
    // itself, we can strip that much whitespace from the left margin of
    // the comment. This only really matters for multiline Block comments,
    // but it doesn't hurt for Line comments.
    if (node.type === "Block" || node.type === "Line" ||
        node.type === "CommentBlock" || node.type === "CommentLine" ||
        this.lines.isPrecededOnlyByWhitespace(loc.start)) {
      newIndent = this.indent = loc.start.column;
    }

    loc.lines = this.lines;
    loc.indent = newIndent;
  }

  var keys = Object.keys(node);
  var keyCount = keys.length;
  for (var i = 0; i < keyCount; ++i) {
    var key = keys[i];
    if (key === "loc") {
      copy[key] = node[key];
    } else if (key === "tokens" &&
               node.type === "File") {
      // Preserve file.tokens (uncopied) in case client code cares about
      // it, even though Recast ignores it when reprinting.
      copy[key] = node[key];
    } else {
      copy[key] = this.copy(node[key]);
    }
  }

  this.indent = oldIndent;

  return copy;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./comments":31,"./lines":33,"./options":35,"./patcher":37,"./types":39,"./util":40,"assert":72,"core-js/es6/map":75}],37:[function(require,module,exports){
var assert = require("assert");
var linesModule = require("./lines");
var types = require("./types");
var getFieldValue = types.getFieldValue;
var Node = types.namedTypes.Node;
var Printable = types.namedTypes.Printable;
var Expression = types.namedTypes.Expression;
var ReturnStatement = types.namedTypes.ReturnStatement;
var SourceLocation = types.namedTypes.SourceLocation;
var util = require("./util");
var comparePos = util.comparePos;
var FastPath = require("./fast-path");
var isObject = types.builtInTypes.object;
var isArray = types.builtInTypes.array;
var isString = types.builtInTypes.string;
var riskyAdjoiningCharExp = /[0-9a-z_$]/i;

function Patcher(lines) {
  assert.ok(this instanceof Patcher);
  assert.ok(lines instanceof linesModule.Lines);

  var self = this,
  replacements = [];

  self.replace = function(loc, lines) {
    if (isString.check(lines))
      lines = linesModule.fromString(lines);

    replacements.push({
      lines: lines,
      start: loc.start,
      end: loc.end
    });
  };

  self.get = function(loc) {
    // If no location is provided, return the complete Lines object.
    loc = loc || {
      start: { line: 1, column: 0 },
      end: { line: lines.length,
             column: lines.getLineLength(lines.length) }
    };

    var sliceFrom = loc.start,
    toConcat = [];

    function pushSlice(from, to) {
      assert.ok(comparePos(from, to) <= 0);
      toConcat.push(lines.slice(from, to));
    }

    replacements.sort(function(a, b) {
      return comparePos(a.start, b.start);
    }).forEach(function(rep) {
      if (comparePos(sliceFrom, rep.start) > 0) {
        // Ignore nested replacement ranges.
      } else {
        pushSlice(sliceFrom, rep.start);
        toConcat.push(rep.lines);
        sliceFrom = rep.end;
      }
    });

    pushSlice(sliceFrom, loc.end);

    return linesModule.concat(toConcat);
  };
}
exports.Patcher = Patcher;

var Pp = Patcher.prototype;

Pp.tryToReprintComments = function(newNode, oldNode, print) {
  var patcher = this;

  if (!newNode.comments &&
      !oldNode.comments) {
    // We were (vacuously) able to reprint all the comments!
    return true;
  }

  var newPath = FastPath.from(newNode);
  var oldPath = FastPath.from(oldNode);

  newPath.stack.push("comments", getSurroundingComments(newNode));
  oldPath.stack.push("comments", getSurroundingComments(oldNode));

  var reprints = [];
  var ableToReprintComments =
    findArrayReprints(newPath, oldPath, reprints);

  // No need to pop anything from newPath.stack or oldPath.stack, since
  // newPath and oldPath are fresh local variables.

  if (ableToReprintComments && reprints.length > 0) {
    reprints.forEach(function(reprint) {
      var oldComment = reprint.oldPath.getValue();
      assert.ok(oldComment.leading || oldComment.trailing);
      patcher.replace(
        oldComment.loc,
        // Comments can't have .comments, so it doesn't matter whether we
        // print with comments or without.
        print(reprint.newPath).indentTail(oldComment.loc.indent)
      );
    });
  }

  return ableToReprintComments;
};

// Get all comments that are either leading or trailing, ignoring any
// comments that occur inside node.loc. Returns an empty array for nodes
// with no leading or trailing comments.
function getSurroundingComments(node) {
  var result = [];
  if (node.comments &&
      node.comments.length > 0) {
    node.comments.forEach(function(comment) {
      if (comment.leading || comment.trailing) {
        result.push(comment);
      }
    });
  }
  return result;
}

Pp.deleteComments = function(node) {
  if (!node.comments) {
    return;
  }

  var patcher = this;

  node.comments.forEach(function(comment) {
    if (comment.leading) {
      // Delete leading comments along with any trailing whitespace they
      // might have.
      patcher.replace({
        start: comment.loc.start,
        end: node.loc.lines.skipSpaces(
          comment.loc.end, false, false)
      }, "");

    } else if (comment.trailing) {
      // Delete trailing comments along with any leading whitespace they
      // might have.
      patcher.replace({
        start: node.loc.lines.skipSpaces(
          comment.loc.start, true, false),
        end: comment.loc.end
      }, "");
    }
  });
};

exports.getReprinter = function(path) {
  assert.ok(path instanceof FastPath);

  // Make sure that this path refers specifically to a Node, rather than
  // some non-Node subproperty of a Node.
  var node = path.getValue();
  if (!Printable.check(node))
    return;

  var orig = node.original;
  var origLoc = orig && orig.loc;
  var lines = origLoc && origLoc.lines;
  var reprints = [];

  if (!lines || !findReprints(path, reprints))
    return;

  return function(print) {
    var patcher = new Patcher(lines);

    reprints.forEach(function(reprint) {
      var newNode = reprint.newPath.getValue();
      var oldNode = reprint.oldPath.getValue();

      SourceLocation.assert(oldNode.loc, true);

      var needToPrintNewPathWithComments =
        !patcher.tryToReprintComments(newNode, oldNode, print)

      if (needToPrintNewPathWithComments) {
        // Since we were not able to preserve all leading/trailing
        // comments, we delete oldNode's comments, print newPath with
        // comments, and then patch the resulting lines where oldNode used
        // to be.
        patcher.deleteComments(oldNode);
      }

      var newLines = print(
        reprint.newPath,
        needToPrintNewPathWithComments
      ).indentTail(oldNode.loc.indent);

      var nls = needsLeadingSpace(lines, oldNode.loc, newLines);
      var nts = needsTrailingSpace(lines, oldNode.loc, newLines);

      // If we try to replace the argument of a ReturnStatement like
      // return"asdf" with e.g. a literal null expression, we run the risk
      // of ending up with returnnull, so we need to add an extra leading
      // space in situations where that might happen. Likewise for
      // "asdf"in obj. See #170.
      if (nls || nts) {
        var newParts = [];
        nls && newParts.push(" ");
        newParts.push(newLines);
        nts && newParts.push(" ");
        newLines = linesModule.concat(newParts);
      }

      patcher.replace(oldNode.loc, newLines);
    });

    // Recall that origLoc is the .loc of an ancestor node that is
    // guaranteed to contain all the reprinted nodes and comments.
    return patcher.get(origLoc).indentTail(-orig.loc.indent);
  };
};

// If the last character before oldLoc and the first character of newLines
// are both identifier characters, they must be separated by a space,
// otherwise they will most likely get fused together into a single token.
function needsLeadingSpace(oldLines, oldLoc, newLines) {
  var posBeforeOldLoc = util.copyPos(oldLoc.start);

  // The character just before the location occupied by oldNode.
  var charBeforeOldLoc =
    oldLines.prevPos(posBeforeOldLoc) &&
    oldLines.charAt(posBeforeOldLoc);

  // First character of the reprinted node.
  var newFirstChar = newLines.charAt(newLines.firstPos());

  return charBeforeOldLoc &&
    riskyAdjoiningCharExp.test(charBeforeOldLoc) &&
    newFirstChar &&
    riskyAdjoiningCharExp.test(newFirstChar);
}

// If the last character of newLines and the first character after oldLoc
// are both identifier characters, they must be separated by a space,
// otherwise they will most likely get fused together into a single token.
function needsTrailingSpace(oldLines, oldLoc, newLines) {
  // The character just after the location occupied by oldNode.
  var charAfterOldLoc = oldLines.charAt(oldLoc.end);

  var newLastPos = newLines.lastPos();

  // Last character of the reprinted node.
  var newLastChar = newLines.prevPos(newLastPos) &&
    newLines.charAt(newLastPos);

  return newLastChar &&
    riskyAdjoiningCharExp.test(newLastChar) &&
    charAfterOldLoc &&
    riskyAdjoiningCharExp.test(charAfterOldLoc);
}

function findReprints(newPath, reprints) {
  var newNode = newPath.getValue();
  Printable.assert(newNode);

  var oldNode = newNode.original;
  Printable.assert(oldNode);

  assert.deepEqual(reprints, []);

  if (newNode.type !== oldNode.type) {
    return false;
  }

  var oldPath = new FastPath(oldNode);
  var canReprint = findChildReprints(newPath, oldPath, reprints);

  if (!canReprint) {
    // Make absolutely sure the calling code does not attempt to reprint
    // any nodes.
    reprints.length = 0;
  }

  return canReprint;
}

function findAnyReprints(newPath, oldPath, reprints) {
  var newNode = newPath.getValue();
  var oldNode = oldPath.getValue();

  if (newNode === oldNode)
    return true;

  if (isArray.check(newNode))
    return findArrayReprints(newPath, oldPath, reprints);

  if (isObject.check(newNode))
    return findObjectReprints(newPath, oldPath, reprints);

  return false;
}

function findArrayReprints(newPath, oldPath, reprints) {
  var newNode = newPath.getValue();
  var oldNode = oldPath.getValue();

  if (newNode === oldNode ||
      newPath.valueIsDuplicate() ||
      oldPath.valueIsDuplicate()) {
    return true;
  }

  isArray.assert(newNode);
  var len = newNode.length;

  if (!(isArray.check(oldNode) &&
        oldNode.length === len))
    return false;

  for (var i = 0; i < len; ++i) {
    newPath.stack.push(i, newNode[i]);
    oldPath.stack.push(i, oldNode[i]);
    var canReprint = findAnyReprints(newPath, oldPath, reprints);
    newPath.stack.length -= 2;
    oldPath.stack.length -= 2;
    if (!canReprint) {
      return false;
    }
  }

  return true;
}

function findObjectReprints(newPath, oldPath, reprints) {
  var newNode = newPath.getValue();
  isObject.assert(newNode);

  if (newNode.original === null) {
    // If newNode.original node was set to null, reprint the node.
    return false;
  }

  var oldNode = oldPath.getValue();
  if (!isObject.check(oldNode))
    return false;

  if (newNode === oldNode ||
      newPath.valueIsDuplicate() ||
      oldPath.valueIsDuplicate()) {
    return true;
  }

  if (Printable.check(newNode)) {
    if (!Printable.check(oldNode)) {
      return false;
    }

    // Here we need to decide whether the reprinted code for newNode is
    // appropriate for patching into the location of oldNode.

    if (newNode.type === oldNode.type) {
      var childReprints = [];

      if (findChildReprints(newPath, oldPath, childReprints)) {
        reprints.push.apply(reprints, childReprints);
      } else if (oldNode.loc) {
        // If we have no .loc information for oldNode, then we won't be
        // able to reprint it.
        reprints.push({
          oldPath: oldPath.copy(),
          newPath: newPath.copy()
        });
      } else {
        return false;
      }

      return true;
    }

    if (Expression.check(newNode) &&
        Expression.check(oldNode) &&
        // If we have no .loc information for oldNode, then we won't be
        // able to reprint it.
        oldNode.loc) {

      // If both nodes are subtypes of Expression, then we should be able
      // to fill the location occupied by the old node with code printed
      // for the new node with no ill consequences.
      reprints.push({
        oldPath: oldPath.copy(),
        newPath: newPath.copy()
      });

      return true;
    }

    // The nodes have different types, and at least one of the types is
    // not a subtype of the Expression type, so we cannot safely assume
    // the nodes are syntactically interchangeable.
    return false;
  }

  return findChildReprints(newPath, oldPath, reprints);
}

// This object is reused in hasOpeningParen and hasClosingParen to avoid
// having to allocate a temporary object.
var reusablePos = { line: 1, column: 0 };
var nonSpaceExp = /\S/;

function hasOpeningParen(oldPath) {
  var oldNode = oldPath.getValue();
  var loc = oldNode.loc;
  var lines = loc && loc.lines;

  if (lines) {
    var pos = reusablePos;
    pos.line = loc.start.line;
    pos.column = loc.start.column;

    while (lines.prevPos(pos)) {
      var ch = lines.charAt(pos);

      if (ch === "(") {
        // If we found an opening parenthesis but it occurred before the
        // start of the original subtree for this reprinting, then we must
        // not return true for hasOpeningParen(oldPath).
        return comparePos(oldPath.getRootValue().loc.start, pos) <= 0;
      }

      if (nonSpaceExp.test(ch)) {
        return false;
      }
    }
  }

  return false;
}

function hasClosingParen(oldPath) {
  var oldNode = oldPath.getValue();
  var loc = oldNode.loc;
  var lines = loc && loc.lines;

  if (lines) {
    var pos = reusablePos;
    pos.line = loc.end.line;
    pos.column = loc.end.column;

    do {
      var ch = lines.charAt(pos);

      if (ch === ")") {
        // If we found a closing parenthesis but it occurred after the end
        // of the original subtree for this reprinting, then we must not
        // return true for hasClosingParen(oldPath).
        return comparePos(pos, oldPath.getRootValue().loc.end) <= 0;
      }

      if (nonSpaceExp.test(ch)) {
        return false;
      }

    } while (lines.nextPos(pos));
  }

  return false;
}

function hasParens(oldPath) {
  // This logic can technically be fooled if the node has parentheses but
  // there are comments intervening between the parentheses and the
  // node. In such cases the node will be harmlessly wrapped in an
  // additional layer of parentheses.
  return hasOpeningParen(oldPath) && hasClosingParen(oldPath);
}

function findChildReprints(newPath, oldPath, reprints) {
  var newNode = newPath.getValue();
  var oldNode = oldPath.getValue();

  isObject.assert(newNode);
  isObject.assert(oldNode);

  if (newNode.original === null) {
    // If newNode.original node was set to null, reprint the node.
    return false;
  }

  // If this type of node cannot come lexically first in its enclosing
  // statement (e.g. a function expression or object literal), and it
  // seems to be doing so, then the only way we can ignore this problem
  // and save ourselves from falling back to the pretty printer is if an
  // opening parenthesis happens to precede the node.  For example,
  // (function(){ ... }()); does not need to be reprinted, even though the
  // FunctionExpression comes lexically first in the enclosing
  // ExpressionStatement and fails the hasParens test, because the parent
  // CallExpression passes the hasParens test. If we relied on the
  // path.needsParens() && !hasParens(oldNode) check below, the absence of
  // a closing parenthesis after the FunctionExpression would trigger
  // pretty-printing unnecessarily.
  if (Node.check(newNode) &&
      !newPath.canBeFirstInStatement() &&
      newPath.firstInStatement() &&
      !hasOpeningParen(oldPath)) {
    return false;
  }

  // If this node needs parentheses and will not be wrapped with
  // parentheses when reprinted, then return false to skip reprinting and
  // let it be printed generically.
  if (newPath.needsParens(true) && !hasParens(oldPath)) {
    return false;
  }

  var keys = util.getUnionOfKeys(oldNode, newNode);

  if (oldNode.type === "File" ||
      newNode.type === "File") {
    // Don't bother traversing file.tokens, an often very large array
    // returned by Babylon, and useless for our purposes.
    delete keys.tokens;
  }

  // Don't bother traversing .loc objects looking for reprintable nodes.
  delete keys.loc;

  var originalReprintCount = reprints.length;

  for (var k in keys) {
    if (k.charAt(0) === "_") {
      // Ignore "private" AST properties added by e.g. Babel plugins and
      // parsers like Babylon.
      continue;
    }

    newPath.stack.push(k, types.getFieldValue(newNode, k));
    oldPath.stack.push(k, types.getFieldValue(oldNode, k));
    var canReprint = findAnyReprints(newPath, oldPath, reprints);
    newPath.stack.length -= 2;
    oldPath.stack.length -= 2;

    if (!canReprint) {
      return false;
    }
  }

  // Return statements might end up running into ASI issues due to
  // comments inserted deep within the tree, so reprint them if anything
  // changed within them.
  if (ReturnStatement.check(newPath.getNode()) &&
      reprints.length > originalReprintCount) {
    return false;
  }

  return true;
}

},{"./fast-path":32,"./lines":33,"./types":39,"./util":40,"assert":72}],38:[function(require,module,exports){
var assert = require("assert");
var sourceMap = require("source-map");
var printComments = require("./comments").printComments;
var linesModule = require("./lines");
var fromString = linesModule.fromString;
var Lines = linesModule.Lines;
var concat = linesModule.concat;
var normalizeOptions = require("./options").normalize;
var getReprinter = require("./patcher").getReprinter;
var types = require("./types");
var namedTypes = types.namedTypes;
var isString = types.builtInTypes.string;
var isObject = types.builtInTypes.object;
var FastPath = require("./fast-path");
var util = require("./util");

function replChr(str, index, chr) {
    return str.substr(0, index) + chr + str.substr(index + 1);
}

function PrintResult(code, sourceMap, options) {
    options = options || normalizeOptions(null);
    assert.ok(this instanceof PrintResult);

    isString.assert(code);

    /*
     * HOTFIX 2: The Third Part a.k.a. The End
     *
     * Now we hunt for all ETX markers, check if they are 
     * followed by a terminator character on the same line 
     * and if they are, we patch that character into 
     * the previous STX character slot.
     *
     * Meanwhile we clear out all ETX character slots
     * with spaces, which should keep any accompanying
     * sourcemap nicely intact! :-)
     */
    var stx_pos = code.indexOf(options.STX);
    var etx_pos = code.indexOf(options.ETX, stx_pos + 1);
    while (stx_pos >= 0 && etx_pos >= 0) {
        var terminator = code[etx_pos + 1];
        // edge case: 
        // 
        // pull terminator from further away as multiple end-of-line-comments-to-skip
        // are printed back-to-back: the terminator, if any, will be found at
        // the end of such a sequence:
        while (terminator === options.STX) {
            // nuke ETX+STX slot at EOL:
            code = code.substr(0, etx_pos) + '  ' + code.substr(etx_pos + 2);   
            etx_pos = code.indexOf(options.ETX, etx_pos + 1);
            assert(etx_pos > 0);
            terminator = code[etx_pos + 1];
        }
        if (terminator /* edge case 2: ETX at EOF, no terminator */
            && /[^\s\r\n]/.test(terminator)
        ) {
            code = replChr(code, stx_pos, terminator);
            // nuke ETX + terminator char at EOL:
            code = code.substr(0, etx_pos) + '  ' + code.substr(etx_pos + 2);   
        } else {
            code = replChr(code, stx_pos, ' ');
            // nuke ETX slot only:
            code = replChr(code, etx_pos, ' ');
        }

        stx_pos = code.indexOf(options.STX, etx_pos + 1);
        etx_pos = code.indexOf(options.ETX, stx_pos + 1);
    }

    this.code = code;

    if (sourceMap) {
        isObject.assert(sourceMap);
        this.map = sourceMap;
    }
}

var PRp = PrintResult.prototype;
var warnedAboutToString = false;

PRp.toString = function() {
    if (!warnedAboutToString) {
        console.warn(
            "Deprecation warning: recast.print now returns an object with " +
            "a .code property. You appear to be treating the object as a " +
            "string, which might still work but is strongly discouraged."
        );

        warnedAboutToString = true;
    }

    return this.code;
};

var emptyPrintResult = new PrintResult("");

function Printer(originalOptions) {
    assert.ok(this instanceof Printer);

    var explicitTabWidth = originalOptions && originalOptions.tabWidth;
    var options = normalizeOptions(originalOptions);
    assert.notStrictEqual(options, originalOptions);

    // It's common for client code to pass the same options into both
    // recast.parse and recast.print, but the Printer doesn't need (and
    // can be confused by) options.sourceFileName, so we null it out.
    options.sourceFileName = null;

    function printWithComments(path) {
        assert.ok(path instanceof FastPath);
        return printComments(path, options, print);
    }

    function print(path, includeComments) {
        if (includeComments)
            return printWithComments(path);

        assert.ok(path instanceof FastPath);

        if (!explicitTabWidth) {
            var oldTabWidth = options.tabWidth;
            var loc = path.getNode().loc;
            if (loc && loc.lines && loc.lines.guessTabWidth) {
                options.tabWidth = loc.lines.guessTabWidth();
                var lines = maybeReprint(path);
                options.tabWidth = oldTabWidth;
                return lines;
            }
        }

        return maybeReprint(path);
    }

    function maybeReprint(path) {
        var reprinter = getReprinter(path);
        if (reprinter) {
            // Since the print function that we pass to the reprinter will
            // be used to print "new" nodes, it's tempting to think we
            // should pass printRootGenerically instead of print, to avoid
            // calling maybeReprint again, but that would be a mistake
            // because the new nodes might not be entirely new, but merely
            // moved from elsewhere in the AST. The print function is the
            // right choice because it gives us the opportunity to reprint
            // such nodes using their original source.
            return maybeAddParens(path, reprinter(print));
        }
        return printRootGenerically(path);
    }

    // Print the root node generically, but then resume reprinting its
    // children non-generically.
    function printRootGenerically(path, includeComments) {
        return includeComments
            ? printComments(path, options, printRootGenerically)
            : genericPrint(path, options, printWithComments);
    }

    // Print the entire AST generically.
    function printGenerically(path) {
        return printComments(path, options, p => genericPrint(p, options, printGenerically));
    }

    this.print = function(ast) {
        if (!ast) {
            return emptyPrintResult;
        }

        var lines = print(FastPath.from(ast), true);

        return new PrintResult(
            lines.toString(options),
            util.composeSourceMaps(
                options.inputSourceMap,
                lines.getSourceMap(
                    options.sourceMapName,
                    options.sourceRoot
                )
            ),
            options
        );
    };

    this.printGenerically = function(ast) {
        if (!ast) {
            return emptyPrintResult;
        }

        var path = FastPath.from(ast);
        var oldReuseWhitespace = options.reuseWhitespace;

        // Do not reuse whitespace (or anything else, for that matter)
        // when printing generically.
        options.reuseWhitespace = false;

        var lines = printGenerically(path, true);

        var pr = new PrintResult(
            lines.toString(options),
            util.composeSourceMaps(
                options.inputSourceMap,
                lines.getSourceMap(
                    options.sourceMapName,
                    options.sourceRoot
                )
            ),
            options
        );
        options.reuseWhitespace = oldReuseWhitespace;
        return pr;
    };
}

exports.Printer = Printer;

function maybeAddParens(path, lines) {
    return path.needsParens() ? concat(["(", lines, ")"]) : lines;
}

function genericPrint(path, options, printPath) {
    assert.ok(path instanceof FastPath);

    var node = path.getValue();
    var parts = [];
    var needsParens = false;
    var linesWithoutParens = genericPrintNoParens(path, options, printPath);

    if (!node || linesWithoutParens.isEmpty()) {
        return linesWithoutParens;
    }

    if (node.decorators &&
        node.decorators.length > 0 &&
        // If the parent node is an export declaration, it will be
        // responsible for printing node.decorators.
        !util.getParentExportDeclaration(path)) {

        path.each(function(decoratorPath) {
            parts.push(printPath(decoratorPath), "\n");
        }, "decorators");
    } else if (util.isExportDeclaration(node) &&
               node.declaration &&
               node.declaration.decorators) {
        // Export declarations are responsible for printing any decorators
        // that logically apply to node.declaration.
        path.each(function(decoratorPath) {
            parts.push(printPath(decoratorPath), "\n");
        }, "declaration", "decorators");
    } else {
        // Nodes with decorators can't have parentheses, so we can avoid
        // computing path.needsParens() except in this case.
        needsParens = path.needsParens();
    }

    if (needsParens) {
        parts.unshift("(");
    }

    parts.push(linesWithoutParens);

    if (needsParens) {
        parts.push(")");
    }

    return concat(parts);
}

function genericPrintNoParens(path, options, print) {
    var n = path.getValue();

    if (!n) {
        return fromString("");
    }

    if (typeof n === "string") {
        return fromString(n, options);
    }

    namedTypes.Printable.assert(n);

    var parts = [];

    switch (n.type) {
    case "File":
        return path.call(print, "program");

    case "Program":
        // Babel 6
        if (n.directives) {
            path.each(function(childPath) {
                parts.push(print(childPath), ";\n");
            }, "directives");
        }

        parts.push(path.call(function(bodyPath) {
            return printStatementSequence(bodyPath, options, print);
        }, "body"));

        return concat(parts);

    case "Noop": // Babel extension.
    case "EmptyStatement":
        return fromString("");

    case "ExpressionStatement":
        return concat([path.call(print, "expression"), ";"]);

    case "ParenthesizedExpression": // Babel extension.
        return concat(["(", path.call(print, "expression"), ")"]);

    case "BinaryExpression":
    case "LogicalExpression":
    case "AssignmentExpression":
        return fromString(" ").join([
            path.call(print, "left"),
            n.operator,
            path.call(print, "right")
        ]);

    case "AssignmentPattern":
        return concat([
            path.call(print, "left"),
            " = ",
            path.call(print, "right")
        ]);

    case "MemberExpression":
        parts.push(path.call(print, "object"));

        var property = path.call(print, "property");
        if (n.computed) {
            parts.push("[", property, "]");
        } else {
            parts.push(".", property);
        }

        return concat(parts);

    case "MetaProperty":
        return concat([
            path.call(print, "meta"),
            ".",
            path.call(print, "property")
        ]);

    case "BindExpression":
        if (n.object) {
            parts.push(path.call(print, "object"));
        }

        parts.push("::", path.call(print, "callee"));

        return concat(parts);

    case "Path":
        return fromString(".").join(n.body);

    case "Identifier":
        return concat([
            fromString(n.name, options),
            path.call(print, "typeAnnotation")
        ]);

    case "SpreadElement":
    case "SpreadElementPattern":
    case "RestProperty": // Babel 6 for ObjectPattern
    case "SpreadProperty":
    case "SpreadPropertyPattern":
    case "ObjectTypeSpreadProperty":
    case "RestElement":
        return concat(["...", path.call(print, "argument")]);

    case "FunctionDeclaration":
    case "FunctionExpression":
        if (n.async)
            parts.push("async ");

        parts.push("function");

        if (n.generator)
            parts.push("*");

        if (n.id) {
            parts.push(
                " ",
                path.call(print, "id"),
                path.call(print, "typeParameters")
            );
        }

        parts.push(
            "(",
            printFunctionParams(path, options, print),
            ")",
            path.call(print, "returnType"),
            " ",
            path.call(print, "body")
        );

        return concat(parts);

    case "ArrowFunctionExpression":
        if (n.async)
            parts.push("async ");

        if (n.typeParameters) {
            parts.push(path.call(print, "typeParameters"));
        }

        if (
            !options.arrowParensAlways &&
            n.params.length === 1 &&
            !n.rest &&
            n.params[0].type === 'Identifier' &&
            !n.params[0].typeAnnotation &&
            !n.returnType
        ) {
            parts.push(path.call(print, "params", 0));
        } else {
            parts.push(
                "(",
                printFunctionParams(path, options, print),
                ")",
                path.call(print, "returnType")
            );
        }

        parts.push(" => ", path.call(print, "body"));

        return concat(parts);

    case "MethodDefinition":
        if (n.static) {
            parts.push("static ");
        }

        parts.push(printMethod(path, options, print));

        return concat(parts);

    case "YieldExpression":
        parts.push("yield");

        if (n.delegate)
            parts.push("*");

        if (n.argument)
            parts.push(" ", path.call(print, "argument"));

        return concat(parts);

    case "AwaitExpression":
        parts.push("await");

        if (n.all)
            parts.push("*");

        if (n.argument)
            parts.push(" ", path.call(print, "argument"));

        return concat(parts);

    case "ModuleDeclaration":
        parts.push("module", path.call(print, "id"));

        if (n.source) {
            assert.ok(!n.body);
            parts.push("from", path.call(print, "source"));
        } else {
            parts.push(path.call(print, "body"));
        }

        return fromString(" ").join(parts);

    case "ImportSpecifier":
        if (n.imported) {
            parts.push(path.call(print, "imported"));
            if (n.local &&
                n.local.name !== n.imported.name) {
                parts.push(" as ", path.call(print, "local"));
            }
        } else if (n.id) {
            parts.push(path.call(print, "id"));
            if (n.name) {
                parts.push(" as ", path.call(print, "name"));
            }
        }

        return concat(parts);

    case "ExportSpecifier":
        if (n.local) {
            parts.push(path.call(print, "local"));
            if (n.exported &&
                n.exported.name !== n.local.name) {
                parts.push(" as ", path.call(print, "exported"));
            }
        } else if (n.id) {
            parts.push(path.call(print, "id"));
            if (n.name) {
                parts.push(" as ", path.call(print, "name"));
            }
        }

        return concat(parts);

    case "ExportBatchSpecifier":
        return fromString("*");

    case "ImportNamespaceSpecifier":
        parts.push("* as ");
        if (n.local) {
            parts.push(path.call(print, "local"));
        } else if (n.id) {
            parts.push(path.call(print, "id"));
        }
        return concat(parts);

    case "ImportDefaultSpecifier":
        if (n.local) {
            return path.call(print, "local");
        }
        return path.call(print, "id");

    case "ExportDeclaration":
    case "ExportDefaultDeclaration":
    case "ExportNamedDeclaration":
        return printExportDeclaration(path, options, print);

    case "ExportAllDeclaration":
        parts.push("export *");

        if (n.exported) {
            parts.push(" as ", path.call(print, "exported"));
        }

        parts.push(
            " from ",
            path.call(print, "source")
        );

        return concat(parts);

    case "ExportNamespaceSpecifier":
        return concat(["* as ", path.call(print, "exported")]);

    case "ExportDefaultSpecifier":
        return path.call(print, "exported");

    case "Import":
        return fromString("import", options);

    case "ImportDeclaration":
        parts.push("import ");

        if (n.importKind && n.importKind !== "value") {
            parts.push(n.importKind + " ");
        }

        if (n.specifiers &&
            n.specifiers.length > 0) {

            var foundImportSpecifier = false;

            path.each(function(specifierPath) {
                var i = specifierPath.getName();
                if (i > 0) {
                    parts.push(", ");
                }

                var value = specifierPath.getValue();

                if (namedTypes.ImportDefaultSpecifier.check(value) ||
                    namedTypes.ImportNamespaceSpecifier.check(value)) {
                    assert.strictEqual(foundImportSpecifier, false);
                } else {
                    namedTypes.ImportSpecifier.assert(value);
                    if (!foundImportSpecifier) {
                        foundImportSpecifier = true;
                        parts.push(
                          options.objectCurlySpacing ? "{ " : "{"
                        );
                    }
                }

                parts.push(print(specifierPath));
            }, "specifiers");

            if (foundImportSpecifier) {
                parts.push(
                  options.objectCurlySpacing ? " }" : "}"
                );
            }

            parts.push(" from ");
        }

        parts.push(path.call(print, "source"), ";");

        return concat(parts);

    case "BlockStatement":
        var naked = path.call(function(bodyPath) {
            return printStatementSequence(bodyPath, options, print);
        }, "body");

        if (naked.isEmpty()) {
            if (!n.directives || n.directives.length === 0) {
                return fromString("{}");
            }
        }

        parts.push("{\n");
        // Babel 6
        if (n.directives) {
            path.each(function(childPath) {
                parts.push(
                    print(childPath).indent(options.tabWidth),
                    ";",
                    n.directives.length > 1 || !naked.isEmpty() ? "\n" : ""
                );
            }, "directives");
        }
        parts.push(naked.indent(options.tabWidth));
        parts.push("\n}");

        return concat(parts);

    case "ReturnStatement":
        parts.push("return");

        if (n.argument) {
            var argLines = path.call(print, "argument");
            if (argLines.startsWithComment() ||
                (argLines.length > 1 &&
                    namedTypes.JSXElement &&
                    namedTypes.JSXElement.check(n.argument)
                )) {
                parts.push(
                    " (\n",
                    argLines.indent(options.tabWidth),
                    "\n)"
                );
            } else {
                parts.push(" ", argLines);
            }
        }

        parts.push(";");

        return concat(parts);

    case "CallExpression":
        return concat([
            path.call(print, "callee"),
            printArgumentsList(path, options, print)
        ]);

    case "ObjectExpression":
    case "ObjectPattern":
    case "ObjectTypeAnnotation":
        var allowBreak = false;
        var isTypeAnnotation = n.type === "ObjectTypeAnnotation";
        var separator = options.flowObjectCommas ? "," : (isTypeAnnotation ? ";" : ",");
        var fields = [];

        if (isTypeAnnotation) {
            fields.push("indexers", "callProperties");
        }

        fields.push("properties");

        var len = 0;
        fields.forEach(function(field) {
            len += n[field].length;
        });

        var oneLine = (isTypeAnnotation && len === 1) || len === 0;
        var leftBrace = n.exact ? "{|" : "{";
        var rightBrace = n.exact ? "|}" : "}";
        parts.push(oneLine ? leftBrace : leftBrace + "\n");
        var leftBraceIndex = parts.length - 1;

        var i = 0;
        fields.forEach(function(field) {
            path.each(function(childPath) {
                var lines = print(childPath);

                if (!oneLine) {
                    lines = lines.indent(options.tabWidth);
                }

                var multiLine = !isTypeAnnotation && lines.length > 1;
                if (multiLine && allowBreak && options.extraLineBreaksForMultilineProperty) {
                    // Similar to the logic for BlockStatement.
                    parts.push("\n");
                }

                parts.push(lines);

                if (i < len - 1) {
                    // Add an extra line break if the previous object property
                    // had a multi-line value.
                    parts.push(separator + (multiLine && options.extraLineBreaksForMultilineProperty ? "\n\n" : "\n"));
                    allowBreak = !multiLine;
                } else if (len !== 1 && isTypeAnnotation) {
                    parts.push(separator);
                } else if (!oneLine && util.isTrailingCommaEnabled(options, "objects")) {
                    parts.push(separator);
                }
                i++;
            }, field);
        });

        parts.push(oneLine ? rightBrace : "\n" + rightBrace);

        if (i !== 0 && oneLine && options.objectCurlySpacing) {
            parts[leftBraceIndex] = leftBrace + " ";
            parts[parts.length - 1] = " " + rightBrace;
        }

        return concat(parts);

    case "PropertyPattern":
        return concat([
            path.call(print, "key"),
            ": ",
            path.call(print, "pattern")
        ]);

    case "ObjectProperty": // Babel 6
    case "Property": // Non-standard AST node type.
        if (n.method || n.kind === "get" || n.kind === "set") {
            return printMethod(path, options, print);
        }

        var key = path.call(print, "key");
        if (n.computed) {
            parts.push("[", key, "]");
        } else {
            parts.push(key);
        }

        if (! n.shorthand) {
            parts.push(": ", path.call(print, "value"));
        }

        return concat(parts);

    case "ClassMethod": // Babel 6
        if (n.static) {
            parts.push("static ");
        }

        return concat([parts, printObjectMethod(path, options, print)]);

    case "ObjectMethod": // Babel 6
        return printObjectMethod(path, options, print);

    case "Decorator":
        return concat(["@", path.call(print, "expression")]);

    case "ArrayExpression":
    case "ArrayPattern":
        var elems = n.elements,
            len = elems.length;

        var printed = path.map(print, "elements");
        var joined = fromString(", ").join(printed);
        var oneLine = joined.getLineLength(1) <= options.wrapColumn;
        if (oneLine) {
          if (options.arrayBracketSpacing) {
            parts.push("[ ");
          } else {
            parts.push("[");
          }
        } else {
          parts.push("[\n");
        }

        path.each(function(elemPath) {
            var i = elemPath.getName();
            var elem = elemPath.getValue();
            if (!elem) {
                // If the array expression ends with a hole, that hole
                // will be ignored by the interpreter, but if it ends with
                // two (or more) holes, we need to write out two (or more)
                // commas so that the resulting code is interpreted with
                // both (all) of the holes.
                parts.push(",");
            } else {
                var lines = printed[i];
                if (oneLine) {
                    if (i > 0)
                        parts.push(" ");
                } else {
                    lines = lines.indent(options.tabWidth);
                }
                parts.push(lines);
                if (i < len - 1 || (!oneLine && util.isTrailingCommaEnabled(options, "arrays"))) {
                    parts.push(",");
                }
                if (!oneLine) {
                    parts.push("\n");
                }
            }
        }, "elements");

        if (oneLine && options.arrayBracketSpacing) {
          parts.push(" ]");
        } else {
          parts.push("]");
        }

        return concat(parts);

    case "SequenceExpression":
        return fromString(", ").join(path.map(print, "expressions"));

    case "ThisExpression":
        return fromString("this");

    case "Super":
        return fromString("super");

    case "NullLiteral": // Babel 6 Literal split
        return fromString("null");

    case "RegExpLiteral": // Babel 6 Literal split
        return fromString(n.extra.raw);

    case "BooleanLiteral": // Babel 6 Literal split
    case "NumericLiteral": // Babel 6 Literal split
    case "StringLiteral": // Babel 6 Literal split
    case "Literal":
        if (typeof n.value !== "string")
            return fromString(n.value, options);

        return fromString(nodeStr(n.value, options), options);

    case "Directive": // Babel 6
        return path.call(print, "value");

    case "DirectiveLiteral": // Babel 6
        return fromString(nodeStr(n.value, options));

    case "ModuleSpecifier":
        if (n.local) {
            throw new Error(
                "The ESTree ModuleSpecifier type should be abstract"
            );
        }

        // The Esprima ModuleSpecifier type is just a string-valued
        // Literal identifying the imported-from module.
        return fromString(nodeStr(n.value, options), options);

    case "UnaryExpression":
        parts.push(n.operator);
        if (/[a-z]$/.test(n.operator))
            parts.push(" ");
        parts.push(path.call(print, "argument"));
        return concat(parts);

    case "UpdateExpression":
        parts.push(
            path.call(print, "argument"),
            n.operator
        );

        if (n.prefix)
            parts.reverse();

        return concat(parts);

    case "ConditionalExpression":
        return concat([
            "(", path.call(print, "test"),
            " ? ", path.call(print, "consequent"),
            " : ", path.call(print, "alternate"), ")"
        ]);

    case "NewExpression":
        parts.push("new ", path.call(print, "callee"));
        var args = n.arguments;
        if (args) {
            parts.push(printArgumentsList(path, options, print));
        }

        return concat(parts);

    case "VariableDeclaration":
        parts.push(n.kind, " ");
        var maxLen = 0;
        var printed = path.map(function(childPath) {
            var lines = print(childPath);
            maxLen = Math.max(lines.length, maxLen);
            return lines;
        }, "declarations");

        if (maxLen === 1) {
            parts.push(fromString(", ").join(printed));
        } else if (printed.length > 1 ) {
            parts.push(
                fromString(",\n").join(printed)
                    .indentTail(n.kind.length + 1)
            );
        } else {
            parts.push(printed[0]);
        }

        // We generally want to terminate all variable declarations with a
        // semicolon, except when they are children of for loops.
        var parentNode = path.getParentNode();
        if (!namedTypes.ForStatement.check(parentNode) &&
            !namedTypes.ForInStatement.check(parentNode) &&
            !(namedTypes.ForOfStatement &&
              namedTypes.ForOfStatement.check(parentNode)) &&
            !(namedTypes.ForAwaitStatement &&
              namedTypes.ForAwaitStatement.check(parentNode))) {
            parts.push(";");
        }

        return concat(parts);

    case "VariableDeclarator":
        return n.init ? fromString(" = ").join([
            path.call(print, "id"),
            path.call(print, "init")
        ]) : path.call(print, "id");

    case "WithStatement":
        return concat([
            "with (",
            path.call(print, "object"),
            ") ",
            path.call(print, "body")
        ]);

    case "IfStatement":
        var con = adjustClause(path.call(print, "consequent"), options),
            parts = ["if (", path.call(print, "test"), ")", con];

        if (n.alternate)
            parts.push(
                endsWithBrace(con, options) ? " else" : "\nelse",
                adjustClause(path.call(print, "alternate"), options));

        return concat(parts);

    case "ForStatement":
        // TODO Get the for (;;) case right.
        var init = path.call(print, "init"),
            sep = init.length > 1 ? ";\n" : "; ",
            forParen = "for (",
            indented = fromString(sep).join([
                init,
                path.call(print, "test"),
                path.call(print, "update")
            ]).indentTail(forParen.length),
            head = concat([forParen, indented, ")"]),
            clause = adjustClause(path.call(print, "body"), options),
            parts = [head];

        if (head.length > 1) {
            parts.push("\n");
            clause = clause.trimLeft();
        }

        parts.push(clause);

        return concat(parts);

    case "WhileStatement":
        return concat([
            "while (",
            path.call(print, "test"),
            ")",
            adjustClause(path.call(print, "body"), options)
        ]);

    case "ForInStatement":
        // Note: esprima can't actually parse "for each (".
        return concat([
            n.each ? "for each (" : "for (",
            path.call(print, "left"),
            " in ",
            path.call(print, "right"),
            ")",
            adjustClause(path.call(print, "body"), options)
        ]);

    case "ForOfStatement":
        return concat([
            "for (",
            path.call(print, "left"),
            " of ",
            path.call(print, "right"),
            ")",
            adjustClause(path.call(print, "body"), options)
        ]);

    case "ForAwaitStatement":
        return concat([
            "for await (",
            path.call(print, "left"),
            " of ",
            path.call(print, "right"),
            ")",
            adjustClause(path.call(print, "body"), options)
        ]);

    case "DoWhileStatement":
        var doBody = concat([
            "do",
            adjustClause(path.call(print, "body"), options)
        ]), parts = [doBody];

        if (endsWithBrace(doBody, options))
            parts.push(" while");
        else
            parts.push("\nwhile");

        parts.push(" (", path.call(print, "test"), ");");

        return concat(parts);

    case "DoExpression":
        var statements = path.call(function(bodyPath) {
            return printStatementSequence(bodyPath, options, print);
        }, "body");

        return concat([
            "do {\n",
            statements.indent(options.tabWidth),
            "\n}"
        ]);

    case "BreakStatement":
        parts.push("break");
        if (n.label)
            parts.push(" ", path.call(print, "label"));
        parts.push(";");
        return concat(parts);

    case "ContinueStatement":
        parts.push("continue");
        if (n.label)
            parts.push(" ", path.call(print, "label"));
        parts.push(";");
        return concat(parts);

    case "LabeledStatement":
        return concat([
            path.call(print, "label"),
            ":\n",
            path.call(print, "body")
        ]);

    case "TryStatement":
        parts.push(
            "try ",
            path.call(print, "block")
        );

        if (n.handler) {
            parts.push(" ", path.call(print, "handler"));
        } else if (n.handlers) {
            path.each(function(handlerPath) {
                parts.push(" ", print(handlerPath));
            }, "handlers");
        }

        if (n.finalizer) {
            parts.push(" finally ", path.call(print, "finalizer"));
        }

        return concat(parts);

    case "CatchClause":
        parts.push("catch (", path.call(print, "param"));

        if (n.guard)
            // Note: esprima does not recognize conditional catch clauses.
            parts.push(" if ", path.call(print, "guard"));

        parts.push(") ", path.call(print, "body"));

        return concat(parts);

    case "ThrowStatement":
        return concat(["throw ", path.call(print, "argument"), ";"]);

    case "SwitchStatement":
        var block = fromString("\n").join(path.map(print, "cases"));

        // WARNING: lastPos()+charAt() API does not deliver as charAt() will
        // produce a newline where there isn't on occasion, so we have to
        // convert the generated code to a string and check the old-fashioned
        // way if the last character is (part of) a line ending:
        var outp = block.toString();
        var ch = outp[outp.length - 1];

        return concat([
            "switch (",
            path.call(print, "discriminant"),
            ") {\n",
            block,
            ((options.lineTerminator + "\r\n").indexOf(ch) >= 0 ? "}" : "\n}")
        ]);

        // Note: ignoring n.lexical because it has no printing consequences.

    case "SwitchCase":
        if (n.test)
            parts.push("case ", path.call(print, "test"), ":");
        else
            parts.push("default:");

        if (n.consequent.length > 0) {
            parts.push("\n", path.call(function(consequentPath) {
                return printStatementSequence(consequentPath, options, print);
            }, "consequent").indent(options.tabWidth));
            parts.push("\n");       // empty line to separate cases/case-collections with code blocks 
        }

        return concat(parts);

    case "DebuggerStatement":
        return fromString("debugger;");

    // JSX extensions below.

    case "JSXAttribute":
        parts.push(path.call(print, "name"));
        if (n.value)
            parts.push("=", path.call(print, "value"));
        return concat(parts);

    case "JSXIdentifier":
        return fromString(n.name, options);

    case "JSXNamespacedName":
        return fromString(":").join([
            path.call(print, "namespace"),
            path.call(print, "name")
        ]);

    case "JSXMemberExpression":
        return fromString(".").join([
            path.call(print, "object"),
            path.call(print, "property")
        ]);

    case "JSXSpreadAttribute":
        return concat(["{...", path.call(print, "argument"), "}"]);

    case "JSXSpreadChild":
        return concat(["{...", path.call(print, "expression"), "}"]);

    case "JSXExpressionContainer":
        return concat(["{", path.call(print, "expression"), "}"]);

    case "JSXElement":
        var openingLines = path.call(print, "openingElement");

        if (n.openingElement.selfClosing) {
            assert.ok(!n.closingElement);
            return openingLines;
        }

        var childLines = concat(
            path.map(function(childPath) {
                var child = childPath.getValue();

                if (namedTypes.Literal.check(child) &&
                    typeof child.value === "string") {
                    if (/\S/.test(child.value)) {
                        return child.value.replace(/^\s+|\s+$/g, "");
                    } else if (/\n/.test(child.value)) {
                        return "\n";
                    }
                }

                return print(childPath);
            }, "children")
        ).indentTail(options.tabWidth);

        var closingLines = path.call(print, "closingElement");

        return concat([
            openingLines,
            childLines,
            closingLines
        ]);

    case "JSXOpeningElement":
        parts.push("<", path.call(print, "name"));
        var attrParts = [];

        path.each(function(attrPath) {
            attrParts.push(" ", print(attrPath));
        }, "attributes");

        var attrLines = concat(attrParts);

        var needLineWrap = (
            attrLines.length > 1 ||
            attrLines.getLineLength(1) > options.wrapColumn
        );

        if (needLineWrap) {
            attrParts.forEach(function(part, i) {
                if (part === " ") {
                    assert.strictEqual(i % 2, 0);
                    attrParts[i] = "\n";
                }
            });

            attrLines = concat(attrParts).indentTail(options.tabWidth);
        }

        parts.push(attrLines, n.selfClosing ? " />" : ">");

        return concat(parts);

    case "JSXClosingElement":
        return concat(["</", path.call(print, "name"), ">"]);

    case "JSXText":
        return fromString(n.value, options);

    case "JSXEmptyExpression":
        return fromString("");

    case "TypeAnnotatedIdentifier":
        return concat([
            path.call(print, "annotation"),
            " ",
            path.call(print, "identifier")
        ]);

    case "ClassBody":
        if (n.body.length === 0) {
            return fromString("{}");
        }

        return concat([
            "{\n",
            path.call(function(bodyPath) {
                return printStatementSequence(bodyPath, options, print);
            }, "body").indent(options.tabWidth),
            "\n}"
        ]);

    case "ClassPropertyDefinition":
        parts.push("static ", path.call(print, "definition"));
        if (!namedTypes.MethodDefinition.check(n.definition))
            parts.push(";");
        return concat(parts);

    case "ClassProperty":
        if (n.static)
            parts.push("static ");

        var key = path.call(print, "key");
        if (n.computed) {
            key = concat(["[", key, "]"]);
        } else if (n.variance === "plus") {
            key = concat(["+", key]);
        } else if (n.variance === "minus") {
            key = concat(["-", key]);
        }
        parts.push(key);

        if (n.typeAnnotation)
            parts.push(path.call(print, "typeAnnotation"));

        if (n.value)
            parts.push(" = ", path.call(print, "value"));

        parts.push(";");
        return concat(parts);

    case "ClassDeclaration":
    case "ClassExpression":
        parts.push("class");

        if (n.id) {
            parts.push(
                " ",
                path.call(print, "id"),
                path.call(print, "typeParameters")
            );
        }

        if (n.superClass) {
            parts.push(
                " extends ",
                path.call(print, "superClass"),
                path.call(print, "superTypeParameters")
            );
        }

        if (n["implements"] && n['implements'].length > 0) {
            parts.push(
                " implements ",
                fromString(", ").join(path.map(print, "implements"))
            );
        }

        parts.push(" ", path.call(print, "body"));

        return concat(parts);

    case "TemplateElement":
        return fromString(n.value.raw, options).lockIndentTail();

    case "TemplateLiteral":
        var expressions = path.map(print, "expressions");
        parts.push("`");

        path.each(function(childPath) {
            var i = childPath.getName();
            parts.push(print(childPath));
            if (i < expressions.length) {
                parts.push("${", expressions[i], "}");
            }
        }, "quasis");

        parts.push("`");

        return concat(parts).lockIndentTail();

    case "TaggedTemplateExpression":
        return concat([
            path.call(print, "tag"),
            path.call(print, "quasi")
        ]);

    // These types are unprintable because they serve as abstract
    // supertypes for other (printable) types.
    case "Node":
    case "Printable":
    case "SourceLocation":
    case "Position":
    case "Statement":
    case "Function":
    case "Pattern":
    case "Expression":
    case "Declaration":
    case "Specifier":
    case "NamedSpecifier":
    case "Comment": // Supertype of Block and Line.
    case "MemberTypeAnnotation": // Flow
    case "TupleTypeAnnotation": // Flow
    case "Type": // Flow
        throw new Error("unprintable type: " + JSON.stringify(n.type));

    case "CommentBlock": // Babel block comment.
    case "Block": // Esprima block comment.
        options.nukeMultiIndent = true;
        var rv = concat(["/*", fromString(n.value, options), "*/"]);
        delete options.nukeMultiIndent;
        return rv;


    case "CommentLine": // Babel line comment.
    case "Line": // Esprima line comment.
        return concat(["//", fromString(n.value, options)]);

    // Type Annotations for Facebook Flow, typically stripped out or
    // transformed away before printing.
    case "TypeAnnotation":
        if (n.typeAnnotation) {
            if (n.typeAnnotation.type !== "FunctionTypeAnnotation") {
                parts.push(": ");
            }
            parts.push(path.call(print, "typeAnnotation"));
            return concat(parts);
        }

        return fromString("");

    case "ExistentialTypeParam":
    case "ExistsTypeAnnotation":
        return fromString("*", options);

    case "EmptyTypeAnnotation":
        return fromString("empty", options);

    case "AnyTypeAnnotation":
        return fromString("any", options);

    case "MixedTypeAnnotation":
        return fromString("mixed", options);

    case "ArrayTypeAnnotation":
        return concat([
            path.call(print, "elementType"),
            "[]"
        ]);

    case "BooleanTypeAnnotation":
        return fromString("boolean", options);

    case "BooleanLiteralTypeAnnotation":
        assert.strictEqual(typeof n.value, "boolean");
        return fromString("" + n.value, options);

    case "DeclareClass":
        return printFlowDeclaration(path, [
            "class ",
            path.call(print, "id"),
            " ",
            path.call(print, "body"),
        ]);

    case "DeclareFunction":
        return printFlowDeclaration(path, [
            "function ",
            path.call(print, "id"),
            ";"
        ]);

    case "DeclareModule":
        return printFlowDeclaration(path, [
            "module ",
            path.call(print, "id"),
            " ",
            path.call(print, "body"),
        ]);

    case "DeclareModuleExports":
        return printFlowDeclaration(path, [
            "module.exports",
            path.call(print, "typeAnnotation"),
        ]);

    case "DeclareVariable":
        return printFlowDeclaration(path, [
            "var ",
            path.call(print, "id"),
            ";"
        ]);

    case "DeclareExportDeclaration":
    case "DeclareExportAllDeclaration":
        return concat([
            "declare ",
            printExportDeclaration(path, options, print)
        ]);

    case "FunctionTypeAnnotation":
        // FunctionTypeAnnotation is ambiguous:
        // declare function(a: B): void; OR
        // var A: (a: B) => void;
        var parent = path.getParentNode(0);
        var isArrowFunctionTypeAnnotation = !(
            namedTypes.ObjectTypeCallProperty.check(parent) ||
            namedTypes.DeclareFunction.check(path.getParentNode(2))
        );

        var needsColon =
            isArrowFunctionTypeAnnotation &&
            !namedTypes.FunctionTypeParam.check(parent);

        if (needsColon) {
            parts.push(": ");
        }

        parts.push(
            "(",
            fromString(", ").join(path.map(print, "params")),
            ")"
        );

        // The returnType is not wrapped in a TypeAnnotation, so the colon
        // needs to be added separately.
        if (n.returnType) {
            parts.push(
                isArrowFunctionTypeAnnotation ? " => " : ": ",
                path.call(print, "returnType")
            );
        }

        return concat(parts);

    case "FunctionTypeParam":
        return concat([
            path.call(print, "name"),
            n.optional ? '?' : '',
            ": ",
            path.call(print, "typeAnnotation"),
        ]);

    case "GenericTypeAnnotation":
        return concat([
            path.call(print, "id"),
            path.call(print, "typeParameters")
        ]);

    case "DeclareInterface":
        parts.push("declare ");
        // Fall through to InterfaceDeclaration...

    case "InterfaceDeclaration":
        parts.push(
            fromString("interface ", options),
            path.call(print, "id"),
            path.call(print, "typeParameters"),
            " "
        );

        if (n["extends"]) {
            parts.push(
                "extends ",
                fromString(", ").join(path.map(print, "extends"))
            );
        }

        parts.push(" ", path.call(print, "body"));

        return concat(parts);

    case "ClassImplements":
    case "InterfaceExtends":
        return concat([
            path.call(print, "id"),
            path.call(print, "typeParameters")
        ]);

    case "IntersectionTypeAnnotation":
        return fromString(" & ").join(path.map(print, "types"));

    case "NullableTypeAnnotation":
        return concat([
            "?",
            path.call(print, "typeAnnotation")
        ]);

    case "NullLiteralTypeAnnotation":
        return fromString("null", options);

    case "ThisTypeAnnotation":
        return fromString("this", options);

    case "NumberTypeAnnotation":
        return fromString("number", options);

    case "ObjectTypeCallProperty":
        return path.call(print, "value");

    case "ObjectTypeIndexer":
        var variance =
            n.variance === "plus" ? "+" :
            n.variance === "minus" ? "-" : "";

        return concat([
            variance,
            "[",
            path.call(print, "id"),
            ": ",
            path.call(print, "key"),
            "]: ",
            path.call(print, "value")
        ]);

    case "ObjectTypeProperty":
        var variance =
            n.variance === "plus" ? "+" :
            n.variance === "minus" ? "-" : "";

        return concat([
            variance,
            path.call(print, "key"),
            n.optional ? "?" : "",
            ": ",
            path.call(print, "value")
        ]);

    case "QualifiedTypeIdentifier":
        return concat([
            path.call(print, "qualification"),
            ".",
            path.call(print, "id")
        ]);

    case "StringLiteralTypeAnnotation":
        return fromString(nodeStr(n.value, options), options);

    case "NumberLiteralTypeAnnotation":
    case "NumericLiteralTypeAnnotation":
        assert.strictEqual(typeof n.value, "number");
        return fromString(JSON.stringify(n.value), options);

    case "StringTypeAnnotation":
        return fromString("string", options);

    case "DeclareTypeAlias":
        parts.push("declare ");
        // Fall through to TypeAlias...

    case "TypeAlias":
        return concat([
            "type ",
            path.call(print, "id"),
            path.call(print, "typeParameters"),
            " = ",
            path.call(print, "right"),
            ";"
        ]);

    case "DeclareOpaqueType":
        parts.push("declare ");
        // Fall through to OpaqueType...

    case "OpaqueType":
        parts.push(
            "opaque type ",
            path.call(print, "id"),
            path.call(print, "typeParameters")
        );

        if (n["supertype"]) {
            parts.push(": ", path.call(print, "supertype"));
        }

        if (n["impltype"]) {
            parts.push(" = ", path.call(print, "impltype"));
        }

        parts.push(";");

        return concat(parts);

    case "TypeCastExpression":
        return concat([
            "(",
            path.call(print, "expression"),
            path.call(print, "typeAnnotation"),
            ")"
        ]);

    case "TypeParameterDeclaration":
    case "TypeParameterInstantiation":
        return concat([
            "<",
            fromString(", ").join(path.map(print, "params")),
            ">"
        ]);

    case "TypeParameter":
        switch (n.variance) {
            case 'plus':
                parts.push('+');
                break;
            case 'minus':
                parts.push('-');
                break;
            default:
        }

        parts.push(path.call(print, 'name'));

        if (n.bound) {
            parts.push(path.call(print, 'bound'));
        }

        if (n['default']) {
            parts.push('=', path.call(print, 'default'));
        }

        return concat(parts);

    case "TypeofTypeAnnotation":
        return concat([
            fromString("typeof ", options),
            path.call(print, "argument")
        ]);

    case "UnionTypeAnnotation":
        return fromString(" | ").join(path.map(print, "types"));

    case "VoidTypeAnnotation":
        return fromString("void", options);

    case "NullTypeAnnotation":
        return fromString("null", options);

    // Unhandled types below. If encountered, nodes of these types should
    // be either left alone or desugared into AST types that are fully
    // supported by the pretty-printer.
    case "ClassHeritage": // TODO
    case "ComprehensionBlock": // TODO
    case "ComprehensionExpression": // TODO
    case "Glob": // TODO
    case "GeneratorExpression": // TODO
    case "LetStatement": // TODO
    case "LetExpression": // TODO
    case "GraphExpression": // TODO
    case "GraphIndexExpression": // TODO

    // XML types that nobody cares about or needs to print.
    case "XMLDefaultDeclaration":
    case "XMLAnyName":
    case "XMLQualifiedIdentifier":
    case "XMLFunctionQualifiedIdentifier":
    case "XMLAttributeSelector":
    case "XMLFilterExpression":
    case "XML":
    case "XMLElement":
    case "XMLList":
    case "XMLEscape":
    case "XMLText":
    case "XMLStartTag":
    case "XMLEndTag":
    case "XMLPointTag":
    case "XMLName":
    case "XMLAttribute":
    case "XMLCdata":
    case "XMLComment":
    case "XMLProcessingInstruction":
    default:
        debugger;
        throw new Error("unknown type: " + JSON.stringify(n.type));
    }

    return p;
}

function printStatementSequence(path, options, print) {
    var inClassBody =
        namedTypes.ClassBody &&
        namedTypes.ClassBody.check(path.getParentNode());

    var filtered = [];
    var sawComment = false;
    var sawStatement = false;

    path.each(function(stmtPath) {
        var i = stmtPath.getName();
        var stmt = stmtPath.getValue();

        // Just in case the AST has been modified to contain falsy
        // "statements," it's safer simply to skip them.
        if (!stmt) {
            return;
        }

        // Skip printing EmptyStatement nodes to avoid leaving stray
        // semicolons lying around.
        if (stmt.type === "EmptyStatement") {
            return;
        }

        if (namedTypes.Comment.check(stmt)) {
            // The pretty printer allows a dangling Comment node to act as
            // a Statement when the Comment can't be attached to any other
            // non-Comment node in the tree.
            sawComment = true;
        } else if (namedTypes.Statement.check(stmt)) {
            sawStatement = true;
        } else {
            // When the pretty printer encounters a string instead of an
            // AST node, it just prints the string. This behavior can be
            // useful for fine-grained formatting decisions like inserting
            // blank lines.
            isString.assert(stmt);
        }

        // We can't hang onto stmtPath outside of this function, because
        // it's just a reference to a mutable FastPath object, so we have
        // to go ahead and print it here.
        filtered.push({
            node: stmt,
            printed: print(stmtPath)
        });
    });

    if (sawComment) {
        assert.strictEqual(
            sawStatement, false,
            "Comments may appear as statements in otherwise empty statement " +
                "lists, but may not coexist with non-Comment nodes."
        );
    }

    var prevTrailingSpace = null;
    var len = filtered.length;
    var parts = [];

    filtered.forEach(function(info, i) {
        var printed = info.printed;
        var stmt = info.node;
        var multiLine = printed.length > 1;
        var notFirst = i > 0;
        var notLast = i < len - 1;
        var leadingSpace;
        var trailingSpace;
        var lines = stmt && stmt.loc && stmt.loc.lines;
        var trueLoc = lines && options.reuseWhitespace &&
            util.getTrueLoc(stmt, lines);

        if (notFirst) {
            if (trueLoc) {
                var beforeStart = lines.skipSpaces(trueLoc.start, true);
                var beforeStartLine = beforeStart ? beforeStart.line : 1;
                var leadingGap = trueLoc.start.line - beforeStartLine;
                leadingSpace = Array(leadingGap + 1).join("\n");
            } else {
                leadingSpace = multiLine ? "\n\n" : "\n";
            }
        } else {
            leadingSpace = "";
        }

        if (notLast) {
            if (trueLoc) {
                var afterEnd = lines.skipSpaces(trueLoc.end);
                var afterEndLine = afterEnd ? afterEnd.line : lines.length;
                var trailingGap = afterEndLine - trueLoc.end.line;
                trailingSpace = Array(trailingGap + 1).join("\n");
            } else {
                trailingSpace = multiLine ? "\n\n" : "\n";
            }
        } else {
            trailingSpace = "";
        }

        parts.push(
            maxSpace(prevTrailingSpace, leadingSpace),
            printed
        );

        if (notLast) {
            prevTrailingSpace = trailingSpace;
        } else if (trailingSpace) {
            parts.push(trailingSpace);
        }
    });

    return concat(parts);
}

function maxSpace(s1, s2) {
    if (!s1 && !s2) {
        return fromString("");
    }

    if (!s1) {
        return fromString(s2);
    }

    if (!s2) {
        return fromString(s1);
    }

    var spaceLines1 = fromString(s1);
    var spaceLines2 = fromString(s2);

    if (spaceLines2.length > spaceLines1.length) {
        return spaceLines2;
    }

    return spaceLines1;
}

function printMethod(path, options, print) {
    var node = path.getNode();
    var kind = node.kind;
    var parts = [];

    if (node.type === "ObjectMethod" || node.type === "ClassMethod") {
        node.value = node;
    } else {
        namedTypes.FunctionExpression.assert(node.value);
    }

    if (node.value.async) {
        parts.push("async ");
    }

    if (!kind || kind === "init" || kind === "method" || kind === "constructor") {
        if (node.value.generator) {
            parts.push("*");
        }
    } else {
        assert.ok(kind === "get" || kind === "set");
        parts.push(kind, " ");
    }

    var key = path.call(print, "key");
    if (node.computed) {
        key = concat(["[", key, "]"]);
    }

    parts.push(
        key,
        path.call(print, "value", "typeParameters"),
        "(",
        path.call(function(valuePath) {
            return printFunctionParams(valuePath, options, print);
        }, "value"),
        ")",
        path.call(print, "value", "returnType"),
        " ",
        path.call(print, "value", "body")
    );

    return concat(parts);
}

function printArgumentsList(path, options, print) {
    var printed = path.map(print, "arguments");
    var trailingComma = util.isTrailingCommaEnabled(options, "parameters");

    var joined = fromString(", ").join(printed);
    if (joined.getLineLength(1) > options.wrapColumn) {
        joined = fromString(",\n").join(printed);
        return concat([
            "(\n",
            joined.indent(options.tabWidth),
            trailingComma ? ",\n)" : "\n)"
        ]);
    }

    return concat(["(", joined, ")"]);
}

function printFunctionParams(path, options, print) {
    var fun = path.getValue();

    namedTypes.Function.assert(fun);

    var printed = path.map(print, "params");

    if (fun.defaults) {
        path.each(function(defExprPath) {
            var i = defExprPath.getName();
            var p = printed[i];
            if (p && defExprPath.getValue()) {
                printed[i] = concat([p, " = ", print(defExprPath)]);
            }
        }, "defaults");
    }

    if (fun.rest) {
        printed.push(concat(["...", path.call(print, "rest")]));
    }

    var joined = fromString(", ").join(printed);
    if (joined.length > 1 ||
        joined.getLineLength(1) > options.wrapColumn) {
        joined = fromString(",\n").join(printed);
        if (util.isTrailingCommaEnabled(options, "parameters") &&
            !fun.rest &&
            fun.params[fun.params.length - 1].type !== 'RestElement') {
            joined = concat([joined, ",\n"]);
        } else {
            joined = concat([joined, "\n"]);
        }
        return concat(["\n", joined.indent(options.tabWidth)]);
    }

    return joined;
}

function printObjectMethod(path, options, print) {
    var objMethod = path.getValue();
    var parts = [];

    if (objMethod.async)
        parts.push("async ");

    if (objMethod.generator)
        parts.push("*");

    if (objMethod.method || objMethod.kind === "get" || objMethod.kind === "set") {
        return printMethod(path, options, print);
    }

    var key = path.call(print, "key");
    if (objMethod.computed) {
        parts.push("[", key, "]");
    } else {
        parts.push(key);
    }

    parts.push(
        "(",
        printFunctionParams(path, options, print),
        ")",
        path.call(print, "returnType"),
        " ",
        path.call(print, "body")
    );

    return concat(parts);
}

function printExportDeclaration(path, options, print) {
    var decl = path.getValue();
    var parts = ["export "];
    var shouldPrintSpaces = options.objectCurlySpacing;

    namedTypes.Declaration.assert(decl);

    if (decl["default"] ||
        decl.type === "ExportDefaultDeclaration") {
        parts.push("default ");
    }

    if (decl.declaration) {
        parts.push(path.call(print, "declaration"));

    } else if (decl.specifiers &&
               decl.specifiers.length > 0) {

        if (decl.specifiers.length === 1 &&
            decl.specifiers[0].type === "ExportBatchSpecifier") {
            parts.push("*");
        } else {
            parts.push(
                shouldPrintSpaces ? "{ " : "{",
                fromString(", ").join(path.map(print, "specifiers")),
                shouldPrintSpaces ? " }" : "}"
            );
        }

        if (decl.source) {
            parts.push(" from ", path.call(print, "source"));
        }
    }

    var lines = concat(parts);

    if (lastNonSpaceCharacter(lines, options) !== ";" &&
        ! (decl.declaration &&
           (decl.declaration.type === "FunctionDeclaration" ||
            decl.declaration.type === "ClassDeclaration"))) {
        lines = concat([lines, ";"]);
    }

    return lines;
}

function printFlowDeclaration(path, parts) {
    var parentExportDecl = util.getParentExportDeclaration(path);

    if (parentExportDecl) {
        assert.strictEqual(
            parentExportDecl.type,
            "DeclareExportDeclaration"
        );
    } else {
        // If the parent node has type DeclareExportDeclaration, then it
        // will be responsible for printing the "declare" token. Otherwise
        // it needs to be printed with this non-exported declaration node.
        parts.unshift("declare ");
    }

    return concat(parts);
}

function adjustClause(clause, options) {
    if (clause.length > 1)
        return concat([" ", clause]);

    return concat([
        "\n",
        maybeAddSemicolon(clause, options).indent(options.tabWidth)
    ]);
}

function lastNonSpaceCharacter(lines, options) {
    var pos = lines.lastPos();
    var skip_ETX_STX_range = false;
    do {
        var ch = lines.charAt(pos);
        // HOTFIX 2: The Second Part
        // 
        // When we hit the END of a trailing line comment, we have
        // to skip it entirely until we hit the START marker and
        // *then* we look for the last-non-space-character 
        // for real!
        // 
        // Meanwhile we *know* the postprocessor will pick up
        // any terminator character appended beyond the END marker
        // on the same line gets shifted to the STX slot, so
        // we can safely do this skip END-to-START manoeuvre here!
        if (ch === options.ETX) {
            skip_ETX_STX_range = true;
        } else if (ch === options.STX) {
            skip_ETX_STX_range = false;
        }
        else if (!skip_ETX_STX_range && /\S/.test(ch)) {
            return ch;
        }
    } while (lines.prevPos(pos));
}

function endsWithBrace(lines, options) {
    return lastNonSpaceCharacter(lines, options) === "}";
}

function swapQuotes(str) {
    return str.replace(/['"]/g, function(m) {
        return m === '"' ? '\'' : '"';
    });
}

function nodeStr(str, options) {
    isString.assert(str);
    switch (options.quote) {
    case "auto":
        var double = JSON.stringify(str);
        var single = swapQuotes(JSON.stringify(swapQuotes(str)));
        return double.length > single.length ? single : double;
    case "single":
        return swapQuotes(JSON.stringify(swapQuotes(str)));
    case "double":
    default:
        return JSON.stringify(str);
    }
}

function maybeAddSemicolon(lines, options) {
    var eoc = lastNonSpaceCharacter(lines, options);
    if (!eoc || "\n};".indexOf(eoc) < 0)
        return concat([lines, ";"]);
    return lines;
}

},{"./comments":31,"./fast-path":32,"./lines":33,"./options":35,"./patcher":37,"./types":39,"./util":40,"assert":72,"source-map":157}],39:[function(require,module,exports){
// This module was originally created so that Recast could add its own
// custom types to the AST type system (in particular, the File type), but
// those types are now incorporated into ast-types, so this module doesn't
// have much to do anymore. Still, it might prove useful in the future.
module.exports = require("@gerhobbelt/ast-types");

},{"@gerhobbelt/ast-types":61}],40:[function(require,module,exports){
var assert = require("assert");
var types = require("./types");
var getFieldValue = types.getFieldValue;
var n = types.namedTypes;
var sourceMap = require("source-map");
var SourceMapConsumer = sourceMap.SourceMapConsumer;
var SourceMapGenerator = sourceMap.SourceMapGenerator;
var hasOwn = Object.prototype.hasOwnProperty;
var util = exports;

function getUnionOfKeys() {
  var result = {};
  var argc = arguments.length;
  for (var i = 0; i < argc; ++i) {
    var keys = Object.keys(arguments[i]);
    var keyCount = keys.length;
    for (var j = 0; j < keyCount; ++j) {
      result[keys[j]] = true;
    }
  }
  return result;
}
util.getUnionOfKeys = getUnionOfKeys;

function comparePos(pos1, pos2) {
  return (pos1.line - pos2.line) || (pos1.column - pos2.column);
}
util.comparePos = comparePos;

function copyPos(pos) {
  return {
    line: pos.line,
    column: pos.column
  };
}
util.copyPos = copyPos;

util.composeSourceMaps = function(formerMap, latterMap) {
  if (formerMap) {
    if (!latterMap) {
      return formerMap;
    }
  } else {
    return latterMap || null;
  }

  var smcFormer = new SourceMapConsumer(formerMap);
  var smcLatter = new SourceMapConsumer(latterMap);
  var smg = new SourceMapGenerator({
    file: latterMap.file,
    sourceRoot: latterMap.sourceRoot
  });

  var sourcesToContents = {};

  smcLatter.eachMapping(function(mapping) {
    var origPos = smcFormer.originalPositionFor({
      line: mapping.originalLine,
      column: mapping.originalColumn
    });

    var sourceName = origPos.source;
    if (sourceName === null) {
      return;
    }

    smg.addMapping({
      source: sourceName,
      original: copyPos(origPos),
      generated: {
        line: mapping.generatedLine,
        column: mapping.generatedColumn
      },
      name: mapping.name
    });

    var sourceContent = smcFormer.sourceContentFor(sourceName);
    if (sourceContent && !hasOwn.call(sourcesToContents, sourceName)) {
      sourcesToContents[sourceName] = sourceContent;
      smg.setSourceContent(sourceName, sourceContent);
    }
  });

  return smg.toJSON();
};

util.getTrueLoc = function(node, lines) {
  // It's possible that node is newly-created (not parsed by Esprima),
  // in which case it probably won't have a .loc property (or an
  // .original property for that matter). That's fine; we'll just
  // pretty-print it as usual.
  if (!node.loc) {
    return null;
  }

  var result = {
    start: node.loc.start,
    end: node.loc.end
  };

  function include(node) {
    expandLoc(result, node.loc);
  }

  // If the node has any comments, their locations might contribute to
  // the true start/end positions of the node.
  if (node.comments) {
    node.comments.forEach(include);
  }

  // If the node is an export declaration and its .declaration has any
  // decorators, their locations might contribute to the true start/end
  // positions of the export declaration node.
  if (node.declaration && util.isExportDeclaration(node) &&
      node.declaration.decorators) {
    node.declaration.decorators.forEach(include);
  }

  if (comparePos(result.start, result.end) < 0) {
    // Trim leading whitespace.
    result.start = copyPos(result.start);
    lines.skipSpaces(result.start, false, true);

    if (comparePos(result.start, result.end) < 0) {
      // Trim trailing whitespace, if the end location is not already the
      // same as the start location.
      result.end = copyPos(result.end);
      lines.skipSpaces(result.end, true, true);
    }
  }

  return result;
};

function expandLoc(parentLoc, childLoc) {
  if (parentLoc && childLoc) {
    if (comparePos(childLoc.start, parentLoc.start) < 0) {
      parentLoc.start = childLoc.start;
    }

    if (comparePos(parentLoc.end, childLoc.end) < 0) {
      parentLoc.end = childLoc.end;
    }
  }
}

util.fixFaultyLocations = function(node, lines) {
  var loc = node.loc;
  if (loc) {
    if (loc.start.line < 1) {
      loc.start.line = 1;
    }

    if (loc.end.line < 1) {
      loc.end.line = 1;
    }
  }

  if (node.type === "File") {
    // Babylon returns File nodes whose .loc.{start,end} do not include
    // leading or trailing whitespace.
    loc.start = lines.firstPos();
    loc.end = lines.lastPos();
  }

  fixForLoopHead(node, lines);
  fixTemplateLiteral(node, lines);

  if (loc && node.decorators) {
    // Expand the .loc of the node responsible for printing the decorators
    // (here, the decorated node) so that it includes node.decorators.
    node.decorators.forEach(function (decorator) {
      expandLoc(loc, decorator.loc);
    });

  } else if (node.declaration && util.isExportDeclaration(node)) {
    // Nullify .loc information for the child declaration so that we never
    // try to reprint it without also reprinting the export declaration.
    node.declaration.loc = null;

    // Expand the .loc of the node responsible for printing the decorators
    // (here, the export declaration) so that it includes node.decorators.
    var decorators = node.declaration.decorators;
    if (decorators) {
      decorators.forEach(function (decorator) {
        expandLoc(loc, decorator.loc);
      });
    }

  } else if ((n.MethodDefinition && n.MethodDefinition.check(node)) ||
             (n.Property.check(node) && (node.method || node.shorthand))) {
    // If the node is a MethodDefinition or a .method or .shorthand
    // Property, then the location information stored in
    // node.value.loc is very likely untrustworthy (just the {body}
    // part of a method, or nothing in the case of shorthand
    // properties), so we null out that information to prevent
    // accidental reuse of bogus source code during reprinting.
    node.value.loc = null;

    if (n.FunctionExpression.check(node.value)) {
      // FunctionExpression method values should be anonymous,
      // because their .id fields are ignored anyway.
      node.value.id = null;
    }

  } else if (node.type === "ObjectTypeProperty") {
    var loc = node.loc;
    var end = loc && loc.end;
    if (end) {
      end = copyPos(end);
      if (lines.prevPos(end) &&
          lines.charAt(end) === ",") {
        // Some parsers accidentally include trailing commas in the
        // .loc.end information for ObjectTypeProperty nodes.
        if ((end = lines.skipSpaces(end, true, true))) {
          loc.end = end;
        }
      }
    }
  }
};

function fixForLoopHead(node, lines) {
  if (node.type !== "ForStatement") {
    return;
  }

  function fix(child) {
    var loc = child && child.loc;
    var start = loc && loc.start;
    var end = loc && copyPos(loc.end);

    while (start && end && comparePos(start, end) < 0) {
      lines.prevPos(end);
      if (lines.charAt(end) === ";") {
        // Update child.loc.end to *exclude* the ';' character.
        loc.end.line = end.line;
        loc.end.column = end.column;
      } else {
        break;
      }
    }
  }

  fix(node.init);
  fix(node.test);
  fix(node.update);
}

function fixTemplateLiteral(node, lines) {
  if (node.type !== "TemplateLiteral") {
    return;
  }

  if (node.quasis.length === 0) {
    // If there are no quasi elements, then there is nothing to fix.
    return;
  }

  // First we need to exclude the opening ` from the .loc of the first
  // quasi element, in case the parser accidentally decided to include it.
  var afterLeftBackTickPos = copyPos(node.loc.start);
  assert.strictEqual(lines.charAt(afterLeftBackTickPos), "`");
  assert.ok(lines.nextPos(afterLeftBackTickPos));
  var firstQuasi = node.quasis[0];
  if (comparePos(firstQuasi.loc.start, afterLeftBackTickPos) < 0) {
    firstQuasi.loc.start = afterLeftBackTickPos;
  }

  // Next we need to exclude the closing ` from the .loc of the last quasi
  // element, in case the parser accidentally decided to include it.
  var rightBackTickPos = copyPos(node.loc.end);
  assert.ok(lines.prevPos(rightBackTickPos));
  assert.strictEqual(lines.charAt(rightBackTickPos), "`");
  var lastQuasi = node.quasis[node.quasis.length - 1];
  if (comparePos(rightBackTickPos, lastQuasi.loc.end) < 0) {
    lastQuasi.loc.end = rightBackTickPos;
  }

  // Now we need to exclude ${ and } characters from the .loc's of all
  // quasi elements, since some parsers accidentally include them.
  node.expressions.forEach(function (expr, i) {
    // Rewind from expr.loc.start over any whitespace and the ${ that
    // precedes the expression. The position of the $ should be the same
    // as the .loc.end of the preceding quasi element, but some parsers
    // accidentally include the ${ in the .loc of the quasi element.
    var dollarCurlyPos = lines.skipSpaces(expr.loc.start, true, false);
    if (lines.prevPos(dollarCurlyPos) &&
        lines.charAt(dollarCurlyPos) === "{" &&
        lines.prevPos(dollarCurlyPos) &&
        lines.charAt(dollarCurlyPos) === "$") {
      var quasiBefore = node.quasis[i];
      if (comparePos(dollarCurlyPos, quasiBefore.loc.end) < 0) {
        quasiBefore.loc.end = dollarCurlyPos;
      }
    }

    // Likewise, some parsers accidentally include the } that follows
    // the expression in the .loc of the following quasi element.
    var rightCurlyPos = lines.skipSpaces(expr.loc.end, false, false);
    if (lines.charAt(rightCurlyPos) === "}") {
      assert.ok(lines.nextPos(rightCurlyPos));
      // Now rightCurlyPos is technically the position just after the }.
      var quasiAfter = node.quasis[i + 1];
      if (comparePos(quasiAfter.loc.start, rightCurlyPos) < 0) {
        quasiAfter.loc.start = rightCurlyPos;
      }
    }
  });
}

util.isExportDeclaration = function (node) {
  if (node) switch (node.type) {
  case "ExportDeclaration":
  case "ExportDefaultDeclaration":
  case "ExportDefaultSpecifier":
  case "DeclareExportDeclaration":
  case "ExportNamedDeclaration":
  case "ExportAllDeclaration":
    return true;
  }

  return false;
};

util.getParentExportDeclaration = function (path) {
  var parentNode = path.getParentNode();
  if (path.getName() === "declaration" &&
      util.isExportDeclaration(parentNode)) {
    return parentNode;
  }

  return null;
};

util.isTrailingCommaEnabled = function(options, context) {
  var trailingComma = options.trailingComma;
  if (typeof trailingComma === "object") {
    return !!trailingComma[context];
  }
  return !!trailingComma;
};

},{"./types":39,"assert":72,"source-map":157}],41:[function(require,module,exports){
(function (process){
var types = require("./lib/types");
var parse = require("./lib/parser").parse;
var Printer = require("./lib/printer").Printer;

function print(node, options) {
    return new Printer(options).print(node);
}

function prettyPrint(node, options) {
    return new Printer(options).printGenerically(node);
}

function run(transformer, options) {
    return runFile(process.argv[2], transformer, options);
}

function runFile(path, transformer, options) {
    require("fs").readFile(path, "utf-8", function(err, code) {
        if (err) {
            console.error(err);
            return;
        }

        runString(code, transformer, options);
    });
}

function defaultWriteback(output) {
    process.stdout.write(output);
}

function runString(code, transformer, options) {
    var writeback = options && options.writeback || defaultWriteback;
    transformer(parse(code, options), function(node) {
        writeback(print(node, options).code);
    });
}

Object.defineProperties(exports, {
    /**
     * Parse a string of code into an augmented syntax tree suitable for
     * arbitrary modification and reprinting.
     */
    parse: {
        enumerable: true,
        value: parse
    },

    /**
     * Traverse and potentially modify an abstract syntax tree using a
     * convenient visitor syntax:
     *
     *   recast.visit(ast, {
     *     names: [],
     *     visitIdentifier: function(path) {
     *       var node = path.value;
     *       this.visitor.names.push(node.name);
     *       this.traverse(path);
     *     }
     *   });
     */
    visit: {
        enumerable: true,
        value: types.visit
    },

    /**
     * Reprint a modified syntax tree using as much of the original source
     * code as possible.
     */
    print: {
        enumerable: true,
        value: print
    },

    /**
     * Print without attempting to reuse any original source code.
     */
    prettyPrint: {
        enumerable: false,
        value: prettyPrint
    },

    /**
     * Customized version of require("ast-types").
     */
    types: {
        enumerable: false,
        value: types
    },

    /**
     * Convenient command-line interface (see e.g. example/add-braces).
     */
    run: {
        enumerable: false,
        value: run
    }
});

}).call(this,require('_process'))
},{"./lib/parser":36,"./lib/printer":38,"./lib/types":39,"_process":146,"fs":73}],42:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"../lib/shared":59,"../lib/types":60,"./es7":48,"dup":3}],43:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"../lib/shared":59,"../lib/types":60,"./babel":42,"dup":4}],44:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"./babel6-core":43,"./flow":50,"dup":5}],45:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"../lib/shared":59,"../lib/types":60,"dup":6}],46:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"../lib/types":60,"./core":45,"dup":7}],47:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"../lib/shared":59,"../lib/types":60,"./core":45,"dup":8}],48:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"../lib/shared":59,"../lib/types":60,"./es6":47,"dup":9}],49:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"../lib/shared":59,"../lib/types":60,"./es7":48,"dup":10}],50:[function(require,module,exports){
module.exports = function (fork) {
    fork.use(require("./es7"));

    var types = fork.use(require("../lib/types"));
    var def = types.Type.def;
    var or = types.Type.or;
    var defaults = fork.use(require("../lib/shared")).defaults;

    // Type Annotations
    def("Type").bases("Node");

    def("AnyTypeAnnotation")
      .bases("Type")
      .build();

    def("EmptyTypeAnnotation")
      .bases("Type")
      .build();

    def("MixedTypeAnnotation")
      .bases("Type")
      .build();

    def("VoidTypeAnnotation")
      .bases("Type")
      .build();

    def("NumberTypeAnnotation")
      .bases("Type")
      .build();

    def("NumberLiteralTypeAnnotation")
      .bases("Type")
      .build("value", "raw")
      .field("value", Number)
      .field("raw", String);

    // Babylon 6 differs in AST from Flow
    // same as NumberLiteralTypeAnnotation
    def("NumericLiteralTypeAnnotation")
      .bases("Type")
      .build("value", "raw")
      .field("value", Number)
      .field("raw", String);

    def("StringTypeAnnotation")
      .bases("Type")
      .build();

    def("StringLiteralTypeAnnotation")
      .bases("Type")
      .build("value", "raw")
      .field("value", String)
      .field("raw", String);

    def("BooleanTypeAnnotation")
      .bases("Type")
      .build();

    def("BooleanLiteralTypeAnnotation")
      .bases("Type")
      .build("value", "raw")
      .field("value", Boolean)
      .field("raw", String);

    def("TypeAnnotation")
      .bases("Node")
      .build("typeAnnotation")
      .field("typeAnnotation", def("Type"));

    def("NullableTypeAnnotation")
      .bases("Type")
      .build("typeAnnotation")
      .field("typeAnnotation", def("Type"));

    def("NullLiteralTypeAnnotation")
      .bases("Type")
      .build();

    def("NullTypeAnnotation")
      .bases("Type")
      .build();

    def("ThisTypeAnnotation")
      .bases("Type")
      .build();

    def("ExistsTypeAnnotation")
      .bases("Type")
      .build();

    def("ExistentialTypeParam")
      .bases("Type")
      .build();

    def("FunctionTypeAnnotation")
      .bases("Type")
      .build("params", "returnType", "rest", "typeParameters")
      .field("params", [def("FunctionTypeParam")])
      .field("returnType", def("Type"))
      .field("rest", or(def("FunctionTypeParam"), null))
      .field("typeParameters", or(def("TypeParameterDeclaration"), null));

    def("FunctionTypeParam")
      .bases("Node")
      .build("name", "typeAnnotation", "optional")
      .field("name", def("Identifier"))
      .field("typeAnnotation", def("Type"))
      .field("optional", Boolean);

    def("ArrayTypeAnnotation")
      .bases("Type")
      .build("elementType")
      .field("elementType", def("Type"));

    def("ObjectTypeAnnotation")
      .bases("Type")
      .build("properties", "indexers", "callProperties")
      .field("properties", [or(def("ObjectTypeProperty"), def("ObjectTypeSpreadProperty"))])
      .field("indexers", [def("ObjectTypeIndexer")], defaults.emptyArray)
      .field("callProperties",
        [def("ObjectTypeCallProperty")],
        defaults.emptyArray)
      .field("exact", Boolean, defaults["false"]);

    def("ObjectTypeProperty")
      .bases("Node")
      .build("key", "value", "optional")
      .field("key", or(def("Literal"), def("Identifier")))
      .field("value", def("Type"))
      .field("optional", Boolean)
      .field("variance",
        or("plus", "minus", null),
        defaults["null"]);

    def("ObjectTypeIndexer")
      .bases("Node")
      .build("id", "key", "value")
      .field("id", def("Identifier"))
      .field("key", def("Type"))
      .field("value", def("Type"))
      .field("variance",
        or("plus", "minus", null),
        defaults["null"]);

    def("ObjectTypeCallProperty")
      .bases("Node")
      .build("value")
      .field("value", def("FunctionTypeAnnotation"))
      .field("static", Boolean, defaults["false"]);

    def("QualifiedTypeIdentifier")
      .bases("Node")
      .build("qualification", "id")
      .field("qualification",
        or(def("Identifier"),
          def("QualifiedTypeIdentifier")))
      .field("id", def("Identifier"));

    def("GenericTypeAnnotation")
      .bases("Type")
      .build("id", "typeParameters")
      .field("id", or(def("Identifier"), def("QualifiedTypeIdentifier")))
      .field("typeParameters", or(def("TypeParameterInstantiation"), null));

    def("MemberTypeAnnotation")
      .bases("Type")
      .build("object", "property")
      .field("object", def("Identifier"))
      .field("property",
        or(def("MemberTypeAnnotation"),
          def("GenericTypeAnnotation")));

    def("UnionTypeAnnotation")
      .bases("Type")
      .build("types")
      .field("types", [def("Type")]);

    def("IntersectionTypeAnnotation")
      .bases("Type")
      .build("types")
      .field("types", [def("Type")]);

    def("TypeofTypeAnnotation")
      .bases("Type")
      .build("argument")
      .field("argument", def("Type"));

    def("ObjectTypeSpreadProperty")
      .bases("Node")
      .build("argument")
      .field("argument", def("Type"));

    def("Identifier")
      .field("typeAnnotation", or(def("TypeAnnotation"), null), defaults["null"]);

    def("ObjectPattern")
      .field("typeAnnotation", or(def("TypeAnnotation"), null), defaults["null"]);

    def("TypeParameterDeclaration")
      .bases("Node")
      .build("params")
      .field("params", [def("TypeParameter")]);

    def("TypeParameterInstantiation")
      .bases("Node")
      .build("params")
      .field("params", [def("Type")]);

    def("TypeParameter")
      .bases("Type")
      .build("name", "variance", "bound")
      .field("name", String)
      .field("variance",
        or("plus", "minus", null),
        defaults["null"])
      .field("bound",
        or(def("TypeAnnotation"), null),
        defaults["null"]);

    def("Function")
      .field("returnType",
        or(def("TypeAnnotation"), null),
        defaults["null"])
      .field("typeParameters",
        or(def("TypeParameterDeclaration"), null),
        defaults["null"]);

    def("ClassProperty")
      .build("key", "value", "typeAnnotation", "static")
      .field("value", or(def("Expression"), null))
      .field("typeAnnotation", or(def("TypeAnnotation"), null))
      .field("static", Boolean, defaults["false"])
      .field("variance",
        or("plus", "minus", null),
        defaults["null"]);

    def("ClassImplements")
      .field("typeParameters",
        or(def("TypeParameterInstantiation"), null),
        defaults["null"]);

    def("InterfaceDeclaration")
      .bases("Declaration")
      .build("id", "body", "extends")
      .field("id", def("Identifier"))
      .field("typeParameters",
        or(def("TypeParameterDeclaration"), null),
        defaults["null"])
      .field("body", def("ObjectTypeAnnotation"))
      .field("extends", [def("InterfaceExtends")]);

    def("DeclareInterface")
      .bases("InterfaceDeclaration")
      .build("id", "body", "extends");

    def("InterfaceExtends")
      .bases("Node")
      .build("id")
      .field("id", def("Identifier"))
      .field("typeParameters", or(def("TypeParameterInstantiation"), null));

    def("TypeAlias")
      .bases("Declaration")
      .build("id", "typeParameters", "right")
      .field("id", def("Identifier"))
      .field("typeParameters", or(def("TypeParameterDeclaration"), null))
      .field("right", def("Type"));

    def("OpaqueType")
      .bases("Declaration")
      .build("id", "typeParameters", "impltype", "supertype")
      .field("id", def("Identifier"))
      .field("typeParameters", or(def("TypeParameterDeclaration"), null))
      .field("implType", def("Type"))
      .field("superType", def("Type"));

    def("DeclareTypeAlias")
      .bases("TypeAlias")
      .build("id", "typeParameters", "right");

    def("DeclareOpaqueType")
      .bases("TypeAlias")
      .build("id", "typeParameters", "supertype");

    def("TypeCastExpression")
      .bases("Expression")
      .build("expression", "typeAnnotation")
      .field("expression", def("Expression"))
      .field("typeAnnotation", def("TypeAnnotation"));

    def("TupleTypeAnnotation")
      .bases("Type")
      .build("types")
      .field("types", [def("Type")]);

    def("DeclareVariable")
      .bases("Statement")
      .build("id")
      .field("id", def("Identifier"));

    def("DeclareFunction")
      .bases("Statement")
      .build("id")
      .field("id", def("Identifier"));

    def("DeclareClass")
      .bases("InterfaceDeclaration")
      .build("id");

    def("DeclareModule")
      .bases("Statement")
      .build("id", "body")
      .field("id", or(def("Identifier"), def("Literal")))
      .field("body", def("BlockStatement"));

    def("DeclareModuleExports")
      .bases("Statement")
      .build("typeAnnotation")
      .field("typeAnnotation", def("Type"));

    def("DeclareExportDeclaration")
      .bases("Declaration")
      .build("default", "declaration", "specifiers", "source")
      .field("default", Boolean)
      .field("declaration", or(
        def("DeclareVariable"),
        def("DeclareFunction"),
        def("DeclareClass"),
        def("Type"), // Implies default.
        null
      ))
      .field("specifiers", [or(
        def("ExportSpecifier"),
        def("ExportBatchSpecifier")
      )], defaults.emptyArray)
      .field("source", or(
        def("Literal"),
        null
      ), defaults["null"]);

    def("DeclareExportAllDeclaration")
      .bases("Declaration")
      .build("source")
      .field("source", or(
        def("Literal"),
        null
      ), defaults["null"]);
      
    def("DeclareModuleExports")
      .bases("Statement")
      .build("typeAnnotation")
      .field("typeAnnotation", def("TypeAnnotation"));
};

},{"../lib/shared":59,"../lib/types":60,"./es7":48}],51:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"../lib/shared":59,"../lib/types":60,"./es7":48,"dup":12}],52:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"../lib/shared":59,"../lib/types":60,"./core":45,"dup":13}],53:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./lib/equiv":54,"./lib/node-path":55,"./lib/path":57,"./lib/path-visitor":56,"./lib/types":60,"dup":14}],54:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"../lib/types":60,"dup":15}],55:[function(require,module,exports){
module.exports = function (fork) {
    var types = fork.use(require("./types"));
    var n = types.namedTypes;
    var b = types.builders;
    var isNumber = types.builtInTypes.number;
    var isArray = types.builtInTypes.array;
    var Path = fork.use(require("./path"));
    var Scope = fork.use(require("./scope"));

    function NodePath(value, parentPath, name) {
        if (!(this instanceof NodePath)) {
            throw new Error("NodePath constructor cannot be invoked without 'new'");
        }
        Path.call(this, value, parentPath, name);
    }

    var NPp = NodePath.prototype = Object.create(Path.prototype, {
        constructor: {
            value: NodePath,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });

    Object.defineProperties(NPp, {
        node: {
            get: function () {
                Object.defineProperty(this, "node", {
                    configurable: true, // Enable deletion.
                    value: this._computeNode()
                });

                return this.node;
            }
        },

        parent: {
            get: function () {
                Object.defineProperty(this, "parent", {
                    configurable: true, // Enable deletion.
                    value: this._computeParent()
                });

                return this.parent;
            }
        },

        scope: {
            get: function () {
                Object.defineProperty(this, "scope", {
                    configurable: true, // Enable deletion.
                    value: this._computeScope()
                });

                return this.scope;
            }
        }
    });

    NPp.replace = function () {
        delete this.node;
        delete this.parent;
        delete this.scope;
        return Path.prototype.replace.apply(this, arguments);
    };

    NPp.prune = function () {
        var remainingNodePath = this.parent;

        this.replace();

        return cleanUpNodesAfterPrune(remainingNodePath);
    };

    // The value of the first ancestor Path whose value is a Node.
    NPp._computeNode = function () {
        var value = this.value;
        if (n.Node.check(value)) {
            return value;
        }

        var pp = this.parentPath;
        return pp && pp.node || null;
    };

    // The first ancestor Path whose value is a Node distinct from this.node.
    NPp._computeParent = function () {
        var value = this.value;
        var pp = this.parentPath;

        if (!n.Node.check(value)) {
            while (pp && !n.Node.check(pp.value)) {
                pp = pp.parentPath;
            }

            if (pp) {
                pp = pp.parentPath;
            }
        }

        while (pp && !n.Node.check(pp.value)) {
            pp = pp.parentPath;
        }

        return pp || null;
    };

    // The closest enclosing scope that governs this node.
    NPp._computeScope = function () {
        var value = this.value;
        var pp = this.parentPath;
        var scope = pp && pp.scope;

        if (n.Node.check(value) &&
          Scope.isEstablishedBy(value)) {
            scope = new Scope(this, scope);
        }

        return scope || null;
    };

    NPp.getValueProperty = function (name) {
        return types.getFieldValue(this.value, name);
    };

    /**
     * Determine whether this.node needs to be wrapped in parentheses in order
     * for a parser to reproduce the same local AST structure.
     *
     * For instance, in the expression `(1 + 2) * 3`, the BinaryExpression
     * whose operator is "+" needs parentheses, because `1 + 2 * 3` would
     * parse differently.
     *
     * If assumeExpressionContext === true, we don't worry about edge cases
     * like an anonymous FunctionExpression appearing lexically first in its
     * enclosing statement and thus needing parentheses to avoid being parsed
     * as a FunctionDeclaration with a missing name.
     */
    NPp.needsParens = function (assumeExpressionContext) {
        var pp = this.parentPath;
        if (!pp) {
            return false;
        }

        var node = this.value;

        // Only expressions need parentheses.
        if (!n.Expression.check(node)) {
            return false;
        }

        // Identifiers never need parentheses.
        if (node.type === "Identifier") {
            return false;
        }

        while (!n.Node.check(pp.value)) {
            pp = pp.parentPath;
            if (!pp) {
                return false;
            }
        }

        var parent = pp.value;

        switch (node.type) {
            case "UnaryExpression":
            case "SpreadElement":
            case "SpreadProperty":
                return parent.type === "MemberExpression"
                  && this.name === "object"
                  && parent.object === node;

            case "BinaryExpression":
            case "LogicalExpression":
                switch (parent.type) {
                    case "CallExpression":
                        return this.name === "callee"
                          && parent.callee === node;

                    case "UnaryExpression":
                    case "SpreadElement":
                    case "SpreadProperty":
                        return true;

                    case "MemberExpression":
                        return this.name === "object"
                          && parent.object === node;

                    case "BinaryExpression":
                    case "LogicalExpression":
                        var po = parent.operator;
                        var pp = PRECEDENCE[po];
                        var no = node.operator;
                        var np = PRECEDENCE[no];

                        if (pp > np) {
                            return true;
                        }

                        if (pp === np && this.name === "right") {
                            if (parent.right !== node) {
                                throw new Error("Nodes must be equal");
                            }
                            return true;
                        }

                    default:
                        return false;
                }

            case "SequenceExpression":
                switch (parent.type) {
                    case "ReturnStatement":
                        return false;

                    case "ForStatement":
                        // Although parentheses wouldn't hurt around sequence
                        // expressions in the head of for loops, traditional style
                        // dictates that e.g. i++, j++ should not be wrapped with
                        // parentheses.
                        return false;

                    case "ExpressionStatement":
                        return this.name !== "expression";

                    default:
                        // Otherwise err on the side of overparenthesization, adding
                        // explicit exceptions above if this proves overzealous.
                        return true;
                }

            case "YieldExpression":
                switch (parent.type) {
                    case "BinaryExpression":
                    case "LogicalExpression":
                    case "UnaryExpression":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "CallExpression":
                    case "MemberExpression":
                    case "NewExpression":
                    case "ConditionalExpression":
                    case "YieldExpression":
                        return true;

                    default:
                        return false;
                }

            case "IntersectionTypeAnnotation":
            case "UnionTypeAnnotation":
                return parent.type === "NullableTypeAnnotation";

            case "Literal":
                return parent.type === "MemberExpression"
                  && isNumber.check(node.value)
                  && this.name === "object"
                  && parent.object === node;

            // Babel 6 Literal split
            case "NumericLiteral":
                return parent.type === "MemberExpression"
                  && this.name === "object"
                  && parent.object === node;

            case "AssignmentExpression":
            case "ConditionalExpression":
                switch (parent.type) {
                    case "UnaryExpression":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "BinaryExpression":
                    case "LogicalExpression":
                        return true;

                    case "CallExpression":
                        return this.name === "callee"
                          && parent.callee === node;

                    case "ConditionalExpression":
                        return this.name === "test"
                          && parent.test === node;

                    case "MemberExpression":
                        return this.name === "object"
                          && parent.object === node;

                    default:
                        return false;
                }

            case "ArrowFunctionExpression":
                if (n.CallExpression.check(parent) && this.name === 'callee') {
                    return true;
                }
                if (n.MemberExpression.check(parent) && this.name === 'object') {
                    return true;
                }

                return isBinary(parent);

            case "ObjectExpression":
                if (parent.type === "ArrowFunctionExpression" &&
                  this.name === "body") {
                    return true;
                }

            default:
                if (parent.type === "NewExpression" &&
                  this.name === "callee" &&
                  parent.callee === node) {
                    return containsCallExpression(node);
                }
        }

        if (assumeExpressionContext !== true &&
          !this.canBeFirstInStatement() &&
          this.firstInStatement())
            return true;

        return false;
    };

    function isBinary(node) {
        return n.BinaryExpression.check(node)
          || n.LogicalExpression.check(node);
    }

    function isUnaryLike(node) {
        return n.UnaryExpression.check(node)
          // I considered making SpreadElement and SpreadProperty subtypes
          // of UnaryExpression, but they're not really Expression nodes.
          || (n.SpreadElement && n.SpreadElement.check(node))
          || (n.SpreadProperty && n.SpreadProperty.check(node));
    }

    var PRECEDENCE = {};
    [
        ["||"],
        ["&&"],
        ["|"],
        ["^"],
        ["&"],
        ["==", "===", "!=", "!=="],
        ["<", ">", "<=", ">=", "in", "instanceof"],
        [">>", "<<", ">>>"],
        ["+", "-"],
        ["*", "/", "%"],
        ["**"]
    ].forEach(function (tier, i) {
        tier.forEach(function (op) {
            PRECEDENCE[op] = i;
        });
    });

    function containsCallExpression(node) {
        if (n.CallExpression.check(node)) {
            return true;
        }

        if (isArray.check(node)) {
            return node.some(containsCallExpression);
        }

        if (n.Node.check(node)) {
            return types.someField(node, function (name, child) {
                return containsCallExpression(child);
            });
        }

        return false;
    }

    NPp.canBeFirstInStatement = function () {
        var node = this.node;
        return !n.FunctionExpression.check(node)
          && !n.ObjectExpression.check(node);
    };

    NPp.firstInStatement = function () {
        return firstInStatement(this);
    };

    function firstInStatement(path) {
        for (var node, parent; path.parent; path = path.parent) {
            node = path.node;
            parent = path.parent.node;

            if (n.BlockStatement.check(parent) &&
              path.parent.name === "body" &&
              path.name === 0) {
                if (parent.body[0] !== node) {
                    throw new Error("Nodes must be equal");
                }
                return true;
            }

            if (n.ExpressionStatement.check(parent) &&
              path.name === "expression") {
                if (parent.expression !== node) {
                    throw new Error("Nodes must be equal");
                }
                return true;
            }

            if (n.SequenceExpression.check(parent) &&
              path.parent.name === "expressions" &&
              path.name === 0) {
                if (parent.expressions[0] !== node) {
                    throw new Error("Nodes must be equal");
                }
                continue;
            }

            if (n.CallExpression.check(parent) &&
              path.name === "callee") {
                if (parent.callee !== node) {
                    throw new Error("Nodes must be equal");
                }
                continue;
            }

            if (n.MemberExpression.check(parent) &&
              path.name === "object") {
                if (parent.object !== node) {
                    throw new Error("Nodes must be equal");
                }
                continue;
            }

            if (n.ConditionalExpression.check(parent) &&
              path.name === "test") {
                if (parent.test !== node) {
                    throw new Error("Nodes must be equal");
                }
                continue;
            }

            if (isBinary(parent) &&
              path.name === "left") {
                if (parent.left !== node) {
                    throw new Error("Nodes must be equal");
                }
                continue;
            }

            if (n.UnaryExpression.check(parent) &&
              !parent.prefix &&
              path.name === "argument") {
                if (parent.argument !== node) {
                    throw new Error("Nodes must be equal");
                }
                continue;
            }

            return false;
        }

        return true;
    }

    /**
     * Pruning certain nodes will result in empty or incomplete nodes, here we clean those nodes up.
     */
    function cleanUpNodesAfterPrune(remainingNodePath) {
        if (n.VariableDeclaration.check(remainingNodePath.node)) {
            var declarations = remainingNodePath.get('declarations').value;
            if (!declarations || declarations.length === 0) {
                return remainingNodePath.prune();
            }
        } else if (n.ExpressionStatement.check(remainingNodePath.node)) {
            if (!remainingNodePath.get('expression').value) {
                return remainingNodePath.prune();
            }
        } else if (n.IfStatement.check(remainingNodePath.node)) {
            cleanUpIfStatementAfterPrune(remainingNodePath);
        }

        return remainingNodePath;
    }

    function cleanUpIfStatementAfterPrune(ifStatement) {
        var testExpression = ifStatement.get('test').value;
        var alternate = ifStatement.get('alternate').value;
        var consequent = ifStatement.get('consequent').value;

        if (!consequent && !alternate) {
            var testExpressionStatement = b.expressionStatement(testExpression);

            ifStatement.replace(testExpressionStatement);
        } else if (!consequent && alternate) {
            var negatedTestExpression = b.unaryExpression('!', testExpression, true);

            if (n.UnaryExpression.check(testExpression) && testExpression.operator === '!') {
                negatedTestExpression = testExpression.argument;
            }

            ifStatement.get("test").replace(negatedTestExpression);
            ifStatement.get("consequent").replace(alternate);
            ifStatement.get("alternate").replace();
        }
    }

    return NodePath;
};

},{"./path":57,"./scope":58,"./types":60}],56:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./node-path":55,"./types":60,"dup":17}],57:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"./types":60,"dup":18}],58:[function(require,module,exports){
var hasOwn = Object.prototype.hasOwnProperty;

module.exports = function (fork) {
    var types = fork.use(require("./types"));
    var Type = types.Type;
    var namedTypes = types.namedTypes;
    var Node = namedTypes.Node;
    var Expression = namedTypes.Expression;
    var isArray = types.builtInTypes.array;
    var b = types.builders;

    function Scope(path, parentScope) {
        if (!(this instanceof Scope)) {
            throw new Error("Scope constructor cannot be invoked without 'new'");
        }
        if (!(path instanceof fork.use(require("./node-path")))) {
            throw new Error("");
        }
        ScopeType.assert(path.value);

        var depth;

        if (parentScope) {
            if (!(parentScope instanceof Scope)) {
                throw new Error("");
            }
            depth = parentScope.depth + 1;
        } else {
            parentScope = null;
            depth = 0;
        }

        Object.defineProperties(this, {
            path: { value: path },
            node: { value: path.value },
            isGlobal: { value: !parentScope, enumerable: true },
            depth: { value: depth },
            parent: { value: parentScope },
            bindings: { value: {} },
            types: { value: {} },
        });
    }

    var scopeTypes = [
        // Program nodes introduce global scopes.
        namedTypes.Program,

        // Function is the supertype of FunctionExpression,
        // FunctionDeclaration, ArrowExpression, etc.
        namedTypes.Function,

        // In case you didn't know, the caught parameter shadows any variable
        // of the same name in an outer scope.
        namedTypes.CatchClause
    ];

    var ScopeType = Type.or.apply(Type, scopeTypes);

    Scope.isEstablishedBy = function(node) {
        return ScopeType.check(node);
    };

    var Sp = Scope.prototype;

// Will be overridden after an instance lazily calls scanScope.
    Sp.didScan = false;

    Sp.declares = function(name) {
        this.scan();
        return hasOwn.call(this.bindings, name);
    };

    Sp.declaresType = function(name) {
        this.scan();
        return hasOwn.call(this.types, name);
    };

    Sp.declareTemporary = function(prefix) {
        if (prefix) {
            if (!/^[a-z$_]/i.test(prefix)) {
                throw new Error("");
            }
        } else {
            prefix = "t$";
        }

        // Include this.depth in the name to make sure the name does not
        // collide with any variables in nested/enclosing scopes.
        prefix += this.depth.toString(36) + "$";

        this.scan();

        var index = 0;
        while (this.declares(prefix + index)) {
            ++index;
        }

        var name = prefix + index;
        return this.bindings[name] = types.builders.identifier(name);
    };

    Sp.injectTemporary = function(identifier, init) {
        identifier || (identifier = this.declareTemporary());

        var bodyPath = this.path.get("body");
        if (namedTypes.BlockStatement.check(bodyPath.value)) {
            bodyPath = bodyPath.get("body");
        }

        bodyPath.unshift(
          b.variableDeclaration(
            "var",
            [b.variableDeclarator(identifier, init || null)]
          )
        );

        return identifier;
    };

    Sp.scan = function(force) {
        if (force || !this.didScan) {
            for (var name in this.bindings) {
                // Empty out this.bindings, just in cases.
                delete this.bindings[name];
            }
            scanScope(this.path, this.bindings, this.types);
            this.didScan = true;
        }
    };

    Sp.getBindings = function () {
        this.scan();
        return this.bindings;
    };

    Sp.getTypes = function () {
        this.scan();
        return this.types;
    };

    function scanScope(path, bindings, scopeTypes) {
        var node = path.value;
        ScopeType.assert(node);

        if (namedTypes.CatchClause.check(node)) {
            // A catch clause establishes a new scope but the only variable
            // bound in that scope is the catch parameter. Any other
            // declarations create bindings in the outer scope.
            addPattern(path.get("param"), bindings);

        } else {
            recursiveScanScope(path, bindings, scopeTypes);
        }
    }

    function recursiveScanScope(path, bindings, scopeTypes) {
        var node = path.value;

        if (path.parent &&
          namedTypes.FunctionExpression.check(path.parent.node) &&
          path.parent.node.id) {
            addPattern(path.parent.get("id"), bindings);
        }

        if (!node) {
            // None of the remaining cases matter if node is falsy.

        } else if (isArray.check(node)) {
            path.each(function(childPath) {
                recursiveScanChild(childPath, bindings, scopeTypes);
            });

        } else if (namedTypes.Function.check(node)) {
            path.get("params").each(function(paramPath) {
                addPattern(paramPath, bindings);
            });

            recursiveScanChild(path.get("body"), bindings, scopeTypes);

        } else if (namedTypes.TypeAlias && namedTypes.TypeAlias.check(node)) {
            addTypePattern(path.get("id"), scopeTypes);

        } else if (namedTypes.VariableDeclarator.check(node)) {
            addPattern(path.get("id"), bindings);
            recursiveScanChild(path.get("init"), bindings, scopeTypes);

        } else if (node.type === "ImportSpecifier" ||
          node.type === "ImportNamespaceSpecifier" ||
          node.type === "ImportDefaultSpecifier") {
            addPattern(
              // Esprima used to use the .name field to refer to the local
              // binding identifier for ImportSpecifier nodes, but .id for
              // ImportNamespaceSpecifier and ImportDefaultSpecifier nodes.
              // ESTree/Acorn/ESpree use .local for all three node types.
              path.get(node.local ? "local" :
                node.name ? "name" : "id"),
              bindings
            );

        } else if (Node.check(node) && !Expression.check(node)) {
            types.eachField(node, function(name, child) {
                var childPath = path.get(name);
                if (!pathHasValue(childPath, child)) {
                    throw new Error("");
                }
                recursiveScanChild(childPath, bindings, scopeTypes);
            });
        }
    }

    function pathHasValue(path, value) {
        if (path.value === value) {
            return true;
        }

        // Empty arrays are probably produced by defaults.emptyArray, in which
        // case is makes sense to regard them as equivalent, if not ===.
        if (Array.isArray(path.value) &&
          path.value.length === 0 &&
          Array.isArray(value) &&
          value.length === 0) {
            return true;
        }

        return false;
    }

    function recursiveScanChild(path, bindings, scopeTypes) {
        var node = path.value;

        if (!node || Expression.check(node)) {
            // Ignore falsy values and Expressions.

        } else if (namedTypes.FunctionDeclaration.check(node) &&
                   node.id !== null) {
            addPattern(path.get("id"), bindings);

        } else if (namedTypes.ClassDeclaration &&
          namedTypes.ClassDeclaration.check(node)) {
            addPattern(path.get("id"), bindings);

        } else if (ScopeType.check(node)) {
            if (namedTypes.CatchClause.check(node)) {
                var catchParamName = node.param.name;
                var hadBinding = hasOwn.call(bindings, catchParamName);

                // Any declarations that occur inside the catch body that do
                // not have the same name as the catch parameter should count
                // as bindings in the outer scope.
                recursiveScanScope(path.get("body"), bindings, scopeTypes);

                // If a new binding matching the catch parameter name was
                // created while scanning the catch body, ignore it because it
                // actually refers to the catch parameter and not the outer
                // scope that we're currently scanning.
                if (!hadBinding) {
                    delete bindings[catchParamName];
                }
            }

        } else {
            recursiveScanScope(path, bindings, scopeTypes);
        }
    }

    function addPattern(patternPath, bindings) {
        var pattern = patternPath.value;
        namedTypes.Pattern.assert(pattern);

        if (namedTypes.Identifier.check(pattern)) {
            if (hasOwn.call(bindings, pattern.name)) {
                bindings[pattern.name].push(patternPath);
            } else {
                bindings[pattern.name] = [patternPath];
            }

        } else if (namedTypes.AssignmentPattern &&
          namedTypes.AssignmentPattern.check(pattern)) {
          addPattern(patternPath.get('left'), bindings);

        } else if (namedTypes.ObjectPattern &&
          namedTypes.ObjectPattern.check(pattern)) {
            patternPath.get('properties').each(function(propertyPath) {
                var property = propertyPath.value;
                if (namedTypes.Pattern.check(property)) {
                    addPattern(propertyPath, bindings);
                } else  if (namedTypes.Property.check(property)) {
                    addPattern(propertyPath.get('value'), bindings);
                } else if (namedTypes.SpreadProperty &&
                  namedTypes.SpreadProperty.check(property)) {
                    addPattern(propertyPath.get('argument'), bindings);
                }
            });

        } else if (namedTypes.ArrayPattern &&
          namedTypes.ArrayPattern.check(pattern)) {
            patternPath.get('elements').each(function(elementPath) {
                var element = elementPath.value;
                if (namedTypes.Pattern.check(element)) {
                    addPattern(elementPath, bindings);
                } else if (namedTypes.SpreadElement &&
                  namedTypes.SpreadElement.check(element)) {
                    addPattern(elementPath.get("argument"), bindings);
                }
            });

        } else if (namedTypes.PropertyPattern &&
          namedTypes.PropertyPattern.check(pattern)) {
            addPattern(patternPath.get('pattern'), bindings);

        } else if ((namedTypes.SpreadElementPattern &&
          namedTypes.SpreadElementPattern.check(pattern)) ||
          (namedTypes.SpreadPropertyPattern &&
          namedTypes.SpreadPropertyPattern.check(pattern))) {
            addPattern(patternPath.get('argument'), bindings);
        }
    }

    function addTypePattern(patternPath, types) {
        var pattern = patternPath.value;
        namedTypes.Pattern.assert(pattern);

        if (namedTypes.Identifier.check(pattern)) {
            if (hasOwn.call(types, pattern.name)) {
                types[pattern.name].push(patternPath);
            } else {
                types[pattern.name] = [patternPath];
            }

        }
    }

    Sp.lookup = function(name) {
        for (var scope = this; scope; scope = scope.parent)
            if (scope.declares(name))
                break;
        return scope;
    };

    Sp.lookupType = function(name) {
        for (var scope = this; scope; scope = scope.parent)
            if (scope.declaresType(name))
                break;
        return scope;
    };

    Sp.getGlobalScope = function() {
        var scope = this;
        while (!scope.isGlobal)
            scope = scope.parent;
        return scope;
    };

    return Scope;
};

},{"./node-path":55,"./types":60}],59:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"../lib/types":60,"dup":20}],60:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],61:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"./def/babel":42,"./def/babel6":44,"./def/core":45,"./def/e4x":46,"./def/es6":47,"./def/es7":48,"./def/esprima":49,"./def/flow":50,"./def/jsx":51,"./def/mozilla":52,"./fork":53,"dup":22}],62:[function(require,module,exports){
"use strict";

var originalObject = Object;
var originalDefProp = Object.defineProperty;
var originalCreate = Object.create;

function defProp(obj, name, value) {
  if (originalDefProp) try {
    originalDefProp.call(originalObject, obj, name, { value: value });
  } catch (definePropertyIsBrokenInIE8) {
    obj[name] = value;
  } else {
    obj[name] = value;
  }
}

// For functions that will be invoked using .call or .apply, we need to
// define those methods on the function objects themselves, rather than
// inheriting them from Function.prototype, so that a malicious or clumsy
// third party cannot interfere with the functionality of this module by
// redefining Function.prototype.call or .apply.
function makeSafeToCall(fun) {
  if (fun) {
    defProp(fun, "call", fun.call);
    defProp(fun, "apply", fun.apply);
  }
  return fun;
}

makeSafeToCall(originalDefProp);
makeSafeToCall(originalCreate);

var hasOwn = makeSafeToCall(Object.prototype.hasOwnProperty);
var numToStr = makeSafeToCall(Number.prototype.toString);
var strSlice = makeSafeToCall(String.prototype.slice);

var cloner = function(){};
function create(prototype) {
  if (originalCreate) {
    return originalCreate.call(originalObject, prototype);
  }
  cloner.prototype = prototype || null;
  return new cloner;
}

var rand = Math.random;
var uniqueKeys = create(null);

function makeUniqueKey() {
  // Collisions are highly unlikely, but this module is in the business of
  // making guarantees rather than safe bets.
  do var uniqueKey = internString(strSlice.call(numToStr.call(rand(), 36), 2));
  while (hasOwn.call(uniqueKeys, uniqueKey));
  return uniqueKeys[uniqueKey] = uniqueKey;
}

function internString(str) {
  var obj = {};
  obj[str] = true;
  return Object.keys(obj)[0];
}

// External users might find this function useful, but it is not necessary
// for the typical use of this module.
exports.makeUniqueKey = makeUniqueKey;

// Object.getOwnPropertyNames is the only way to enumerate non-enumerable
// properties, so if we wrap it to ignore our secret keys, there should be
// no way (except guessing) to access those properties.
var originalGetOPNs = Object.getOwnPropertyNames;
Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
  for (var names = originalGetOPNs(object),
           src = 0,
           dst = 0,
           len = names.length;
       src < len;
       ++src) {
    if (!hasOwn.call(uniqueKeys, names[src])) {
      if (src > dst) {
        names[dst] = names[src];
      }
      ++dst;
    }
  }
  names.length = dst;
  return names;
};

function defaultCreatorFn(object) {
  return create(null);
}

function makeAccessor(secretCreatorFn) {
  var brand = makeUniqueKey();
  var passkey = create(null);

  secretCreatorFn = secretCreatorFn || defaultCreatorFn;

  function register(object) {
    var secret; // Created lazily.

    function vault(key, forget) {
      // Only code that has access to the passkey can retrieve (or forget)
      // the secret object.
      if (key === passkey) {
        return forget
          ? secret = null
          : secret || (secret = secretCreatorFn(object));
      }
    }

    defProp(object, brand, vault);
  }

  function accessor(object) {
    if (!hasOwn.call(object, brand))
      register(object);
    return object[brand](passkey);
  }

  accessor.forget = function(object) {
    if (hasOwn.call(object, brand))
      object[brand](passkey, true);
  };

  return accessor;
}

exports.makeAccessor = makeAccessor;

},{}],63:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

/*!
 * XRegExp.build
 * <xregexp.com>
 * Steven Levithan (c) 2012-2017 MIT License
 * Inspired by Lea Verou's RegExp.create <lea.verou.me>
 */

exports.default = function (XRegExp) {

    var REGEX_DATA = 'xregexp';
    var subParts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*\]/g;
    var parts = XRegExp.union([/\({{([\w$]+)}}\)|{{([\w$]+)}}/, subParts], 'g', {
        conjunction: 'or'
    });

    /**
     * Strips a leading `^` and trailing unescaped `$`, if both are present.
     *
     * @private
     * @param {String} pattern Pattern to process.
     * @returns {String} Pattern with edge anchors removed.
     */
    function deanchor(pattern) {
        // Allow any number of empty noncapturing groups before/after anchors, because regexes
        // built/generated by XRegExp sometimes include them
        var leadingAnchor = /^(?:\(\?:\))*\^/;
        var trailingAnchor = /\$(?:\(\?:\))*$/;

        if (leadingAnchor.test(pattern) && trailingAnchor.test(pattern) &&
        // Ensure that the trailing `$` isn't escaped
        trailingAnchor.test(pattern.replace(/\\[\s\S]/g, ''))) {
            return pattern.replace(leadingAnchor, '').replace(trailingAnchor, '');
        }

        return pattern;
    }

    /**
     * Converts the provided value to an XRegExp. Native RegExp flags are not preserved.
     *
     * @private
     * @param {String|RegExp} value Value to convert.
     * @param {Boolean} [addFlagX] Whether to apply the `x` flag in cases when `value` is not
     *   already a regex generated by XRegExp
     * @returns {RegExp} XRegExp object with XRegExp syntax applied.
     */
    function asXRegExp(value, addFlagX) {
        var flags = addFlagX ? 'x' : '';
        return XRegExp.isRegExp(value) ? value[REGEX_DATA] && value[REGEX_DATA].captureNames ?
        // Don't recompile, to preserve capture names
        value :
        // Recompile as XRegExp
        XRegExp(value.source, flags) :
        // Compile string as XRegExp
        XRegExp(value, flags);
    }

    function interpolate(substitution) {
        return substitution instanceof RegExp ? substitution : XRegExp.escape(substitution);
    }

    function reduceToSubpatternsObject(subpatterns, interpolated, subpatternIndex) {
        subpatterns['subpattern' + subpatternIndex] = interpolated;
        return subpatterns;
    }

    function embedSubpatternAfter(raw, subpatternIndex, rawLiterals) {
        var hasSubpattern = subpatternIndex < rawLiterals.length - 1;
        return raw + (hasSubpattern ? '{{subpattern' + subpatternIndex + '}}' : '');
    }

    /**
     * Provides tagged template literals that create regexes with XRegExp syntax and flags. The
     * provided pattern is handled as a raw string, so backslashes don't need to be escaped.
     *
     * Interpolation of strings and regexes shares the features of `XRegExp.build`. Interpolated
     * patterns are treated as atomic units when quantified, interpolated strings have their special
     * characters escaped, a leading `^` and trailing unescaped `$` are stripped from interpolated
     * regexes if both are present, and any backreferences within an interpolated regex are
     * rewritten to work within the overall pattern.
     *
     * @memberOf XRegExp
     * @param {String} [flags] Any combination of XRegExp flags.
     * @returns {Function} Handler for template literals that construct regexes with XRegExp syntax.
     * @example
     *
     * const h12 = /1[0-2]|0?[1-9]/;
     * const h24 = /2[0-3]|[01][0-9]/;
     * const hours = XRegExp.tag('x')`${h12} : | ${h24}`;
     * const minutes = /^[0-5][0-9]$/;
     * // Note that explicitly naming the 'minutes' group is required for named backreferences
     * const time = XRegExp.tag('x')`^ ${hours} (?<minutes>${minutes}) $`;
     * time.test('10:59'); // -> true
     * XRegExp.exec('10:59', time).minutes; // -> '59'
     */
    XRegExp.tag = function (flags) {
        return function (literals) {
            for (var _len = arguments.length, substitutions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                substitutions[_key - 1] = arguments[_key];
            }

            var subpatterns = substitutions.map(interpolate).reduce(reduceToSubpatternsObject, {});
            var pattern = literals.raw.map(embedSubpatternAfter).join('');
            return XRegExp.build(pattern, subpatterns, flags);
        };
    };

    /**
     * Builds regexes using named subpatterns, for readability and pattern reuse. Backreferences in
     * the outer pattern and provided subpatterns are automatically renumbered to work correctly.
     * Native flags used by provided subpatterns are ignored in favor of the `flags` argument.
     *
     * @memberOf XRegExp
     * @param {String} pattern XRegExp pattern using `{{name}}` for embedded subpatterns. Allows
     *   `({{name}})` as shorthand for `(?<name>{{name}})`. Patterns cannot be embedded within
     *   character classes.
     * @param {Object} subs Lookup object for named subpatterns. Values can be strings or regexes. A
     *   leading `^` and trailing unescaped `$` are stripped from subpatterns, if both are present.
     * @param {String} [flags] Any combination of XRegExp flags.
     * @returns {RegExp} Regex with interpolated subpatterns.
     * @example
     *
     * const time = XRegExp.build('(?x)^ {{hours}} ({{minutes}}) $', {
     *   hours: XRegExp.build('{{h12}} : | {{h24}}', {
     *     h12: /1[0-2]|0?[1-9]/,
     *     h24: /2[0-3]|[01][0-9]/
     *   }, 'x'),
     *   minutes: /^[0-5][0-9]$/
     * });
     * time.test('10:59'); // -> true
     * XRegExp.exec('10:59', time).minutes; // -> '59'
     */
    XRegExp.build = function (pattern, subs, flags) {
        flags = flags || '';
        // Used with `asXRegExp` calls for `pattern` and subpatterns in `subs`, to work around how
        // some browsers convert `RegExp('\n')` to a regex that contains the literal characters `\`
        // and `n`. See more details at <https://github.com/slevithan/xregexp/pull/163>.
        var addFlagX = flags.indexOf('x') !== -1;
        var inlineFlags = /^\(\?([\w$]+)\)/.exec(pattern);
        // Add flags within a leading mode modifier to the overall pattern's flags
        if (inlineFlags) {
            flags = XRegExp._clipDuplicates(flags + inlineFlags[1]);
        }

        var data = {};
        for (var p in subs) {
            if (subs.hasOwnProperty(p)) {
                // Passing to XRegExp enables extended syntax and ensures independent validity,
                // lest an unescaped `(`, `)`, `[`, or trailing `\` breaks the `(?:)` wrapper. For
                // subpatterns provided as native regexes, it dies on octals and adds the property
                // used to hold extended regex instance data, for simplicity.
                var sub = asXRegExp(subs[p], addFlagX);
                data[p] = {
                    // Deanchoring allows embedding independently useful anchored regexes. If you
                    // really need to keep your anchors, double them (i.e., `^^...$$`).
                    pattern: deanchor(sub.source),
                    names: sub[REGEX_DATA].captureNames || []
                };
            }
        }

        // Passing to XRegExp dies on octals and ensures the outer pattern is independently valid;
        // helps keep this simple. Named captures will be put back.
        var patternAsRegex = asXRegExp(pattern, addFlagX);

        // 'Caps' is short for 'captures'
        var numCaps = 0;
        var numPriorCaps = void 0;
        var numOuterCaps = 0;
        var outerCapsMap = [0];
        var outerCapNames = patternAsRegex[REGEX_DATA].captureNames || [];
        var output = patternAsRegex.source.replace(parts, function ($0, $1, $2, $3, $4) {
            var subName = $1 || $2;
            var capName = void 0;
            var intro = void 0;
            var localCapIndex = void 0;
            // Named subpattern
            if (subName) {
                if (!data.hasOwnProperty(subName)) {
                    throw new ReferenceError('Undefined property ' + $0);
                }
                // Named subpattern was wrapped in a capturing group
                if ($1) {
                    capName = outerCapNames[numOuterCaps];
                    outerCapsMap[++numOuterCaps] = ++numCaps;
                    // If it's a named group, preserve the name. Otherwise, use the subpattern name
                    // as the capture name
                    intro = '(?<' + (capName || subName) + '>';
                } else {
                    intro = '(?:';
                }
                numPriorCaps = numCaps;
                var rewrittenSubpattern = data[subName].pattern.replace(subParts, function (match, paren, backref) {
                    // Capturing group
                    if (paren) {
                        capName = data[subName].names[numCaps - numPriorCaps];
                        ++numCaps;
                        // If the current capture has a name, preserve the name
                        if (capName) {
                            return '(?<' + capName + '>';
                        }
                        // Backreference
                    } else if (backref) {
                        localCapIndex = +backref - 1;
                        // Rewrite the backreference
                        return data[subName].names[localCapIndex] ?
                        // Need to preserve the backreference name in case using flag `n`
                        '\\k<' + data[subName].names[localCapIndex] + '>' : '\\' + (+backref + numPriorCaps);
                    }
                    return match;
                });
                return '' + intro + rewrittenSubpattern + ')';
            }
            // Capturing group
            if ($3) {
                capName = outerCapNames[numOuterCaps];
                outerCapsMap[++numOuterCaps] = ++numCaps;
                // If the current capture has a name, preserve the name
                if (capName) {
                    return '(?<' + capName + '>';
                }
                // Backreference
            } else if ($4) {
                localCapIndex = +$4 - 1;
                // Rewrite the backreference
                return outerCapNames[localCapIndex] ?
                // Need to preserve the backreference name in case using flag `n`
                '\\k<' + outerCapNames[localCapIndex] + '>' : '\\' + outerCapsMap[+$4];
            }
            return $0;
        });

        return XRegExp(output, flags);
    };
}; // End of module


module.exports = exports['default'];
},{}],64:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

/*!
 * XRegExp.matchRecursive
 * <xregexp.com>
 * Steven Levithan (c) 2009-2017 MIT License
 */

exports.default = function (XRegExp) {

    /**
     * Returns a match detail object composed of the provided values.
     *
     * @private
     */
    function row(name, value, start, end) {
        return {
            name: name,
            value: value,
            start: start,
            end: end
        };
    }

    /**
     * Returns an array of match strings between outermost left and right delimiters, or an array of
     * objects with detailed match parts and position data. An error is thrown if delimiters are
     * unbalanced within the data.
     *
     * @memberOf XRegExp
     * @param {String} str String to search.
     * @param {String} left Left delimiter as an XRegExp pattern.
     * @param {String} right Right delimiter as an XRegExp pattern.
     * @param {String} [flags] Any native or XRegExp flags, used for the left and right delimiters.
     * @param {Object} [options] Lets you specify `valueNames` and `escapeChar` options.
     * @returns {Array} Array of matches, or an empty array.
     * @example
     *
     * // Basic usage
     * let str = '(t((e))s)t()(ing)';
     * XRegExp.matchRecursive(str, '\\(', '\\)', 'g');
     * // -> ['t((e))s', '', 'ing']
     *
     * // Extended information mode with valueNames
     * str = 'Here is <div> <div>an</div></div> example';
     * XRegExp.matchRecursive(str, '<div\\s*>', '</div>', 'gi', {
     *   valueNames: ['between', 'left', 'match', 'right']
     * });
     * // -> [
     * // {name: 'between', value: 'Here is ',       start: 0,  end: 8},
     * // {name: 'left',    value: '<div>',          start: 8,  end: 13},
     * // {name: 'match',   value: ' <div>an</div>', start: 13, end: 27},
     * // {name: 'right',   value: '</div>',         start: 27, end: 33},
     * // {name: 'between', value: ' example',       start: 33, end: 41}
     * // ]
     *
     * // Omitting unneeded parts with null valueNames, and using escapeChar
     * str = '...{1}.\\{{function(x,y){return {y:x}}}';
     * XRegExp.matchRecursive(str, '{', '}', 'g', {
     *   valueNames: ['literal', null, 'value', null],
     *   escapeChar: '\\'
     * });
     * // -> [
     * // {name: 'literal', value: '...',  start: 0, end: 3},
     * // {name: 'value',   value: '1',    start: 4, end: 5},
     * // {name: 'literal', value: '.\\{', start: 6, end: 9},
     * // {name: 'value',   value: 'function(x,y){return {y:x}}', start: 10, end: 37}
     * // ]
     *
     * // Sticky mode via flag y
     * str = '<1><<<2>>><3>4<5>';
     * XRegExp.matchRecursive(str, '<', '>', 'gy');
     * // -> ['1', '<<2>>', '3']
     */
    XRegExp.matchRecursive = function (str, left, right, flags, options) {
        flags = flags || '';
        options = options || {};
        var global = flags.indexOf('g') !== -1;
        var sticky = flags.indexOf('y') !== -1;
        // Flag `y` is controlled internally
        var basicFlags = flags.replace(/y/g, '');
        var escapeChar = options.escapeChar;
        var vN = options.valueNames;
        var output = [];
        var openTokens = 0;
        var delimStart = 0;
        var delimEnd = 0;
        var lastOuterEnd = 0;
        var outerStart = void 0;
        var innerStart = void 0;
        var leftMatch = void 0;
        var rightMatch = void 0;
        var esc = void 0;
        left = XRegExp(left, basicFlags);
        right = XRegExp(right, basicFlags);

        if (escapeChar) {
            if (escapeChar.length > 1) {
                throw new Error('Cannot use more than one escape character');
            }
            escapeChar = XRegExp.escape(escapeChar);
            // Example of concatenated `esc` regex:
            // `escapeChar`: '%'
            // `left`: '<'
            // `right`: '>'
            // Regex is: /(?:%[\S\s]|(?:(?!<|>)[^%])+)+/
            esc = new RegExp('(?:' + escapeChar + '[\\S\\s]|(?:(?!' +
            // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`.
            // Intentionally not passing `basicFlags` to `XRegExp.union` since any syntax
            // transformation resulting from those flags was already applied to `left` and
            // `right` when they were passed through the XRegExp constructor above.
            XRegExp.union([left, right], '', { conjunction: 'or' }).source + ')[^' + escapeChar + '])+)+',
            // Flags `gy` not needed here
            flags.replace(/[^imu]+/g, ''));
        }

        while (true) {
            // If using an escape character, advance to the delimiter's next starting position,
            // skipping any escaped characters in between
            if (escapeChar) {
                delimEnd += (XRegExp.exec(str, esc, delimEnd, 'sticky') || [''])[0].length;
            }
            leftMatch = XRegExp.exec(str, left, delimEnd);
            rightMatch = XRegExp.exec(str, right, delimEnd);
            // Keep the leftmost match only
            if (leftMatch && rightMatch) {
                if (leftMatch.index <= rightMatch.index) {
                    rightMatch = null;
                } else {
                    leftMatch = null;
                }
            }
            // Paths (LM: leftMatch, RM: rightMatch, OT: openTokens):
            // LM | RM | OT | Result
            // 1  | 0  | 1  | loop
            // 1  | 0  | 0  | loop
            // 0  | 1  | 1  | loop
            // 0  | 1  | 0  | throw
            // 0  | 0  | 1  | throw
            // 0  | 0  | 0  | break
            // The paths above don't include the sticky mode special case. The loop ends after the
            // first completed match if not `global`.
            if (leftMatch || rightMatch) {
                delimStart = (leftMatch || rightMatch).index;
                delimEnd = delimStart + (leftMatch || rightMatch)[0].length;
            } else if (!openTokens) {
                break;
            }
            if (sticky && !openTokens && delimStart > lastOuterEnd) {
                break;
            }
            if (leftMatch) {
                if (!openTokens) {
                    outerStart = delimStart;
                    innerStart = delimEnd;
                }
                ++openTokens;
            } else if (rightMatch && openTokens) {
                if (! --openTokens) {
                    if (vN) {
                        if (vN[0] && outerStart > lastOuterEnd) {
                            output.push(row(vN[0], str.slice(lastOuterEnd, outerStart), lastOuterEnd, outerStart));
                        }
                        if (vN[1]) {
                            output.push(row(vN[1], str.slice(outerStart, innerStart), outerStart, innerStart));
                        }
                        if (vN[2]) {
                            output.push(row(vN[2], str.slice(innerStart, delimStart), innerStart, delimStart));
                        }
                        if (vN[3]) {
                            output.push(row(vN[3], str.slice(delimStart, delimEnd), delimStart, delimEnd));
                        }
                    } else {
                        output.push(str.slice(innerStart, delimStart));
                    }
                    lastOuterEnd = delimEnd;
                    if (!global) {
                        break;
                    }
                }
            } else {
                throw new Error('Unbalanced delimiter found in string');
            }
            // If the delimiter matched an empty string, avoid an infinite loop
            if (delimStart === delimEnd) {
                ++delimEnd;
            }
        }

        if (global && !sticky && vN && vN[0] && str.length > lastOuterEnd) {
            output.push(row(vN[0], str.slice(lastOuterEnd), lastOuterEnd, str.length));
        }

        return output;
    };
}; // End of module


module.exports = exports['default'];
},{}],65:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

/*!
 * XRegExp Unicode Base
 * <xregexp.com>
 * Steven Levithan (c) 2008-2017 MIT License
 */

exports.default = function (XRegExp) {

    /**
     * Adds base support for Unicode matching:
     * - Adds syntax `\p{..}` for matching Unicode tokens. Tokens can be inverted using `\P{..}` or
     *   `\p{^..}`. Token names ignore case, spaces, hyphens, and underscores. You can omit the
     *   braces for token names that are a single letter (e.g. `\pL` or `PL`).
     * - Adds flag A (astral), which enables 21-bit Unicode support.
     * - Adds the `XRegExp.addUnicodeData` method used by other addons to provide character data.
     *
     * Unicode Base relies on externally provided Unicode character data. Official addons are
     * available to provide data for Unicode categories, scripts, blocks, and properties.
     *
     * @requires XRegExp
     */

    // ==--------------------------==
    // Private stuff
    // ==--------------------------==

    // Storage for Unicode data
    var unicode = {};

    // Reuse utils
    var dec = XRegExp._dec;
    var hex = XRegExp._hex;
    var pad4 = XRegExp._pad4;

    // Generates a token lookup name: lowercase, with hyphens, spaces, and underscores removed
    function normalize(name) {
        return name.replace(/[- _]+/g, '').toLowerCase();
    }

    // Gets the decimal code of a literal code unit, \xHH, \uHHHH, or a backslash-escaped literal
    function charCode(chr) {
        var esc = /^\\[xu](.+)/.exec(chr);
        return esc ? dec(esc[1]) : chr.charCodeAt(chr[0] === '\\' ? 1 : 0);
    }

    // Inverts a list of ordered BMP characters and ranges
    function invertBmp(range) {
        var output = '';
        var lastEnd = -1;

        XRegExp.forEach(range, /(\\x..|\\u....|\\?[\s\S])(?:-(\\x..|\\u....|\\?[\s\S]))?/, function (m) {
            var start = charCode(m[1]);
            if (start > lastEnd + 1) {
                output += '\\u' + pad4(hex(lastEnd + 1));
                if (start > lastEnd + 2) {
                    output += '-\\u' + pad4(hex(start - 1));
                }
            }
            lastEnd = charCode(m[2] || m[1]);
        });

        if (lastEnd < 0xFFFF) {
            output += '\\u' + pad4(hex(lastEnd + 1));
            if (lastEnd < 0xFFFE) {
                output += '-\\uFFFF';
            }
        }

        return output;
    }

    // Generates an inverted BMP range on first use
    function cacheInvertedBmp(slug) {
        var prop = 'b!';
        return unicode[slug][prop] || (unicode[slug][prop] = invertBmp(unicode[slug].bmp));
    }

    // Combines and optionally negates BMP and astral data
    function buildAstral(slug, isNegated) {
        var item = unicode[slug];
        var combined = '';

        if (item.bmp && !item.isBmpLast) {
            combined = '[' + item.bmp + ']' + (item.astral ? '|' : '');
        }
        if (item.astral) {
            combined += item.astral;
        }
        if (item.isBmpLast && item.bmp) {
            combined += (item.astral ? '|' : '') + '[' + item.bmp + ']';
        }

        // Astral Unicode tokens always match a code point, never a code unit
        return isNegated ? '(?:(?!' + combined + ')(?:[\uD800-\uDBFF][\uDC00-\uDFFF]|[\0-\uFFFF]))' : '(?:' + combined + ')';
    }

    // Builds a complete astral pattern on first use
    function cacheAstral(slug, isNegated) {
        var prop = isNegated ? 'a!' : 'a=';
        return unicode[slug][prop] || (unicode[slug][prop] = buildAstral(slug, isNegated));
    }

    // ==--------------------------==
    // Core functionality
    // ==--------------------------==

    /*
     * Add astral mode (flag A) and Unicode token syntax: `\p{..}`, `\P{..}`, `\p{^..}`, `\pC`.
     */
    XRegExp.addToken(
    // Use `*` instead of `+` to avoid capturing `^` as the token name in `\p{^}`
    /\\([pP])(?:{(\^?)([^}]*)}|([A-Za-z]))/, function (match, scope, flags) {
        var ERR_DOUBLE_NEG = 'Invalid double negation ';
        var ERR_UNKNOWN_NAME = 'Unknown Unicode token ';
        var ERR_UNKNOWN_REF = 'Unicode token missing data ';
        var ERR_ASTRAL_ONLY = 'Astral mode required for Unicode token ';
        var ERR_ASTRAL_IN_CLASS = 'Astral mode does not support Unicode tokens within character classes';
        // Negated via \P{..} or \p{^..}
        var isNegated = match[1] === 'P' || !!match[2];
        // Switch from BMP (0-FFFF) to astral (0-10FFFF) mode via flag A
        var isAstralMode = flags.indexOf('A') !== -1;
        // Token lookup name. Check `[4]` first to avoid passing `undefined` via `\p{}`
        var slug = normalize(match[4] || match[3]);
        // Token data object
        var item = unicode[slug];

        if (match[1] === 'P' && match[2]) {
            throw new SyntaxError(ERR_DOUBLE_NEG + match[0]);
        }
        if (!unicode.hasOwnProperty(slug)) {
            throw new SyntaxError(ERR_UNKNOWN_NAME + match[0]);
        }

        // Switch to the negated form of the referenced Unicode token
        if (item.inverseOf) {
            slug = normalize(item.inverseOf);
            if (!unicode.hasOwnProperty(slug)) {
                throw new ReferenceError(ERR_UNKNOWN_REF + match[0] + ' -> ' + item.inverseOf);
            }
            item = unicode[slug];
            isNegated = !isNegated;
        }

        if (!(item.bmp || isAstralMode)) {
            throw new SyntaxError(ERR_ASTRAL_ONLY + match[0]);
        }
        if (isAstralMode) {
            if (scope === 'class') {
                throw new SyntaxError(ERR_ASTRAL_IN_CLASS);
            }

            return cacheAstral(slug, isNegated);
        }

        return scope === 'class' ? isNegated ? cacheInvertedBmp(slug) : item.bmp : (isNegated ? '[^' : '[') + item.bmp + ']';
    }, {
        scope: 'all',
        optionalFlags: 'A',
        leadChar: '\\'
    });

    /**
     * Adds to the list of Unicode tokens that XRegExp regexes can match via `\p` or `\P`.
     *
     * @memberOf XRegExp
     * @param {Array} data Objects with named character ranges. Each object may have properties
     *   `name`, `alias`, `isBmpLast`, `inverseOf`, `bmp`, and `astral`. All but `name` are
     *   optional, although one of `bmp` or `astral` is required (unless `inverseOf` is set). If
     *   `astral` is absent, the `bmp` data is used for BMP and astral modes. If `bmp` is absent,
     *   the name errors in BMP mode but works in astral mode. If both `bmp` and `astral` are
     *   provided, the `bmp` data only is used in BMP mode, and the combination of `bmp` and
     *   `astral` data is used in astral mode. `isBmpLast` is needed when a token matches orphan
     *   high surrogates *and* uses surrogate pairs to match astral code points. The `bmp` and
     *   `astral` data should be a combination of literal characters and `\xHH` or `\uHHHH` escape
     *   sequences, with hyphens to create ranges. Any regex metacharacters in the data should be
     *   escaped, apart from range-creating hyphens. The `astral` data can additionally use
     *   character classes and alternation, and should use surrogate pairs to represent astral code
     *   points. `inverseOf` can be used to avoid duplicating character data if a Unicode token is
     *   defined as the exact inverse of another token.
     * @example
     *
     * // Basic use
     * XRegExp.addUnicodeData([{
     *   name: 'XDigit',
     *   alias: 'Hexadecimal',
     *   bmp: '0-9A-Fa-f'
     * }]);
     * XRegExp('\\p{XDigit}:\\p{Hexadecimal}+').test('0:3D'); // -> true
     */
    XRegExp.addUnicodeData = function (data) {
        var ERR_NO_NAME = 'Unicode token requires name';
        var ERR_NO_DATA = 'Unicode token has no character data ';
        var item = void 0;

        for (var i = 0; i < data.length; ++i) {
            item = data[i];
            if (!item.name) {
                throw new Error(ERR_NO_NAME);
            }
            if (!(item.inverseOf || item.bmp || item.astral)) {
                throw new Error(ERR_NO_DATA + item.name);
            }
            unicode[normalize(item.name)] = item;
            if (item.alias) {
                unicode[normalize(item.alias)] = item;
            }
        }

        // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and
        // flags might now produce different results
        XRegExp.cache.flush('patterns');
    };

    /**
     * @ignore
     *
     * Return a reference to the internal Unicode definition structure for the given Unicode
     * Property if the given name is a legal Unicode Property for use in XRegExp `\p` or `\P` regex
     * constructs.
     *
     * @memberOf XRegExp
     * @param {String} name Name by which the Unicode Property may be recognized (case-insensitive),
     *   e.g. `'N'` or `'Number'`. The given name is matched against all registered Unicode
     *   Properties and Property Aliases.
     * @returns {Object} Reference to definition structure when the name matches a Unicode Property.
     *
     * @note
     * For more info on Unicode Properties, see also http://unicode.org/reports/tr18/#Categories.
     *
     * @note
     * This method is *not* part of the officially documented API and may change or be removed in
     * the future. It is meant for userland code that wishes to reuse the (large) internal Unicode
     * structures set up by XRegExp as a single point of Unicode 'knowledge' in the application.
     *
     * See some example usage of this functionality, used as a boolean check if the given name
     * is legal and to obtain internal structural data:
     * - `function prepareMacros(...)` in https://github.com/GerHobbelt/jison-lex/blob/master/regexp-lexer.js#L885
     * - `function generateRegexesInitTableCode(...)` in https://github.com/GerHobbelt/jison-lex/blob/master/regexp-lexer.js#L1999
     *
     * Note that the second function in the example (`function generateRegexesInitTableCode(...)`)
     * uses a approach without using this API to obtain a Unicode range spanning regex for use in environments
     * which do not support XRegExp by simply expanding the XRegExp instance to a String through
     * the `map()` mapping action and subsequent `join()`.
     */
    XRegExp._getUnicodeProperty = function (name) {
        var slug = normalize(name);
        return unicode[slug];
    };
}; // End of module


module.exports = exports['default'];
},{}],66:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

/*!
 * XRegExp Unicode Blocks 
 * <xregexp.com>
 * Steven Levithan (c) 2010-2017 MIT License
 * Unicode data by Mathias Bynens <mathiasbynens.be>
 */

exports.default = function (XRegExp) {

    /**
     * Adds support for all Unicode blocks. Block names use the prefix 'In'. E.g.,
     * `\p{InBasicLatin}`. Token names are case insensitive, and any spaces, hyphens, and
     * underscores are ignored.
     *
     * Uses Unicode 9.0.0.
     *
     * @requires XRegExp, Unicode Base
     */

    if (!XRegExp.addUnicodeData) {
        throw new ReferenceError('Unicode Base must be loaded before Unicode Blocks');
    }

    XRegExp.addUnicodeData([{
        name: 'InAdlam',
        astral: '\uD83A[\uDD00-\uDD5F]'
    }, {
        name: 'InAegean_Numbers',
        astral: '\uD800[\uDD00-\uDD3F]'
    }, {
        name: 'InAhom',
        astral: '\uD805[\uDF00-\uDF3F]'
    }, {
        name: 'InAlchemical_Symbols',
        astral: '\uD83D[\uDF00-\uDF7F]'
    }, {
        name: 'InAlphabetic_Presentation_Forms',
        bmp: '\uFB00-\uFB4F'
    }, {
        name: 'InAnatolian_Hieroglyphs',
        astral: '\uD811[\uDC00-\uDE7F]'
    }, {
        name: 'InAncient_Greek_Musical_Notation',
        astral: '\uD834[\uDE00-\uDE4F]'
    }, {
        name: 'InAncient_Greek_Numbers',
        astral: '\uD800[\uDD40-\uDD8F]'
    }, {
        name: 'InAncient_Symbols',
        astral: '\uD800[\uDD90-\uDDCF]'
    }, {
        name: 'InArabic',
        bmp: '\u0600-\u06FF'
    }, {
        name: 'InArabic_Extended_A',
        bmp: '\u08A0-\u08FF'
    }, {
        name: 'InArabic_Mathematical_Alphabetic_Symbols',
        astral: '\uD83B[\uDE00-\uDEFF]'
    }, {
        name: 'InArabic_Presentation_Forms_A',
        bmp: '\uFB50-\uFDFF'
    }, {
        name: 'InArabic_Presentation_Forms_B',
        bmp: '\uFE70-\uFEFF'
    }, {
        name: 'InArabic_Supplement',
        bmp: '\u0750-\u077F'
    }, {
        name: 'InArmenian',
        bmp: '\u0530-\u058F'
    }, {
        name: 'InArrows',
        bmp: '\u2190-\u21FF'
    }, {
        name: 'InAvestan',
        astral: '\uD802[\uDF00-\uDF3F]'
    }, {
        name: 'InBalinese',
        bmp: '\u1B00-\u1B7F'
    }, {
        name: 'InBamum',
        bmp: '\uA6A0-\uA6FF'
    }, {
        name: 'InBamum_Supplement',
        astral: '\uD81A[\uDC00-\uDE3F]'
    }, {
        name: 'InBasic_Latin',
        bmp: '\0-\x7F'
    }, {
        name: 'InBassa_Vah',
        astral: '\uD81A[\uDED0-\uDEFF]'
    }, {
        name: 'InBatak',
        bmp: '\u1BC0-\u1BFF'
    }, {
        name: 'InBengali',
        bmp: '\u0980-\u09FF'
    }, {
        name: 'InBhaiksuki',
        astral: '\uD807[\uDC00-\uDC6F]'
    }, {
        name: 'InBlock_Elements',
        bmp: '\u2580-\u259F'
    }, {
        name: 'InBopomofo',
        bmp: '\u3100-\u312F'
    }, {
        name: 'InBopomofo_Extended',
        bmp: '\u31A0-\u31BF'
    }, {
        name: 'InBox_Drawing',
        bmp: '\u2500-\u257F'
    }, {
        name: 'InBrahmi',
        astral: '\uD804[\uDC00-\uDC7F]'
    }, {
        name: 'InBraille_Patterns',
        bmp: '\u2800-\u28FF'
    }, {
        name: 'InBuginese',
        bmp: '\u1A00-\u1A1F'
    }, {
        name: 'InBuhid',
        bmp: '\u1740-\u175F'
    }, {
        name: 'InByzantine_Musical_Symbols',
        astral: '\uD834[\uDC00-\uDCFF]'
    }, {
        name: 'InCJK_Compatibility',
        bmp: '\u3300-\u33FF'
    }, {
        name: 'InCJK_Compatibility_Forms',
        bmp: '\uFE30-\uFE4F'
    }, {
        name: 'InCJK_Compatibility_Ideographs',
        bmp: '\uF900-\uFAFF'
    }, {
        name: 'InCJK_Compatibility_Ideographs_Supplement',
        astral: '\uD87E[\uDC00-\uDE1F]'
    }, {
        name: 'InCJK_Radicals_Supplement',
        bmp: '\u2E80-\u2EFF'
    }, {
        name: 'InCJK_Strokes',
        bmp: '\u31C0-\u31EF'
    }, {
        name: 'InCJK_Symbols_and_Punctuation',
        bmp: '\u3000-\u303F'
    }, {
        name: 'InCJK_Unified_Ideographs',
        bmp: '\u4E00-\u9FFF'
    }, {
        name: 'InCJK_Unified_Ideographs_Extension_A',
        bmp: '\u3400-\u4DBF'
    }, {
        name: 'InCJK_Unified_Ideographs_Extension_B',
        astral: '[\uD840-\uD868][\uDC00-\uDFFF]|\uD869[\uDC00-\uDEDF]'
    }, {
        name: 'InCJK_Unified_Ideographs_Extension_C',
        astral: '\uD869[\uDF00-\uDFFF]|[\uD86A-\uD86C][\uDC00-\uDFFF]|\uD86D[\uDC00-\uDF3F]'
    }, {
        name: 'InCJK_Unified_Ideographs_Extension_D',
        astral: '\uD86D[\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1F]'
    }, {
        name: 'InCJK_Unified_Ideographs_Extension_E',
        astral: '\uD86E[\uDC20-\uDFFF]|[\uD86F-\uD872][\uDC00-\uDFFF]|\uD873[\uDC00-\uDEAF]'
    }, {
        name: 'InCarian',
        astral: '\uD800[\uDEA0-\uDEDF]'
    }, {
        name: 'InCaucasian_Albanian',
        astral: '\uD801[\uDD30-\uDD6F]'
    }, {
        name: 'InChakma',
        astral: '\uD804[\uDD00-\uDD4F]'
    }, {
        name: 'InCham',
        bmp: '\uAA00-\uAA5F'
    }, {
        name: 'InCherokee',
        bmp: '\u13A0-\u13FF'
    }, {
        name: 'InCherokee_Supplement',
        bmp: '\uAB70-\uABBF'
    }, {
        name: 'InCombining_Diacritical_Marks',
        bmp: '\u0300-\u036F'
    }, {
        name: 'InCombining_Diacritical_Marks_Extended',
        bmp: '\u1AB0-\u1AFF'
    }, {
        name: 'InCombining_Diacritical_Marks_Supplement',
        bmp: '\u1DC0-\u1DFF'
    }, {
        name: 'InCombining_Diacritical_Marks_for_Symbols',
        bmp: '\u20D0-\u20FF'
    }, {
        name: 'InCombining_Half_Marks',
        bmp: '\uFE20-\uFE2F'
    }, {
        name: 'InCommon_Indic_Number_Forms',
        bmp: '\uA830-\uA83F'
    }, {
        name: 'InControl_Pictures',
        bmp: '\u2400-\u243F'
    }, {
        name: 'InCoptic',
        bmp: '\u2C80-\u2CFF'
    }, {
        name: 'InCoptic_Epact_Numbers',
        astral: '\uD800[\uDEE0-\uDEFF]'
    }, {
        name: 'InCounting_Rod_Numerals',
        astral: '\uD834[\uDF60-\uDF7F]'
    }, {
        name: 'InCuneiform',
        astral: '\uD808[\uDC00-\uDFFF]'
    }, {
        name: 'InCuneiform_Numbers_and_Punctuation',
        astral: '\uD809[\uDC00-\uDC7F]'
    }, {
        name: 'InCurrency_Symbols',
        bmp: '\u20A0-\u20CF'
    }, {
        name: 'InCypriot_Syllabary',
        astral: '\uD802[\uDC00-\uDC3F]'
    }, {
        name: 'InCyrillic',
        bmp: '\u0400-\u04FF'
    }, {
        name: 'InCyrillic_Extended_A',
        bmp: '\u2DE0-\u2DFF'
    }, {
        name: 'InCyrillic_Extended_B',
        bmp: '\uA640-\uA69F'
    }, {
        name: 'InCyrillic_Extended_C',
        bmp: '\u1C80-\u1C8F'
    }, {
        name: 'InCyrillic_Supplement',
        bmp: '\u0500-\u052F'
    }, {
        name: 'InDeseret',
        astral: '\uD801[\uDC00-\uDC4F]'
    }, {
        name: 'InDevanagari',
        bmp: '\u0900-\u097F'
    }, {
        name: 'InDevanagari_Extended',
        bmp: '\uA8E0-\uA8FF'
    }, {
        name: 'InDingbats',
        bmp: '\u2700-\u27BF'
    }, {
        name: 'InDomino_Tiles',
        astral: '\uD83C[\uDC30-\uDC9F]'
    }, {
        name: 'InDuployan',
        astral: '\uD82F[\uDC00-\uDC9F]'
    }, {
        name: 'InEarly_Dynastic_Cuneiform',
        astral: '\uD809[\uDC80-\uDD4F]'
    }, {
        name: 'InEgyptian_Hieroglyphs',
        astral: '\uD80C[\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F]'
    }, {
        name: 'InElbasan',
        astral: '\uD801[\uDD00-\uDD2F]'
    }, {
        name: 'InEmoticons',
        astral: '\uD83D[\uDE00-\uDE4F]'
    }, {
        name: 'InEnclosed_Alphanumeric_Supplement',
        astral: '\uD83C[\uDD00-\uDDFF]'
    }, {
        name: 'InEnclosed_Alphanumerics',
        bmp: '\u2460-\u24FF'
    }, {
        name: 'InEnclosed_CJK_Letters_and_Months',
        bmp: '\u3200-\u32FF'
    }, {
        name: 'InEnclosed_Ideographic_Supplement',
        astral: '\uD83C[\uDE00-\uDEFF]'
    }, {
        name: 'InEthiopic',
        bmp: '\u1200-\u137F'
    }, {
        name: 'InEthiopic_Extended',
        bmp: '\u2D80-\u2DDF'
    }, {
        name: 'InEthiopic_Extended_A',
        bmp: '\uAB00-\uAB2F'
    }, {
        name: 'InEthiopic_Supplement',
        bmp: '\u1380-\u139F'
    }, {
        name: 'InGeneral_Punctuation',
        bmp: '\u2000-\u206F'
    }, {
        name: 'InGeometric_Shapes',
        bmp: '\u25A0-\u25FF'
    }, {
        name: 'InGeometric_Shapes_Extended',
        astral: '\uD83D[\uDF80-\uDFFF]'
    }, {
        name: 'InGeorgian',
        bmp: '\u10A0-\u10FF'
    }, {
        name: 'InGeorgian_Supplement',
        bmp: '\u2D00-\u2D2F'
    }, {
        name: 'InGlagolitic',
        bmp: '\u2C00-\u2C5F'
    }, {
        name: 'InGlagolitic_Supplement',
        astral: '\uD838[\uDC00-\uDC2F]'
    }, {
        name: 'InGothic',
        astral: '\uD800[\uDF30-\uDF4F]'
    }, {
        name: 'InGrantha',
        astral: '\uD804[\uDF00-\uDF7F]'
    }, {
        name: 'InGreek_Extended',
        bmp: '\u1F00-\u1FFF'
    }, {
        name: 'InGreek_and_Coptic',
        bmp: '\u0370-\u03FF'
    }, {
        name: 'InGujarati',
        bmp: '\u0A80-\u0AFF'
    }, {
        name: 'InGurmukhi',
        bmp: '\u0A00-\u0A7F'
    }, {
        name: 'InHalfwidth_and_Fullwidth_Forms',
        bmp: '\uFF00-\uFFEF'
    }, {
        name: 'InHangul_Compatibility_Jamo',
        bmp: '\u3130-\u318F'
    }, {
        name: 'InHangul_Jamo',
        bmp: '\u1100-\u11FF'
    }, {
        name: 'InHangul_Jamo_Extended_A',
        bmp: '\uA960-\uA97F'
    }, {
        name: 'InHangul_Jamo_Extended_B',
        bmp: '\uD7B0-\uD7FF'
    }, {
        name: 'InHangul_Syllables',
        bmp: '\uAC00-\uD7AF'
    }, {
        name: 'InHanunoo',
        bmp: '\u1720-\u173F'
    }, {
        name: 'InHatran',
        astral: '\uD802[\uDCE0-\uDCFF]'
    }, {
        name: 'InHebrew',
        bmp: '\u0590-\u05FF'
    }, {
        name: 'InHigh_Private_Use_Surrogates',
        bmp: '\uDB80-\uDBFF'
    }, {
        name: 'InHigh_Surrogates',
        bmp: '\uD800-\uDB7F'
    }, {
        name: 'InHiragana',
        bmp: '\u3040-\u309F'
    }, {
        name: 'InIPA_Extensions',
        bmp: '\u0250-\u02AF'
    }, {
        name: 'InIdeographic_Description_Characters',
        bmp: '\u2FF0-\u2FFF'
    }, {
        name: 'InIdeographic_Symbols_and_Punctuation',
        astral: '\uD81B[\uDFE0-\uDFFF]'
    }, {
        name: 'InImperial_Aramaic',
        astral: '\uD802[\uDC40-\uDC5F]'
    }, {
        name: 'InInscriptional_Pahlavi',
        astral: '\uD802[\uDF60-\uDF7F]'
    }, {
        name: 'InInscriptional_Parthian',
        astral: '\uD802[\uDF40-\uDF5F]'
    }, {
        name: 'InJavanese',
        bmp: '\uA980-\uA9DF'
    }, {
        name: 'InKaithi',
        astral: '\uD804[\uDC80-\uDCCF]'
    }, {
        name: 'InKana_Supplement',
        astral: '\uD82C[\uDC00-\uDCFF]'
    }, {
        name: 'InKanbun',
        bmp: '\u3190-\u319F'
    }, {
        name: 'InKangxi_Radicals',
        bmp: '\u2F00-\u2FDF'
    }, {
        name: 'InKannada',
        bmp: '\u0C80-\u0CFF'
    }, {
        name: 'InKatakana',
        bmp: '\u30A0-\u30FF'
    }, {
        name: 'InKatakana_Phonetic_Extensions',
        bmp: '\u31F0-\u31FF'
    }, {
        name: 'InKayah_Li',
        bmp: '\uA900-\uA92F'
    }, {
        name: 'InKharoshthi',
        astral: '\uD802[\uDE00-\uDE5F]'
    }, {
        name: 'InKhmer',
        bmp: '\u1780-\u17FF'
    }, {
        name: 'InKhmer_Symbols',
        bmp: '\u19E0-\u19FF'
    }, {
        name: 'InKhojki',
        astral: '\uD804[\uDE00-\uDE4F]'
    }, {
        name: 'InKhudawadi',
        astral: '\uD804[\uDEB0-\uDEFF]'
    }, {
        name: 'InLao',
        bmp: '\u0E80-\u0EFF'
    }, {
        name: 'InLatin_Extended_Additional',
        bmp: '\u1E00-\u1EFF'
    }, {
        name: 'InLatin_Extended_A',
        bmp: '\u0100-\u017F'
    }, {
        name: 'InLatin_Extended_B',
        bmp: '\u0180-\u024F'
    }, {
        name: 'InLatin_Extended_C',
        bmp: '\u2C60-\u2C7F'
    }, {
        name: 'InLatin_Extended_D',
        bmp: '\uA720-\uA7FF'
    }, {
        name: 'InLatin_Extended_E',
        bmp: '\uAB30-\uAB6F'
    }, {
        name: 'InLatin_1_Supplement',
        bmp: '\x80-\xFF'
    }, {
        name: 'InLepcha',
        bmp: '\u1C00-\u1C4F'
    }, {
        name: 'InLetterlike_Symbols',
        bmp: '\u2100-\u214F'
    }, {
        name: 'InLimbu',
        bmp: '\u1900-\u194F'
    }, {
        name: 'InLinear_A',
        astral: '\uD801[\uDE00-\uDF7F]'
    }, {
        name: 'InLinear_B_Ideograms',
        astral: '\uD800[\uDC80-\uDCFF]'
    }, {
        name: 'InLinear_B_Syllabary',
        astral: '\uD800[\uDC00-\uDC7F]'
    }, {
        name: 'InLisu',
        bmp: '\uA4D0-\uA4FF'
    }, {
        name: 'InLow_Surrogates',
        bmp: '\uDC00-\uDFFF'
    }, {
        name: 'InLycian',
        astral: '\uD800[\uDE80-\uDE9F]'
    }, {
        name: 'InLydian',
        astral: '\uD802[\uDD20-\uDD3F]'
    }, {
        name: 'InMahajani',
        astral: '\uD804[\uDD50-\uDD7F]'
    }, {
        name: 'InMahjong_Tiles',
        astral: '\uD83C[\uDC00-\uDC2F]'
    }, {
        name: 'InMalayalam',
        bmp: '\u0D00-\u0D7F'
    }, {
        name: 'InMandaic',
        bmp: '\u0840-\u085F'
    }, {
        name: 'InManichaean',
        astral: '\uD802[\uDEC0-\uDEFF]'
    }, {
        name: 'InMarchen',
        astral: '\uD807[\uDC70-\uDCBF]'
    }, {
        name: 'InMathematical_Alphanumeric_Symbols',
        astral: '\uD835[\uDC00-\uDFFF]'
    }, {
        name: 'InMathematical_Operators',
        bmp: '\u2200-\u22FF'
    }, {
        name: 'InMeetei_Mayek',
        bmp: '\uABC0-\uABFF'
    }, {
        name: 'InMeetei_Mayek_Extensions',
        bmp: '\uAAE0-\uAAFF'
    }, {
        name: 'InMende_Kikakui',
        astral: '\uD83A[\uDC00-\uDCDF]'
    }, {
        name: 'InMeroitic_Cursive',
        astral: '\uD802[\uDDA0-\uDDFF]'
    }, {
        name: 'InMeroitic_Hieroglyphs',
        astral: '\uD802[\uDD80-\uDD9F]'
    }, {
        name: 'InMiao',
        astral: '\uD81B[\uDF00-\uDF9F]'
    }, {
        name: 'InMiscellaneous_Mathematical_Symbols_A',
        bmp: '\u27C0-\u27EF'
    }, {
        name: 'InMiscellaneous_Mathematical_Symbols_B',
        bmp: '\u2980-\u29FF'
    }, {
        name: 'InMiscellaneous_Symbols',
        bmp: '\u2600-\u26FF'
    }, {
        name: 'InMiscellaneous_Symbols_and_Arrows',
        bmp: '\u2B00-\u2BFF'
    }, {
        name: 'InMiscellaneous_Symbols_and_Pictographs',
        astral: '\uD83C[\uDF00-\uDFFF]|\uD83D[\uDC00-\uDDFF]'
    }, {
        name: 'InMiscellaneous_Technical',
        bmp: '\u2300-\u23FF'
    }, {
        name: 'InModi',
        astral: '\uD805[\uDE00-\uDE5F]'
    }, {
        name: 'InModifier_Tone_Letters',
        bmp: '\uA700-\uA71F'
    }, {
        name: 'InMongolian',
        bmp: '\u1800-\u18AF'
    }, {
        name: 'InMongolian_Supplement',
        astral: '\uD805[\uDE60-\uDE7F]'
    }, {
        name: 'InMro',
        astral: '\uD81A[\uDE40-\uDE6F]'
    }, {
        name: 'InMultani',
        astral: '\uD804[\uDE80-\uDEAF]'
    }, {
        name: 'InMusical_Symbols',
        astral: '\uD834[\uDD00-\uDDFF]'
    }, {
        name: 'InMyanmar',
        bmp: '\u1000-\u109F'
    }, {
        name: 'InMyanmar_Extended_A',
        bmp: '\uAA60-\uAA7F'
    }, {
        name: 'InMyanmar_Extended_B',
        bmp: '\uA9E0-\uA9FF'
    }, {
        name: 'InNKo',
        bmp: '\u07C0-\u07FF'
    }, {
        name: 'InNabataean',
        astral: '\uD802[\uDC80-\uDCAF]'
    }, {
        name: 'InNew_Tai_Lue',
        bmp: '\u1980-\u19DF'
    }, {
        name: 'InNewa',
        astral: '\uD805[\uDC00-\uDC7F]'
    }, {
        name: 'InNumber_Forms',
        bmp: '\u2150-\u218F'
    }, {
        name: 'InOgham',
        bmp: '\u1680-\u169F'
    }, {
        name: 'InOl_Chiki',
        bmp: '\u1C50-\u1C7F'
    }, {
        name: 'InOld_Hungarian',
        astral: '\uD803[\uDC80-\uDCFF]'
    }, {
        name: 'InOld_Italic',
        astral: '\uD800[\uDF00-\uDF2F]'
    }, {
        name: 'InOld_North_Arabian',
        astral: '\uD802[\uDE80-\uDE9F]'
    }, {
        name: 'InOld_Permic',
        astral: '\uD800[\uDF50-\uDF7F]'
    }, {
        name: 'InOld_Persian',
        astral: '\uD800[\uDFA0-\uDFDF]'
    }, {
        name: 'InOld_South_Arabian',
        astral: '\uD802[\uDE60-\uDE7F]'
    }, {
        name: 'InOld_Turkic',
        astral: '\uD803[\uDC00-\uDC4F]'
    }, {
        name: 'InOptical_Character_Recognition',
        bmp: '\u2440-\u245F'
    }, {
        name: 'InOriya',
        bmp: '\u0B00-\u0B7F'
    }, {
        name: 'InOrnamental_Dingbats',
        astral: '\uD83D[\uDE50-\uDE7F]'
    }, {
        name: 'InOsage',
        astral: '\uD801[\uDCB0-\uDCFF]'
    }, {
        name: 'InOsmanya',
        astral: '\uD801[\uDC80-\uDCAF]'
    }, {
        name: 'InPahawh_Hmong',
        astral: '\uD81A[\uDF00-\uDF8F]'
    }, {
        name: 'InPalmyrene',
        astral: '\uD802[\uDC60-\uDC7F]'
    }, {
        name: 'InPau_Cin_Hau',
        astral: '\uD806[\uDEC0-\uDEFF]'
    }, {
        name: 'InPhags_pa',
        bmp: '\uA840-\uA87F'
    }, {
        name: 'InPhaistos_Disc',
        astral: '\uD800[\uDDD0-\uDDFF]'
    }, {
        name: 'InPhoenician',
        astral: '\uD802[\uDD00-\uDD1F]'
    }, {
        name: 'InPhonetic_Extensions',
        bmp: '\u1D00-\u1D7F'
    }, {
        name: 'InPhonetic_Extensions_Supplement',
        bmp: '\u1D80-\u1DBF'
    }, {
        name: 'InPlaying_Cards',
        astral: '\uD83C[\uDCA0-\uDCFF]'
    }, {
        name: 'InPrivate_Use_Area',
        bmp: '\uE000-\uF8FF'
    }, {
        name: 'InPsalter_Pahlavi',
        astral: '\uD802[\uDF80-\uDFAF]'
    }, {
        name: 'InRejang',
        bmp: '\uA930-\uA95F'
    }, {
        name: 'InRumi_Numeral_Symbols',
        astral: '\uD803[\uDE60-\uDE7F]'
    }, {
        name: 'InRunic',
        bmp: '\u16A0-\u16FF'
    }, {
        name: 'InSamaritan',
        bmp: '\u0800-\u083F'
    }, {
        name: 'InSaurashtra',
        bmp: '\uA880-\uA8DF'
    }, {
        name: 'InSharada',
        astral: '\uD804[\uDD80-\uDDDF]'
    }, {
        name: 'InShavian',
        astral: '\uD801[\uDC50-\uDC7F]'
    }, {
        name: 'InShorthand_Format_Controls',
        astral: '\uD82F[\uDCA0-\uDCAF]'
    }, {
        name: 'InSiddham',
        astral: '\uD805[\uDD80-\uDDFF]'
    }, {
        name: 'InSinhala',
        bmp: '\u0D80-\u0DFF'
    }, {
        name: 'InSinhala_Archaic_Numbers',
        astral: '\uD804[\uDDE0-\uDDFF]'
    }, {
        name: 'InSmall_Form_Variants',
        bmp: '\uFE50-\uFE6F'
    }, {
        name: 'InSora_Sompeng',
        astral: '\uD804[\uDCD0-\uDCFF]'
    }, {
        name: 'InSpacing_Modifier_Letters',
        bmp: '\u02B0-\u02FF'
    }, {
        name: 'InSpecials',
        bmp: '\uFFF0-\uFFFF'
    }, {
        name: 'InSundanese',
        bmp: '\u1B80-\u1BBF'
    }, {
        name: 'InSundanese_Supplement',
        bmp: '\u1CC0-\u1CCF'
    }, {
        name: 'InSuperscripts_and_Subscripts',
        bmp: '\u2070-\u209F'
    }, {
        name: 'InSupplemental_Arrows_A',
        bmp: '\u27F0-\u27FF'
    }, {
        name: 'InSupplemental_Arrows_B',
        bmp: '\u2900-\u297F'
    }, {
        name: 'InSupplemental_Arrows_C',
        astral: '\uD83E[\uDC00-\uDCFF]'
    }, {
        name: 'InSupplemental_Mathematical_Operators',
        bmp: '\u2A00-\u2AFF'
    }, {
        name: 'InSupplemental_Punctuation',
        bmp: '\u2E00-\u2E7F'
    }, {
        name: 'InSupplemental_Symbols_and_Pictographs',
        astral: '\uD83E[\uDD00-\uDDFF]'
    }, {
        name: 'InSupplementary_Private_Use_Area_A',
        astral: '[\uDB80-\uDBBF][\uDC00-\uDFFF]'
    }, {
        name: 'InSupplementary_Private_Use_Area_B',
        astral: '[\uDBC0-\uDBFF][\uDC00-\uDFFF]'
    }, {
        name: 'InSutton_SignWriting',
        astral: '\uD836[\uDC00-\uDEAF]'
    }, {
        name: 'InSyloti_Nagri',
        bmp: '\uA800-\uA82F'
    }, {
        name: 'InSyriac',
        bmp: '\u0700-\u074F'
    }, {
        name: 'InTagalog',
        bmp: '\u1700-\u171F'
    }, {
        name: 'InTagbanwa',
        bmp: '\u1760-\u177F'
    }, {
        name: 'InTags',
        astral: '\uDB40[\uDC00-\uDC7F]'
    }, {
        name: 'InTai_Le',
        bmp: '\u1950-\u197F'
    }, {
        name: 'InTai_Tham',
        bmp: '\u1A20-\u1AAF'
    }, {
        name: 'InTai_Viet',
        bmp: '\uAA80-\uAADF'
    }, {
        name: 'InTai_Xuan_Jing_Symbols',
        astral: '\uD834[\uDF00-\uDF5F]'
    }, {
        name: 'InTakri',
        astral: '\uD805[\uDE80-\uDECF]'
    }, {
        name: 'InTamil',
        bmp: '\u0B80-\u0BFF'
    }, {
        name: 'InTangut',
        astral: '[\uD81C-\uD821][\uDC00-\uDFFF]'
    }, {
        name: 'InTangut_Components',
        astral: '\uD822[\uDC00-\uDEFF]'
    }, {
        name: 'InTelugu',
        bmp: '\u0C00-\u0C7F'
    }, {
        name: 'InThaana',
        bmp: '\u0780-\u07BF'
    }, {
        name: 'InThai',
        bmp: '\u0E00-\u0E7F'
    }, {
        name: 'InTibetan',
        bmp: '\u0F00-\u0FFF'
    }, {
        name: 'InTifinagh',
        bmp: '\u2D30-\u2D7F'
    }, {
        name: 'InTirhuta',
        astral: '\uD805[\uDC80-\uDCDF]'
    }, {
        name: 'InTransport_and_Map_Symbols',
        astral: '\uD83D[\uDE80-\uDEFF]'
    }, {
        name: 'InUgaritic',
        astral: '\uD800[\uDF80-\uDF9F]'
    }, {
        name: 'InUnified_Canadian_Aboriginal_Syllabics',
        bmp: '\u1400-\u167F'
    }, {
        name: 'InUnified_Canadian_Aboriginal_Syllabics_Extended',
        bmp: '\u18B0-\u18FF'
    }, {
        name: 'InVai',
        bmp: '\uA500-\uA63F'
    }, {
        name: 'InVariation_Selectors',
        bmp: '\uFE00-\uFE0F'
    }, {
        name: 'InVariation_Selectors_Supplement',
        astral: '\uDB40[\uDD00-\uDDEF]'
    }, {
        name: 'InVedic_Extensions',
        bmp: '\u1CD0-\u1CFF'
    }, {
        name: 'InVertical_Forms',
        bmp: '\uFE10-\uFE1F'
    }, {
        name: 'InWarang_Citi',
        astral: '\uD806[\uDCA0-\uDCFF]'
    }, {
        name: 'InYi_Radicals',
        bmp: '\uA490-\uA4CF'
    }, {
        name: 'InYi_Syllables',
        bmp: '\uA000-\uA48F'
    }, {
        name: 'InYijing_Hexagram_Symbols',
        bmp: '\u4DC0-\u4DFF'
    }]);
}; // End of module


module.exports = exports['default'];
},{}],67:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

/*!
 * XRegExp Unicode Categories 
 * <xregexp.com>
 * Steven Levithan (c) 2010-2017 MIT License
 * Unicode data by Mathias Bynens <mathiasbynens.be>
 */

exports.default = function (XRegExp) {

    /**
     * Adds support for Unicode's general categories. E.g., `\p{Lu}` or `\p{Uppercase Letter}`. See
     * category descriptions in UAX #44 <http://unicode.org/reports/tr44/#GC_Values_Table>. Token
     * names are case insensitive, and any spaces, hyphens, and underscores are ignored.
     *
     * Uses Unicode 9.0.0.
     *
     * @requires XRegExp, Unicode Base
     */

    if (!XRegExp.addUnicodeData) {
        throw new ReferenceError('Unicode Base must be loaded before Unicode Categories');
    }

    XRegExp.addUnicodeData([{
        name: 'C',
        alias: 'Other',
        isBmpLast: true,
        bmp: '\0-\x1F\x7F-\x9F\xAD\u0378\u0379\u0380-\u0383\u038B\u038D\u03A2\u0530\u0557\u0558\u0560\u0588\u058B\u058C\u0590\u05C8-\u05CF\u05EB-\u05EF\u05F5-\u0605\u061C\u061D\u06DD\u070E\u070F\u074B\u074C\u07B2-\u07BF\u07FB-\u07FF\u082E\u082F\u083F\u085C\u085D\u085F-\u089F\u08B5\u08BE-\u08D3\u08E2\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09FC-\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF2-\u0AF8\u0AFA-\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B55\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B78-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BFB-\u0BFF\u0C04\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C77\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0D00\u0D04\u0D0D\u0D11\u0D3B\u0D3C\u0D45\u0D49\u0D50-\u0D53\u0D64\u0D65\u0D80\u0D81\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF5-\u0E00\u0E3B-\u0E3E\u0E5C-\u0E80\u0E83\u0E85\u0E86\u0E89\u0E8B\u0E8C\u0E8E-\u0E93\u0E98\u0EA0\u0EA4\u0EA6\u0EA8\u0EA9\u0EAC\u0EBA\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F48\u0F6D-\u0F70\u0F98\u0FBD\u0FCD\u0FDB-\u0FFF\u10C6\u10C8-\u10CC\u10CE\u10CF\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u137D-\u137F\u139A-\u139F\u13F6\u13F7\u13FE\u13FF\u169D-\u169F\u16F9-\u16FF\u170D\u1715-\u171F\u1737-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17DE\u17DF\u17EA-\u17EF\u17FA-\u17FF\u180E\u180F\u181A-\u181F\u1878-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u193F\u1941-\u1943\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DB-\u19DD\u1A1C\u1A1D\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1A9F\u1AAE\u1AAF\u1ABF-\u1AFF\u1B4C-\u1B4F\u1B7D-\u1B7F\u1BF4-\u1BFB\u1C38-\u1C3A\u1C4A-\u1C4C\u1C89-\u1CBF\u1CC8-\u1CCF\u1CF7\u1CFA-\u1CFF\u1DF6-\u1DFA\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FC5\u1FD4\u1FD5\u1FDC\u1FF0\u1FF1\u1FF5\u1FFF\u200B-\u200F\u202A-\u202E\u2060-\u206F\u2072\u2073\u208F\u209D-\u209F\u20BF-\u20CF\u20F1-\u20FF\u218C-\u218F\u23FF\u2427-\u243F\u244B-\u245F\u2B74\u2B75\u2B96\u2B97\u2BBA-\u2BBC\u2BC9\u2BD2-\u2BEB\u2BF0-\u2BFF\u2C2F\u2C5F\u2CF4-\u2CF8\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D71-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E45-\u2E7F\u2E9A\u2EF4-\u2EFF\u2FD6-\u2FEF\u2FFC-\u2FFF\u3040\u3097\u3098\u3100-\u3104\u312E-\u3130\u318F\u31BB-\u31BF\u31E4-\u31EF\u321F\u32FF\u4DB6-\u4DBF\u9FD6-\u9FFF\uA48D-\uA48F\uA4C7-\uA4CF\uA62C-\uA63F\uA6F8-\uA6FF\uA7AF\uA7B8-\uA7F6\uA82C-\uA82F\uA83A-\uA83F\uA878-\uA87F\uA8C6-\uA8CD\uA8DA-\uA8DF\uA8FE\uA8FF\uA954-\uA95E\uA97D-\uA97F\uA9CE\uA9DA-\uA9DD\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A\uAA5B\uAAC3-\uAADA\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB66-\uAB6F\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBC2-\uFBD2\uFD40-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFE\uFDFF\uFE1A-\uFE1F\uFE53\uFE67\uFE6C-\uFE6F\uFE75\uFEFD-\uFF00\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFDF\uFFE7\uFFEF-\uFFFB\uFFFE\uFFFF',
        astral: '\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDCFF\uDD03-\uDD06\uDD34-\uDD36\uDD8F\uDD9C-\uDD9F\uDDA1-\uDDCF\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEFC-\uDEFF\uDF24-\uDF2F\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDFC4-\uDFC7\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6E\uDD70-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56\uDC9F-\uDCA6\uDCB0-\uDCDF\uDCF3\uDCF6-\uDCFA\uDD1C-\uDD1E\uDD3A-\uDD3E\uDD40-\uDD7F\uDDB8-\uDDBB\uDDD0\uDDD1\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE34-\uDE37\uDE3B-\uDE3E\uDE48-\uDE4F\uDE59-\uDE5F\uDEA0-\uDEBF\uDEE7-\uDEEA\uDEF7-\uDEFF\uDF36-\uDF38\uDF56\uDF57\uDF73-\uDF77\uDF92-\uDF98\uDF9D-\uDFA8\uDFB0-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCF9\uDD00-\uDE5F\uDE7F-\uDFFF]|\uD804[\uDC4E-\uDC51\uDC70-\uDC7E\uDCBD\uDCC2-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD44-\uDD4F\uDD77-\uDD7F\uDDCE\uDDCF\uDDE0\uDDF5-\uDDFF\uDE12\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEAA-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF3B\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC5A\uDC5C\uDC5E-\uDC7F\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDDE-\uDDFF\uDE45-\uDE4F\uDE5A-\uDE5F\uDE6D-\uDE7F\uDEB8-\uDEBF\uDECA-\uDEFF\uDF1A-\uDF1C\uDF2C-\uDF2F\uDF40-\uDFFF]|\uD806[\uDC00-\uDC9F\uDCF3-\uDCFE\uDD00-\uDEBF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC46-\uDC4F\uDC6D-\uDC6F\uDC90\uDC91\uDCA8\uDCB7-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F\uDC75-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD823-\uD82B\uD82D\uD82E\uD830-\uD833\uD837\uD839\uD83F\uD874-\uD87D\uD87F-\uDB3F\uDB41-\uDBFF][\uDC00-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDE6D\uDE70-\uDECF\uDEEE\uDEEF\uDEF6-\uDEFF\uDF46-\uDF4F\uDF5A\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDEFF\uDF45-\uDF4F\uDF7F-\uDF8E\uDFA0-\uDFDF\uDFE1-\uDFFF]|\uD821[\uDFED-\uDFFF]|\uD822[\uDEF3-\uDFFF]|\uD82C[\uDC02-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A\uDC9B\uDCA0-\uDFFF]|\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDD73-\uDD7A\uDDE9-\uDDFF\uDE46-\uDEFF\uDF57-\uDF5F\uDF72-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]|\uD836[\uDE8C-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDFFF]|\uD83A[\uDCC5\uDCC6\uDCD7-\uDCFF\uDD4B-\uDD4F\uDD5A-\uDD5D\uDD60-\uDFFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDEEF\uDEF2-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD6F\uDDAD-\uDDE5\uDE03-\uDE0F\uDE3C-\uDE3F\uDE49-\uDE4F\uDE52-\uDEFF]|\uD83D[\uDED3-\uDEDF\uDEED-\uDEEF\uDEF7-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDD0F\uDD1F\uDD28-\uDD2F\uDD31\uDD32\uDD3F\uDD4C-\uDD4F\uDD5F-\uDD7F\uDD92-\uDDBF\uDDC1-\uDFFF]|\uD869[\uDED7-\uDEFF]|\uD86D[\uDF35-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uDB40[\uDC00-\uDCFF\uDDF0-\uDFFF]'
    }, {
        name: 'Cc',
        alias: 'Control',
        bmp: '\0-\x1F\x7F-\x9F'
    }, {
        name: 'Cf',
        alias: 'Format',
        bmp: '\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB',
        astral: '\uD804\uDCBD|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]'
    }, {
        name: 'Cn',
        alias: 'Unassigned',
        bmp: '\u0378\u0379\u0380-\u0383\u038B\u038D\u03A2\u0530\u0557\u0558\u0560\u0588\u058B\u058C\u0590\u05C8-\u05CF\u05EB-\u05EF\u05F5-\u05FF\u061D\u070E\u074B\u074C\u07B2-\u07BF\u07FB-\u07FF\u082E\u082F\u083F\u085C\u085D\u085F-\u089F\u08B5\u08BE-\u08D3\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09FC-\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF2-\u0AF8\u0AFA-\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B55\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B78-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BFB-\u0BFF\u0C04\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C77\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0D00\u0D04\u0D0D\u0D11\u0D3B\u0D3C\u0D45\u0D49\u0D50-\u0D53\u0D64\u0D65\u0D80\u0D81\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF5-\u0E00\u0E3B-\u0E3E\u0E5C-\u0E80\u0E83\u0E85\u0E86\u0E89\u0E8B\u0E8C\u0E8E-\u0E93\u0E98\u0EA0\u0EA4\u0EA6\u0EA8\u0EA9\u0EAC\u0EBA\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F48\u0F6D-\u0F70\u0F98\u0FBD\u0FCD\u0FDB-\u0FFF\u10C6\u10C8-\u10CC\u10CE\u10CF\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u137D-\u137F\u139A-\u139F\u13F6\u13F7\u13FE\u13FF\u169D-\u169F\u16F9-\u16FF\u170D\u1715-\u171F\u1737-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17DE\u17DF\u17EA-\u17EF\u17FA-\u17FF\u180F\u181A-\u181F\u1878-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u193F\u1941-\u1943\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DB-\u19DD\u1A1C\u1A1D\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1A9F\u1AAE\u1AAF\u1ABF-\u1AFF\u1B4C-\u1B4F\u1B7D-\u1B7F\u1BF4-\u1BFB\u1C38-\u1C3A\u1C4A-\u1C4C\u1C89-\u1CBF\u1CC8-\u1CCF\u1CF7\u1CFA-\u1CFF\u1DF6-\u1DFA\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FC5\u1FD4\u1FD5\u1FDC\u1FF0\u1FF1\u1FF5\u1FFF\u2065\u2072\u2073\u208F\u209D-\u209F\u20BF-\u20CF\u20F1-\u20FF\u218C-\u218F\u23FF\u2427-\u243F\u244B-\u245F\u2B74\u2B75\u2B96\u2B97\u2BBA-\u2BBC\u2BC9\u2BD2-\u2BEB\u2BF0-\u2BFF\u2C2F\u2C5F\u2CF4-\u2CF8\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D71-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E45-\u2E7F\u2E9A\u2EF4-\u2EFF\u2FD6-\u2FEF\u2FFC-\u2FFF\u3040\u3097\u3098\u3100-\u3104\u312E-\u3130\u318F\u31BB-\u31BF\u31E4-\u31EF\u321F\u32FF\u4DB6-\u4DBF\u9FD6-\u9FFF\uA48D-\uA48F\uA4C7-\uA4CF\uA62C-\uA63F\uA6F8-\uA6FF\uA7AF\uA7B8-\uA7F6\uA82C-\uA82F\uA83A-\uA83F\uA878-\uA87F\uA8C6-\uA8CD\uA8DA-\uA8DF\uA8FE\uA8FF\uA954-\uA95E\uA97D-\uA97F\uA9CE\uA9DA-\uA9DD\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A\uAA5B\uAAC3-\uAADA\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB66-\uAB6F\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uD7FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBC2-\uFBD2\uFD40-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFE\uFDFF\uFE1A-\uFE1F\uFE53\uFE67\uFE6C-\uFE6F\uFE75\uFEFD\uFEFE\uFF00\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFDF\uFFE7\uFFEF-\uFFF8\uFFFE\uFFFF',
        astral: '\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDCFF\uDD03-\uDD06\uDD34-\uDD36\uDD8F\uDD9C-\uDD9F\uDDA1-\uDDCF\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEFC-\uDEFF\uDF24-\uDF2F\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDFC4-\uDFC7\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6E\uDD70-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56\uDC9F-\uDCA6\uDCB0-\uDCDF\uDCF3\uDCF6-\uDCFA\uDD1C-\uDD1E\uDD3A-\uDD3E\uDD40-\uDD7F\uDDB8-\uDDBB\uDDD0\uDDD1\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE34-\uDE37\uDE3B-\uDE3E\uDE48-\uDE4F\uDE59-\uDE5F\uDEA0-\uDEBF\uDEE7-\uDEEA\uDEF7-\uDEFF\uDF36-\uDF38\uDF56\uDF57\uDF73-\uDF77\uDF92-\uDF98\uDF9D-\uDFA8\uDFB0-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCF9\uDD00-\uDE5F\uDE7F-\uDFFF]|\uD804[\uDC4E-\uDC51\uDC70-\uDC7E\uDCC2-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD44-\uDD4F\uDD77-\uDD7F\uDDCE\uDDCF\uDDE0\uDDF5-\uDDFF\uDE12\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEAA-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF3B\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC5A\uDC5C\uDC5E-\uDC7F\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDDE-\uDDFF\uDE45-\uDE4F\uDE5A-\uDE5F\uDE6D-\uDE7F\uDEB8-\uDEBF\uDECA-\uDEFF\uDF1A-\uDF1C\uDF2C-\uDF2F\uDF40-\uDFFF]|\uD806[\uDC00-\uDC9F\uDCF3-\uDCFE\uDD00-\uDEBF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC46-\uDC4F\uDC6D-\uDC6F\uDC90\uDC91\uDCA8\uDCB7-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F\uDC75-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD823-\uD82B\uD82D\uD82E\uD830-\uD833\uD837\uD839\uD83F\uD874-\uD87D\uD87F-\uDB3F\uDB41-\uDB7F][\uDC00-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDE6D\uDE70-\uDECF\uDEEE\uDEEF\uDEF6-\uDEFF\uDF46-\uDF4F\uDF5A\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDEFF\uDF45-\uDF4F\uDF7F-\uDF8E\uDFA0-\uDFDF\uDFE1-\uDFFF]|\uD821[\uDFED-\uDFFF]|\uD822[\uDEF3-\uDFFF]|\uD82C[\uDC02-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A\uDC9B\uDCA4-\uDFFF]|\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDDE9-\uDDFF\uDE46-\uDEFF\uDF57-\uDF5F\uDF72-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]|\uD836[\uDE8C-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDFFF]|\uD83A[\uDCC5\uDCC6\uDCD7-\uDCFF\uDD4B-\uDD4F\uDD5A-\uDD5D\uDD60-\uDFFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDEEF\uDEF2-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD6F\uDDAD-\uDDE5\uDE03-\uDE0F\uDE3C-\uDE3F\uDE49-\uDE4F\uDE52-\uDEFF]|\uD83D[\uDED3-\uDEDF\uDEED-\uDEEF\uDEF7-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDD0F\uDD1F\uDD28-\uDD2F\uDD31\uDD32\uDD3F\uDD4C-\uDD4F\uDD5F-\uDD7F\uDD92-\uDDBF\uDDC1-\uDFFF]|\uD869[\uDED7-\uDEFF]|\uD86D[\uDF35-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uDB40[\uDC00\uDC02-\uDC1F\uDC80-\uDCFF\uDDF0-\uDFFF]|[\uDBBF\uDBFF][\uDFFE\uDFFF]'
    }, {
        name: 'Co',
        alias: 'Private_Use',
        bmp: '\uE000-\uF8FF',
        astral: '[\uDB80-\uDBBE\uDBC0-\uDBFE][\uDC00-\uDFFF]|[\uDBBF\uDBFF][\uDC00-\uDFFD]'
    }, {
        name: 'Cs',
        alias: 'Surrogate',
        bmp: '\uD800-\uDFFF'
    }, {
        name: 'L',
        alias: 'Letter',
        bmp: 'A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC',
        astral: '\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]'
    }, {
        name: 'Ll',
        alias: 'Lowercase_Letter',
        bmp: 'a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1C80-\u1C88\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A',
        astral: '\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD83A[\uDD22-\uDD43]'
    }, {
        name: 'Lm',
        alias: 'Modifier_Letter',
        bmp: '\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA69C\uA69D\uA717-\uA71F\uA770\uA788\uA7F8\uA7F9\uA9CF\uA9E6\uAA70\uAADD\uAAF3\uAAF4\uAB5C-\uAB5F\uFF70\uFF9E\uFF9F',
        astral: '\uD81A[\uDF40-\uDF43]|\uD81B[\uDF93-\uDF9F\uDFE0]'
    }, {
        name: 'Lo',
        alias: 'Other_Letter',
        bmp: '\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA78F\uA7F7\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9E0-\uA9E4\uA9E7-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC',
        astral: '\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC50-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]'
    }, {
        name: 'Lt',
        alias: 'Titlecase_Letter',
        bmp: '\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC'
    }, {
        name: 'Lu',
        alias: 'Uppercase_Letter',
        bmp: 'A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AE\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A',
        astral: '\uD801[\uDC00-\uDC27\uDCB0-\uDCD3]|\uD803[\uDC80-\uDCB2]|\uD806[\uDCA0-\uDCBF]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD83A[\uDD00-\uDD21]'
    }, {
        name: 'M',
        alias: 'Mark',
        bmp: '\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F',
        astral: '\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDDCA-\uDDCC\uDE2C-\uDE37\uDE3E\uDEDF-\uDEEA\uDF00-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC35-\uDC46\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDDDC\uDDDD\uDE30-\uDE40\uDEAB-\uDEB7\uDF1D-\uDF2B]|\uD807[\uDC2F-\uDC36\uDC38-\uDC3F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uDB40[\uDD00-\uDDEF]'
    }, {
        name: 'Mc',
        alias: 'Spacing_Mark',
        bmp: '\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BE-\u09C0\u09C7\u09C8\u09CB\u09CC\u09D7\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD7\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0-\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0D02\u0D03\u0D3E-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D57\u0D82\u0D83\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DF2\u0DF3\u0F3E\u0F3F\u0F7F\u102B\u102C\u1031\u1038\u103B\u103C\u1056\u1057\u1062-\u1064\u1067-\u106D\u1083\u1084\u1087-\u108C\u108F\u109A-\u109C\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1B04\u1B35\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF2\u1CF3\u302E\u302F\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BD-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAA7B\uAA7D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC',
        astral: '\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3E\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB0-\uDCB2\uDCB9\uDCBB-\uDCBE\uDCC1\uDDAF-\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF20\uDF21\uDF26]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4]|\uD81B[\uDF51-\uDF7E]|\uD834[\uDD65\uDD66\uDD6D-\uDD72]'
    }, {
        name: 'Me',
        alias: 'Enclosing_Mark',
        bmp: '\u0488\u0489\u1ABE\u20DD-\u20E0\u20E2-\u20E4\uA670-\uA672'
    }, {
        name: 'Mn',
        alias: 'Nonspacing_Mark',
        bmp: '\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D01\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8C5\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F',
        astral: '\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDCA-\uDDCC\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3C\uDF40\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDCB3-\uDCB8\uDCBA\uDCBF\uDCC0\uDCC2\uDCC3\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uDB40[\uDD00-\uDDEF]'
    }, {
        name: 'N',
        alias: 'Number',
        bmp: '0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D58-\u0D5E\u0D66-\u0D78\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19',
        astral: '\uD800[\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23\uDF41\uDF4A\uDFD1-\uDFD5]|\uD801[\uDCA0-\uDCA9]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE47\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDCFA-\uDCFF\uDE60-\uDE7E]|\uD804[\uDC52-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDDE1-\uDDF4\uDEF0-\uDEF9]|\uD805[\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF3B]|\uD806[\uDCE0-\uDCF2]|\uD807[\uDC50-\uDC6C]|\uD809[\uDC00-\uDC6E]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59\uDF5B-\uDF61]|\uD834[\uDF60-\uDF71]|\uD835[\uDFCE-\uDFFF]|\uD83A[\uDCC7-\uDCCF\uDD50-\uDD59]|\uD83C[\uDD00-\uDD0C]'
    }, {
        name: 'Nd',
        alias: 'Decimal_Number',
        bmp: '0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19',
        astral: '\uD801[\uDCA0-\uDCA9]|\uD804[\uDC66-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDEF0-\uDEF9]|\uD805[\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF39]|\uD806[\uDCE0-\uDCE9]|\uD807[\uDC50-\uDC59]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59]|\uD835[\uDFCE-\uDFFF]|\uD83A[\uDD50-\uDD59]'
    }, {
        name: 'Nl',
        alias: 'Letter_Number',
        bmp: '\u16EE-\u16F0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303A\uA6E6-\uA6EF',
        astral: '\uD800[\uDD40-\uDD74\uDF41\uDF4A\uDFD1-\uDFD5]|\uD809[\uDC00-\uDC6E]'
    }, {
        name: 'No',
        alias: 'Other_Number',
        bmp: '\xB2\xB3\xB9\xBC-\xBE\u09F4-\u09F9\u0B72-\u0B77\u0BF0-\u0BF2\u0C78-\u0C7E\u0D58-\u0D5E\u0D70-\u0D78\u0F2A-\u0F33\u1369-\u137C\u17F0-\u17F9\u19DA\u2070\u2074-\u2079\u2080-\u2089\u2150-\u215F\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA830-\uA835',
        astral: '\uD800[\uDD07-\uDD33\uDD75-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE47\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDCFA-\uDCFF\uDE60-\uDE7E]|\uD804[\uDC52-\uDC65\uDDE1-\uDDF4]|\uD805[\uDF3A\uDF3B]|\uD806[\uDCEA-\uDCF2]|\uD807[\uDC5A-\uDC6C]|\uD81A[\uDF5B-\uDF61]|\uD834[\uDF60-\uDF71]|\uD83A[\uDCC7-\uDCCF]|\uD83C[\uDD00-\uDD0C]'
    }, {
        name: 'P',
        alias: 'Punctuation',
        bmp: '\x21-\x23\x25-\\x2A\x2C-\x2F\x3A\x3B\\x3F\x40\\x5B-\\x5D\x5F\\x7B\x7D\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E44\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65',
        astral: '\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD807[\uDC41-\uDC45\uDC70\uDC71]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]'
    }, {
        name: 'Pc',
        alias: 'Connector_Punctuation',
        bmp: '\x5F\u203F\u2040\u2054\uFE33\uFE34\uFE4D-\uFE4F\uFF3F'
    }, {
        name: 'Pd',
        alias: 'Dash_Punctuation',
        bmp: '\\x2D\u058A\u05BE\u1400\u1806\u2010-\u2015\u2E17\u2E1A\u2E3A\u2E3B\u2E40\u301C\u3030\u30A0\uFE31\uFE32\uFE58\uFE63\uFF0D'
    }, {
        name: 'Pe',
        alias: 'Close_Punctuation',
        bmp: '\\x29\\x5D\x7D\u0F3B\u0F3D\u169C\u2046\u207E\u208E\u2309\u230B\u232A\u2769\u276B\u276D\u276F\u2771\u2773\u2775\u27C6\u27E7\u27E9\u27EB\u27ED\u27EF\u2984\u2986\u2988\u298A\u298C\u298E\u2990\u2992\u2994\u2996\u2998\u29D9\u29DB\u29FD\u2E23\u2E25\u2E27\u2E29\u3009\u300B\u300D\u300F\u3011\u3015\u3017\u3019\u301B\u301E\u301F\uFD3E\uFE18\uFE36\uFE38\uFE3A\uFE3C\uFE3E\uFE40\uFE42\uFE44\uFE48\uFE5A\uFE5C\uFE5E\uFF09\uFF3D\uFF5D\uFF60\uFF63'
    }, {
        name: 'Pf',
        alias: 'Final_Punctuation',
        bmp: '\xBB\u2019\u201D\u203A\u2E03\u2E05\u2E0A\u2E0D\u2E1D\u2E21'
    }, {
        name: 'Pi',
        alias: 'Initial_Punctuation',
        bmp: '\xAB\u2018\u201B\u201C\u201F\u2039\u2E02\u2E04\u2E09\u2E0C\u2E1C\u2E20'
    }, {
        name: 'Po',
        alias: 'Other_Punctuation',
        bmp: '\x21-\x23\x25-\x27\\x2A\x2C\\x2E\x2F\x3A\x3B\\x3F\x40\\x5C\xA1\xA7\xB6\xB7\xBF\u037E\u0387\u055A-\u055F\u0589\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u166D\u166E\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u1805\u1807-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2016\u2017\u2020-\u2027\u2030-\u2038\u203B-\u203E\u2041-\u2043\u2047-\u2051\u2053\u2055-\u205E\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00\u2E01\u2E06-\u2E08\u2E0B\u2E0E-\u2E16\u2E18\u2E19\u2E1B\u2E1E\u2E1F\u2E2A-\u2E2E\u2E30-\u2E39\u2E3C-\u2E3F\u2E41\u2E43\u2E44\u3001-\u3003\u303D\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFE10-\uFE16\uFE19\uFE30\uFE45\uFE46\uFE49-\uFE4C\uFE50-\uFE52\uFE54-\uFE57\uFE5F-\uFE61\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF07\uFF0A\uFF0C\uFF0E\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3C\uFF61\uFF64\uFF65',
        astral: '\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD807[\uDC41-\uDC45\uDC70\uDC71]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]'
    }, {
        name: 'Ps',
        alias: 'Open_Punctuation',
        bmp: '\\x28\\x5B\\x7B\u0F3A\u0F3C\u169B\u201A\u201E\u2045\u207D\u208D\u2308\u230A\u2329\u2768\u276A\u276C\u276E\u2770\u2772\u2774\u27C5\u27E6\u27E8\u27EA\u27EC\u27EE\u2983\u2985\u2987\u2989\u298B\u298D\u298F\u2991\u2993\u2995\u2997\u29D8\u29DA\u29FC\u2E22\u2E24\u2E26\u2E28\u2E42\u3008\u300A\u300C\u300E\u3010\u3014\u3016\u3018\u301A\u301D\uFD3F\uFE17\uFE35\uFE37\uFE39\uFE3B\uFE3D\uFE3F\uFE41\uFE43\uFE47\uFE59\uFE5B\uFE5D\uFF08\uFF3B\uFF5B\uFF5F\uFF62'
    }, {
        name: 'S',
        alias: 'Symbol',
        bmp: '\\x24\\x2B\x3C-\x3E\\x5E\x60\\x7C\x7E\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20BE\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u23FE\u2400-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B98-\u2BB9\u2BBD-\u2BC8\u2BCA-\u2BD1\u2BEC-\u2BEF\u2CE5-\u2CEA\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u32FE\u3300-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uFB29\uFBB2-\uFBC1\uFDFC\uFDFD\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD',
        astral: '\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9B\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD83B[\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD10-\uDD2E\uDD30-\uDD6B\uDD70-\uDDAC\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED2\uDEE0-\uDEEC\uDEF0-\uDEF6\uDF00-\uDF73\uDF80-\uDFD4]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDD10-\uDD1E\uDD20-\uDD27\uDD30\uDD33-\uDD3E\uDD40-\uDD4B\uDD50-\uDD5E\uDD80-\uDD91\uDDC0]'
    }, {
        name: 'Sc',
        alias: 'Currency_Symbol',
        bmp: '\\x24\xA2-\xA5\u058F\u060B\u09F2\u09F3\u09FB\u0AF1\u0BF9\u0E3F\u17DB\u20A0-\u20BE\uA838\uFDFC\uFE69\uFF04\uFFE0\uFFE1\uFFE5\uFFE6'
    }, {
        name: 'Sk',
        alias: 'Modifier_Symbol',
        bmp: '\\x5E\x60\xA8\xAF\xB4\xB8\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u309B\u309C\uA700-\uA716\uA720\uA721\uA789\uA78A\uAB5B\uFBB2-\uFBC1\uFF3E\uFF40\uFFE3',
        astral: '\uD83C[\uDFFB-\uDFFF]'
    }, {
        name: 'Sm',
        alias: 'Math_Symbol',
        bmp: '\\x2B\x3C-\x3E\\x7C\x7E\xAC\xB1\xD7\xF7\u03F6\u0606-\u0608\u2044\u2052\u207A-\u207C\u208A-\u208C\u2118\u2140-\u2144\u214B\u2190-\u2194\u219A\u219B\u21A0\u21A3\u21A6\u21AE\u21CE\u21CF\u21D2\u21D4\u21F4-\u22FF\u2320\u2321\u237C\u239B-\u23B3\u23DC-\u23E1\u25B7\u25C1\u25F8-\u25FF\u266F\u27C0-\u27C4\u27C7-\u27E5\u27F0-\u27FF\u2900-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2AFF\u2B30-\u2B44\u2B47-\u2B4C\uFB29\uFE62\uFE64-\uFE66\uFF0B\uFF1C-\uFF1E\uFF5C\uFF5E\uFFE2\uFFE9-\uFFEC',
        astral: '\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD83B[\uDEF0\uDEF1]'
    }, {
        name: 'So',
        alias: 'Other_Symbol',
        bmp: '\xA6\xA9\xAE\xB0\u0482\u058D\u058E\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u09FA\u0B70\u0BF3-\u0BF8\u0BFA\u0C7F\u0D4F\u0D79\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116\u2117\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u214A\u214C\u214D\u214F\u218A\u218B\u2195-\u2199\u219C-\u219F\u21A1\u21A2\u21A4\u21A5\u21A7-\u21AD\u21AF-\u21CD\u21D0\u21D1\u21D3\u21D5-\u21F3\u2300-\u2307\u230C-\u231F\u2322-\u2328\u232B-\u237B\u237D-\u239A\u23B4-\u23DB\u23E2-\u23FE\u2400-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u25B6\u25B8-\u25C0\u25C2-\u25F7\u2600-\u266E\u2670-\u2767\u2794-\u27BF\u2800-\u28FF\u2B00-\u2B2F\u2B45\u2B46\u2B4D-\u2B73\u2B76-\u2B95\u2B98-\u2BB9\u2BBD-\u2BC8\u2BCA-\u2BD1\u2BEC-\u2BEF\u2CE5-\u2CEA\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u32FE\u3300-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA828-\uA82B\uA836\uA837\uA839\uAA77-\uAA79\uFDFD\uFFE4\uFFE8\uFFED\uFFEE\uFFFC\uFFFD',
        astral: '\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9B\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD10-\uDD2E\uDD30-\uDD6B\uDD70-\uDDAC\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDF00-\uDFFA]|\uD83D[\uDC00-\uDED2\uDEE0-\uDEEC\uDEF0-\uDEF6\uDF00-\uDF73\uDF80-\uDFD4]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDD10-\uDD1E\uDD20-\uDD27\uDD30\uDD33-\uDD3E\uDD40-\uDD4B\uDD50-\uDD5E\uDD80-\uDD91\uDDC0]'
    }, {
        name: 'Z',
        alias: 'Separator',
        bmp: '\x20\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000'
    }, {
        name: 'Zl',
        alias: 'Line_Separator',
        bmp: '\u2028'
    }, {
        name: 'Zp',
        alias: 'Paragraph_Separator',
        bmp: '\u2029'
    }, {
        name: 'Zs',
        alias: 'Space_Separator',
        bmp: '\x20\xA0\u1680\u2000-\u200A\u202F\u205F\u3000'
    }]);
}; // End of module


module.exports = exports['default'];
},{}],68:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

/*!
 * XRegExp Unicode Properties 
 * <xregexp.com>
 * Steven Levithan (c) 2012-2017 MIT License
 * Unicode data by Mathias Bynens <mathiasbynens.be>
 */

exports.default = function (XRegExp) {

    /**
     * Adds properties to meet the UTS #18 Level 1 RL1.2 requirements for Unicode regex support. See
     * <http://unicode.org/reports/tr18/#RL1.2>. Following are definitions of these properties from
     * UAX #44 <http://unicode.org/reports/tr44/>:
     *
     * - Alphabetic
     *   Characters with the Alphabetic property. Generated from: Lowercase + Uppercase + Lt + Lm +
     *   Lo + Nl + Other_Alphabetic.
     *
     * - Default_Ignorable_Code_Point
     *   For programmatic determination of default ignorable code points. New characters that should
     *   be ignored in rendering (unless explicitly supported) will be assigned in these ranges,
     *   permitting programs to correctly handle the default rendering of such characters when not
     *   otherwise supported.
     *
     * - Lowercase
     *   Characters with the Lowercase property. Generated from: Ll + Other_Lowercase.
     *
     * - Noncharacter_Code_Point
     *   Code points permanently reserved for internal use.
     *
     * - Uppercase
     *   Characters with the Uppercase property. Generated from: Lu + Other_Uppercase.
     *
     * - White_Space
     *   Spaces, separator characters and other control characters which should be treated by
     *   programming languages as "white space" for the purpose of parsing elements.
     *
     * The properties ASCII, Any, and Assigned are also included but are not defined in UAX #44. UTS
     * #18 RL1.2 additionally requires support for Unicode scripts and general categories. These are
     * included in XRegExp's Unicode Categories and Unicode Scripts addons.
     *
     * Token names are case insensitive, and any spaces, hyphens, and underscores are ignored.
     *
     * Uses Unicode 9.0.0.
     *
     * @requires XRegExp, Unicode Base
     */

    if (!XRegExp.addUnicodeData) {
        throw new ReferenceError('Unicode Base must be loaded before Unicode Properties');
    }

    var unicodeData = [{
        name: 'ASCII',
        bmp: '\0-\x7F'
    }, {
        name: 'Alphabetic',
        bmp: 'A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0345\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05B0-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0657\u0659-\u065F\u066E-\u06D3\u06D5-\u06DC\u06E1-\u06E8\u06ED-\u06EF\u06FA-\u06FC\u06FF\u0710-\u073F\u074D-\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0817\u081A-\u082C\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08DF\u08E3-\u08E9\u08F0-\u093B\u093D-\u094C\u094E-\u0950\u0955-\u0963\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C4\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09F0\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A42\u0A47\u0A48\u0A4B\u0A4C\u0A51\u0A59-\u0A5C\u0A5E\u0A70-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC5\u0AC7-\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0-\u0AE3\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D-\u0B44\u0B47\u0B48\u0B4B\u0B4C\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4C\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCC\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E46\u0E4D\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0ECD\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F71-\u0F81\u0F88-\u0F97\u0F99-\u0FBC\u1000-\u1036\u1038\u103B-\u103F\u1050-\u1062\u1065-\u1068\u106E-\u1086\u108E\u109C\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1713\u1720-\u1733\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17B3\u17B6-\u17C8\u17D7\u17DC\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u1938\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A1B\u1A20-\u1A5E\u1A61-\u1A74\u1AA7\u1B00-\u1B33\u1B35-\u1B43\u1B45-\u1B4B\u1B80-\u1BA9\u1BAC-\u1BAF\u1BBA-\u1BE5\u1BE7-\u1BF1\u1C00-\u1C35\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1D00-\u1DBF\u1DE7-\u1DF4\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u24B6-\u24E9\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA674-\uA67B\uA67F-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA827\uA840-\uA873\uA880-\uA8C3\uA8C5\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA92A\uA930-\uA952\uA960-\uA97C\uA980-\uA9B2\uA9B4-\uA9BF\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA60-\uAA76\uAA7A\uAA7E-\uAABE\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC',
        astral: '\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC45\uDC82-\uDCB8\uDCD0-\uDCE8\uDD00-\uDD32\uDD50-\uDD72\uDD76\uDD80-\uDDBF\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE34\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEE8\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D-\uDF44\uDF47\uDF48\uDF4B\uDF4C\uDF50\uDF57\uDF5D-\uDF63]|\uD805[\uDC00-\uDC41\uDC43-\uDC45\uDC47-\uDC4A\uDC80-\uDCC1\uDCC4\uDCC5\uDCC7\uDD80-\uDDB5\uDDB8-\uDDBE\uDDD8-\uDDDD\uDE00-\uDE3E\uDE40\uDE44\uDE80-\uDEB5\uDF00-\uDF19\uDF1D-\uDF2A]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC3E\uDC40\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF36\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9E]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD47]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD30-\uDD49\uDD50-\uDD69\uDD70-\uDD89]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]'
    }, {
        name: 'Any',
        isBmpLast: true,
        bmp: '\0-\uFFFF',
        astral: '[\uD800-\uDBFF][\uDC00-\uDFFF]'
    }, {
        name: 'Default_Ignorable_Code_Point',
        bmp: '\xAD\u034F\u061C\u115F\u1160\u17B4\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8',
        astral: '\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|[\uDB40-\uDB43][\uDC00-\uDFFF]'
    }, {
        name: 'Lowercase',
        bmp: 'a-z\xAA\xB5\xBA\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02B8\u02C0\u02C1\u02E0-\u02E4\u0345\u0371\u0373\u0377\u037A-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1C80-\u1C88\u1D00-\u1DBF\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u2071\u207F\u2090-\u209C\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2170-\u217F\u2184\u24D0-\u24E9\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7D\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B-\uA69D\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7F8-\uA7FA\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A',
        astral: '\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD83A[\uDD22-\uDD43]'
    }, {
        name: 'Noncharacter_Code_Point',
        bmp: '\uFDD0-\uFDEF\uFFFE\uFFFF',
        astral: '[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]'
    }, {
        name: 'Uppercase',
        bmp: 'A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2160-\u216F\u2183\u24B6-\u24CF\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AE\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A',
        astral: '\uD801[\uDC00-\uDC27\uDCB0-\uDCD3]|\uD803[\uDC80-\uDCB2]|\uD806[\uDCA0-\uDCBF]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD83A[\uDD00-\uDD21]|\uD83C[\uDD30-\uDD49\uDD50-\uDD69\uDD70-\uDD89]'
    }, {
        name: 'White_Space',
        bmp: '\x09-\x0D\x20\x85\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000'
    }];

    // Add non-generated data
    unicodeData.push({
        name: 'Assigned',
        // Since this is defined as the inverse of Unicode category Cn (Unassigned), the Unicode
        // Categories addon is required to use this property
        inverseOf: 'Cn'
    });

    XRegExp.addUnicodeData(unicodeData);
}; // End of module


module.exports = exports['default'];
},{}],69:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

/*!
 * XRegExp Unicode Scripts 
 * <xregexp.com>
 * Steven Levithan (c) 2010-2017 MIT License
 * Unicode data by Mathias Bynens <mathiasbynens.be>
 */

exports.default = function (XRegExp) {

    /**
     * Adds support for all Unicode scripts. E.g., `\p{Latin}`. Token names are case insensitive,
     * and any spaces, hyphens, and underscores are ignored.
     *
     * Uses Unicode 9.0.0.
     *
     * @requires XRegExp, Unicode Base
     */

    if (!XRegExp.addUnicodeData) {
        throw new ReferenceError('Unicode Base must be loaded before Unicode Scripts');
    }

    XRegExp.addUnicodeData([{
        name: 'Adlam',
        astral: '\uD83A[\uDD00-\uDD4A\uDD50-\uDD59\uDD5E\uDD5F]'
    }, {
        name: 'Ahom',
        astral: '\uD805[\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF3F]'
    }, {
        name: 'Anatolian_Hieroglyphs',
        astral: '\uD811[\uDC00-\uDE46]'
    }, {
        name: 'Arabic',
        bmp: '\u0600-\u0604\u0606-\u060B\u060D-\u061A\u061E\u0620-\u063F\u0641-\u064A\u0656-\u066F\u0671-\u06DC\u06DE-\u06FF\u0750-\u077F\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u08FF\uFB50-\uFBC1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFD\uFE70-\uFE74\uFE76-\uFEFC',
        astral: '\uD803[\uDE60-\uDE7E]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB\uDEF0\uDEF1]'
    }, {
        name: 'Armenian',
        bmp: '\u0531-\u0556\u0559-\u055F\u0561-\u0587\u058A\u058D-\u058F\uFB13-\uFB17'
    }, {
        name: 'Avestan',
        astral: '\uD802[\uDF00-\uDF35\uDF39-\uDF3F]'
    }, {
        name: 'Balinese',
        bmp: '\u1B00-\u1B4B\u1B50-\u1B7C'
    }, {
        name: 'Bamum',
        bmp: '\uA6A0-\uA6F7',
        astral: '\uD81A[\uDC00-\uDE38]'
    }, {
        name: 'Bassa_Vah',
        astral: '\uD81A[\uDED0-\uDEED\uDEF0-\uDEF5]'
    }, {
        name: 'Batak',
        bmp: '\u1BC0-\u1BF3\u1BFC-\u1BFF'
    }, {
        name: 'Bengali',
        bmp: '\u0980-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09FB'
    }, {
        name: 'Bhaiksuki',
        astral: '\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC45\uDC50-\uDC6C]'
    }, {
        name: 'Bopomofo',
        bmp: '\u02EA\u02EB\u3105-\u312D\u31A0-\u31BA'
    }, {
        name: 'Brahmi',
        astral: '\uD804[\uDC00-\uDC4D\uDC52-\uDC6F\uDC7F]'
    }, {
        name: 'Braille',
        bmp: '\u2800-\u28FF'
    }, {
        name: 'Buginese',
        bmp: '\u1A00-\u1A1B\u1A1E\u1A1F'
    }, {
        name: 'Buhid',
        bmp: '\u1740-\u1753'
    }, {
        name: 'Canadian_Aboriginal',
        bmp: '\u1400-\u167F\u18B0-\u18F5'
    }, {
        name: 'Carian',
        astral: '\uD800[\uDEA0-\uDED0]'
    }, {
        name: 'Caucasian_Albanian',
        astral: '\uD801[\uDD30-\uDD63\uDD6F]'
    }, {
        name: 'Chakma',
        astral: '\uD804[\uDD00-\uDD34\uDD36-\uDD43]'
    }, {
        name: 'Cham',
        bmp: '\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA5C-\uAA5F'
    }, {
        name: 'Cherokee',
        bmp: '\u13A0-\u13F5\u13F8-\u13FD\uAB70-\uABBF'
    }, {
        name: 'Common',
        bmp: '\0-\x40\\x5B-\x60\\x7B-\xA9\xAB-\xB9\xBB-\xBF\xD7\xF7\u02B9-\u02DF\u02E5-\u02E9\u02EC-\u02FF\u0374\u037E\u0385\u0387\u0589\u0605\u060C\u061B\u061C\u061F\u0640\u06DD\u08E2\u0964\u0965\u0E3F\u0FD5-\u0FD8\u10FB\u16EB-\u16ED\u1735\u1736\u1802\u1803\u1805\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u2000-\u200B\u200E-\u2064\u2066-\u2070\u2074-\u207E\u2080-\u208E\u20A0-\u20BE\u2100-\u2125\u2127-\u2129\u212C-\u2131\u2133-\u214D\u214F-\u215F\u2189-\u218B\u2190-\u23FE\u2400-\u2426\u2440-\u244A\u2460-\u27FF\u2900-\u2B73\u2B76-\u2B95\u2B98-\u2BB9\u2BBD-\u2BC8\u2BCA-\u2BD1\u2BEC-\u2BEF\u2E00-\u2E44\u2FF0-\u2FFB\u3000-\u3004\u3006\u3008-\u3020\u3030-\u3037\u303C-\u303F\u309B\u309C\u30A0\u30FB\u30FC\u3190-\u319F\u31C0-\u31E3\u3220-\u325F\u327F-\u32CF\u3358-\u33FF\u4DC0-\u4DFF\uA700-\uA721\uA788-\uA78A\uA830-\uA839\uA92E\uA9CF\uAB5B\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFEFF\uFF01-\uFF20\uFF3B-\uFF40\uFF5B-\uFF65\uFF70\uFF9E\uFF9F\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD',
        astral: '\uD800[\uDD00-\uDD02\uDD07-\uDD33\uDD37-\uDD3F\uDD90-\uDD9B\uDDD0-\uDDFC\uDEE1-\uDEFB]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD66\uDD6A-\uDD7A\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDF00-\uDF56\uDF60-\uDF71]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDFCB\uDFCE-\uDFFF]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD00-\uDD0C\uDD10-\uDD2E\uDD30-\uDD6B\uDD70-\uDDAC\uDDE6-\uDDFF\uDE01\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED2\uDEE0-\uDEEC\uDEF0-\uDEF6\uDF00-\uDF73\uDF80-\uDFD4]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDD10-\uDD1E\uDD20-\uDD27\uDD30\uDD33-\uDD3E\uDD40-\uDD4B\uDD50-\uDD5E\uDD80-\uDD91\uDDC0]|\uDB40[\uDC01\uDC20-\uDC7F]'
    }, {
        name: 'Coptic',
        bmp: '\u03E2-\u03EF\u2C80-\u2CF3\u2CF9-\u2CFF'
    }, {
        name: 'Cuneiform',
        astral: '\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC70-\uDC74\uDC80-\uDD43]'
    }, {
        name: 'Cypriot',
        astral: '\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F]'
    }, {
        name: 'Cyrillic',
        bmp: '\u0400-\u0484\u0487-\u052F\u1C80-\u1C88\u1D2B\u1D78\u2DE0-\u2DFF\uA640-\uA69F\uFE2E\uFE2F'
    }, {
        name: 'Deseret',
        astral: '\uD801[\uDC00-\uDC4F]'
    }, {
        name: 'Devanagari',
        bmp: '\u0900-\u0950\u0953-\u0963\u0966-\u097F\uA8E0-\uA8FD'
    }, {
        name: 'Duployan',
        astral: '\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9C-\uDC9F]'
    }, {
        name: 'Egyptian_Hieroglyphs',
        astral: '\uD80C[\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]'
    }, {
        name: 'Elbasan',
        astral: '\uD801[\uDD00-\uDD27]'
    }, {
        name: 'Ethiopic',
        bmp: '\u1200-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u137C\u1380-\u1399\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E'
    }, {
        name: 'Georgian',
        bmp: '\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u10FF\u2D00-\u2D25\u2D27\u2D2D'
    }, {
        name: 'Glagolitic',
        bmp: '\u2C00-\u2C2E\u2C30-\u2C5E',
        astral: '\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]'
    }, {
        name: 'Gothic',
        astral: '\uD800[\uDF30-\uDF4A]'
    }, {
        name: 'Grantha',
        astral: '\uD804[\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]'
    }, {
        name: 'Greek',
        bmp: '\u0370-\u0373\u0375-\u0377\u037A-\u037D\u037F\u0384\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03E1\u03F0-\u03FF\u1D26-\u1D2A\u1D5D-\u1D61\u1D66-\u1D6A\u1DBF\u1F00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FC4\u1FC6-\u1FD3\u1FD6-\u1FDB\u1FDD-\u1FEF\u1FF2-\u1FF4\u1FF6-\u1FFE\u2126\uAB65',
        astral: '\uD800[\uDD40-\uDD8E\uDDA0]|\uD834[\uDE00-\uDE45]'
    }, {
        name: 'Gujarati',
        bmp: '\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AF1\u0AF9'
    }, {
        name: 'Gurmukhi',
        bmp: '\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75'
    }, {
        name: 'Han',
        bmp: '\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u3005\u3007\u3021-\u3029\u3038-\u303B\u3400-\u4DB5\u4E00-\u9FD5\uF900-\uFA6D\uFA70-\uFAD9',
        astral: '[\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]'
    }, {
        name: 'Hangul',
        bmp: '\u1100-\u11FF\u302E\u302F\u3131-\u318E\u3200-\u321E\u3260-\u327E\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC'
    }, {
        name: 'Hanunoo',
        bmp: '\u1720-\u1734'
    }, {
        name: 'Hatran',
        astral: '\uD802[\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDCFF]'
    }, {
        name: 'Hebrew',
        bmp: '\u0591-\u05C7\u05D0-\u05EA\u05F0-\u05F4\uFB1D-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFB4F'
    }, {
        name: 'Hiragana',
        bmp: '\u3041-\u3096\u309D-\u309F',
        astral: '\uD82C\uDC01|\uD83C\uDE00'
    }, {
        name: 'Imperial_Aramaic',
        astral: '\uD802[\uDC40-\uDC55\uDC57-\uDC5F]'
    }, {
        name: 'Inherited',
        bmp: '\u0300-\u036F\u0485\u0486\u064B-\u0655\u0670\u0951\u0952\u1AB0-\u1ABE\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u200C\u200D\u20D0-\u20F0\u302A-\u302D\u3099\u309A\uFE00-\uFE0F\uFE20-\uFE2D',
        astral: '\uD800[\uDDFD\uDEE0]|\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD]|\uDB40[\uDD00-\uDDEF]'
    }, {
        name: 'Inscriptional_Pahlavi',
        astral: '\uD802[\uDF60-\uDF72\uDF78-\uDF7F]'
    }, {
        name: 'Inscriptional_Parthian',
        astral: '\uD802[\uDF40-\uDF55\uDF58-\uDF5F]'
    }, {
        name: 'Javanese',
        bmp: '\uA980-\uA9CD\uA9D0-\uA9D9\uA9DE\uA9DF'
    }, {
        name: 'Kaithi',
        astral: '\uD804[\uDC80-\uDCC1]'
    }, {
        name: 'Kannada',
        bmp: '\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2'
    }, {
        name: 'Katakana',
        bmp: '\u30A1-\u30FA\u30FD-\u30FF\u31F0-\u31FF\u32D0-\u32FE\u3300-\u3357\uFF66-\uFF6F\uFF71-\uFF9D',
        astral: '\uD82C\uDC00'
    }, {
        name: 'Kayah_Li',
        bmp: '\uA900-\uA92D\uA92F'
    }, {
        name: 'Kharoshthi',
        astral: '\uD802[\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F-\uDE47\uDE50-\uDE58]'
    }, {
        name: 'Khmer',
        bmp: '\u1780-\u17DD\u17E0-\u17E9\u17F0-\u17F9\u19E0-\u19FF'
    }, {
        name: 'Khojki',
        astral: '\uD804[\uDE00-\uDE11\uDE13-\uDE3E]'
    }, {
        name: 'Khudawadi',
        astral: '\uD804[\uDEB0-\uDEEA\uDEF0-\uDEF9]'
    }, {
        name: 'Lao',
        bmp: '\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF'
    }, {
        name: 'Latin',
        bmp: 'A-Za-z\xAA\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02E0-\u02E4\u1D00-\u1D25\u1D2C-\u1D5C\u1D62-\u1D65\u1D6B-\u1D77\u1D79-\u1DBE\u1E00-\u1EFF\u2071\u207F\u2090-\u209C\u212A\u212B\u2132\u214E\u2160-\u2188\u2C60-\u2C7F\uA722-\uA787\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA7FF\uAB30-\uAB5A\uAB5C-\uAB64\uFB00-\uFB06\uFF21-\uFF3A\uFF41-\uFF5A'
    }, {
        name: 'Lepcha',
        bmp: '\u1C00-\u1C37\u1C3B-\u1C49\u1C4D-\u1C4F'
    }, {
        name: 'Limbu',
        bmp: '\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1940\u1944-\u194F'
    }, {
        name: 'Linear_A',
        astral: '\uD801[\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]'
    }, {
        name: 'Linear_B',
        astral: '\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA]'
    }, {
        name: 'Lisu',
        bmp: '\uA4D0-\uA4FF'
    }, {
        name: 'Lycian',
        astral: '\uD800[\uDE80-\uDE9C]'
    }, {
        name: 'Lydian',
        astral: '\uD802[\uDD20-\uDD39\uDD3F]'
    }, {
        name: 'Mahajani',
        astral: '\uD804[\uDD50-\uDD76]'
    }, {
        name: 'Malayalam',
        bmp: '\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4F\u0D54-\u0D63\u0D66-\u0D7F'
    }, {
        name: 'Mandaic',
        bmp: '\u0840-\u085B\u085E'
    }, {
        name: 'Manichaean',
        astral: '\uD802[\uDEC0-\uDEE6\uDEEB-\uDEF6]'
    }, {
        name: 'Marchen',
        astral: '\uD807[\uDC70-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]'
    }, {
        name: 'Meetei_Mayek',
        bmp: '\uAAE0-\uAAF6\uABC0-\uABED\uABF0-\uABF9'
    }, {
        name: 'Mende_Kikakui',
        astral: '\uD83A[\uDC00-\uDCC4\uDCC7-\uDCD6]'
    }, {
        name: 'Meroitic_Cursive',
        astral: '\uD802[\uDDA0-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDDFF]'
    }, {
        name: 'Meroitic_Hieroglyphs',
        astral: '\uD802[\uDD80-\uDD9F]'
    }, {
        name: 'Miao',
        astral: '\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]'
    }, {
        name: 'Modi',
        astral: '\uD805[\uDE00-\uDE44\uDE50-\uDE59]'
    }, {
        name: 'Mongolian',
        bmp: '\u1800\u1801\u1804\u1806-\u180E\u1810-\u1819\u1820-\u1877\u1880-\u18AA',
        astral: '\uD805[\uDE60-\uDE6C]'
    }, {
        name: 'Mro',
        astral: '\uD81A[\uDE40-\uDE5E\uDE60-\uDE69\uDE6E\uDE6F]'
    }, {
        name: 'Multani',
        astral: '\uD804[\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA9]'
    }, {
        name: 'Myanmar',
        bmp: '\u1000-\u109F\uA9E0-\uA9FE\uAA60-\uAA7F'
    }, {
        name: 'Nabataean',
        astral: '\uD802[\uDC80-\uDC9E\uDCA7-\uDCAF]'
    }, {
        name: 'New_Tai_Lue',
        bmp: '\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u19DE\u19DF'
    }, {
        name: 'Newa',
        astral: '\uD805[\uDC00-\uDC59\uDC5B\uDC5D]'
    }, {
        name: 'Nko',
        bmp: '\u07C0-\u07FA'
    }, {
        name: 'Ogham',
        bmp: '\u1680-\u169C'
    }, {
        name: 'Ol_Chiki',
        bmp: '\u1C50-\u1C7F'
    }, {
        name: 'Old_Hungarian',
        astral: '\uD803[\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDCFF]'
    }, {
        name: 'Old_Italic',
        astral: '\uD800[\uDF00-\uDF23]'
    }, {
        name: 'Old_North_Arabian',
        astral: '\uD802[\uDE80-\uDE9F]'
    }, {
        name: 'Old_Permic',
        astral: '\uD800[\uDF50-\uDF7A]'
    }, {
        name: 'Old_Persian',
        astral: '\uD800[\uDFA0-\uDFC3\uDFC8-\uDFD5]'
    }, {
        name: 'Old_South_Arabian',
        astral: '\uD802[\uDE60-\uDE7F]'
    }, {
        name: 'Old_Turkic',
        astral: '\uD803[\uDC00-\uDC48]'
    }, {
        name: 'Oriya',
        bmp: '\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B77'
    }, {
        name: 'Osage',
        astral: '\uD801[\uDCB0-\uDCD3\uDCD8-\uDCFB]'
    }, {
        name: 'Osmanya',
        astral: '\uD801[\uDC80-\uDC9D\uDCA0-\uDCA9]'
    }, {
        name: 'Pahawh_Hmong',
        astral: '\uD81A[\uDF00-\uDF45\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]'
    }, {
        name: 'Palmyrene',
        astral: '\uD802[\uDC60-\uDC7F]'
    }, {
        name: 'Pau_Cin_Hau',
        astral: '\uD806[\uDEC0-\uDEF8]'
    }, {
        name: 'Phags_Pa',
        bmp: '\uA840-\uA877'
    }, {
        name: 'Phoenician',
        astral: '\uD802[\uDD00-\uDD1B\uDD1F]'
    }, {
        name: 'Psalter_Pahlavi',
        astral: '\uD802[\uDF80-\uDF91\uDF99-\uDF9C\uDFA9-\uDFAF]'
    }, {
        name: 'Rejang',
        bmp: '\uA930-\uA953\uA95F'
    }, {
        name: 'Runic',
        bmp: '\u16A0-\u16EA\u16EE-\u16F8'
    }, {
        name: 'Samaritan',
        bmp: '\u0800-\u082D\u0830-\u083E'
    }, {
        name: 'Saurashtra',
        bmp: '\uA880-\uA8C5\uA8CE-\uA8D9'
    }, {
        name: 'Sharada',
        astral: '\uD804[\uDD80-\uDDCD\uDDD0-\uDDDF]'
    }, {
        name: 'Shavian',
        astral: '\uD801[\uDC50-\uDC7F]'
    }, {
        name: 'Siddham',
        astral: '\uD805[\uDD80-\uDDB5\uDDB8-\uDDDD]'
    }, {
        name: 'SignWriting',
        astral: '\uD836[\uDC00-\uDE8B\uDE9B-\uDE9F\uDEA1-\uDEAF]'
    }, {
        name: 'Sinhala',
        bmp: '\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4',
        astral: '\uD804[\uDDE1-\uDDF4]'
    }, {
        name: 'Sora_Sompeng',
        astral: '\uD804[\uDCD0-\uDCE8\uDCF0-\uDCF9]'
    }, {
        name: 'Sundanese',
        bmp: '\u1B80-\u1BBF\u1CC0-\u1CC7'
    }, {
        name: 'Syloti_Nagri',
        bmp: '\uA800-\uA82B'
    }, {
        name: 'Syriac',
        bmp: '\u0700-\u070D\u070F-\u074A\u074D-\u074F'
    }, {
        name: 'Tagalog',
        bmp: '\u1700-\u170C\u170E-\u1714'
    }, {
        name: 'Tagbanwa',
        bmp: '\u1760-\u176C\u176E-\u1770\u1772\u1773'
    }, {
        name: 'Tai_Le',
        bmp: '\u1950-\u196D\u1970-\u1974'
    }, {
        name: 'Tai_Tham',
        bmp: '\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD'
    }, {
        name: 'Tai_Viet',
        bmp: '\uAA80-\uAAC2\uAADB-\uAADF'
    }, {
        name: 'Takri',
        astral: '\uD805[\uDE80-\uDEB7\uDEC0-\uDEC9]'
    }, {
        name: 'Tamil',
        bmp: '\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BFA'
    }, {
        name: 'Tangut',
        astral: '\uD81B\uDFE0|[\uD81C-\uD820][\uDC00-\uDFFF]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]'
    }, {
        name: 'Telugu',
        bmp: '\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C78-\u0C7F'
    }, {
        name: 'Thaana',
        bmp: '\u0780-\u07B1'
    }, {
        name: 'Thai',
        bmp: '\u0E01-\u0E3A\u0E40-\u0E5B'
    }, {
        name: 'Tibetan',
        bmp: '\u0F00-\u0F47\u0F49-\u0F6C\u0F71-\u0F97\u0F99-\u0FBC\u0FBE-\u0FCC\u0FCE-\u0FD4\u0FD9\u0FDA'
    }, {
        name: 'Tifinagh',
        bmp: '\u2D30-\u2D67\u2D6F\u2D70\u2D7F'
    }, {
        name: 'Tirhuta',
        astral: '\uD805[\uDC80-\uDCC7\uDCD0-\uDCD9]'
    }, {
        name: 'Ugaritic',
        astral: '\uD800[\uDF80-\uDF9D\uDF9F]'
    }, {
        name: 'Vai',
        bmp: '\uA500-\uA62B'
    }, {
        name: 'Warang_Citi',
        astral: '\uD806[\uDCA0-\uDCF2\uDCFF]'
    }, {
        name: 'Yi',
        bmp: '\uA000-\uA48C\uA490-\uA4C6'
    }]);
}; // End of module


module.exports = exports['default'];
},{}],70:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _xregexp = require('./xregexp');

var _xregexp2 = _interopRequireDefault(_xregexp);

var _build = require('./addons/build');

var _build2 = _interopRequireDefault(_build);

var _matchrecursive = require('./addons/matchrecursive');

var _matchrecursive2 = _interopRequireDefault(_matchrecursive);

var _unicodeBase = require('./addons/unicode-base');

var _unicodeBase2 = _interopRequireDefault(_unicodeBase);

var _unicodeBlocks = require('./addons/unicode-blocks');

var _unicodeBlocks2 = _interopRequireDefault(_unicodeBlocks);

var _unicodeCategories = require('./addons/unicode-categories');

var _unicodeCategories2 = _interopRequireDefault(_unicodeCategories);

var _unicodeProperties = require('./addons/unicode-properties');

var _unicodeProperties2 = _interopRequireDefault(_unicodeProperties);

var _unicodeScripts = require('./addons/unicode-scripts');

var _unicodeScripts2 = _interopRequireDefault(_unicodeScripts);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _build2.default)(_xregexp2.default);
(0, _matchrecursive2.default)(_xregexp2.default);
(0, _unicodeBase2.default)(_xregexp2.default);
(0, _unicodeBlocks2.default)(_xregexp2.default);
(0, _unicodeCategories2.default)(_xregexp2.default);
(0, _unicodeProperties2.default)(_xregexp2.default);
(0, _unicodeScripts2.default)(_xregexp2.default);

exports.default = _xregexp2.default;
module.exports = exports['default'];
},{"./addons/build":63,"./addons/matchrecursive":64,"./addons/unicode-base":65,"./addons/unicode-blocks":66,"./addons/unicode-categories":67,"./addons/unicode-properties":68,"./addons/unicode-scripts":69,"./xregexp":71}],71:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
/*!
 * XRegExp
 * <xregexp.com>
 * Steven Levithan (c) 2007-2017 MIT License
 */

/**
 * XRegExp provides augmented, extensible regular expressions. You get additional regex syntax and
 * flags, beyond what browsers support natively. XRegExp is also a regex utility belt with tools to
 * make your client-side grepping simpler and more powerful, while freeing you from related
 * cross-browser inconsistencies.
 */

// ==--------------------------==
// Private stuff
// ==--------------------------==

// Property name used for extended regex instance data
var REGEX_DATA = 'xregexp';
// Optional features that can be installed and uninstalled
var features = {
    astral: false,
    natives: false
};
// Native methods to use and restore ('native' is an ES3 reserved keyword)
var nativ = {
    exec: RegExp.prototype.exec,
    test: RegExp.prototype.test,
    match: String.prototype.match,
    replace: String.prototype.replace,
    split: String.prototype.split
};
// Storage for fixed/extended native methods
var fixed = {};
// Storage for regexes cached by `XRegExp.cache`
var regexCache = {};
// Storage for pattern details cached by the `XRegExp` constructor
var patternCache = {};
// Storage for regex syntax tokens added internally or by `XRegExp.addToken`
var tokens = [];
// Token scopes
var defaultScope = 'default';
var classScope = 'class';
// Regexes that match native regex syntax, including octals
var nativeTokens = {
    // Any native multicharacter token in default scope, or any single character
    'default': /\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|\(\?(?:[:=!]|<[=!])|[?*+]\?|{\d+(?:,\d*)?}\??|[\s\S]/,
    // Any native multicharacter token in character class scope, or any single character
    'class': /\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|[\s\S]/
};
// Any backreference or dollar-prefixed character in replacement strings
var replacementToken = /\$(?:{([\w$]+)}|<([\w$]+)>|(\d\d?|[\s\S]))/g;
// Check for correct `exec` handling of nonparticipating capturing groups
var correctExecNpcg = nativ.exec.call(/()??/, '')[1] === undefined;
// Check for ES6 `flags` prop support
var hasFlagsProp = /x/.flags !== undefined;
// Shortcut to `Object.prototype.toString`
var toString = {}.toString;

function hasNativeFlag(flag) {
    // Can't check based on the presence of properties/getters since browsers might support such
    // properties even when they don't support the corresponding flag in regex construction (tested
    // in Chrome 48, where `'unicode' in /x/` is true but trying to construct a regex with flag `u`
    // throws an error)
    var isSupported = true;
    try {
        // Can't use regex literals for testing even in a `try` because regex literals with
        // unsupported flags cause a compilation error in IE
        new RegExp('', flag);
    } catch (exception) {
        isSupported = false;
    }
    return isSupported;
}
// Check for ES6 `u` flag support
var hasNativeU = hasNativeFlag('u');
// Check for ES6 `y` flag support
var hasNativeY = hasNativeFlag('y');
// Tracker for known flags, including addon flags
var registeredFlags = {
    g: true,
    i: true,
    m: true,
    u: hasNativeU,
    y: hasNativeY
};

/**
 * Attaches extended data and `XRegExp.prototype` properties to a regex object.
 *
 * @private
 * @param {RegExp} regex Regex to augment.
 * @param {Array} captureNames Array with capture names, or `null`.
 * @param {String} xSource XRegExp pattern used to generate `regex`, or `null` if N/A.
 * @param {String} xFlags XRegExp flags used to generate `regex`, or `null` if N/A.
 * @param {Boolean} [isNotNative=false] Whether the regex requires some XRegExp specific feature.
 * @param {Boolean} [isInternalOnly=false] Whether the regex will be used only for internal
 *   operations, and never exposed to users. For internal-only regexes, we can improve perf by
 *   skipping some operations like attaching `XRegExp.prototype` properties.
 * @returns {RegExp} Augmented regex.
 */
function augment(regex, captureNames, xSource, xFlags, isNotNative, isInternalOnly) {
    var p = void 0;

    regex[REGEX_DATA] = {
        captureNames: captureNames
    };

    if (isInternalOnly) {
        return regex;
    }

    // Can't auto-inherit these since the XRegExp constructor returns a nonprimitive value
    if (regex.__proto__) {
        regex.__proto__ = XRegExp.prototype;
    } else {
        for (p in XRegExp.prototype) {
            // An `XRegExp.prototype.hasOwnProperty(p)` check wouldn't be worth it here, since this
            // is performance sensitive, and enumerable `Object.prototype` or `RegExp.prototype`
            // extensions exist on `regex.prototype` anyway
            regex[p] = XRegExp.prototype[p];
        }
    }

    regex[REGEX_DATA].source = xSource;
    // Emulate the ES6 `flags` prop by ensuring flags are in alphabetical order
    regex[REGEX_DATA].flags = xFlags ? xFlags.split('').sort().join('') : xFlags;

    // signal whether the given regex is a standard RegExp one ('native') or does require
    // one or more XRegExp specific features:
    regex[REGEX_DATA].isNative = !isNotNative;

    return regex;
}

/**
 * Removes any duplicate characters from the provided string.
 *
 * @private
 * @param {String} str String to remove duplicate characters from.
 * @returns {String} String with any duplicate characters removed.
 */
function clipDuplicates(str) {
    return nativ.replace.call(str, /([\s\S])(?=[\s\S]*\1)/g, '');
}

/**
 * Copies a regex object while preserving extended data and augmenting with `XRegExp.prototype`
 * properties. The copy has a fresh `lastIndex` property (set to zero). Allows adding and removing
 * flags g and y while copying the regex.
 *
 * @private
 * @param {RegExp} regex Regex to copy.
 * @param {Object} [options] Options object with optional properties:
 *   - `addG` {Boolean} Add flag g while copying the regex.
 *   - `addY` {Boolean} Add flag y while copying the regex.
 *   - `removeG` {Boolean} Remove flag g while copying the regex.
 *   - `removeY` {Boolean} Remove flag y while copying the regex.
 *   - `isInternalOnly` {Boolean} Whether the copied regex will be used only for internal
 *     operations, and never exposed to users. For internal-only regexes, we can improve perf by
 *     skipping some operations like attaching `XRegExp.prototype` properties.
 *   - `source` {String} Overrides `<regex>.source`, for special cases.
 * @returns {RegExp} Copy of the provided regex, possibly with modified flags.
 */
function copyRegex(regex, options) {
    if (!XRegExp.isRegExp(regex)) {
        throw new TypeError('Type RegExp expected');
    }

    var xData = regex[REGEX_DATA] || {};
    var flags = getNativeFlags(regex);
    var flagsToAdd = '';
    var flagsToRemove = '';
    var xregexpSource = null;
    var xregexpFlags = null;

    options = options || {};

    if (options.removeG) {
        flagsToRemove += 'g';
    }
    if (options.removeY) {
        flagsToRemove += 'y';
    }
    if (flagsToRemove) {
        flags = nativ.replace.call(flags, new RegExp('[' + flagsToRemove + ']+', 'g'), '');
    }

    if (options.addG) {
        flagsToAdd += 'g';
    }
    if (options.addY) {
        flagsToAdd += 'y';
    }
    if (flagsToAdd) {
        flags = clipDuplicates(flags + flagsToAdd);
    }

    if (!options.isInternalOnly) {
        if (xData.source !== undefined) {
            xregexpSource = xData.source;
        }
        // null or undefined; don't want to add to `flags` if the previous value was null, since
        // that indicates we're not tracking original precompilation flags
        if (xData.flags != null) {
            // Flags are only added for non-internal regexes by `XRegExp.globalize`. Flags are never
            // removed for non-internal regexes, so don't need to handle it
            xregexpFlags = flagsToAdd ? clipDuplicates(xData.flags + flagsToAdd) : xData.flags;
        }
    }

    // Augment with `XRegExp.prototype` properties, but use the native `RegExp` constructor to avoid
    // searching for special tokens. That would be wrong for regexes constructed by `RegExp`, and
    // unnecessary for regexes constructed by `XRegExp` because the regex has already undergone the
    // translation to native regex syntax
    var hasCaptureNames = hasNamedCapture(regex);

    // Strip all but custom flags, except the 'A' flag
    var customFlags = flags;
    if (xregexpFlags) {
        customFlags += xregexpFlags;
    }
    customFlags = nativ.replace.call(clipDuplicates(customFlags), /[Agimuy]+/g, '');
    regex = augment(new RegExp(options.source || regex.source, flags), hasCaptureNames ? xData.captureNames.slice(0) : null, xregexpSource, xregexpFlags, customFlags || hasCaptureNames || regex.source !== xregexpSource, options.isInternalOnly);

    return regex;
}

/**
 * Converts hexadecimal to decimal.
 *
 * @private
 * @param {String} hex
 * @returns {Number}
 */
function dec(hex) {
    return parseInt(hex, 16);
}

/**
 * Returns a pattern that can be used in a native RegExp in place of an ignorable token such as an
 * inline comment or whitespace with flag x. This is used directly as a token handler function
 * passed to `XRegExp.addToken`.
 *
 * @private
 * @param {String} match Match arg of `XRegExp.addToken` handler
 * @param {String} scope Scope arg of `XRegExp.addToken` handler
 * @param {String} flags Flags arg of `XRegExp.addToken` handler
 * @returns {String} Either '' or '(?:)', depending on which is needed in the context of the match.
 */
function getContextualTokenSeparator(match, scope, flags) {
    if (
    // No need to separate tokens if at the beginning or end of a group
    match.input[match.index - 1] === '(' || match.input[match.index + match[0].length] === ')' ||
    // No need to separate tokens if at the beginning of a non-capturing group or lookahead
    match.input.slice(match.index - 3, 3).match(/\(\?[:=!]/) ||
    // No need to separate tokens if before or after a `|`
    match.input[match.index - 1] === '|' || match.input[match.index + match[0].length] === '|' ||
    // No need to separate tokens if at the beginning or end of the pattern
    match.input[match.index - 1] === undefined || match.input[match.index + match[0].length] === undefined ||
    // Avoid separating tokens when the following token is a quantifier
    isQuantifierNext(match.input, match.index + match[0].length, flags)) {
        return '';
    }
    // Keep tokens separated. This avoids e.g. inadvertedly changing `\1 1` or `\1(?#)1` to `\11`.
    // This also ensures all tokens remain as discrete atoms, e.g. it avoids converting the syntax
    // error `(? :` into `(?:`.
    return '(?:)';
}

/**
 * Returns native `RegExp` flags used by a regex object.
 *
 * @private
 * @param {RegExp} regex Regex to check.
 * @returns {String} Native flags in use.
 */
function getNativeFlags(regex) {
    return hasFlagsProp ? regex.flags :
    // Explicitly using `RegExp.prototype.toString` (rather than e.g. `String` or concatenation
    // with an empty string) allows this to continue working predictably when
    // `XRegExp.proptotype.toString` is overridden
    nativ.exec.call(/\/([a-z]*)$/i, RegExp.prototype.toString.call(regex))[1];
}

/**
 * Determines whether a regex has extended instance data used to track capture names.
 *
 * @private
 * @param {RegExp} regex Regex to check.
 * @returns {Boolean} Whether the regex uses named capture.
 */
function hasNamedCapture(regex) {
    return !!(regex[REGEX_DATA] && regex[REGEX_DATA].captureNames);
}

/**
 * Converts decimal to hexadecimal.
 *
 * @private
 * @param {Number|String} dec
 * @returns {String}
 */
function hex(dec) {
    return parseInt(dec, 10).toString(16);
}

/**
 * Checks whether the next nonignorable token after the specified position is a quantifier.
 *
 * @private
 * @param {String} pattern Pattern to search within.
 * @param {Number} pos Index in `pattern` to search at.
 * @param {String} flags Flags used by the pattern.
 * @returns {Boolean} Whether the next nonignorable token is a quantifier.
 */
function isQuantifierNext(pattern, pos, flags) {
    var inlineCommentPattern = '\\(\\?#[^)]*\\)';
    var lineCommentPattern = '#[^#\\n]*';
    var quantifierPattern = '[?*+]|{\\d+(?:,\\d*)?}';
    return nativ.test.call(flags.indexOf('x') !== -1 ?
    // Ignore any leading whitespace, line comments, and inline comments
    /^(?:\s|#[^#\n]*|\(\?#[^)]*\))*(?:[?*+]|{\d+(?:,\d*)?})/ :
    // Ignore any leading inline comments
    /^(?:\(\?#[^)]*\))*(?:[?*+]|{\d+(?:,\d*)?})/, pattern.slice(pos));
}

/**
 * Determines whether a value is of the specified type, by resolving its internal [[Class]].
 *
 * @private
 * @param {*} value Object to check.
 * @param {String} type Type to check for, in TitleCase.
 * @returns {Boolean} Whether the object matches the type.
 */
function isType(value, type) {
    return toString.call(value) === '[object ' + type + ']';
}

/**
 * Adds leading zeros if shorter than four characters. Used for fixed-length hexadecimal values.
 *
 * @private
 * @param {String} str
 * @returns {String}
 */
function pad4(str) {
    while (str.length < 4) {
        str = '0' + str;
    }
    return str;
}

/**
 * Checks for flag-related errors, and strips/applies flags in a leading mode modifier. Offloads
 * the flag preparation logic from the `XRegExp` constructor.
 *
 * @private
 * @param {String} pattern Regex pattern, possibly with a leading mode modifier.
 * @param {String} flags Any combination of flags.
 * @returns {Object} Object with properties `pattern` and `flags`.
 */
function prepareFlags(pattern, flags) {
    var i = void 0;

    // Recent browsers throw on duplicate flags, so copy this behavior for nonnative flags
    if (clipDuplicates(flags) !== flags) {
        throw new SyntaxError('Invalid duplicate regex flag ' + flags);
    }

    // Strip and apply a leading mode modifier with any combination of flags except g or y
    var output = nativ.replace.call(pattern, /^\(\?([\w$]+)\)/, function ($0, $1) {
        if (nativ.test.call(/[gy]/, $1)) {
            throw new SyntaxError('Cannot use flag g or y in mode modifier ' + $0);
        }
        // Allow duplicate flags within the mode modifier
        flags = clipDuplicates(flags + $1);
        return '';
    });

    // Throw on unknown native or nonnative flags
    for (i = 0; i < flags.length; ++i) {
        if (!registeredFlags[flags[i]]) {
            throw new SyntaxError('Unknown regex flag ' + flags[i]);
        }
    }

    return {
        pattern: output,
        flags: flags
    };
}

/**
 * Prepares an options object from the given value.
 *
 * @private
 * @param {String|Object} value Value to convert to an options object.
 * @returns {Object} Options object.
 */
function prepareOptions(value) {
    var options = {};

    if (isType(value, 'String')) {
        XRegExp.forEach(value, /[^\s,]+/, function (match) {
            options[match] = true;
        });

        return options;
    }

    return value;
}

/**
 * Registers a flag so it doesn't throw an 'unknown flag' error.
 *
 * @private
 * @param {String} flag Single-character flag to register.
 */
function registerFlag(flag) {
    if (!/^[\w$]$/.test(flag)) {
        throw new Error('Flag must be a single character A-Za-z0-9_$');
    }

    registeredFlags[flag] = true;
}

/**
 * Runs built-in and custom regex syntax tokens in reverse insertion order at the specified
 * position, until a match is found.
 *
 * @private
 * @param {String} pattern Original pattern from which an XRegExp object is being built.
 * @param {String} flags Flags being used to construct the regex.
 * @param {Number} pos Position to search for tokens within `pattern`.
 * @param {Number} scope Regex scope to apply: 'default' or 'class'.
 * @param {Object} context Context object to use for token handler functions.
 * @returns {Object} Object with properties `matchLength`, `output`, and `reparse`; or `null`.
 */
function runTokens(pattern, flags, pos, scope, context) {
    var i = tokens.length;
    var leadChar = pattern[pos];
    var result = null;
    var match = void 0;
    var t = void 0;

    // Run in reverse insertion order
    while (i--) {
        t = tokens[i];
        if (t.leadChar && t.leadChar !== leadChar || t.scope !== scope && t.scope !== 'all' || t.flag && !(flags.indexOf(t.flag) !== -1)) {
            continue;
        }

        match = XRegExp.exec(pattern, t.regex, pos, 'sticky');
        if (match) {
            result = {
                matchLength: match[0].length,
                output: t.handler.call(context, match, scope, flags),
                reparse: t.reparse
            };
            // Finished with token tests
            break;
        }
    }

    return result;
}

/**
 * Enables or disables implicit astral mode opt-in. When enabled, flag A is automatically added to
 * all new regexes created by XRegExp. This causes an error to be thrown when creating regexes if
 * the Unicode Base addon is not available, since flag A is registered by that addon.
 *
 * @private
 * @param {Boolean} on `true` to enable; `false` to disable.
 */
function setAstral(on) {
    features.astral = on;
}

/**
 * Enables or disables native method overrides.
 *
 * @private
 * @param {Boolean} on `true` to enable; `false` to disable.
 */
function setNatives(on) {
    RegExp.prototype.exec = (on ? fixed : nativ).exec;
    RegExp.prototype.test = (on ? fixed : nativ).test;
    String.prototype.match = (on ? fixed : nativ).match;
    String.prototype.replace = (on ? fixed : nativ).replace;
    String.prototype.split = (on ? fixed : nativ).split;

    features.natives = on;
}

/**
 * Returns the object, or throws an error if it is `null` or `undefined`. This is used to follow
 * the ES5 abstract operation `ToObject`.
 *
 * @private
 * @param {*} value Object to check and return.
 * @returns {*} The provided object.
 */
function toObject(value) {
    // null or undefined
    if (value == null) {
        throw new TypeError('Cannot convert null or undefined to object');
    }

    return value;
}

/**
 * Returns an Array that is the list of given patterns to be joined. Patterns can be provided as
 * regex objects or strings. Metacharacters are escaped in patterns provided as strings.
 * Backreferences in provided regex objects are automatically renumbered to work correctly. Native
 * flags used by provided regexes are ignored in favor of the `flags` argument.
 *
 * @private
 * @param {Array} patterns Regexes and strings to combine.
 * @returns {Array} modified patterns RegExps and Strings to be combined.
 */
function prepareJoin(patterns) {
    var numCaptures = 0;
    var numPriorCaptures = void 0;
    var captureNames = void 0;

    function rewrite(match, paren, backref) {
        var name = captureNames[numCaptures - numPriorCaptures];

        // Capturing group
        if (paren) {
            ++numCaptures;
            // If the current capture has a name, preserve the name
            if (name) {
                return '(?<' + name + '>';
            }
            // Backreference
        } else if (backref) {
            // Rewrite the backreference
            return '\\' + (+backref + numPriorCaptures);
        }

        return match;
    }

    if (!(isType(patterns, 'Array') && patterns.length)) {
        throw new TypeError('Must provide a nonempty array of patterns to merge');
    }

    var parts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*\]/g;
    var output = [];
    var pattern = void 0;
    for (var i = 0; i < patterns.length; ++i) {
        pattern = patterns[i];

        if (XRegExp.isRegExp(pattern)) {
            numPriorCaptures = numCaptures;
            captureNames = pattern[REGEX_DATA] && pattern[REGEX_DATA].captureNames || [];

            // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns are
            // independently valid; helps keep this simple. Named captures are put back
            output.push(nativ.replace.call(XRegExp(pattern.source).source, parts, rewrite));
        } else {
            output.push(XRegExp.escape(pattern));
        }
    }

    return output;
}

// ==--------------------------==
// Constructor
// ==--------------------------==

/**
 * Creates an extended regular expression object for matching text with a pattern. Differs from a
 * native regular expression in that additional syntax and flags are supported. The returned object
 * is in fact a native `RegExp` and works with all native methods.
 *
 * @class XRegExp
 * @constructor
 * @param {String|RegExp} pattern Regex pattern string, or an existing regex object to copy.
 * @param {String} [flags] Any combination of flags.
 *   Native flags:
 *     - `g` - global
 *     - `i` - ignore case
 *     - `m` - multiline anchors
 *     - `u` - unicode (ES6)
 *     - `y` - sticky (Firefox 3+, ES6)
 *   Additional XRegExp flags:
 *     - `n` - explicit capture
 *     - `s` - dot matches all (aka singleline)
 *     - `x` - free-spacing and line comments (aka extended)
 *     - `A` - astral (requires the Unicode Base addon)
 *   Flags cannot be provided when constructing one `RegExp` from another.
 * @returns {RegExp} Extended regular expression object.
 * @example
 *
 * // With named capture and flag x
 * XRegExp(`(?<year>  [0-9]{4} ) -?  # year
 *          (?<month> [0-9]{2} ) -?  # month
 *          (?<day>   [0-9]{2} )     # day`, 'x');
 *
 * // Providing a regex object copies it. Native regexes are recompiled using native (not XRegExp)
 * // syntax. Copies maintain extended data, are augmented with `XRegExp.prototype` properties, and
 * // have fresh `lastIndex` properties (set to zero).
 * XRegExp(/regex/);
 */
function XRegExp(pattern, flags) {
    if (XRegExp.isRegExp(pattern)) {
        if (flags !== undefined) {
            throw new TypeError('Cannot supply flags when copying a RegExp');
        }
        return copyRegex(pattern);
    }

    // Copy the argument behavior of `RegExp`
    pattern = pattern === undefined ? '' : String(pattern);
    flags = flags === undefined ? '' : String(flags);

    if (XRegExp.isInstalled('astral') && !(flags.indexOf('A') !== -1)) {
        // This causes an error to be thrown if the Unicode Base addon is not available
        flags += 'A';
    }

    if (!patternCache[pattern]) {
        patternCache[pattern] = {};
    }

    var appliedFlags = void 0;

    if (!patternCache[pattern][flags]) {
        var context = {
            hasNamedCapture: false,
            captureNames: []
        };
        var scope = defaultScope;
        var output = '';
        var pos = 0;
        var result = void 0;

        // Check for flag-related errors, and strip/apply flags in a leading mode modifier
        var applied = prepareFlags(pattern, flags);
        var appliedPattern = applied.pattern;

        appliedFlags = applied.flags;

        // Use XRegExp's tokens to translate the pattern to a native regex pattern.
        // `appliedPattern.length` may change on each iteration if tokens use `reparse`
        while (pos < appliedPattern.length) {
            do {
                // Check for custom tokens at the current position
                result = runTokens(appliedPattern, appliedFlags, pos, scope, context);
                // If the matched token used the `reparse` option, splice its output into the
                // pattern before running tokens again at the same position
                if (result && result.reparse) {
                    appliedPattern = appliedPattern.slice(0, pos) + result.output + appliedPattern.slice(pos + result.matchLength);
                }
            } while (result && result.reparse);

            if (result) {
                output += result.output;
                pos += result.matchLength || 1;
            } else {
                // Get the native token at the current position
                var token = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, 'sticky')[0];
                output += token;
                pos += token.length;
                if (token === '[' && scope === defaultScope) {
                    scope = classScope;
                } else if (token === ']' && scope === classScope) {
                    scope = defaultScope;
                }
            }
        }

        patternCache[pattern][flags] = {
            // Use basic cleanup to collapse repeated empty groups like `(?:)(?:)` to `(?:)`. Empty
            // groups are sometimes inserted during regex transpilation in order to keep tokens
            // separated. However, more than one empty group in a row is never needed.
            pattern: nativ.replace.call(output, /(?:\(\?:\))+/g, '(?:)'),
            // Strip all but native flags
            flags: nativ.replace.call(appliedFlags, /[^gimuy]+/g, ''),
            // `context.captureNames` has an item for each capturing group, even if unnamed
            captures: context.hasNamedCapture ? context.captureNames : null
        };
    }

    var generated = patternCache[pattern][flags];

    // Strip all but custom flags, except the 'A' flag
    var customFlags = flags;
    if (appliedFlags) {
        customFlags += appliedFlags;
    }
    customFlags = nativ.replace.call(clipDuplicates(customFlags), /[Agimuy]+/g, '');
    return augment(new RegExp(generated.pattern, generated.flags), generated.captures, pattern, flags, customFlags || generated.captures || generated.pattern !== pattern);
}

// Add `RegExp.prototype` to the prototype chain
XRegExp.prototype = /(?:)/;

// ==--------------------------==
// Public properties
// ==--------------------------==

/**
 * The XRegExp version number as a string containing three dot-separated parts. For example,
 * '2.0.0-beta-3'.
 *
 * @static
 * @memberOf XRegExp
 * @type String
 */
XRegExp.version = '3.2.0-22';

// ==--------------------------==
// Public methods
// ==--------------------------==

// Intentionally undocumented; used in tests and addons
XRegExp._clipDuplicates = clipDuplicates;
XRegExp._hasNativeFlag = hasNativeFlag;
XRegExp._registeredFlags = function _getRegisteredFlags() {
    return registeredFlags;
};
XRegExp._dec = dec;
XRegExp._hex = hex;
XRegExp._pad4 = pad4;

/**
 * Extends XRegExp syntax and allows custom flags. This is used internally and can be used to
 * create XRegExp addons. If more than one token can match the same string, the last added wins.
 *
 * @memberOf XRegExp
 * @param {RegExp} regex Regex object that matches the new token.
 * @param {Function} handler Function that returns a new pattern string (using native regex syntax)
 *   to replace the matched token within all future XRegExp regexes. Has access to persistent
 *   properties of the regex being built, through `this`. Invoked with three arguments:
 *   - The match array, with named backreference properties.
 *   - The regex scope where the match was found: 'default' or 'class'.
 *   - The flags used by the regex, including any flags in a leading mode modifier.
 *   The handler function becomes part of the XRegExp construction process, so be careful not to
 *   construct XRegExps within the function or you will trigger infinite recursion.
 * @param {Object} [options] Options object with optional properties:
 *   - `scope` {String} Scope where the token applies: 'default', 'class', or 'all'.
 *   - `flag` {String} Single-character flag that triggers the token. This also registers the
 *     flag, which prevents XRegExp from throwing an 'unknown flag' error when the flag is used.
 *   - `optionalFlags` {String} Any custom flags checked for within the token `handler` that are
 *     not required to trigger the token. This registers the flags, to prevent XRegExp from
 *     throwing an 'unknown flag' error when any of the flags are used.
 *   - `reparse` {Boolean} Whether the `handler` function's output should not be treated as
 *     final, and instead be reparseable by other tokens (including the current token). Allows
 *     token chaining or deferring.
 *   - `leadChar` {String} Single character that occurs at the beginning of any successful match
 *     of the token (not always applicable). This doesn't change the behavior of the token unless
 *     you provide an erroneous value. However, providing it can increase the token's performance
 *     since the token can be skipped at any positions where this character doesn't appear.
 * @example
 *
 * // Basic usage: Add \a for the ALERT control code
 * XRegExp.addToken(
 *   /\\a/,
 *   () => '\\x07',
 *   {scope: 'all'}
 * );
 * XRegExp('\\a[\\a-\\n]+').test('\x07\n\x07'); // -> true
 *
 * // Add the U (ungreedy) flag from PCRE and RE2, which reverses greedy and lazy quantifiers.
 * // Since `scope` is not specified, it uses 'default' (i.e., transformations apply outside of
 * // character classes only)
 * XRegExp.addToken(
 *   /([?*+]|{\d+(?:,\d*)?})(\??)/,
 *   (match) => `${match[1]}${match[2] ? '' : '?'}`,
 *   {flag: 'U'}
 * );
 * XRegExp('a+', 'U').exec('aaa')[0]; // -> 'a'
 * XRegExp('a+?', 'U').exec('aaa')[0]; // -> 'aaa'
 */
XRegExp.addToken = function (regex, handler, options) {
    options = options || {};
    var optionalFlags = options.optionalFlags;
    var i = void 0;

    if (options.flag) {
        registerFlag(options.flag);
    }

    if (optionalFlags) {
        optionalFlags = nativ.split.call(optionalFlags, '');
        for (i = 0; i < optionalFlags.length; ++i) {
            registerFlag(optionalFlags[i]);
        }
    }

    // Add to the private list of syntax tokens
    tokens.push({
        regex: copyRegex(regex, {
            addG: true,
            addY: hasNativeY,
            isInternalOnly: true
        }),
        handler: handler,
        scope: options.scope || defaultScope,
        flag: options.flag,
        reparse: options.reparse,
        leadChar: options.leadChar
    });

    // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and flags
    // might now produce different results
    XRegExp.cache.flush('patterns');
};

/**
 * Caches and returns the result of calling `XRegExp(pattern, flags)`. On any subsequent call with
 * the same pattern and flag combination, the cached copy of the regex is returned.
 *
 * @memberOf XRegExp
 * @param {String} pattern Regex pattern string.
 * @param {String} [flags] Any combination of XRegExp flags.
 * @returns {RegExp} Cached XRegExp object.
 * @example
 *
 * while (match = XRegExp.cache('.', 'gs').exec(str)) {
 *   // The regex is compiled once only
 * }
 */
XRegExp.cache = function (pattern, flags) {
    if (!regexCache[pattern]) {
        regexCache[pattern] = {};
    }
    return regexCache[pattern][flags] || (regexCache[pattern][flags] = XRegExp(pattern, flags));
};

// Intentionally undocumented; used in tests
XRegExp.cache.flush = function (cacheName) {
    if (cacheName === 'patterns') {
        // Flush the pattern cache used by the `XRegExp` constructor
        patternCache = {};
    } else {
        // Flush the regex cache populated by `XRegExp.cache`
        regexCache = {};
    }
};

/**
 * Escapes any regular expression metacharacters, for use when matching literal strings. The result
 * can safely be used at any point within a regex that uses any flags.
 *
 * @memberOf XRegExp
 * @param {String} str String to escape.
 * @returns {String} String with regex metacharacters escaped.
 * @example
 *
 * XRegExp.escape('Escaped? <.>');
 * // -> 'Escaped\?\ <\.>'
 */
XRegExp.escape = function (str) {
    return nativ.replace.call(toObject(str), /[-\[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
};

/**
 * Executes a regex search in a specified string. Returns a match array or `null`. If the provided
 * regex uses named capture, named backreference properties are included on the match array.
 * Optional `pos` and `sticky` arguments specify the search start position, and whether the match
 * must start at the specified position only. The `lastIndex` property of the provided regex is not
 * used, but is updated for compatibility. Also fixes browser bugs compared to the native
 * `RegExp.prototype.exec` and can be used reliably cross-browser.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {Number} [pos=0] Zero-based index at which to start the search.
 * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position
 *   only. The string `'sticky'` is accepted as an alternative to `true`.
 * @returns {Array} Match array with named backreference properties, or `null`.
 * @example
 *
 * // Basic use, with named backreference
 * let match = XRegExp.exec('U+2620', XRegExp('U\\+(?<hex>[0-9A-F]{4})'));
 * match.hex; // -> '2620'
 *
 * // With pos and sticky, in a loop
 * let pos = 2, result = [], match;
 * while (match = XRegExp.exec('<1><2><3><4>5<6>', /<(\d)>/, pos, 'sticky')) {
 *   result.push(match[1]);
 *   pos = match.index + match[0].length;
 * }
 * // result -> ['2', '3', '4']
 */
XRegExp.exec = function (str, regex, pos, sticky) {
    var cacheKey = 'g';
    var addY = false;
    var fakeY = false;
    var match = void 0;

    addY = hasNativeY && !!(sticky || regex.sticky && sticky !== false);
    if (addY) {
        cacheKey += 'y';
    } else if (sticky) {
        // Simulate sticky matching by appending an empty capture to the original regex. The
        // resulting regex will succeed no matter what at the current index (set with `lastIndex`),
        // and will not search the rest of the subject string. We'll know that the original regex
        // has failed if that last capture is `''` rather than `undefined` (i.e., if that last
        // capture participated in the match).
        fakeY = true;
        cacheKey += 'FakeY';
    }

    regex[REGEX_DATA] = regex[REGEX_DATA] || {};

    // Shares cached copies with `XRegExp.match`/`replace`
    var r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
        addG: true,
        addY: addY,
        source: fakeY ? regex.source + '|()' : undefined,
        removeY: sticky === false,
        isInternalOnly: true
    }));

    pos = pos || 0;
    r2.lastIndex = pos;

    // Fixed `exec` required for `lastIndex` fix, named backreferences, etc.
    match = fixed.exec.call(r2, str);

    // Get rid of the capture added by the pseudo-sticky matcher if needed. An empty string means
    // the original regexp failed (see above).
    if (fakeY && match && match.pop() === '') {
        match = null;
    }

    if (regex.global) {
        regex.lastIndex = match ? r2.lastIndex : 0;
    }

    return match;
};

/**
 * Executes a provided function once per regex match. Searches always start at the beginning of the
 * string and continue until the end, regardless of the state of the regex's `global` property and
 * initial `lastIndex`.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {Function} callback Function to execute for each match. Invoked with four arguments:
 *   - The match array, with named backreference properties.
 *   - The zero-based match index.
 *   - The string being traversed.
 *   - The regex object being used to traverse the string.
 * @example
 *
 * // Extracts every other digit from a string
 * const evens = [];
 * XRegExp.forEach('1a2345', /\d/, (match, i) => {
 *   if (i % 2) evens.push(+match[0]);
 * });
 * // evens -> [2, 4]
 */
XRegExp.forEach = function (str, regex, callback) {
    var pos = 0;
    var i = -1;
    var match = void 0;

    while (match = XRegExp.exec(str, regex, pos)) {
        // Because `regex` is provided to `callback`, the function could use the deprecated/
        // nonstandard `RegExp.prototype.compile` to mutate the regex. However, since `XRegExp.exec`
        // doesn't use `lastIndex` to set the search position, this can't lead to an infinite loop,
        // at least. Actually, because of the way `XRegExp.exec` caches globalized versions of
        // regexes, mutating the regex will not have any effect on the iteration or matched strings,
        // which is a nice side effect that brings extra safety.
        callback(match, ++i, str, regex);

        pos = match.index + (match[0].length || 1);
    }
};

/**
 * Copies a regex object and adds flag `g`. The copy maintains extended data, is augmented with
 * `XRegExp.prototype` properties, and has a fresh `lastIndex` property (set to zero). Native
 * regexes are not recompiled using XRegExp syntax.
 *
 * @memberOf XRegExp
 * @param {RegExp} regex Regex to globalize.
 * @returns {RegExp} Copy of the provided regex with flag `g` added.
 * @example
 *
 * const globalCopy = XRegExp.globalize(/regex/);
 * globalCopy.global; // -> true
 */
XRegExp.globalize = function (regex) {
    return copyRegex(regex, { addG: true });
};

/**
 * Installs optional features according to the specified options. Can be undone using
 * `XRegExp.uninstall`.
 *
 * @memberOf XRegExp
 * @param {Object|String} options Options object or string.
 * @example
 *
 * // With an options object
 * XRegExp.install({
 *   // Enables support for astral code points in Unicode addons (implicitly sets flag A)
 *   astral: true,
 *
 *   // DEPRECATED: Overrides native regex methods with fixed/extended versions
 *   natives: true
 * });
 *
 * // With an options string
 * XRegExp.install('astral natives');
 */
XRegExp.install = function (options) {
    options = prepareOptions(options);

    if (!features.astral && options.astral) {
        setAstral(true);
    }

    if (!features.natives && options.natives) {
        setNatives(true);
    }
};

/**
 * Checks whether an individual optional feature is installed.
 *
 * @memberOf XRegExp
 * @param {String} feature Name of the feature to check. One of:
 *   - `astral`
 *   - `natives`
 * @returns {Boolean} Whether the feature is installed.
 * @example
 *
 * XRegExp.isInstalled('astral');
 */
XRegExp.isInstalled = function (feature) {
    return !!features[feature];
};

/**
 * Returns `true` if an object is a regex; `false` if it isn't. This works correctly for regexes
 * created in another frame, when `instanceof` and `constructor` checks would fail.
 *
 * @memberOf XRegExp
 * @param {*} value Object to check.
 * @returns {Boolean} Whether the object is a `RegExp` object.
 * @example
 *
 * XRegExp.isRegExp('string'); // -> false
 * XRegExp.isRegExp(/regex/i); // -> true
 * XRegExp.isRegExp(RegExp('^', 'm')); // -> true
 * XRegExp.isRegExp(XRegExp('(?s).')); // -> true
 */
XRegExp.isRegExp = function (value) {
    return toString.call(value) === '[object RegExp]';
}; // isType(value, 'RegExp');

/**
 * Returns the first matched string, or in global mode, an array containing all matched strings.
 * This is essentially a more convenient re-implementation of `String.prototype.match` that gives
 * the result types you actually want (string instead of `exec`-style array in match-first mode,
 * and an empty array instead of `null` when no matches are found in match-all mode). It also lets
 * you override flag g and ignore `lastIndex`, and fixes browser bugs.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {String} [scope='one'] Use 'one' to return the first match as a string. Use 'all' to
 *   return an array of all matched strings. If not explicitly specified and `regex` uses flag g,
 *   `scope` is 'all'.
 * @returns {String|Array} In match-first mode: First match as a string, or `null`. In match-all
 *   mode: Array of all matched strings, or an empty array.
 * @example
 *
 * // Match first
 * XRegExp.match('abc', /\w/); // -> 'a'
 * XRegExp.match('abc', /\w/g, 'one'); // -> 'a'
 * XRegExp.match('abc', /x/g, 'one'); // -> null
 *
 * // Match all
 * XRegExp.match('abc', /\w/g); // -> ['a', 'b', 'c']
 * XRegExp.match('abc', /\w/, 'all'); // -> ['a', 'b', 'c']
 * XRegExp.match('abc', /x/, 'all'); // -> []
 */
XRegExp.match = function (str, regex, scope) {
    var global = regex.global && scope !== 'one' || scope === 'all';
    var cacheKey = (global ? 'g' : '') + (regex.sticky ? 'y' : '') || 'noGY';

    regex[REGEX_DATA] = regex[REGEX_DATA] || {};

    // Shares cached copies with `XRegExp.exec`/`replace`
    var r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
        addG: !!global,
        removeG: scope === 'one',
        isInternalOnly: true
    }));

    var result = nativ.match.call(toObject(str), r2);

    if (regex.global) {
        regex.lastIndex = scope === 'one' && result ?
        // Can't use `r2.lastIndex` since `r2` is nonglobal in this case
        result.index + result[0].length : 0;
    }

    return global ? result || [] : result && result[0];
};

/**
 * Retrieves the matches from searching a string using a chain of regexes that successively search
 * within previous matches. The provided `chain` array can contain regexes and or objects with
 * `regex` and `backref` properties. When a backreference is specified, the named or numbered
 * backreference is passed forward to the next regex or returned.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {Array} chain Regexes that each search for matches within preceding results.
 * @returns {Array} Matches by the last regex in the chain, or an empty array.
 * @example
 *
 * // Basic usage; matches numbers within <b> tags
 * XRegExp.matchChain('1 <b>2</b> 3 <b>4 a 56</b>', [
 *   XRegExp('(?is)<b>.*?</b>'),
 *   /\d+/
 * ]);
 * // -> ['2', '4', '56']
 *
 * // Passing forward and returning specific backreferences
 * html = '<a href="http://xregexp.com/api/">XRegExp</a>\
 *         <a href="http://www.google.com/">Google</a>';
 * XRegExp.matchChain(html, [
 *   {regex: /<a href="([^"]+)">/i, backref: 1},
 *   {regex: XRegExp('(?i)^https?://(?<domain>[^/?#]+)'), backref: 'domain'}
 * ]);
 * // -> ['xregexp.com', 'www.google.com']
 */
XRegExp.matchChain = function (str, chain) {
    return function recurseChain(values, level) {
        var item = chain[level].regex ? chain[level] : { regex: chain[level] };
        var matches = [];

        function addMatch(match) {
            if (item.backref) {
                // Safari 4.0.5 (but not 5.0.5+) inappropriately uses sparse arrays to hold the
                // `undefined`s for backreferences to nonparticipating capturing groups. In such
                // cases, a `hasOwnProperty` or `in` check on its own would inappropriately throw
                // the exception, so also check if the backreference is a number that is within the
                // bounds of the array.
                if (!(match.hasOwnProperty(item.backref) || +item.backref < match.length)) {
                    throw new ReferenceError('Backreference to undefined group: ' + item.backref);
                }

                matches.push(match[item.backref] || '');
            } else {
                matches.push(match[0]);
            }
        }

        for (var i = 0; i < values.length; ++i) {
            XRegExp.forEach(values[i], item.regex, addMatch);
        }

        return level === chain.length - 1 || !matches.length ? matches : recurseChain(matches, level + 1);
    }([str], 0);
};

/**
 * Returns a new string with one or all matches of a pattern replaced. The pattern can be a string
 * or regex, and the replacement can be a string or a function to be called for each match. To
 * perform a global search and replace, use the optional `scope` argument or include flag g if using
 * a regex. Replacement strings can use `${n}` or `$<n>` for named and numbered backreferences.
 * Replacement functions can use named backreferences via `arguments[0].name`. Also fixes browser
 * bugs compared to the native `String.prototype.replace` and can be used reliably cross-browser.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {RegExp|String} search Search pattern to be replaced.
 * @param {String|Function} replacement Replacement string or a function invoked to create it.
 *   Replacement strings can include special replacement syntax:
 *     - $$ - Inserts a literal $ character.
 *     - $&, $0 - Inserts the matched substring.
 *     - $` - Inserts the string that precedes the matched substring (left context).
 *     - $' - Inserts the string that follows the matched substring (right context).
 *     - $n, $nn - Where n/nn are digits referencing an existent capturing group, inserts
 *       backreference n/nn.
 *     - ${n}, $<n> - Where n is a name or any number of digits that reference an existent capturing
 *       group, inserts backreference n.
 *   Replacement functions are invoked with three or more arguments:
 *     - The matched substring (corresponds to $& above). Named backreferences are accessible as
 *       properties of this first argument.
 *     - 0..n arguments, one for each backreference (corresponding to $1, $2, etc. above).
 *     - The zero-based index of the match within the total search string.
 *     - The total string being searched.
 * @param {String} [scope='one'] Use 'one' to replace the first match only, or 'all'. If not
 *   explicitly specified and using a regex with flag g, `scope` is 'all'.
 * @returns {String} New string with one or all matches replaced.
 * @example
 *
 * // Regex search, using named backreferences in replacement string
 * const name = XRegExp('(?<first>\\w+) (?<last>\\w+)');
 * XRegExp.replace('John Smith', name, '$<last>, $<first>');
 * // -> 'Smith, John'
 *
 * // Regex search, using named backreferences in replacement function
 * XRegExp.replace('John Smith', name, (match) => `${match.last}, ${match.first}`);
 * // -> 'Smith, John'
 *
 * // String search, with replace-all
 * XRegExp.replace('RegExp builds RegExps', 'RegExp', 'XRegExp', 'all');
 * // -> 'XRegExp builds XRegExps'
 */
XRegExp.replace = function (str, search, replacement, scope) {
    var isRegex = XRegExp.isRegExp(search);
    var global = search.global && scope !== 'one' || scope === 'all';
    var cacheKey = (global ? 'g' : '') + (search.sticky ? 'y' : '') || 'noGY';
    var s2 = search;

    if (isRegex) {
        search[REGEX_DATA] = search[REGEX_DATA] || {};

        // Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used, `search`'s
        // `lastIndex` isn't updated *during* replacement iterations
        s2 = search[REGEX_DATA][cacheKey] || (search[REGEX_DATA][cacheKey] = copyRegex(search, {
            addG: !!global,
            removeG: scope === 'one',
            isInternalOnly: true
        }));
    } else if (global) {
        s2 = new RegExp(XRegExp.escape(String(search)), 'g');
    }

    // Fixed `replace` required for named backreferences, etc.
    var result = fixed.replace.call(toObject(str), s2, replacement);

    if (isRegex && search.global) {
        // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)
        search.lastIndex = 0;
    }

    return result;
};

/**
 * Performs batch processing of string replacements. Used like `XRegExp.replace`, but accepts an
 * array of replacement details. Later replacements operate on the output of earlier replacements.
 * Replacement details are accepted as an array with a regex or string to search for, the
 * replacement string or function, and an optional scope of 'one' or 'all'. Uses the XRegExp
 * replacement text syntax, which supports named backreference properties via `${name}` or
 * `$<name>`.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {Array} replacements Array of replacement detail arrays.
 * @returns {String} New string with all replacements.
 * @example
 *
 * str = XRegExp.replaceEach(str, [
 *   [XRegExp('(?<name>a)'), 'z${name}'],
 *   [/b/gi, 'y'],
 *   [/c/g, 'x', 'one'], // scope 'one' overrides /g
 *   [/d/, 'w', 'all'],  // scope 'all' overrides lack of /g
 *   ['e', 'v', 'all'],  // scope 'all' allows replace-all for strings
 *   [/f/g, ($0) => $0.toUpperCase()]
 * ]);
 */
XRegExp.replaceEach = function (str, replacements) {
    var i = void 0;
    var r = void 0;

    for (i = 0; i < replacements.length; ++i) {
        r = replacements[i];
        str = XRegExp.replace(str, r[0], r[1], r[2]);
    }

    return str;
};

/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 *
 * @memberOf XRegExp
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * XRegExp.split('a b c', ' ');
 * // -> ['a', 'b', 'c']
 *
 * // With limit
 * XRegExp.split('a b c', ' ', 2);
 * // -> ['a', 'b']
 *
 * // Backreferences in result array
 * XRegExp.split('..word1..', /([a-z]+)(\d+)/i);
 * // -> ['..', 'word', '1', '..']
 */
XRegExp.split = function (str, separator, limit) {
    return fixed.split.call(toObject(str), separator, limit);
};

/**
 * Executes a regex search in a specified string. Returns `true` or `false`. Optional `pos` and
 * `sticky` arguments specify the search start position, and whether the match must start at the
 * specified position only. The `lastIndex` property of the provided regex is not used, but is
 * updated for compatibility. Also fixes browser bugs compared to the native
 * `RegExp.prototype.test` and can be used reliably cross-browser.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {Number} [pos=0] Zero-based index at which to start the search.
 * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position
 *   only. The string `'sticky'` is accepted as an alternative to `true`.
 * @returns {Boolean} Whether the regex matched the provided value.
 * @example
 *
 * // Basic use
 * XRegExp.test('abc', /c/); // -> true
 *
 * // With pos and sticky
 * XRegExp.test('abc', /c/, 0, 'sticky'); // -> false
 * XRegExp.test('abc', /c/, 2, 'sticky'); // -> true
 */
// Do this the easy way :-)
XRegExp.test = function (str, regex, pos, sticky) {
    return !!XRegExp.exec(str, regex, pos, sticky);
};

/**
 * Uninstalls optional features according to the specified options. All optional features start out
 * uninstalled, so this is used to undo the actions of `XRegExp.install`.
 *
 * @memberOf XRegExp
 * @param {Object|String} options Options object or string.
 * @example
 *
 * // With an options object
 * XRegExp.uninstall({
 *   // Disables support for astral code points in Unicode addons
 *   astral: true,
 *
 *   // DEPRECATED: Restores native regex methods
 *   natives: true
 * });
 *
 * // With an options string
 * XRegExp.uninstall('astral natives');
 */
XRegExp.uninstall = function (options) {
    options = prepareOptions(options);

    if (features.astral && options.astral) {
        setAstral(false);
    }

    if (features.natives && options.natives) {
        setNatives(false);
    }
};

/**
 * Returns an XRegExp object that is the concatenation of the given patterns. Patterns can be provided as
 * regex objects or strings. Metacharacters are escaped in patterns provided as strings.
 * Backreferences in provided regex objects are automatically renumbered to work correctly within
 * the larger combined pattern. Native flags used by provided regexes are ignored in favor of the
 * `flags` argument.
 *
 * @memberOf XRegExp
 * @param {Array} patterns Regexes and strings to combine.
 * @param {String|RegExp} separator Regex or string to use as the joining separator.
 * @param {String} [flags] Any combination of XRegExp flags.
 * @returns {RegExp} Union of the provided regexes and strings.
 * @example
 *
 * XRegExp.join(['a+b*c', /(dogs)\1/, /(cats)\1/], 'i');
 * // -> /a\+b\*c(dogs)\1(cats)\2/i
 */
XRegExp.join = function (patterns, separator, flags) {
    separator = separator || '';
    var separatorStr = XRegExp.isRegExp(separator) ? separator.source : XRegExp.escape(separator);
    var output = prepareJoin(patterns);
    return XRegExp(output.join(separatorStr), flags);
};

/**
 * Returns an XRegExp object that is the union of the given patterns. Patterns can be provided as
 * regex objects or strings. Metacharacters are escaped in patterns provided as strings.
 * Backreferences in provided regex objects are automatically renumbered to work correctly within
 * the larger combined pattern. Native flags used by provided regexes are ignored in favor of the
 * `flags` argument.
 *
 * @memberOf XRegExp
 * @param {Array} patterns Regexes and strings to combine.
 * @param {String} [flags] Any combination of XRegExp flags.
 * @param {Object} [options] Options object with optional properties:
 *   - `conjunction` {String} Type of conjunction to use: 'or' (default) or 'none'.
 * @returns {RegExp} Union of the provided regexes and strings.
 * @example
 *
 * XRegExp.union(['a+b*c', /(dogs)\1/, /(cats)\1/], 'i');
 * // -> /a\+b\*c|(dogs)\1|(cats)\2/i
 *
 * XRegExp.union([/man/, /bear/, /pig/], 'i', {conjunction: 'none'});
 * // -> /manbearpig/i
 */
XRegExp.union = function (patterns, flags, options) {
    options = options || {};
    var conjunction = options.conjunction || 'or';
    var separator = conjunction === 'none' ? '' : /|/;
    return XRegExp.join(patterns, separator, flags);
};

// ==--------------------------==
// Fixed/extended native methods
// ==--------------------------==

/**
 * Adds named capture support (with backreferences returned as `result.name`), and fixes browser
 * bugs in the native `RegExp.prototype.exec`. Calling `XRegExp.install('natives')` uses this to
 * override the native method. Use via `XRegExp.exec` without overriding natives.
 *
 * @memberOf RegExp
 * @param {String} str String to search.
 * @returns {Array} Match array with named backreference properties, or `null`.
 */
fixed.exec = function (str) {
    var origLastIndex = this.lastIndex;
    var match = nativ.exec.apply(this, arguments);

    if (match) {
        // Fix browsers whose `exec` methods don't return `undefined` for nonparticipating capturing
        // groups. This fixes IE 5.5-8, but not IE 9's quirks mode or emulation of older IEs. IE 9
        // in standards mode follows the spec.
        if (!correctExecNpcg && match.length > 1 && match.indexOf('') !== -1) {
            var r2 = copyRegex(this, {
                removeG: true,
                isInternalOnly: true
            });
            // Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed
            // matching due to characters outside the match
            nativ.replace.call(String(str).slice(match.index), r2, function () {
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                }

                var len = args.length;
                // Skip index 0 and the last 2
                for (var i = 1; i < len - 2; ++i) {
                    if (args[i] === undefined) {
                        match[i] = undefined;
                    }
                }
            });
        }

        // Attach named capture properties
        if (this[REGEX_DATA] && this[REGEX_DATA].captureNames) {
            // Skip index 0
            for (var i = 1; i < match.length; ++i) {
                var name = this[REGEX_DATA].captureNames[i - 1];
                if (name) {
                    if (match[i] != undefined || match[name] == undefined) {
                        match[name] = match[i];
                    }
                }
            }
        }

        // Fix browsers that increment `lastIndex` after zero-length matches
        if (this.global && !match[0].length && this.lastIndex > match.index) {
            this.lastIndex = match.index;
        }
    }

    if (!this.global) {
        // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)
        this.lastIndex = origLastIndex;
    }

    return match;
};

/**
 * Fixes browser bugs in the native `RegExp.prototype.test`. Calling `XRegExp.install('natives')`
 * uses this to override the native method.
 *
 * @memberOf RegExp
 * @param {String} str String to search.
 * @returns {Boolean} Whether the regex matched the provided value.
 */
fixed.test = function (str) {
    // Do this the easy way :-)
    return !!fixed.exec.call(this, str);
};

/**
 * Adds named capture support (with backreferences returned as `result.name`), and fixes browser
 * bugs in the native `String.prototype.match`. Calling `XRegExp.install('natives')` uses this to
 * override the native method.
 *
 * @memberOf String
 * @param {RegExp|*} regex Regex to search with. If not a regex object, it is passed to `RegExp`.
 * @returns {Array} If `regex` uses flag g, an array of match strings or `null`. Without flag g,
 *   the result of calling `regex.exec(this)`.
 */
fixed.match = function (regex) {
    if (!XRegExp.isRegExp(regex)) {
        // Use the native `RegExp` rather than `XRegExp`
        regex = new RegExp(regex);
    } else if (regex.global) {
        var result = nativ.match.apply(this, arguments);
        // Fixes IE bug
        regex.lastIndex = 0;

        return result;
    }

    return fixed.exec.call(regex, toObject(this));
};

/**
 * Adds support for `${n}` (or `$<n>`) tokens for named and numbered backreferences in replacement
 * text, and provides named backreferences to replacement functions as `arguments[0].name`. Also
 * fixes browser bugs in replacement text syntax when performing a replacement using a nonregex
 * search value, and the value of a replacement regex's `lastIndex` property during replacement
 * iterations and upon completion. Calling `XRegExp.install('natives')` uses this to override the
 * native method. Note that this doesn't support SpiderMonkey's proprietary third (`flags`)
 * argument. Use via `XRegExp.replace` without overriding natives.
 *
 * @memberOf String
 * @param {RegExp|String} search Search pattern to be replaced.
 * @param {String|Function} replacement Replacement string or a function invoked to create it.
 * @returns {String} New string with one or all matches replaced.
 */
fixed.replace = function (search, replacement) {
    var isRegex = XRegExp.isRegExp(search);
    var origLastIndex = void 0;
    var captureNames = void 0;
    var result = void 0;

    if (isRegex) {
        if (search[REGEX_DATA]) {
            captureNames = search[REGEX_DATA].captureNames;
        }
        // Only needed if `search` is nonglobal
        origLastIndex = search.lastIndex;
    } else {
        search += ''; // Type-convert
    }

    // Don't use `typeof`; some older browsers return 'function' for regex objects
    if (isType(replacement, 'Function')) {
        // Stringifying `this` fixes a bug in IE < 9 where the last argument in replacement
        // functions isn't type-converted to a string
        result = nativ.replace.call(String(this), search, function () {
            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
            }

            if (captureNames) {
                // Change the `args[0]` string primitive to a `String` object that can store
                // properties. This really does need to use `String` as a constructor
                args[0] = new String(args[0]);
                // Store named backreferences on the first argument
                for (var i = 0; i < captureNames.length; ++i) {
                    if (captureNames[i]) {
                        args[0][captureNames[i]] = args[i + 1];
                    }
                }
            }
            // Update `lastIndex` before calling `replacement`. Fixes IE, Chrome, Firefox, Safari
            // bug (last tested IE 9, Chrome 17, Firefox 11, Safari 5.1)
            if (isRegex && search.global) {
                search.lastIndex = args[args.length - 2] + args[0].length;
            }
            // ES6 specs the context for replacement functions as `undefined`
            return replacement.apply(undefined, args);
        });
    } else {
        // Ensure that the last value of `args` will be a string when given nonstring `this`,
        // while still throwing on null or undefined context
        result = nativ.replace.call(this == null ? this : String(this), search, function () {
            for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                args[_key3] = arguments[_key3];
            }

            return nativ.replace.call(String(replacement), replacementToken, replacer);

            function replacer($0, bracketed, angled, dollarToken) {
                bracketed = bracketed || angled;
                // Named or numbered backreference with curly or angled braces
                if (bracketed) {
                    // XRegExp behavior for `${n}` or `$<n>`:
                    // 1. Backreference to numbered capture, if `n` is an integer. Use `0` for the
                    //    entire match. Any number of leading zeros may be used.
                    // 2. Backreference to named capture `n`, if it exists and is not an integer
                    //    overridden by numbered capture. In practice, this does not overlap with
                    //    numbered capture since XRegExp does not allow named capture to use a bare
                    //    integer as the name.
                    // 3. If the name or number does not refer to an existing capturing group, it's
                    //    an error.
                    var n = +bracketed; // Type-convert; drop leading zeros
                    if (n <= args.length - 3) {
                        return args[n] || '';
                    }
                    // Groups with the same name is an error, else would need `lastIndexOf`
                    n = captureNames ? captureNames.indexOf(bracketed) : -1;
                    if (n < 0) {
                        throw new SyntaxError('Backreference to undefined group ' + $0);
                    }
                    return args[n + 1] || '';
                }
                // Else, special variable or numbered backreference without curly braces
                if (dollarToken === '$') {
                    // $$
                    return '$';
                }
                if (dollarToken === '&' || +dollarToken === 0) {
                    // $&, $0 (not followed by 1-9), $00
                    return args[0];
                }
                if (dollarToken === '`') {
                    // $` (left context)
                    return args[args.length - 1].slice(0, args[args.length - 2]);
                }
                if (dollarToken === "'") {
                    // $' (right context)
                    return args[args.length - 1].slice(args[args.length - 2] + args[0].length);
                }
                // Else, numbered backreference without braces
                dollarToken = +dollarToken; // Type-convert; drop leading zero
                // XRegExp behavior for `$n` and `$nn`:
                // - Backrefs end after 1 or 2 digits. Use `${..}` or `$<..>` for more digits.
                // - `$1` is an error if no capturing groups.
                // - `$10` is an error if less than 10 capturing groups. Use `${1}0` or `$<1>0`
                //   instead.
                // - `$01` is `$1` if at least one capturing group, else it's an error.
                // - `$0` (not followed by 1-9) and `$00` are the entire match.
                // Native behavior, for comparison:
                // - Backrefs end after 1 or 2 digits. Cannot reference capturing group 100+.
                // - `$1` is a literal `$1` if no capturing groups.
                // - `$10` is `$1` followed by a literal `0` if less than 10 capturing groups.
                // - `$01` is `$1` if at least one capturing group, else it's a literal `$01`.
                // - `$0` is a literal `$0`.
                if (!isNaN(dollarToken)) {
                    if (dollarToken > args.length - 3) {
                        throw new SyntaxError('Backreference to undefined group ' + $0);
                    }
                    return args[dollarToken] || '';
                }
                // `$` followed by an unsupported char is an error, unlike native JS
                throw new SyntaxError('Invalid token ' + $0);
            }
        });
    }

    if (isRegex) {
        if (search.global) {
            // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)
            search.lastIndex = 0;
        } else {
            // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)
            search.lastIndex = origLastIndex;
        }
    }

    return result;
};

/**
 * Fixes browser bugs in the native `String.prototype.split`. Calling `XRegExp.install('natives')`
 * uses this to override the native method. Use via `XRegExp.split` without overriding natives.
 *
 * @memberOf String
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 */
fixed.split = function (separator, limit) {
    if (!XRegExp.isRegExp(separator)) {
        // Browsers handle nonregex split correctly, so use the faster native method
        return nativ.split.apply(this, arguments);
    }

    var str = String(this);
    var output = [];
    var origLastIndex = separator.lastIndex;
    var lastLastIndex = 0;
    var lastLength = void 0;

    // Values for `limit`, per the spec:
    // If undefined: pow(2,32) - 1
    // If 0, Infinity, or NaN: 0
    // If positive number: limit = floor(limit); if (limit >= pow(2,32)) limit -= pow(2,32);
    // If negative number: pow(2,32) - floor(abs(limit))
    // If other: Type-convert, then use the above rules
    // This line fails in very strange ways for some values of `limit` in Opera 10.5-10.63, unless
    // Opera Dragonfly is open (go figure). It works in at least Opera 9.5-10.1 and 11+
    limit = (limit === undefined ? -1 : limit) >>> 0;

    XRegExp.forEach(str, separator, function (match) {
        // This condition is not the same as `if (match[0].length)`
        if (match.index + match[0].length > lastLastIndex) {
            output.push(str.slice(lastLastIndex, match.index));
            if (match.length > 1 && match.index < str.length) {
                Array.prototype.push.apply(output, match.slice(1));
            }
            lastLength = match[0].length;
            lastLastIndex = match.index + lastLength;
        }
    });

    if (lastLastIndex === str.length) {
        if (!nativ.test.call(separator, '') || lastLength) {
            output.push('');
        }
    } else {
        output.push(str.slice(lastLastIndex));
    }

    separator.lastIndex = origLastIndex;
    return output.length > limit ? output.slice(0, limit) : output;
};

// ==--------------------------==
// Built-in syntax/flag tokens
// ==--------------------------==

/*
 * Letter escapes that natively match literal characters: `\a`, `\A`, etc. These should be
 * SyntaxErrors but are allowed in web reality. XRegExp makes them errors for cross-browser
 * consistency and to reserve their syntax, but lets them be superseded by addons.
 */
XRegExp.addToken(/\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\dA-Fa-f]{4}|{[\dA-Fa-f]+})|x(?![\dA-Fa-f]{2}))/, function (match, scope) {
    // \B is allowed in default scope only
    if (match[1] === 'B' && scope === defaultScope) {
        return match[0];
    }
    throw new SyntaxError('Invalid escape ' + match[0]);
}, {
    scope: 'all',
    leadChar: '\\'
});

/*
 * Unicode code point escape with curly braces: `\u{N..}`. `N..` is any one or more digit
 * hexadecimal number from 0-10FFFF, and can include leading zeros. Requires the native ES6 `u` flag
 * to support code points greater than U+FFFF. Avoids converting code points above U+FFFF to
 * surrogate pairs (which could be done without flag `u`), since that could lead to broken behavior
 * if you follow a `\u{N..}` token that references a code point above U+FFFF with a quantifier, or
 * if you use the same in a character class.
 */
XRegExp.addToken(/\\u{([\dA-Fa-f]+)}/, function (match, scope, flags) {
    var code = dec(match[1]);
    if (code > 0x10FFFF) {
        throw new SyntaxError('Invalid Unicode code point ' + match[0]);
    }
    if (code <= 0xFFFF) {
        // Converting to \uNNNN avoids needing to escape the literal character and keep it
        // separate from preceding tokens
        return '\\u' + pad4(hex(code));
    }
    // If `code` is between 0xFFFF and 0x10FFFF, require and defer to native handling
    if (hasNativeU && flags.indexOf('u') !== -1) {
        return match[0];
    }
    throw new SyntaxError('Cannot use Unicode code point above \\u{FFFF} without flag u');
}, {
    scope: 'all',
    leadChar: '\\'
});

/*
 * Empty character class: `[]` or `[^]`. This fixes a critical cross-browser syntax inconsistency.
 * Unless this is standardized (per the ES spec), regex syntax can't be accurately parsed because
 * character class endings can't be determined.
 */
XRegExp.addToken(/\[(\^?)\]/,
// For cross-browser compatibility with ES3, convert [] to \b\B and [^] to [\s\S].
// (?!) should work like \b\B, but is unreliable in some versions of Firefox
/* eslint-disable no-confusing-arrow */
function (match) {
    return match[1] ? '[\\s\\S]' : '\\b\\B';
},
/* eslint-enable no-confusing-arrow */
{ leadChar: '[' });

/*
 * Comment pattern: `(?# )`. Inline comments are an alternative to the line comments allowed in
 * free-spacing mode (flag x).
 */
XRegExp.addToken(/\(\?#[^)]*\)/, getContextualTokenSeparator, { leadChar: '(' });

/*
 * Whitespace and line comments, in free-spacing mode (aka extended mode, flag x) only.
 */
XRegExp.addToken(/\s+|#[^\n]*\n?/, getContextualTokenSeparator, { flag: 'x' });

/*
 * Dot, in dotall mode (aka singleline mode, flag s) only.
 */
XRegExp.addToken(/\./, function () {
    return '[\\s\\S]';
}, {
    flag: 's',
    leadChar: '.'
});

/*
 * Named backreference: `\k<name>`. Backreference names can use the characters A-Z, a-z, 0-9, _,
 * and $ only. Also allows numbered backreferences as `\k<n>`.
 */
XRegExp.addToken(/\\k<([\w$]+)>/, function (match) {
    // Groups with the same name is an error, else would need `lastIndexOf`
    var index = isNaN(match[1]) ? this.captureNames.indexOf(match[1]) + 1 : +match[1];
    var endIndex = match.index + match[0].length;
    if (!index || index > this.captureNames.length) {
        throw new SyntaxError('Backreference to undefined group ' + match[0]);
    }
    // Keep backreferences separate from subsequent literal numbers. This avoids e.g.
    // inadvertedly changing `(?<n>)\k<n>1` to `()\11`.
    return '\\' + index + (endIndex === match.input.length || isNaN(match.input[endIndex]) ? '' : '(?:)');
}, { leadChar: '\\' });

/*
 * Numbered backreference or octal, plus any following digits: `\0`, `\11`, etc. Octals except `\0`
 * not followed by 0-9 and backreferences to unopened capture groups throw an error. Other matches
 * are returned unaltered. IE < 9 doesn't support backreferences above `\99` in regex syntax.
 */
XRegExp.addToken(/\\(\d+)/, function (match, scope) {
    if (!(scope === defaultScope && /^[1-9]/.test(match[1]) && +match[1] <= this.captureNames.length) && match[1] !== '0') {
        throw new SyntaxError('Cannot use octal escape or backreference to undefined group ' + match[0]);
    }
    return match[0];
}, {
    scope: 'all',
    leadChar: '\\'
});

/*
 * Named capturing group; match the opening delimiter only: `(?<name>`. Capture names can use the
 * characters A-Z, a-z, 0-9, _, and $ only. Names can't be integers. Supports Python-style
 * `(?P<name>` as an alternate syntax to avoid issues in some older versions of Opera which natively
 * supported the Python-style syntax. Otherwise, XRegExp might treat numbered backreferences to
 * Python-style named capture as octals.
 */
XRegExp.addToken(/\(\?P?<([\w$]+)>/, function (match) {
    // Disallow bare integers as names because named backreferences are added to match arrays
    // and therefore numeric properties may lead to incorrect lookups
    if (!isNaN(match[1])) {
        throw new SyntaxError('Cannot use integer as capture name ' + match[0]);
    }
    if (match[1] === 'length' || match[1] === '__proto__') {
        throw new SyntaxError('Cannot use reserved word as capture name ' + match[0]);
    }
    if (this.captureNames.indexOf(match[1]) !== -1) {
        throw new SyntaxError('Cannot use same name for multiple groups ' + match[0]);
    }
    this.captureNames.push(match[1]);
    this.hasNamedCapture = true;
    return '(';
}, { leadChar: '(' });

/*
 * Capturing group; match the opening parenthesis only. Required for support of named capturing
 * groups. Also adds explicit capture mode (flag n).
 */
XRegExp.addToken(/\((?!\?)/, function (match, scope, flags) {
    if (flags.indexOf('n') !== -1) {
        return '(?:';
    }
    this.captureNames.push(null);
    return '(';
}, {
    optionalFlags: 'n',
    leadChar: '('
});

// ==--------------------------==
// Expose XRegExp
// ==--------------------------==

exports.default = XRegExp;
module.exports = exports['default'];
},{}],72:[function(require,module,exports){
(function (global){
'use strict';

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"util/":160}],73:[function(require,module,exports){

},{}],74:[function(require,module,exports){
arguments[4][73][0].apply(exports,arguments)
},{"dup":73}],75:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.map');
module.exports = require('../modules/_core').Map;

},{"../modules/_core":85,"../modules/es6.map":139,"../modules/es6.object.to-string":140,"../modules/es6.string.iterator":141,"../modules/web.dom.iterable":142}],76:[function(require,module,exports){
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],77:[function(require,module,exports){
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./_wks')('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) require('./_hide')(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

},{"./_hide":96,"./_wks":136}],78:[function(require,module,exports){
module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

},{}],79:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":102}],80:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-absolute-index":128,"./_to-iobject":130,"./_to-length":131}],81:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":82,"./_wks":136}],82:[function(require,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],83:[function(require,module,exports){
'use strict';
var dP = require('./_object-dp').f;
var create = require('./_object-create');
var redefineAll = require('./_redefine-all');
var ctx = require('./_ctx');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var $iterDefine = require('./_iter-define');
var step = require('./_iter-step');
var setSpecies = require('./_set-species');
var DESCRIPTORS = require('./_descriptors');
var fastKey = require('./_meta').fastKey;
var validate = require('./_validate-collection');
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

},{"./_an-instance":78,"./_ctx":86,"./_descriptors":88,"./_for-of":93,"./_iter-define":105,"./_iter-step":107,"./_meta":110,"./_object-create":111,"./_object-dp":112,"./_redefine-all":120,"./_set-species":123,"./_validate-collection":135}],84:[function(require,module,exports){
'use strict';
var global = require('./_global');
var $export = require('./_export');
var redefine = require('./_redefine');
var redefineAll = require('./_redefine-all');
var meta = require('./_meta');
var forOf = require('./_for-of');
var anInstance = require('./_an-instance');
var isObject = require('./_is-object');
var fails = require('./_fails');
var $iterDetect = require('./_iter-detect');
var setToStringTag = require('./_set-to-string-tag');
var inheritIfRequired = require('./_inherit-if-required');

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

},{"./_an-instance":78,"./_export":91,"./_fails":92,"./_for-of":93,"./_global":94,"./_inherit-if-required":99,"./_is-object":102,"./_iter-detect":106,"./_meta":110,"./_redefine":121,"./_redefine-all":120,"./_set-to-string-tag":124}],85:[function(require,module,exports){
var core = module.exports = { version: '2.5.1' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],86:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":76}],87:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],88:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":92}],89:[function(require,module,exports){
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":94,"./_is-object":102}],90:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],91:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var hide = require('./_hide');
var redefine = require('./_redefine');
var ctx = require('./_ctx');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_core":85,"./_ctx":86,"./_global":94,"./_hide":96,"./_redefine":121}],92:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],93:[function(require,module,exports){
var ctx = require('./_ctx');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var anObject = require('./_an-object');
var toLength = require('./_to-length');
var getIterFn = require('./core.get-iterator-method');
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;

},{"./_an-object":79,"./_ctx":86,"./_is-array-iter":101,"./_iter-call":103,"./_to-length":131,"./core.get-iterator-method":137}],94:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],95:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],96:[function(require,module,exports){
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":88,"./_object-dp":112,"./_property-desc":119}],97:[function(require,module,exports){
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":94}],98:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":88,"./_dom-create":89,"./_fails":92}],99:[function(require,module,exports){
var isObject = require('./_is-object');
var setPrototypeOf = require('./_set-proto').set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};

},{"./_is-object":102,"./_set-proto":122}],100:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":82}],101:[function(require,module,exports){
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":108,"./_wks":136}],102:[function(require,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],103:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"./_an-object":79}],104:[function(require,module,exports){
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_hide":96,"./_object-create":111,"./_property-desc":119,"./_set-to-string-tag":124,"./_wks":136}],105:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var has = require('./_has');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_export":91,"./_has":95,"./_hide":96,"./_iter-create":104,"./_iterators":108,"./_library":109,"./_object-gpo":115,"./_redefine":121,"./_set-to-string-tag":124,"./_wks":136}],106:[function(require,module,exports){
var ITERATOR = require('./_wks')('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

},{"./_wks":136}],107:[function(require,module,exports){
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],108:[function(require,module,exports){
module.exports = {};

},{}],109:[function(require,module,exports){
module.exports = false;

},{}],110:[function(require,module,exports){
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !require('./_fails')(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"./_fails":92,"./_has":95,"./_is-object":102,"./_object-dp":112,"./_uid":134}],111:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":79,"./_dom-create":89,"./_enum-bug-keys":90,"./_html":97,"./_object-dps":113,"./_shared-key":125}],112:[function(require,module,exports){
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":79,"./_descriptors":88,"./_ie8-dom-define":98,"./_to-primitive":133}],113:[function(require,module,exports){
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_an-object":79,"./_descriptors":88,"./_object-dp":112,"./_object-keys":117}],114:[function(require,module,exports){
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_descriptors":88,"./_has":95,"./_ie8-dom-define":98,"./_object-pie":118,"./_property-desc":119,"./_to-iobject":130,"./_to-primitive":133}],115:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":95,"./_shared-key":125,"./_to-object":132}],116:[function(require,module,exports){
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_array-includes":80,"./_has":95,"./_shared-key":125,"./_to-iobject":130}],117:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_enum-bug-keys":90,"./_object-keys-internal":116}],118:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;

},{}],119:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],120:[function(require,module,exports){
var redefine = require('./_redefine');
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};

},{"./_redefine":121}],121:[function(require,module,exports){
var global = require('./_global');
var hide = require('./_hide');
var has = require('./_has');
var SRC = require('./_uid')('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

require('./_core').inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

},{"./_core":85,"./_global":94,"./_has":95,"./_hide":96,"./_uid":134}],122:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object');
var anObject = require('./_an-object');
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

},{"./_an-object":79,"./_ctx":86,"./_is-object":102,"./_object-gopd":114}],123:[function(require,module,exports){
'use strict';
var global = require('./_global');
var dP = require('./_object-dp');
var DESCRIPTORS = require('./_descriptors');
var SPECIES = require('./_wks')('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};

},{"./_descriptors":88,"./_global":94,"./_object-dp":112,"./_wks":136}],124:[function(require,module,exports){
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_has":95,"./_object-dp":112,"./_wks":136}],125:[function(require,module,exports){
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":126,"./_uid":134}],126:[function(require,module,exports){
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};

},{"./_global":94}],127:[function(require,module,exports){
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_defined":87,"./_to-integer":129}],128:[function(require,module,exports){
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":129}],129:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],130:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_defined":87,"./_iobject":100}],131:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":129}],132:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":87}],133:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":102}],134:[function(require,module,exports){
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],135:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

},{"./_is-object":102}],136:[function(require,module,exports){
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_global":94,"./_shared":126,"./_uid":134}],137:[function(require,module,exports){
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":81,"./_core":85,"./_iterators":108,"./_wks":136}],138:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":77,"./_iter-define":105,"./_iter-step":107,"./_iterators":108,"./_to-iobject":130}],139:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var MAP = 'Map';

// 23.1 Map Objects
module.exports = require('./_collection')(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

},{"./_collection":84,"./_collection-strong":83,"./_validate-collection":135}],140:[function(require,module,exports){
'use strict';
// 19.1.3.6 Object.prototype.toString()
var classof = require('./_classof');
var test = {};
test[require('./_wks')('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  require('./_redefine')(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}

},{"./_classof":81,"./_redefine":121,"./_wks":136}],141:[function(require,module,exports){
'use strict';
var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"./_iter-define":105,"./_string-at":127}],142:[function(require,module,exports){
var $iterators = require('./es6.array.iterator');
var getKeys = require('./_object-keys');
var redefine = require('./_redefine');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var wks = require('./_wks');
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}

},{"./_global":94,"./_hide":96,"./_iterators":108,"./_object-keys":117,"./_redefine":121,"./_wks":136,"./es6.array.iterator":138}],143:[function(require,module,exports){
exports.endianness = function () { return 'LE' };

exports.hostname = function () {
    if (typeof location !== 'undefined') {
        return location.hostname
    }
    else return '';
};

exports.loadavg = function () { return [] };

exports.uptime = function () { return 0 };

exports.freemem = function () {
    return Number.MAX_VALUE;
};

exports.totalmem = function () {
    return Number.MAX_VALUE;
};

exports.cpus = function () { return [] };

exports.type = function () { return 'Browser' };

exports.release = function () {
    if (typeof navigator !== 'undefined') {
        return navigator.appVersion;
    }
    return '';
};

exports.networkInterfaces
= exports.getNetworkInterfaces
= function () { return {} };

exports.arch = function () { return 'javascript' };

exports.platform = function () { return 'browser' };

exports.tmpdir = exports.tmpDir = function () {
    return '/tmp';
};

exports.EOL = '\n';

exports.homedir = function () {
	return '/'
};

},{}],144:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))
},{"_process":146}],145:[function(require,module,exports){
arguments[4][62][0].apply(exports,arguments)
},{"dup":62}],146:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],147:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
        return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;

},{"./util":156}],148:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = require('./base64');

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};

},{"./base64":149}],149:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};

},{}],150:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  }
  else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  }
  else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};

},{}],151:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;

},{"./util":156}],152:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + (Math.random() * (high - low)));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};

},{}],153:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');
var binarySearch = require('./binary-search');
var ArraySet = require('./array-set').ArraySet;
var base64VLQ = require('./base64-vlq');
var quickSort = require('./quick-sort').quickSort;

function SourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  return sourceMap.sections != null
    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}

SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator =
  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    var mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }

    var mappings = [];

    var index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  if (sourceRoot) {
    sourceRoot = util.normalize(sourceRoot);
  }

  sources = sources
    .map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
        ? util.relative(sourceRoot, source)
        : source;
    });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this._absoluteSources = this._sources.toArray().map(function (s) {
    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
  });

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this._sourceMapURL = aSourceMapURL;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */
BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
  var relativeSource = aSource;
  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }

  if (this._sources.has(relativeSource)) {
    return this._sources.indexOf(relativeSource);
  }

  // Maybe aSource is an absolute URL as returned by |sources|.  In
  // this case we can't simply undo the transform.
  var i;
  for (i = 0; i < this._absoluteSources.length; ++i) {
    if (this._absoluteSources[i] == aSource) {
      return i;
    }
  }

  return -1;
};

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);

    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                            smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function (s) {
      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    return smc;
  };

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._absoluteSources.slice();
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      }
      else if (aStr.charAt(index) === ',') {
        index++;
      }
      else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);

        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;

    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                         aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got '
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got '
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
  function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
  function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util.compareByGeneratedPositionsDeflated,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function (sc) { return sc == null; });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
      return this.sourcesContent[index];
    }

    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }

    var url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    source = this._findSourceIndex(source);
    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util.compareByOriginalPositions,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
    }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections,
      function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);
        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
        this._sources.add(source);
        source = this._sources.indexOf(source);

        var name = null;
        if (mapping.name) {
          name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
        }

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;

},{"./array-set":147,"./base64-vlq":148,"./binary-search":150,"./quick-sort":152,"./util":156}],154:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = require('./base64-vlq');
var util = require('./util');
var ArraySet = require('./array-set').ArraySet;
var MappingList = require('./mapping-list').MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }

      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }

      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        throw new Error(
            'original.line and original.column are not numbers -- you probably meant to omit ' +
            'the original mapping entirely and only map the generated position. If so, pass ' +
            'null for the original mapping instead of an object with empty or null values.'
        );
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.SourceMapGenerator = SourceMapGenerator;

},{"./array-set":147,"./base64-vlq":148,"./mapping-list":151,"./util":156}],155:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
var util = require('./util');

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      // The last line of a file might not have a newline.
      var newLine = getNextLine() || "";
      return lineContents + newLine;

      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ?
            remainingLines[remainingLinesIndex++] : undefined;
      }
    };

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;

    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[remainingLinesIndex] || '';
          var code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || '';
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      }
    }
  };

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length-1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    }
    else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
                     line: this.line,
                     column: this.column,
                     name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len-1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  }
  else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  }
  else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
  function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null
        && original.line !== null
        && original.column !== null) {
      if(lastOriginalSource !== original.source
         || lastOriginalLine !== original.line
         || lastOriginalColumn !== original.column
         || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;

},{"./source-map-generator":154,"./util":156}],156:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 === null) {
    return 1; // aStr2 !== null
  }

  if (aStr2 === null) {
    return -1; // aStr1 !== null
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */
function parseSourceMapInput(str) {
  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}
exports.parseSourceMapInput = parseSourceMapInput;

/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */
function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || '';

  if (sourceRoot) {
    // This follows what Chrome does.
    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
      sourceRoot += '/';
    }
    // The spec says:
    //   Line 4: An optional source root, useful for relocating source
    //   files on a server or removing repeated values in the
    //   sources entry.  This value is prepended to the individual
    //   entries in the source field.
    sourceURL = sourceRoot + sourceURL;
  }

  // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   sourceRoot, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).
  if (sourceMapURL) {
    var parsed = urlParse(sourceMapURL);
    if (!parsed) {
      throw new Error("sourceMapURL could not be parsed");
    }
    if (parsed.path) {
      // Strip the last path component, but keep the "/".
      var index = parsed.path.lastIndexOf('/');
      if (index >= 0) {
        parsed.path = parsed.path.substring(0, index + 1);
      }
    }
    sourceURL = join(urlGenerate(parsed), sourceURL);
  }

  return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;

},{}],157:[function(require,module,exports){
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./lib/source-node').SourceNode;

},{"./lib/source-map-consumer":153,"./lib/source-map-generator":154,"./lib/source-node":155}],158:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],159:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],160:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":159,"_process":146,"inherits":158}]},{},[2]);
