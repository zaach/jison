//
// Stage 2(C) parser: 'The Back End = The Pretty Printer'
//
// TODO!
//
// This one represents the classic textbook 'parser/tokenizer' backend: 
// using a 'tree walker' to generate 'object code output': in this case 
// the 'backend' is tasked to 'pretty print' the given formula
// so that the human user can be fed back her input, including possible
// color coding, error markup, tagging and what-not.
//
// This is yet another back-end to un alongside the others: 
// compile_calc_exec and compile_calc_codegen.
//
// The AST is stored in an array and since the AST acts as the INTERFACE
// between front-end and backend of the compiler/engine, its precise format
// is known to both 'parsers': the compile_calc_parse front-end and this
// back-end, plus additional back-ends which feed off the same AST for
// different purposes.
//
// This 'Pretty Printer' is designed to be FAST, hence the AST stream has been
// constructed the way it is, using a Polish Notation simile: this takes
// the fewest AST nodes and the fewest number of grammar rules to express
// the entire formula calculation power.
//
// We also assume the AST is always valid (errors can be encoded in there, but
// we will exit HARD when your front-end screwed up the AST 'internal structure'
// in any way!), the result of which is that we now have enabled jison to
// recognize the absence of all and any error checking and reporting facilities,
// which our JISON takes as an opportunity to create a severely stripped down,
// FAST grammar parser, hence a very fast 'tree walker'.
//
// Of course, the usual process is to write such a 'tree walker' by hand,
// but I want to showcase the concept here and there's something to say for
// readability as now AST format and actions performed on the atoms is
// nicely separated! :-)
//
// ---
//
// A crucial detail is the use of the `%import` jison feature which allows
// us to import the symbol table generated by jison as part of the front-end
// parser engine: that way we have a guaranteed good set of token #IDs which we
// can use at both ends of the AST stream interface: this allows us to use
// the other JISON feature which is `#<name>` in the action blocks everywhere:
// this will be expanded into the numeric ID of the given token by jison,
// saving us from having to generate and maintain a separate table of IDs
// for our AST objects!
//
// ---
//
// This example also uses the new JISON `%include` feature which allows us
// to include any given source file *verbatim* in our generated jison output.
// Thus we will produce a complete, working, app in a single file here.
// (See near bottom of this jison file.)



// one grammar is MASTER for our common symbol set:
%import symbols  "./output/compiled_calc/compiled_calc_parse.js"







%token      NUM             // Simple double precision number
%token      VAR FUNCTION    // Variable and Function
%token      CONSTANT        // Predefined Constant Value, e.g. PI or E
%token      ERROR           // Mark error in statement
%token      COMMENT         // A line (or multiple lines) of comment

%token      END             // token to mark the end of a function argument list in the output token stream
%token      FUNCTION_0      // optimization: function without any input parameters
%token      FUNCTION_1      // optimization: function with one input parameter
%token      FUNCTION_2      // optimization: function with two input parameters
%token      FUNCTION_3      // optimization: function with three input parameters

%nonassoc   IF_ELSE         // IF ... THEN ... ELSE ...
%nonassoc   IF              // IF ... THEN ... (ELSE nil) -- the 'dangling else' issue has already been resolved by the *parser* hence this AST input stream doesn't suffer from that issue any more!


// %right      '='
%nonassoc   ASSIGN

%nonassoc   XOR
%nonassoc   OR
%nonassoc   AND

%nonassoc   EQ NEQ GEQ LEQ GT LT

// %left       '^'
// %left       '|'
// %left       '&'
%nonassoc   BITWISE_XOR
%nonassoc   BITWISE_OR
%nonassoc   BITWISE_AND

// %left       '-' '+'
// %left       '*' '/' '%'
// %right      POWER
// %right      '~'
// %right      '!' NOT
%nonassoc   ADD SUBTRACT
%nonassoc   MULTIPLY DIVIDE MODULO
%nonassoc   POWER
%nonassoc   BITWISE_NOT
%nonassoc   NOT
%nonassoc   FACTORIAL
%nonassoc   UMINUS     /* Negation--unary minus */
%nonassoc   UPLUS      /* unary plus */
%nonassoc   PERCENT    /* unary percentage */




/* Grammar follows */

%start input


//%debug

//%options on-demand-lookahead              // camelCased: option.onDemandLookahead
//%options default-action-mode=none,merge   // JISON shouldn't bother injecting the default `$$ = $1` action anywhere!
%options no-try-catch                       // we assume this parser won't ever crash and we want the fastest Animal possible! So get rid of the try/catch/finally in the kernel!

%parse-param globalSpace        // extra function parameter for the generated parse() API; we use this one to pass in a reference to our workspace for the functions to play with.



%%


input:
  Îµ                             /* empty */
                                {
                                  $$ = [];
                                }
| input line EOL
                                {
                                  $input.push($line);
                                  $$ = $input;
                                }
| input COMMENT EOL
                                {
                                  var comment = $COMMENT.split('\n');
                                  comment.forEach(function (cmtline) {
                                    $input.push('# ' + cmtline);
                                  });
                                  $$ = $input;
                                }
;

line:
  exp
                                {
                                  console.log('expression result value: ', $exp);
                                  $$ = $exp;
                                }
| ERROR
                                {
                                  console.log('expression result value: ERROR - erroneous input line');
                                  $$ = 'ERROR: ', $ERROR;
                                }
;


exp:
  NUM
                                { 
                                  $$ = $(#NUM, $NUM); 
                                }
| CONSTANT
                                { 
                                  $$ = $(#CONSTANT, yy.constants[$CONSTANT].name); 
                                }
| VAR
                                { 
                                  $$ = $(#VAR, yy.variables[$VAR].name); 
                                }
| ASSIGN exp
                                {
                                  /*
                                     Note: #assign is always to a simple variable, hence we don't need the `#VAR`
                                     token here: it is implicit as there's nothing else we can do.

                                     Technically, this is an AST optimization, but it's such a fundamental one
                                     we do it here instead of later.

                                     NOTE: #assign implies the presence of a VAR as lhs (left hand side) so it
                                     would only be cluttering the AST stream to have a #VAR# token in there:
                                     it is *implicit* to #assign!
                                   */
                                  $$ = $(#ASSIGN, yy.variables[$ASSIGN].name, '=', __($exp, 0, #ASSIGN));
                                  //$$ = yy.variables[$ASSIGN].name = $exp;
                                }
| FUNCTION_0
                                { 
                                  $$ = $(#FUNCTION_0#, yy.functions[$FUNCTION_0].name);
                                }
| FUNCTION arglist END
                                {
                                  //$$ = $(#FUNCTION#, yy.functions[$FUNCTION_0].name, arglist);
                                  $arglist.unshift(#FUNCTION#, yy.functions[$FUNCTION_0].name);
                                  $$ = $.apply(this, arglist);
                                }
| FUNCTION_1 exp
                                {
                                  $$ = $(#FUNCTION_1#, yy.functions[$FUNCTION_1].name, $exp);
                                }
| FUNCTION_2 exp exp
                                {
                                  $$ = $(#FUNCTION_2#, yy.functions[$FUNCTION_2].name, $exp1, $exp2);
                                }
| FUNCTION_3 exp exp exp
                                {
                                  $$ = $(#FUNCTION_3#, yy.functions[$FUNCTION_3].name, $exp1, $exp2, $exp3);
                                }

| EQ exp exp
                                { $$ = $(#EQ, $exp1, $exp2); }
| NEQ exp exp
                                { $$ = $(#NEQ, $exp1, $exp2); }
| LEQ exp exp
                                { $$ = $(#LEQ, $exp1, $exp2); }
| GEQ exp exp
                                { $$ = $(#GEQ, $exp1, $exp2); }
| LT exp exp
                                { $$ = $(#LT, $exp1, $exp2); }
| GT exp exp
                                { $$ = $(#GT, $exp1, $exp2); }
| OR exp exp
                                { $$ = $(#OR, $exp1, $exp2); }
| XOR exp exp
                                { $$ = $(#XOR, $exp1, $exp2); }
| AND exp exp
                                { $$ = $(#AND, $exp1, $exp2); }

| BITWISE_OR exp exp
                                { $$ = $(#BITWISE_OR, $exp1, $exp2); }
| BITWISE_XOR exp exp
                                { $$ = $(#BITWISE_XOR, $exp1, $exp2); }
| BITWISE_AND exp exp
                                { $$ = $(#BITWISE_AND, $exp1, $exp2); }

| ADD exp exp
                                { $$ = $(#ADD, $exp1, $exp2); }
| SUBTRACT exp exp
                                { $$ = $(#SUBTRACT, $exp1, $exp2); }
| MULTIPLY exp exp
                                { $$ = $(#MULTIPLY, $exp1, $exp2); }
| DIVIDE exp exp
                                { $$ = $(#DIVIDE, $exp1, $exp2); }
| MODULO exp exp
                                { $$ = $(#MODULO, $exp1, $exp2); }
| UMINUS exp
                                { $$ = $(#UMINUS, $exp1); }
| UPLUS exp
                                { $$ = $(#UPLUS, $exp1); }
| POWER exp exp
                                { $$ = $(#POWER, $exp1, $exp2); }
| PERCENT exp
                                { $$ = $(#PERCENT, $exp1); }
| FACTORIAL exp
                                { $$ = $(#FACTORIAL, $exp1); }

| BITWISE_NOT exp
                                { $$ = $(#BITWISE_NOT, $exp1); }
| NOT exp
                                { $$ = $(#NOT, $exp1); }


| IF_ELSE exp exp exp
                                { $$ = $(#IF_ELSE, $exp1, $exp2, $exp3); }
| IF exp exp
                                { $$ = $(#IF, $exp1, $exp2); }
;

arglist:
  exp
                                { $$ = [$exp]; }
| arglist exp
                                {
                                  $$ = $arglist;
                                  $$.push($exp);
                                }
;





/* End of grammar */


%%

/* @const */ var precedence_order = {
  #NUM#:            1,
  #ADD#:            100,
  #AND#:            175,
  #ASSIGN#:         300,
  #BITWISE_AND#:    50,
  #BITWISE_NOT#:    20,
  #BITWISE_OR#:     50,
  #BITWISE_XOR#:    50,
  #CONSTANT#:       1,
  #DIVIDE#:         80,
  #EQ#:             150,
  #FACTORIAL#:      20,
  #FUNCTION#:       1,
  #FUNCTION_0#:     1,
  #FUNCTION_1#:     1,
  #FUNCTION_2#:     1,
  #FUNCTION_3#:     1,
  #GEQ#:            150,
  #GT#:             150,
  #IF#:             200,
  #IF_ELSE#:        200,
  #LEQ#:            150,
  #LT#:             150,
  #MODULO#:         80,
  #MULTIPLY#:       90,
  #NEQ#:            150,
  #NOT#:            20,
  #OR#:             175,
  #PERCENT#:        20,
  #POWER#:          70,
  #SUBTRACT#:       100,
  #UMINUS#:         20,
  #UPLUS#:          20,
  #VAR#:            1,
  #XOR#:            175,
};
/* @const */ var associativity = {
  #NUM#:            0,
  #ADD#:            2,
  #AND#:            2,
  #ASSIGN#:         2,
  #BITWISE_AND#:    2,
  #BITWISE_NOT#:    1,
  #BITWISE_OR#:     2,
  #BITWISE_XOR#:    2,
  #CONSTANT#:       0,
  #DIVIDE#:         2,
  #EQ#:             2,
  #FACTORIAL#:      2,
  #FUNCTION#:       0,
  #FUNCTION_0#:     0,
  #FUNCTION_1#:     0,
  #FUNCTION_2#:     0,
  #FUNCTION_3#:     0,
  #GEQ#:            2,
  #GT#:             2,
  #IF#:             2,
  #IF_ELSE#:        2,
  #LEQ#:            2,
  #LT#:             2,
  #MODULO#:         2,
  #MULTIPLY#:       2,
  #NEQ#:            2,
  #NOT#:            1,
  #OR#:             2,
  #PERCENT#:        1,
  #POWER#:          2,
  #SUBTRACT#:       2,
  #UMINUS#:         1,
  #UPLUS#:          1,
  #VAR#:            0,
  #XOR#:            2,
};
/* @const */ var display = {
  #NUM#:                    '1',
  #ADD#:                    '(1) + (2)',
  #AND#:                    '(1) && (2)',
  #ASSIGN#:                 '1 = (2)',
  #BITWISE_AND#:            '(1) & (2)',
  #BITWISE_NOT#:            '~(1)',
  #BITWISE_OR#:             '(1) | (2)',
  #BITWISE_XOR#:            '(1) ^ (2)',
  #CONSTANT#:               '1',
  #DIVIDE#:                 '(1) / (2)',
  #EQ#:                     '(1) == (2)',
  #FACTORIAL#:              '(1)!',
  // #FUNCTION# receives special treatment:
  #FUNCTION#:               '1((2)...3...X..., (3)...)',
  #FUNCTION_0#:             '1()', 
  #FUNCTION_1#:             '1((2))',
  #FUNCTION_2#:             '1((2), (3))',
  #FUNCTION_3#:             '1((2), (3), (4))',
  #GEQ#:                    '(1) >= (2)',
  #GT#:                     '(1) > (2)',
  #IF#:                     'IF (:1:) THEN (2)',
  #IF_ELSE#:                '(1) ? (2) : (3)',
  #LEQ#:                    '(1) <= (2)',
  #LT#:                     '(1) < (2)',
  #MODULO#:                 '(1) % (2)',
  #MULTIPLY#:               '(1) * (2)',
  #NEQ#:                    '(1) != (2)',
  #NOT#:                    '!(1)',
  #OR#:                     '(1) || (2)',
  #PERCENT#:                '(1)%',
  #POWER#:                  '(1) ** (2)',
  #SUBTRACT#:               '(1) - (2)',
  #UMINUS#:                 '-(1)',
  #UPLUS#:                  '+(1)',
  #VAR#:                    '1',
  #XOR#:                    '(1) XOR (2)',
};

var argument_regex = [
  /[\[\{\(:'"]?\b1\b[\]\}\):'"]?/,
];


function escape_quotes(s, q) {
  s = s
  // escapes escape characters before we add any of our own
  .replace(/\\/g, '\\\\')
  // escape the quote `q`:
  .replace(new RegExp(q, 'g'), '\\' + q);

  return s;  
}

function $(op /* ,... */ ) {
  // first check how many args we got:
  var args = Array.prototype.slice.call(arguments, 1);
  var cnt = args.length;

  // - if any arg contains content which carries *lower* precedences, it must be braced.
  // - if the left/right argument contains content with the *same* precedence and is not supposed to, given this op's *associativity*, then it must be braced.
  var brace_me = new Array(cnt);
  var my_prec = precedence_order[op] || 0;    // precedence is higher when number is LOWER!
  var my_assoc = associativity[op] || 0;

  var s = display[op];

  // before we go and replace all the arguments, we have one prep job to do first:
  // when we're printing a function which accepts an arbitrary number of arguments,
  // e.g. `average(...)`, then we must facilitate the argument templating process 
  // below for *any* number of arguments!
  //
  // We accomplish this by preprocessing the display template to fit the number
  // of available arguments:
  // we inject the selected format for each of the arguments available in a given
  // argument index range, which can be
  // - from N to infinity, i.e. the entire remainder of the argument set
  // - from N to -M, i.e. the arguments from index N up to the argument at 
  //   index LENGTH+M, for example with argument set of 10 arguments and M = -2,
  //   N = 5 we would have to print the arguments 5, 6, 7, 8 (=10-2). This allows
  //   for printing functions which have reserved special treatment for their
  //   last few input parameters.
  // - from N to M, i.e. the arguments from index N up to and including index M.
  //   When M is specified with an explicit '+' it is a count rather than an offset,
  //   M = +2 means the range spans 2 arguments exactly.
  //
  // The template format also includes the ability to specify exactly what format
  // you wish to apply to each of the arguments: that's the third parameter of
  // a range set spec: `...N...M...fmt...`, where `fmt` can use any number to
  // represent the argument at hand.
  //
  // Note that 'infinity' is represented by 'X' in the spec:
  function adjust_one_rangespec(s, n1, m2, f3) {
    var n = parseInt(n1);
    var m = (m2 === 'X' ? cnt - 1 : parseInt(m2));
    if (m2[0] === '-') {
      m = cnt - Math.max(-m, 1);
    } else if (mm[0] === '+') {
      m = Math.min(cnt - 1, m + n);
    }
    // and replace the entire thing, using format f3 for every arg and 'joining'
    // the whole party: 
    var out = [];
    for (var i = n; i <= m; i++) {
      out.push(f3
        .replace(/[0-9]+/, i)
      );
    }
    return out.join('');
  }

  s = s.replace(/\.\.\.([0-9]+)\.\.\.(X|[-+][0-9]+)\.\.\.(.*?)\.\.\./g, adjust_one_rangespec);
console.log('$() display:', s, op, arguments);

  // now print every arg using the template:
  for (var i = 0; i < cnt; i++) {
    // is argument an 'augmented item'?
    var a = args[i];
    if (a.augmented) {
      // check precedence:
      brace_me[i] = (a.precedence > my_prec);
      // check associativity?
      if (a.precedence >= my_prec && my_assoc != i) {
        brace_me[i] = true; 
      }
    }

    // replace arg [0] via regex `/1/`, etc.:
    var re = argument_regex[i];
    if (!re) {
      // and when we have run out of arg specs, we just re-use the one for the previous argument
      re = argument_regex[i - 1];
      var re_s = '' + re;
      re_s = re_s.replace(/[0-9]+/, function (m) {
        var j = parseInt(m);
        j++;
        return '' + j;
      })
      .replace(/^\/(.*)\/$/, '$1');
      re = new RegExp(re_s);
      // and cache this one, if it is sane to do (not sane is when you cache the regex for the 100th argument, for example)
      if (i < 42) {
console.warn('cache regex for index ', i, re);
        argument_regex[i] = re;
      }
    }
console.log('$() replace argument at index:', i, a, brace_me[i], s, re, ' ::: ', arguments);

    s = s
    .replace(re, function (m) {
      var s = (a.augmented ? a.display : '' + a);

      // detect formatting requirements:
      switch (m[0]) {
      // :1: --> plain 1, no braces, even when we might previously have detected that they would be needed
      case ':':
        // s = s;
        break;
      
      // (1) --> optional braces around 1
      // {1} --> optional curly braces around 1
      // [1] --> optional square brackets around 1
      // 
      // Note: if we'd wanted *mandatory* braces around 1, we would have specced it as `(:1:)` instead!
      case '(':
      case '{':
      case '[':
        if (brace_me[i]) {
          s = m[0] + s + m[m.length - 1];
        }
        break;

      // '1' --> mandatory quotes around 1
      case "'":
      case '"':
        s = m[0] + escape_quotes(s, m[0]) + m[m.length - 1];
        break;

      // 1 --> just plain 1, no braces:
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        // s = s;
        break;

      // ?1? --> anything else surrounding 1 is a spec error.
      default:
        throw new Error('arg fmt spec error at index ' + i + ': illegal spec = ' + re);
      }

      return s;
    });
  }

  var rv = {
    augmented: true,
    display: s,
    precedence: my_prec,
  };  
  console.warn('$() output: ', rv, arguments);
  return rv;
}

